/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
// @version 0.7.23
! function() {
	window.WebComponents = window.WebComponents || {
		flags: {}
	};
	console.log("oss_demo_bin")
	var e = "webcomponents-lite.js",
		t = document.querySelector('script[src*="' + e + '"]'),
		n = {};
	if (!n.noOpts) {
		if (location.search.slice(1).split("&").forEach(function(e) {
				var t, o = e.split("=");
				o[0] && (t = o[0].match(/wc-(.+)/)) && (n[t[1]] = o[1] || !0)
			}), t)
			for (var o, r = 0; o = t.attributes[r]; r++) "src" !== o.name && (n[o.name] = o.value || !0);
		if (n.log && n.log.split) {
			var i = n.log.split(",");
			n.log = {}, i.forEach(function(e) {
				n.log[e] = !0
			})
		} else n.log = {}
	}
	n.register && (window.CustomElements = window.CustomElements || {
		flags: {}
	}, window.CustomElements.flags.register = n.register), WebComponents.flags = n
}(),
function(e) {
	"use strict";

	function t(e) {
		return void 0 !== h[e]
	}

	function n() {
		s.call(this), this._isInvalid = !0
	}

	function o(e) {
		return "" == e && n.call(this), e.toLowerCase()
	}

	function r(e) {
		var t = e.charCodeAt(0);
		return t > 32 && t < 127 && [34, 35, 60, 62, 63, 96].indexOf(t) == -1 ? e : encodeURIComponent(e)
	}

	function i(e) {
		var t = e.charCodeAt(0);
		return t > 32 && t < 127 && [34, 35, 60, 62, 96].indexOf(t) == -1 ? e : encodeURIComponent(e)
	}

	function a(e, a, s) {
		function c(e) {
			g.push(e)
		}
		var d = a || "scheme start",
			l = 0,
			u = "",
			w = !1,
			_ = !1,
			g = [];
		e: for (;
			(e[l - 1] != p || 0 == l) && !this._isInvalid;) {
			var b = e[l];
			switch (d) {
				case "scheme start":
					if (!b || !m.test(b)) {
						if (a) {
							c("Invalid scheme.");
							break e
						}
						u = "", d = "no scheme";
						continue
					}
					u += b.toLowerCase(), d = "scheme";
					break;
				case "scheme":
					if (b && v.test(b)) u += b.toLowerCase();
					else {
						if (":" != b) {
							if (a) {
								if (p == b) break e;
								c("Code point not allowed in scheme: " + b);
								break e
							}
							u = "", l = 0, d = "no scheme";
							continue
						}
						if (this._scheme = u, u = "", a) break e;
						t(this._scheme) && (this._isRelative = !0), d = "file" == this._scheme ? "relative" : this._isRelative && s && s._scheme == this._scheme ? "relative or authority" : this._isRelative ? "authority first slash" : "scheme data"
					}
					break;
				case "scheme data":
					"?" == b ? (this._query = "?", d = "query") : "#" == b ? (this._fragment = "#", d = "fragment") : p != b && "\t" != b && "\n" != b && "\r" != b && (this._schemeData += r(b));
					break;
				case "no scheme":
					if (s && t(s._scheme)) {
						d = "relative";
						continue
					}
					c("Missing scheme."), n.call(this);
					break;
				case "relative or authority":
					if ("/" != b || "/" != e[l + 1]) {
						c("Expected /, got: " + b), d = "relative";
						continue
					}
					d = "authority ignore slashes";
					break;
				case "relative":
					if (this._isRelative = !0, "file" != this._scheme && (this._scheme = s._scheme), p == b) {
						this._host = s._host, this._port = s._port, this._path = s._path.slice(), this._query = s._query, this._username = s._username, this._password = s._password;
						break e
					}
					if ("/" == b || "\\" == b) "\\" == b && c("\\ is an invalid code point."), d = "relative slash";
					else if ("?" == b) this._host = s._host, this._port = s._port, this._path = s._path.slice(), this._query = "?", this._username = s._username, this._password = s._password, d = "query";
					else {
						if ("#" != b) {
							var y = e[l + 1],
								E = e[l + 2];
							("file" != this._scheme || !m.test(b) || ":" != y && "|" != y || p != E && "/" != E && "\\" != E && "?" != E && "#" != E) && (this._host = s._host, this._port = s._port, this._username = s._username, this._password = s._password, this._path = s._path.slice(), this._path.pop()), d = "relative path";
							continue
						}
						this._host = s._host, this._port = s._port, this._path = s._path.slice(), this._query = s._query, this._fragment = "#", this._username = s._username, this._password = s._password, d = "fragment"
					}
					break;
				case "relative slash":
					if ("/" != b && "\\" != b) {
						"file" != this._scheme && (this._host = s._host, this._port = s._port, this._username = s._username, this._password = s._password), d = "relative path";
						continue
					}
					"\\" == b && c("\\ is an invalid code point."), d = "file" == this._scheme ? "file host" : "authority ignore slashes";
					break;
				case "authority first slash":
					if ("/" != b) {
						c("Expected '/', got: " + b), d = "authority ignore slashes";
						continue
					}
					d = "authority second slash";
					break;
				case "authority second slash":
					if (d = "authority ignore slashes", "/" != b) {
						c("Expected '/', got: " + b);
						continue
					}
					break;
				case "authority ignore slashes":
					if ("/" != b && "\\" != b) {
						d = "authority";
						continue
					}
					c("Expected authority, got: " + b);
					break;
				case "authority":
					if ("@" == b) {
						w && (c("@ already seen."), u += "%40"), w = !0;
						for (var L = 0; L < u.length; L++) {
							var N = u[L];
							if ("\t" != N && "\n" != N && "\r" != N)
								if (":" != N || null !== this._password) {
									var M = r(N);
									null !== this._password ? this._password += M : this._username += M
								} else this._password = "";
							else c("Invalid whitespace in authority.")
						}
						u = ""
					} else {
						if (p == b || "/" == b || "\\" == b || "?" == b || "#" == b) {
							l -= u.length, u = "", d = "host";
							continue
						}
						u += b
					}
					break;
				case "file host":
					if (p == b || "/" == b || "\\" == b || "?" == b || "#" == b) {
						2 != u.length || !m.test(u[0]) || ":" != u[1] && "|" != u[1] ? 0 == u.length ? d = "relative path start" : (this._host = o.call(this, u), u = "", d = "relative path start") : d = "relative path";
						continue
					}
					"\t" == b || "\n" == b || "\r" == b ? c("Invalid whitespace in file host.") : u += b;
					break;
				case "host":
				case "hostname":
					if (":" != b || _) {
						if (p == b || "/" == b || "\\" == b || "?" == b || "#" == b) {
							if (this._host = o.call(this, u), u = "", d = "relative path start", a) break e;
							continue
						}
						"\t" != b && "\n" != b && "\r" != b ? ("[" == b ? _ = !0 : "]" == b && (_ = !1), u += b) : c("Invalid code point in host/hostname: " + b)
					} else if (this._host = o.call(this, u), u = "", d = "port", "hostname" == a) break e;
					break;
				case "port":
					if (/[0-9]/.test(b)) u += b;
					else {
						if (p == b || "/" == b || "\\" == b || "?" == b || "#" == b || a) {
							if ("" != u) {
								var T = parseInt(u, 10);
								T != h[this._scheme] && (this._port = T + ""), u = ""
							}
							if (a) break e;
							d = "relative path start";
							continue
						}
						"\t" == b || "\n" == b || "\r" == b ? c("Invalid code point in port: " + b) : n.call(this)
					}
					break;
				case "relative path start":
					if ("\\" == b && c("'\\' not allowed in path."), d = "relative path", "/" != b && "\\" != b) continue;
					break;
				case "relative path":
					if (p != b && "/" != b && "\\" != b && (a || "?" != b && "#" != b)) "\t" != b && "\n" != b && "\r" != b && (u += r(b));
					else {
						"\\" == b && c("\\ not allowed in relative path.");
						var O;
						(O = f[u.toLowerCase()]) && (u = O), ".." == u ? (this._path.pop(), "/" != b && "\\" != b && this._path.push("")) : "." == u && "/" != b && "\\" != b ? this._path.push("") : "." != u && ("file" == this._scheme && 0 == this._path.length && 2 == u.length && m.test(u[0]) && "|" == u[1] && (u = u[0] + ":"), this._path.push(u)), u = "", "?" == b ? (this._query = "?", d = "query") : "#" == b && (this._fragment = "#", d = "fragment")
					}
					break;
				case "query":
					a || "#" != b ? p != b && "\t" != b && "\n" != b && "\r" != b && (this._query += i(b)) : (this._fragment = "#", d = "fragment");
					break;
				case "fragment":
					p != b && "\t" != b && "\n" != b && "\r" != b && (this._fragment += b)
			}
			l++
		}
	}

	function s() {
		this._scheme = "", this._schemeData = "", this._username = "", this._password = null, this._host = "", this._port = "", this._path = [], this._query = "", this._fragment = "", this._isInvalid = !1, this._isRelative = !1
	}

	function c(e, t) {
		void 0 === t || t instanceof c || (t = new c(String(t))), this._url = e, s.call(this);
		var n = e.replace(/^[ \t\r\n\f]+|[ \t\r\n\f]+$/g, "");
		a.call(this, n, null, t)
	}
	var d = !1;
	if (!e.forceJURL) try {
		var l = new URL("b", "http://a");
		l.pathname = "c%20d", d = "http://a/c%20d" === l.href
	} catch (u) {}
	if (!d) {
		var h = Object.create(null);
		h.ftp = 21, h.file = 0, h.gopher = 70, h.http = 80, h.https = 443, h.ws = 80, h.wss = 443;
		var f = Object.create(null);
		f["%2e"] = ".", f[".%2e"] = "..", f["%2e."] = "..", f["%2e%2e"] = "..";
		var p = void 0,
			m = /[a-zA-Z]/,
			v = /[a-zA-Z0-9\+\-\.]/;
		c.prototype = {
			toString: function() {
				return this.href
			},
			get href() {
				if (this._isInvalid) return this._url;
				var e = "";
				return "" == this._username && null == this._password || (e = this._username + (null != this._password ? ":" + this._password : "") + "@"), this.protocol + (this._isRelative ? "//" + e + this.host : "") + this.pathname + this._query + this._fragment
			},
			set href(e) {
				s.call(this), a.call(this, e)
			},
			get protocol() {
				return this._scheme + ":"
			},
			set protocol(e) {
				this._isInvalid || a.call(this, e + ":", "scheme start")
			},
			get host() {
				return this._isInvalid ? "" : this._port ? this._host + ":" + this._port : this._host
			},
			set host(e) {
				!this._isInvalid && this._isRelative && a.call(this, e, "host")
			},
			get hostname() {
				return this._host
			},
			set hostname(e) {
				!this._isInvalid && this._isRelative && a.call(this, e, "hostname")
			},
			get port() {
				return this._port
			},
			set port(e) {
				!this._isInvalid && this._isRelative && a.call(this, e, "port")
			},
			get pathname() {
				return this._isInvalid ? "" : this._isRelative ? "/" + this._path.join("/") : this._schemeData
			},
			set pathname(e) {
				!this._isInvalid && this._isRelative && (this._path = [], a.call(this, e, "relative path start"))
			},
			get search() {
				return this._isInvalid || !this._query || "?" == this._query ? "" : this._query
			},
			set search(e) {
				!this._isInvalid && this._isRelative && (this._query = "?", "?" == e[0] && (e = e.slice(1)), a.call(this, e, "query"))
			},
			get hash() {
				return this._isInvalid || !this._fragment || "#" == this._fragment ? "" : this._fragment
			},
			set hash(e) {
				this._isInvalid || (this._fragment = "#", "#" == e[0] && (e = e.slice(1)), a.call(this, e, "fragment"))
			},
			get origin() {
				var e;
				if (this._isInvalid || !this._scheme) return "";
				switch (this._scheme) {
					case "data":
					case "file":
					case "javascript":
					case "mailto":
						return "null"
				}
				return e = this.host, e ? this._scheme + "://" + e : ""
			}
		};
		var w = e.URL;
		w && (c.createObjectURL = function(e) {
			return w.createObjectURL.apply(w, arguments)
		}, c.revokeObjectURL = function(e) {
			w.revokeObjectURL(e)
		}), e.URL = c
	}
}(self), "undefined" == typeof WeakMap && ! function() {
		var e = Object.defineProperty,
			t = Date.now() % 1e9,
			n = function() {
				this.name = "__st" + (1e9 * Math.random() >>> 0) + (t++ + "__")
			};
		n.prototype = {
			set: function(t, n) {
				var o = t[this.name];
				return o && o[0] === t ? o[1] = n : e(t, this.name, {
					value: [t, n],
					writable: !0
				}), this
			},
			get: function(e) {
				var t;
				return (t = e[this.name]) && t[0] === e ? t[1] : void 0
			},
			"delete": function(e) {
				var t = e[this.name];
				return !(!t || t[0] !== e) && (t[0] = t[1] = void 0, !0)
			},
			has: function(e) {
				var t = e[this.name];
				return !!t && t[0] === e
			}
		}, window.WeakMap = n
	}(),
	function(e) {
		function t(e) {
			b.push(e), g || (g = !0, m(o))
		}

		function n(e) {
			return window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(e) || e
		}

		function o() {
			g = !1;
			var e = b;
			b = [], e.sort(function(e, t) {
				return e.uid_ - t.uid_
			});
			var t = !1;
			e.forEach(function(e) {
				var n = e.takeRecords();
				r(e), n.length && (e.callback_(n, e), t = !0)
			}), t && o()
		}

		function r(e) {
			e.nodes_.forEach(function(t) {
				var n = v.get(t);
				n && n.forEach(function(t) {
					t.observer === e && t.removeTransientObservers()
				})
			})
		}

		function i(e, t) {
			for (var n = e; n; n = n.parentNode) {
				var o = v.get(n);
				if (o)
					for (var r = 0; r < o.length; r++) {
						var i = o[r],
							a = i.options;
						if (n === e || a.subtree) {
							var s = t(a);
							s && i.enqueue(s)
						}
					}
			}
		}

		function a(e) {
			this.callback_ = e, this.nodes_ = [], this.records_ = [], this.uid_ = ++y
		}

		function s(e, t) {
			this.type = e, this.target = t, this.addedNodes = [], this.removedNodes = [], this.previousSibling = null, this.nextSibling = null, this.attributeName = null, this.attributeNamespace = null, this.oldValue = null
		}

		function c(e) {
			var t = new s(e.type, e.target);
			return t.addedNodes = e.addedNodes.slice(), t.removedNodes = e.removedNodes.slice(), t.previousSibling = e.previousSibling, t.nextSibling = e.nextSibling, t.attributeName = e.attributeName, t.attributeNamespace = e.attributeNamespace, t.oldValue = e.oldValue, t
		}

		function d(e, t) {
			return E = new s(e, t)
		}

		function l(e) {
			return L ? L : (L = c(E), L.oldValue = e, L)
		}

		function u() {
			E = L = void 0
		}

		function h(e) {
			return e === L || e === E
		}

		function f(e, t) {
			return e === t ? e : L && h(e) ? L : null
		}

		function p(e, t, n) {
			this.observer = e, this.target = t, this.options = n, this.transientObservedNodes = []
		}
		if (!e.JsMutationObserver) {
			var m, v = new WeakMap;
			if (/Trident|Edge/.test(navigator.userAgent)) m = setTimeout;
			else if (window.setImmediate) m = window.setImmediate;
			else {
				var w = [],
					_ = String(Math.random());
				window.addEventListener("message", function(e) {
					if (e.data === _) {
						var t = w;
						w = [], t.forEach(function(e) {
							e()
						})
					}
				}), m = function(e) {
					w.push(e), window.postMessage(_, "*")
				}
			}
			var g = !1,
				b = [],
				y = 0;
			a.prototype = {
				observe: function(e, t) {
					if (e = n(e), !t.childList && !t.attributes && !t.characterData || t.attributeOldValue && !t.attributes || t.attributeFilter && t.attributeFilter.length && !t.attributes || t.characterDataOldValue && !t.characterData) throw new SyntaxError;
					var o = v.get(e);
					o || v.set(e, o = []);
					for (var r, i = 0; i < o.length; i++)
						if (o[i].observer === this) {
							r = o[i], r.removeListeners(), r.options = t;
							break
						}
					r || (r = new p(this, e, t), o.push(r), this.nodes_.push(e)), r.addListeners()
				},
				disconnect: function() {
					this.nodes_.forEach(function(e) {
						for (var t = v.get(e), n = 0; n < t.length; n++) {
							var o = t[n];
							if (o.observer === this) {
								o.removeListeners(), t.splice(n, 1);
								break
							}
						}
					}, this), this.records_ = []
				},
				takeRecords: function() {
					var e = this.records_;
					return this.records_ = [], e
				}
			};
			var E, L;
			p.prototype = {
				enqueue: function(e) {
					var n = this.observer.records_,
						o = n.length;
					if (n.length > 0) {
						var r = n[o - 1],
							i = f(r, e);
						if (i) return void(n[o - 1] = i)
					} else t(this.observer);
					n[o] = e
				},
				addListeners: function() {
					this.addListeners_(this.target)
				},
				addListeners_: function(e) {
					var t = this.options;
					t.attributes && e.addEventListener("DOMAttrModified", this, !0), t.characterData && e.addEventListener("DOMCharacterDataModified", this, !0), t.childList && e.addEventListener("DOMNodeInserted", this, !0), (t.childList || t.subtree) && e.addEventListener("DOMNodeRemoved", this, !0)
				},
				removeListeners: function() {
					this.removeListeners_(this.target)
				},
				removeListeners_: function(e) {
					var t = this.options;
					t.attributes && e.removeEventListener("DOMAttrModified", this, !0), t.characterData && e.removeEventListener("DOMCharacterDataModified", this, !0), t.childList && e.removeEventListener("DOMNodeInserted", this, !0), (t.childList || t.subtree) && e.removeEventListener("DOMNodeRemoved", this, !0)
				},
				addTransientObserver: function(e) {
					if (e !== this.target) {
						this.addListeners_(e), this.transientObservedNodes.push(e);
						var t = v.get(e);
						t || v.set(e, t = []), t.push(this)
					}
				},
				removeTransientObservers: function() {
					var e = this.transientObservedNodes;
					this.transientObservedNodes = [], e.forEach(function(e) {
						this.removeListeners_(e);
						for (var t = v.get(e), n = 0; n < t.length; n++)
							if (t[n] === this) {
								t.splice(n, 1);
								break
							}
					}, this)
				},
				handleEvent: function(e) {
					switch (e.stopImmediatePropagation(), e.type) {
						case "DOMAttrModified":
							var t = e.attrName,
								n = e.relatedNode.namespaceURI,
								o = e.target,
								r = new d("attributes", o);
							r.attributeName = t, r.attributeNamespace = n;
							var a = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;
							i(o, function(e) {
								if (e.attributes && (!e.attributeFilter || !e.attributeFilter.length || e.attributeFilter.indexOf(t) !== -1 || e.attributeFilter.indexOf(n) !== -1)) return e.attributeOldValue ? l(a) : r
							});
							break;
						case "DOMCharacterDataModified":
							var o = e.target,
								r = d("characterData", o),
								a = e.prevValue;
							i(o, function(e) {
								if (e.characterData) return e.characterDataOldValue ? l(a) : r
							});
							break;
						case "DOMNodeRemoved":
							this.addTransientObserver(e.target);
						case "DOMNodeInserted":
							var s, c, h = e.target;
							"DOMNodeInserted" === e.type ? (s = [h], c = []) : (s = [], c = [h]);
							var f = h.previousSibling,
								p = h.nextSibling,
								r = d("childList", e.target.parentNode);
							r.addedNodes = s, r.removedNodes = c, r.previousSibling = f, r.nextSibling = p, i(e.relatedNode, function(e) {
								if (e.childList) return r
							})
					}
					u()
				}
			}, e.JsMutationObserver = a, e.MutationObserver || (e.MutationObserver = a, a._isPolyfilled = !0)
		}
	}(self),
	function() {
		function e(e) {
			switch (e) {
				case "&":
					return "&amp;";
				case "<":
					return "&lt;";
				case ">":
					return "&gt;";
				case " ":
					return "&nbsp;"
			}
		}

		function t(t) {
			return t.replace(u, e)
		}
		var n = "undefined" == typeof HTMLTemplateElement;
		/Trident/.test(navigator.userAgent) && ! function() {
			var e = document.importNode;
			document.importNode = function() {
				var t = e.apply(document, arguments);
				if (t.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
					var n = document.createDocumentFragment();
					return n.appendChild(t), n
				}
				return t
			}
		}();
		var o = function() {
				if (!n) {
					var e = document.createElement("template"),
						t = document.createElement("template");
					t.content.appendChild(document.createElement("div")), e.content.appendChild(t);
					var o = e.cloneNode(!0);
					return 0 === o.content.childNodes.length || 0 === o.content.firstChild.content.childNodes.length
				}
			}(),
			r = "template",
			i = function() {};
		if (n) {
			var a = document.implementation.createHTMLDocument("template"),
				s = !0,
				c = document.createElement("style");
			c.textContent = r + "{display:none;}";
			var d = document.head;
			d.insertBefore(c, d.firstElementChild), i.prototype = Object.create(HTMLElement.prototype), i.decorate = function(e) {
				if (!e.content) {
					e.content = a.createDocumentFragment();
					for (var n; n = e.firstChild;) e.content.appendChild(n);
					if (e.cloneNode = function(e) {
							return i.cloneNode(this, e)
						}, s) try {
						Object.defineProperty(e, "innerHTML", {
							get: function() {
								for (var e = "", n = this.content.firstChild; n; n = n.nextSibling) e += n.outerHTML || t(n.data);
								return e
							},
							set: function(e) {
								for (a.body.innerHTML = e, i.bootstrap(a); this.content.firstChild;) this.content.removeChild(this.content.firstChild);
								for (; a.body.firstChild;) this.content.appendChild(a.body.firstChild)
							},
							configurable: !0
						})
					} catch (o) {
						s = !1
					}
					i.bootstrap(e.content)
				}
			}, i.bootstrap = function(e) {
				for (var t, n = e.querySelectorAll(r), o = 0, a = n.length; o < a && (t = n[o]); o++) i.decorate(t)
			}, document.addEventListener("DOMContentLoaded", function() {
				i.bootstrap(document)
			});
			var l = document.createElement;
			document.createElement = function() {
				"use strict";
				var e = l.apply(document, arguments);
				return "template" === e.localName && i.decorate(e), e
			};
			var u = /[&\u00A0<>]/g
		}
		if (n || o) {
			var h = Node.prototype.cloneNode;
			i.cloneNode = function(e, t) {
				var n = h.call(e, !1);
				return this.decorate && this.decorate(n), t && (n.content.appendChild(h.call(e.content, !0)), this.fixClonedDom(n.content, e.content)), n
			}, i.fixClonedDom = function(e, t) {
				if (t.querySelectorAll)
					for (var n, o, i = t.querySelectorAll(r), a = e.querySelectorAll(r), s = 0, c = a.length; s < c; s++) o = i[s], n = a[s], this.decorate && this.decorate(o), n.parentNode.replaceChild(o.cloneNode(!0), n)
			};
			var f = document.importNode;
			Node.prototype.cloneNode = function(e) {
				var t = h.call(this, e);
				return e && i.fixClonedDom(t, this), t
			}, document.importNode = function(e, t) {
				if (e.localName === r) return i.cloneNode(e, t);
				var n = f.call(document, e, t);
				return t && i.fixClonedDom(n, e), n
			}, o && (HTMLTemplateElement.prototype.cloneNode = function(e) {
				return i.cloneNode(this, e)
			})
		}
		n && (window.HTMLTemplateElement = i)
	}(),
	function(e) {
		"use strict";
		if (!window.performance || !window.performance.now) {
			var t = Date.now();
			window.performance = {
				now: function() {
					return Date.now() - t
				}
			}
		}
		window.requestAnimationFrame || (window.requestAnimationFrame = function() {
			var e = window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
			return e ? function(t) {
				return e(function() {
					t(performance.now())
				})
			} : function(e) {
				return window.setTimeout(e, 1e3 / 60)
			}
		}()), window.cancelAnimationFrame || (window.cancelAnimationFrame = function() {
			return window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || function(e) {
				clearTimeout(e)
			}
		}());
		var n = function() {
			var e = document.createEvent("Event");
			return e.initEvent("foo", !0, !0), e.preventDefault(), e.defaultPrevented
		}();
		if (!n) {
			var o = Event.prototype.preventDefault;
			Event.prototype.preventDefault = function() {
				this.cancelable && (o.call(this), Object.defineProperty(this, "defaultPrevented", {
					get: function() {
						return !0
					},
					configurable: !0
				}))
			}
		}
		var r = /Trident/.test(navigator.userAgent);
		if ((!window.CustomEvent || r && "function" != typeof window.CustomEvent) && (window.CustomEvent = function(e, t) {
				t = t || {};
				var n = document.createEvent("CustomEvent");
				return n.initCustomEvent(e, Boolean(t.bubbles), Boolean(t.cancelable), t.detail), n
			}, window.CustomEvent.prototype = window.Event.prototype), !window.Event || r && "function" != typeof window.Event) {
			var i = window.Event;
			window.Event = function(e, t) {
				t = t || {};
				var n = document.createEvent("Event");
				return n.initEvent(e, Boolean(t.bubbles), Boolean(t.cancelable)), n
			}, window.Event.prototype = i.prototype
		}
	}(window.WebComponents), window.HTMLImports = window.HTMLImports || {
		flags: {}
	},
	function(e) {
		function t(e, t) {
			t = t || p, o(function() {
				i(e, t)
			}, t)
		}

		function n(e) {
			return "complete" === e.readyState || e.readyState === w
		}

		function o(e, t) {
			if (n(t)) e && e();
			else {
				var r = function() {
					"complete" !== t.readyState && t.readyState !== w || (t.removeEventListener(_, r), o(e, t))
				};
				t.addEventListener(_, r)
			}
		}

		function r(e) {
			e.target.__loaded = !0
		}

		function i(e, t) {
			function n() {
				c == d && e && e({
					allImports: s,
					loadedImports: l,
					errorImports: u
				})
			}

			function o(e) {
				r(e), l.push(this), c++, n()
			}

			function i(e) {
				u.push(this), c++, n()
			}
			var s = t.querySelectorAll("link[rel=import]"),
				c = 0,
				d = s.length,
				l = [],
				u = [];
			if (d)
				for (var h, f = 0; f < d && (h = s[f]); f++) a(h) ? (l.push(this), c++, n()) : (h.addEventListener("load", o), h.addEventListener("error", i));
			else n()
		}

		function a(e) {
			return u ? e.__loaded || e["import"] && "loading" !== e["import"].readyState : e.__importParsed
		}

		function s(e) {
			for (var t, n = 0, o = e.length; n < o && (t = e[n]); n++) c(t) && d(t)
		}

		function c(e) {
			return "link" === e.localName && "import" === e.rel
		}

		function d(e) {
			var t = e["import"];
			t ? r({
				target: e
			}) : (e.addEventListener("load", r), e.addEventListener("error", r))
		}
		var l = "import",
			u = Boolean(l in document.createElement("link")),
			h = Boolean(window.ShadowDOMPolyfill),
			f = function(e) {
				return h ? window.ShadowDOMPolyfill.wrapIfNeeded(e) : e
			},
			p = f(document),
			m = {
				get: function() {
					var e = window.HTMLImports.currentScript || document.currentScript || ("complete" !== document.readyState ? document.scripts[document.scripts.length - 1] : null);
					return f(e)
				},
				configurable: !0
			};
		Object.defineProperty(document, "_currentScript", m), Object.defineProperty(p, "_currentScript", m);
		var v = /Trident/.test(navigator.userAgent),
			w = v ? "complete" : "interactive",
			_ = "readystatechange";
		u && (new MutationObserver(function(e) {
			for (var t, n = 0, o = e.length; n < o && (t = e[n]); n++) t.addedNodes && s(t.addedNodes)
		}).observe(document.head, {
			childList: !0
		}), function() {
			if ("loading" === document.readyState)
				for (var e, t = document.querySelectorAll("link[rel=import]"), n = 0, o = t.length; n < o && (e = t[n]); n++) d(e)
		}()), t(function(e) {
			window.HTMLImports.ready = !0, window.HTMLImports.readyTime = (new Date).getTime();
			var t = p.createEvent("CustomEvent");
			t.initCustomEvent("HTMLImportsLoaded", !0, !0, e), p.dispatchEvent(t)
		}), e.IMPORT_LINK_TYPE = l, e.useNative = u, e.rootDocument = p, e.whenReady = t, e.isIE = v
	}(window.HTMLImports),
	function(e) {
		var t = [],
			n = function(e) {
				t.push(e)
			},
			o = function() {
				t.forEach(function(t) {
					t(e)
				})
			};
		e.addModule = n, e.initializeModules = o
	}(window.HTMLImports), window.HTMLImports.addModule(function(e) {
		var t = /(url\()([^)]*)(\))/g,
			n = /(@import[\s]+(?!url\())([^;]*)(;)/g,
			o = {
				resolveUrlsInStyle: function(e, t) {
					var n = e.ownerDocument,
						o = n.createElement("a");
					return e.textContent = this.resolveUrlsInCssText(e.textContent, t, o), e
				},
				resolveUrlsInCssText: function(e, o, r) {
					var i = this.replaceUrls(e, r, o, t);
					return i = this.replaceUrls(i, r, o, n)
				},
				replaceUrls: function(e, t, n, o) {
					return e.replace(o, function(e, o, r, i) {
						var a = r.replace(/["']/g, "");
						return n && (a = new URL(a, n).href), t.href = a, a = t.href, o + "'" + a + "'" + i
					})
				}
			};
		e.path = o
	}), window.HTMLImports.addModule(function(e) {
		var t = {
			async: !0,
			ok: function(e) {
				return e.status >= 200 && e.status < 300 || 304 === e.status || 0 === e.status
			},
			load: function(n, o, r) {
				var i = new XMLHttpRequest;
				return (e.flags.debug || e.flags.bust) && (n += "?" + Math.random()), i.open("GET", n, t.async), i.addEventListener("readystatechange", function(e) {
					if (4 === i.readyState) {
						var n = null;
						try {
							var a = i.getResponseHeader("Location");
							a && (n = "/" === a.substr(0, 1) ? location.origin + a : a)
						} catch (e) {
							console.error(e.message)
						}
						o.call(r, !t.ok(i) && i, i.response || i.responseText, n)
					}
				}), i.send(), i
			},
			loadDocument: function(e, t, n) {
				this.load(e, t, n).responseType = "document"
			}
		};
		e.xhr = t
	}), window.HTMLImports.addModule(function(e) {
		var t = e.xhr,
			n = e.flags,
			o = function(e, t) {
				this.cache = {}, this.onload = e, this.oncomplete = t, this.inflight = 0, this.pending = {}
			};
		o.prototype = {
			addNodes: function(e) {
				this.inflight += e.length;
				for (var t, n = 0, o = e.length; n < o && (t = e[n]); n++) this.require(t);
				this.checkDone()
			},
			addNode: function(e) {
				this.inflight++, this.require(e), this.checkDone()
			},
			require: function(e) {
				var t = e.src || e.href;
				e.__nodeUrl = t, this.dedupe(t, e) || this.fetch(t, e)
			},
			dedupe: function(e, t) {
				if (this.pending[e]) return this.pending[e].push(t), !0;
				return this.cache[e] ? (this.onload(e, t, this.cache[e]), this.tail(), !0) : (this.pending[e] = [t], !1)
			},
			fetch: function(e, o) {
				if (n.load && console.log("fetch", e, o), e)
					if (e.match(/^data:/)) {
						var r = e.split(","),
							i = r[0],
							a = r[1];
						a = i.indexOf(";base64") > -1 ? atob(a) : decodeURIComponent(a), setTimeout(function() {
							this.receive(e, o, null, a)
						}.bind(this), 0)
					} else {
						var s = function(t, n, r) {
							this.receive(e, o, t, n, r)
						}.bind(this);
						t.load(e, s)
					}
				else setTimeout(function() {
					this.receive(e, o, {
						error: "href must be specified"
					}, null)
				}.bind(this), 0)
			},
			receive: function(e, t, n, o, r) {
				this.cache[e] = o;
				for (var i, a = this.pending[e], s = 0, c = a.length; s < c && (i = a[s]); s++) this.onload(e, i, o, n, r), this.tail();
				this.pending[e] = null
			},
			tail: function() {
				--this.inflight, this.checkDone()
			},
			checkDone: function() {
				this.inflight || this.oncomplete()
			}
		}, e.Loader = o
	}), window.HTMLImports.addModule(function(e) {
		var t = function(e) {
			this.addCallback = e, this.mo = new MutationObserver(this.handler.bind(this))
		};
		t.prototype = {
			handler: function(e) {
				for (var t, n = 0, o = e.length; n < o && (t = e[n]); n++) "childList" === t.type && t.addedNodes.length && this.addedNodes(t.addedNodes)
			},
			addedNodes: function(e) {
				this.addCallback && this.addCallback(e);
				for (var t, n = 0, o = e.length; n < o && (t = e[n]); n++) t.children && t.children.length && this.addedNodes(t.children)
			},
			observe: function(e) {
				this.mo.observe(e, {
					childList: !0,
					subtree: !0
				})
			}
		}, e.Observer = t
	}), window.HTMLImports.addModule(function(e) {
		function t(e) {
			return "link" === e.localName && e.rel === l
		}

		function n(e) {
			var t = o(e);
			return "data:text/javascript;charset=utf-8," + encodeURIComponent(t)
		}

		function o(e) {
			return e.textContent + r(e)
		}

		function r(e) {
			var t = e.ownerDocument;
			t.__importedScripts = t.__importedScripts || 0;
			var n = e.ownerDocument.baseURI,
				o = t.__importedScripts ? "-" + t.__importedScripts : "";
			return t.__importedScripts++, "\n//# sourceURL=" + n + o + ".js\n"
		}

		function i(e) {
			var t = e.ownerDocument.createElement("style");
			return t.textContent = e.textContent, a.resolveUrlsInStyle(t), t
		}
		var a = e.path,
			s = e.rootDocument,
			c = e.flags,
			d = e.isIE,
			l = e.IMPORT_LINK_TYPE,
			u = "link[rel=" + l + "]",
			h = {
				documentSelectors: u,
				importsSelectors: [u, "link[rel=stylesheet]:not([type])", "style:not([type])", "script:not([type])", 'script[type="application/javascript"]', 'script[type="text/javascript"]'].join(","),
				map: {
					link: "parseLink",
					script: "parseScript",
					style: "parseStyle"
				},
				dynamicElements: [],
				parseNext: function() {
					var e = this.nextToParse();
					e && this.parse(e)
				},
				parse: function(e) {
					if (this.isParsed(e)) return void(c.parse && console.log("[%s] is already parsed", e.localName));
					var t = this[this.map[e.localName]];
					t && (this.markParsing(e), t.call(this, e))
				},
				parseDynamic: function(e, t) {
					this.dynamicElements.push(e), t || this.parseNext()
				},
				markParsing: function(e) {
					c.parse && console.log("parsing", e), this.parsingElement = e
				},
				markParsingComplete: function(e) {
					e.__importParsed = !0, this.markDynamicParsingComplete(e), e.__importElement && (e.__importElement.__importParsed = !0, this.markDynamicParsingComplete(e.__importElement)), this.parsingElement = null, c.parse && console.log("completed", e)
				},
				markDynamicParsingComplete: function(e) {
					var t = this.dynamicElements.indexOf(e);
					t >= 0 && this.dynamicElements.splice(t, 1)
				},
				parseImport: function(e) {
					if (e["import"] = e.__doc, window.HTMLImports.__importsParsingHook && window.HTMLImports.__importsParsingHook(e), e["import"] && (e["import"].__importParsed = !0), this.markParsingComplete(e), e.__resource && !e.__error ? e.dispatchEvent(new CustomEvent("load", {
							bubbles: !1
						})) : e.dispatchEvent(new CustomEvent("error", {
							bubbles: !1
						})), e.__pending)
						for (var t; e.__pending.length;) t = e.__pending.shift(), t && t({
							target: e
						});
					this.parseNext()
				},
				parseLink: function(e) {
					t(e) ? this.parseImport(e) : (e.href = e.href, this.parseGeneric(e))
				},
				parseStyle: function(e) {
					var t = e;
					e = i(e), t.__appliedElement = e, e.__importElement = t, this.parseGeneric(e)
				},
				parseGeneric: function(e) {
					this.trackElement(e), this.addElementToDocument(e)
				},
				rootImportForElement: function(e) {
					for (var t = e; t.ownerDocument.__importLink;) t = t.ownerDocument.__importLink;
					return t
				},
				addElementToDocument: function(e) {
					var t = this.rootImportForElement(e.__importElement || e);
					t.parentNode.insertBefore(e, t)
				},
				trackElement: function(e, t) {
					var n = this,
						o = function(r) {
							e.removeEventListener("load", o), e.removeEventListener("error", o), t && t(r), n.markParsingComplete(e), n.parseNext()
						};
					if (e.addEventListener("load", o), e.addEventListener("error", o), d && "style" === e.localName) {
						var r = !1;
						if (e.textContent.indexOf("@import") == -1) r = !0;
						else if (e.sheet) {
							r = !0;
							for (var i, a = e.sheet.cssRules, s = a ? a.length : 0, c = 0; c < s && (i = a[c]); c++) i.type === CSSRule.IMPORT_RULE && (r = r && Boolean(i.styleSheet))
						}
						r && setTimeout(function() {
							e.dispatchEvent(new CustomEvent("load", {
								bubbles: !1
							}))
						})
					}
				},
				parseScript: function(t) {
					var o = document.createElement("script");
					o.__importElement = t, o.src = t.src ? t.src : n(t), e.currentScript = t, this.trackElement(o, function(t) {
						o.parentNode && o.parentNode.removeChild(o), e.currentScript = null
					}), this.addElementToDocument(o)
				},
				nextToParse: function() {
					return this._mayParse = [], !this.parsingElement && (this.nextToParseInDoc(s) || this.nextToParseDynamic())
				},
				nextToParseInDoc: function(e, n) {
					if (e && this._mayParse.indexOf(e) < 0) {
						this._mayParse.push(e);
						for (var o, r = e.querySelectorAll(this.parseSelectorsForNode(e)), i = 0, a = r.length; i < a && (o = r[i]); i++)
							if (!this.isParsed(o)) return this.hasResource(o) ? t(o) ? this.nextToParseInDoc(o.__doc, o) : o : void 0
					}
					return n
				},
				nextToParseDynamic: function() {
					return this.dynamicElements[0]
				},
				parseSelectorsForNode: function(e) {
					var t = e.ownerDocument || e;
					return t === s ? this.documentSelectors : this.importsSelectors
				},
				isParsed: function(e) {
					return e.__importParsed
				},
				needsDynamicParsing: function(e) {
					return this.dynamicElements.indexOf(e) >= 0
				},
				hasResource: function(e) {
					return !t(e) || void 0 !== e.__doc
				}
			};
		e.parser = h, e.IMPORT_SELECTOR = u
	}), window.HTMLImports.addModule(function(e) {
		function t(e) {
			return n(e, a)
		}

		function n(e, t) {
			return "link" === e.localName && e.getAttribute("rel") === t
		}

		function o(e) {
			return !!Object.getOwnPropertyDescriptor(e, "baseURI")
		}

		function r(e, t) {
			var n = document.implementation.createHTMLDocument(a);
			n._URL = t;
			var r = n.createElement("base");
			r.setAttribute("href", t), n.baseURI || o(n) || Object.defineProperty(n, "baseURI", {
				value: t
			});
			var i = n.createElement("meta");
			return i.setAttribute("charset", "utf-8"), n.head.appendChild(i), n.head.appendChild(r), n.body.innerHTML = e, window.HTMLTemplateElement && HTMLTemplateElement.bootstrap && HTMLTemplateElement.bootstrap(n), n
		}
		var i = e.flags,
			a = e.IMPORT_LINK_TYPE,
			s = e.IMPORT_SELECTOR,
			c = e.rootDocument,
			d = e.Loader,
			l = e.Observer,
			u = e.parser,
			h = {
				documents: {},
				documentPreloadSelectors: s,
				importsPreloadSelectors: [s].join(","),
				loadNode: function(e) {
					f.addNode(e)
				},
				loadSubtree: function(e) {
					var t = this.marshalNodes(e);
					f.addNodes(t)
				},
				marshalNodes: function(e) {
					return e.querySelectorAll(this.loadSelectorsForNode(e))
				},
				loadSelectorsForNode: function(e) {
					var t = e.ownerDocument || e;
					return t === c ? this.documentPreloadSelectors : this.importsPreloadSelectors
				},
				loaded: function(e, n, o, a, s) {
					if (i.load && console.log("loaded", e, n), n.__resource = o, n.__error = a, t(n)) {
						var c = this.documents[e];
						void 0 === c && (c = a ? null : r(o, s || e), c && (c.__importLink = n, this.bootDocument(c)), this.documents[e] = c), n.__doc = c
					}
					u.parseNext()
				},
				bootDocument: function(e) {
					this.loadSubtree(e), this.observer.observe(e), u.parseNext()
				},
				loadedAll: function() {
					u.parseNext()
				}
			},
			f = new d(h.loaded.bind(h), h.loadedAll.bind(h));
		if (h.observer = new l, !document.baseURI) {
			var p = {
				get: function() {
					var e = document.querySelector("base");
					return e ? e.href : window.location.href
				},
				configurable: !0
			};
			Object.defineProperty(document, "baseURI", p), Object.defineProperty(c, "baseURI", p)
		}
		e.importer = h, e.importLoader = f
	}), window.HTMLImports.addModule(function(e) {
		var t = e.parser,
			n = e.importer,
			o = {
				added: function(e) {
					for (var o, r, i, a, s = 0, c = e.length; s < c && (a = e[s]); s++) o || (o = a.ownerDocument, r = t.isParsed(o)), i = this.shouldLoadNode(a), i && n.loadNode(a), this.shouldParseNode(a) && r && t.parseDynamic(a, i)
				},
				shouldLoadNode: function(e) {
					return 1 === e.nodeType && r.call(e, n.loadSelectorsForNode(e))
				},
				shouldParseNode: function(e) {
					return 1 === e.nodeType && r.call(e, t.parseSelectorsForNode(e))
				}
			};
		n.observer.addCallback = o.added.bind(o);
		var r = HTMLElement.prototype.matches || HTMLElement.prototype.matchesSelector || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector || HTMLElement.prototype.msMatchesSelector
	}),
	function(e) {
		function t() {
			window.HTMLImports.importer.bootDocument(o)
		}
		var n = e.initializeModules;
		e.isIE;
		if (!e.useNative) {
			n();
			var o = e.rootDocument;
			"complete" === document.readyState || "interactive" === document.readyState && !window.attachEvent ? t() : document.addEventListener("DOMContentLoaded", t)
		}
	}(window.HTMLImports), window.CustomElements = window.CustomElements || {
		flags: {}
	},
	function(e) {
		var t = e.flags,
			n = [],
			o = function(e) {
				n.push(e)
			},
			r = function() {
				n.forEach(function(t) {
					t(e)
				})
			};
		e.addModule = o, e.initializeModules = r, e.hasNative = Boolean(document.registerElement), e.isIE = /Trident/.test(navigator.userAgent), e.useNative = !t.register && e.hasNative && !window.ShadowDOMPolyfill && (!window.HTMLImports || window.HTMLImports.useNative)
	}(window.CustomElements), window.CustomElements.addModule(function(e) {
		function t(e, t) {
			n(e, function(e) {
				return !!t(e) || void o(e, t)
			}), o(e, t)
		}

		function n(e, t, o) {
			var r = e.firstElementChild;
			if (!r)
				for (r = e.firstChild; r && r.nodeType !== Node.ELEMENT_NODE;) r = r.nextSibling;
			for (; r;) t(r, o) !== !0 && n(r, t, o), r = r.nextElementSibling;
			return null
		}

		function o(e, n) {
			for (var o = e.shadowRoot; o;) t(o, n), o = o.olderShadowRoot
		}

		function r(e, t) {
			i(e, t, [])
		}

		function i(e, t, n) {
			if (e = window.wrap(e), !(n.indexOf(e) >= 0)) {
				n.push(e);
				for (var o, r = e.querySelectorAll("link[rel=" + a + "]"), s = 0, c = r.length; s < c && (o = r[s]); s++) o["import"] && i(o["import"], t, n);
				t(e)
			}
		}
		var a = window.HTMLImports ? window.HTMLImports.IMPORT_LINK_TYPE : "none";
		e.forDocumentTree = r, e.forSubtree = t
	}), window.CustomElements.addModule(function(e) {
		function t(e, t) {
			return n(e, t) || o(e, t)
		}

		function n(t, n) {
			return !!e.upgrade(t, n) || void(n && a(t))
		}

		function o(e, t) {
			g(e, function(e) {
				if (n(e, t)) return !0
			})
		}

		function r(e) {
			L.push(e), E || (E = !0, setTimeout(i))
		}

		function i() {
			E = !1;
			for (var e, t = L, n = 0, o = t.length; n < o && (e = t[n]); n++) e();
			L = []
		}

		function a(e) {
			y ? r(function() {
				s(e);
			}) : s(e)
		}

		function s(e) {
			e.__upgraded__ && !e.__attached && (e.__attached = !0, e.attachedCallback && e.attachedCallback())
		}

		function c(e) {
			d(e), g(e, function(e) {
				d(e)
			})
		}

		function d(e) {
			y ? r(function() {
				l(e)
			}) : l(e)
		}

		function l(e) {
			e.__upgraded__ && e.__attached && (e.__attached = !1, e.detachedCallback && e.detachedCallback())
		}

		function u(e) {
			for (var t = e, n = window.wrap(document); t;) {
				if (t == n) return !0;
				t = t.parentNode || t.nodeType === Node.DOCUMENT_FRAGMENT_NODE && t.host
			}
		}

		function h(e) {
			if (e.shadowRoot && !e.shadowRoot.__watched) {
				_.dom && console.log("watching shadow-root for: ", e.localName);
				for (var t = e.shadowRoot; t;) m(t), t = t.olderShadowRoot
			}
		}

		function f(e, n) {
			if (_.dom) {
				var o = n[0];
				if (o && "childList" === o.type && o.addedNodes && o.addedNodes) {
					for (var r = o.addedNodes[0]; r && r !== document && !r.host;) r = r.parentNode;
					var i = r && (r.URL || r._URL || r.host && r.host.localName) || "";
					i = i.split("/?").shift().split("/").pop()
				}
				console.group("mutations (%d) [%s]", n.length, i || "")
			}
			var a = u(e);
			n.forEach(function(e) {
				"childList" === e.type && (N(e.addedNodes, function(e) {
					e.localName && t(e, a)
				}), N(e.removedNodes, function(e) {
					e.localName && c(e)
				}))
			}), _.dom && console.groupEnd()
		}

		function p(e) {
			for (e = window.wrap(e), e || (e = window.wrap(document)); e.parentNode;) e = e.parentNode;
			var t = e.__observer;
			t && (f(e, t.takeRecords()), i())
		}

		function m(e) {
			if (!e.__observer) {
				var t = new MutationObserver(f.bind(this, e));
				t.observe(e, {
					childList: !0,
					subtree: !0
				}), e.__observer = t
			}
		}

		function v(e) {
			e = window.wrap(e), _.dom && console.group("upgradeDocument: ", e.baseURI.split("/").pop());
			var n = e === window.wrap(document);
			t(e, n), m(e), _.dom && console.groupEnd()
		}

		function w(e) {
			b(e, v)
		}
		var _ = e.flags,
			g = e.forSubtree,
			b = e.forDocumentTree,
			y = window.MutationObserver._isPolyfilled && _["throttle-attached"];
		e.hasPolyfillMutations = y, e.hasThrottledAttached = y;
		var E = !1,
			L = [],
			N = Array.prototype.forEach.call.bind(Array.prototype.forEach),
			M = Element.prototype.createShadowRoot;
		M && (Element.prototype.createShadowRoot = function() {
			var e = M.call(this);
			return window.CustomElements.watchShadow(this), e
		}), e.watchShadow = h, e.upgradeDocumentTree = w, e.upgradeDocument = v, e.upgradeSubtree = o, e.upgradeAll = t, e.attached = a, e.takeRecords = p
	}), window.CustomElements.addModule(function(e) {
		function t(t, o) {
			if ("template" === t.localName && window.HTMLTemplateElement && HTMLTemplateElement.decorate && HTMLTemplateElement.decorate(t), !t.__upgraded__ && t.nodeType === Node.ELEMENT_NODE) {
				var r = t.getAttribute("is"),
					i = e.getRegisteredDefinition(t.localName) || e.getRegisteredDefinition(r);
				if (i && (r && i.tag == t.localName || !r && !i["extends"])) return n(t, i, o)
			}
		}

		function n(t, n, r) {
			return a.upgrade && console.group("upgrade:", t.localName), n.is && t.setAttribute("is", n.is), o(t, n), t.__upgraded__ = !0, i(t), r && e.attached(t), e.upgradeSubtree(t, r), a.upgrade && console.groupEnd(), t
		}

		function o(e, t) {
			Object.__proto__ ? e.__proto__ = t.prototype : (r(e, t.prototype, t["native"]), e.__proto__ = t.prototype)
		}

		function r(e, t, n) {
			for (var o = {}, r = t; r !== n && r !== HTMLElement.prototype;) {
				for (var i, a = Object.getOwnPropertyNames(r), s = 0; i = a[s]; s++) o[i] || (Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(r, i)), o[i] = 1);
				r = Object.getPrototypeOf(r)
			}
		}

		function i(e) {
			e.createdCallback && e.createdCallback()
		}
		var a = e.flags;
		e.upgrade = t, e.upgradeWithDefinition = n, e.implementPrototype = o
	}), window.CustomElements.addModule(function(e) {
		function t(t, o) {
			var c = o || {};
			if (!t) throw new Error("document.registerElement: first argument `name` must not be empty");
			if (t.indexOf("-") < 0) throw new Error("document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '" + String(t) + "'.");
			if (r(t)) throw new Error("Failed to execute 'registerElement' on 'Document': Registration failed for type '" + String(t) + "'. The type name is invalid.");
			if (d(t)) throw new Error("DuplicateDefinitionError: a type with name '" + String(t) + "' is already registered");
			return c.prototype || (c.prototype = Object.create(HTMLElement.prototype)), c.__name = t.toLowerCase(), c["extends"] && (c["extends"] = c["extends"].toLowerCase()), c.lifecycle = c.lifecycle || {}, c.ancestry = i(c["extends"]), a(c), s(c), n(c.prototype), l(c.__name, c), c.ctor = u(c), c.ctor.prototype = c.prototype, c.prototype.constructor = c.ctor, e.ready && v(document), c.ctor
		}

		function n(e) {
			if (!e.setAttribute._polyfilled) {
				var t = e.setAttribute;
				e.setAttribute = function(e, n) {
					o.call(this, e, n, t)
				};
				var n = e.removeAttribute;
				e.removeAttribute = function(e) {
					o.call(this, e, null, n)
				}, e.setAttribute._polyfilled = !0
			}
		}

		function o(e, t, n) {
			e = e.toLowerCase();
			var o = this.getAttribute(e);
			n.apply(this, arguments);
			var r = this.getAttribute(e);
			this.attributeChangedCallback && r !== o && this.attributeChangedCallback(e, o, r)
		}

		function r(e) {
			for (var t = 0; t < y.length; t++)
				if (e === y[t]) return !0
		}

		function i(e) {
			var t = d(e);
			return t ? i(t["extends"]).concat([t]) : []
		}

		function a(e) {
			for (var t, n = e["extends"], o = 0; t = e.ancestry[o]; o++) n = t.is && t.tag;
			e.tag = n || e.__name, n && (e.is = e.__name)
		}

		function s(e) {
			if (!Object.__proto__) {
				var t = HTMLElement.prototype;
				if (e.is) {
					var n = document.createElement(e.tag);
					t = Object.getPrototypeOf(n)
				}
				for (var o, r = e.prototype, i = !1; r;) r == t && (i = !0), o = Object.getPrototypeOf(r), o && (r.__proto__ = o), r = o;
				i || console.warn(e.tag + " prototype not found in prototype chain for " + e.is), e["native"] = t
			}
		}

		function c(e) {
			return _(N(e.tag), e)
		}

		function d(e) {
			if (e) return E[e.toLowerCase()]
		}

		function l(e, t) {
			E[e] = t
		}

		function u(e) {
			return function() {
				return c(e)
			}
		}

		function h(e, t, n) {
			return e === L ? f(t, n) : M(e, t)
		}

		function f(e, t) {
			e && (e = e.toLowerCase()), t && (t = t.toLowerCase());
			var n = d(t || e);
			if (n) {
				if (e == n.tag && t == n.is) return new n.ctor;
				if (!t && !n.is) return new n.ctor
			}
			var o;
			return t ? (o = f(e), o.setAttribute("is", t), o) : (o = N(e), e.indexOf("-") >= 0 && g(o, HTMLElement), o)
		}

		function p(e, t) {
			var n = e[t];
			e[t] = function() {
				var e = n.apply(this, arguments);
				return w(e), e
			}
		}
		var m, v = (e.isIE, e.upgradeDocumentTree),
			w = e.upgradeAll,
			_ = e.upgradeWithDefinition,
			g = e.implementPrototype,
			b = e.useNative,
			y = ["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"],
			E = {},
			L = "http://www.w3.org/1999/xhtml",
			N = document.createElement.bind(document),
			M = document.createElementNS.bind(document);
		m = Object.__proto__ || b ? function(e, t) {
			return e instanceof t
		} : function(e, t) {
			if (e instanceof t) return !0;
			for (var n = e; n;) {
				if (n === t.prototype) return !0;
				n = n.__proto__
			}
			return !1
		}, p(Node.prototype, "cloneNode"), p(document, "importNode"), document.registerElement = t, document.createElement = f, document.createElementNS = h, e.registry = E, e["instanceof"] = m, e.reservedTagList = y, e.getRegisteredDefinition = d, document.register = document.registerElement
	}),
	function(e) {
		function t() {
			i(window.wrap(document)), window.CustomElements.ready = !0;
			var e = window.requestAnimationFrame || function(e) {
				setTimeout(e, 16)
			};
			e(function() {
				setTimeout(function() {
					window.CustomElements.readyTime = Date.now(), window.HTMLImports && (window.CustomElements.elapsed = window.CustomElements.readyTime - window.HTMLImports.readyTime), document.dispatchEvent(new CustomEvent("WebComponentsReady", {
						bubbles: !0
					}))
				})
			})
		}
		var n = e.useNative,
			o = e.initializeModules;
		e.isIE;
		if (n) {
			var r = function() {};
			e.watchShadow = r, e.upgrade = r, e.upgradeAll = r, e.upgradeDocumentTree = r, e.upgradeSubtree = r, e.takeRecords = r, e["instanceof"] = function(e, t) {
				return e instanceof t
			}
		} else o();
		var i = e.upgradeDocumentTree,
			a = e.upgradeDocument;
		if (window.wrap || (window.ShadowDOMPolyfill ? (window.wrap = window.ShadowDOMPolyfill.wrapIfNeeded, window.unwrap = window.ShadowDOMPolyfill.unwrapIfNeeded) : window.wrap = window.unwrap = function(e) {
				return e
			}), window.HTMLImports && (window.HTMLImports.__importsParsingHook = function(e) {
				e["import"] && a(wrap(e["import"]))
			}), "complete" === document.readyState || e.flags.eager) t();
		else if ("interactive" !== document.readyState || window.attachEvent || window.HTMLImports && !window.HTMLImports.ready) {
			var s = window.HTMLImports && !window.HTMLImports.ready ? "HTMLImportsLoaded" : "DOMContentLoaded";
			window.addEventListener(s, t)
		} else t()
	}(window.CustomElements),
	function(e) {
		var t = document.createElement("style");
		t.textContent = "body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";
		var n = document.querySelector("head");
		n.insertBefore(t, n.firstChild)
	}(window.WebComponents);
(function() {
	function resolve() {
		document.body.removeAttribute("unresolved")
	}
	if (window.WebComponents) addEventListener("WebComponentsReady", resolve);
	else if (document.readyState === "interactive" || document.readyState === "complete") resolve();
	else addEventListener("DOMContentLoaded", resolve)
})();
window.Polymer = {
	Settings: function() {
		var settings = window.Polymer || {};
		if (!settings.noUrlSettings) {
			var parts = location.search.slice(1).split("&");
			for (var i = 0, o; i < parts.length && (o = parts[i]); i++) {
				o = o.split("=");
				o[0] && (settings[o[0]] = o[1] || true)
			}
		}
		settings.wantShadow = settings.dom === "shadow";
		settings.hasShadow = Boolean(Element.prototype.createShadowRoot);
		settings.nativeShadow = settings.hasShadow && !window.ShadowDOMPolyfill;
		settings.useShadow = settings.wantShadow && settings.hasShadow;
		settings.hasNativeImports = Boolean("import" in
			document.createElement("link"));
		settings.useNativeImports = settings.hasNativeImports;
		settings.useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
		settings.useNativeShadow = settings.useShadow && settings.nativeShadow;
		settings.usePolyfillProto = !settings.useNativeCustomElements && !Object.__proto__;
		settings.hasNativeCSSProperties = !navigator.userAgent.match("AppleWebKit/601") && window.CSS && CSS.supports && CSS.supports("box-shadow", "0 0 0 var(--foo)");
		settings.useNativeCSSProperties =
			settings.hasNativeCSSProperties && settings.lazyRegister && settings.useNativeCSSProperties;
		return settings
	}()
};
(function() {
	var userPolymer = window.Polymer;
	window.Polymer = function(prototype) {
		if (typeof prototype === "function") prototype = prototype.prototype;
		if (!prototype) prototype = {};
		var factory = desugar(prototype);
		prototype = factory.prototype;
		var options = {
			prototype: prototype
		};
		if (prototype["extends"]) options["extends"] = prototype["extends"];
		Polymer.telemetry._registrate(prototype);
		document.registerElement(prototype.is, options);
		return factory
	};
	var desugar = function(prototype) {
		var base = Polymer.Base;
		if (prototype["extends"]) base =
			Polymer.Base._getExtendedPrototype(prototype["extends"]);
		prototype = Polymer.Base.chainObject(prototype, base);
		prototype.registerCallback();
		return prototype.constructor
	};
	if (userPolymer)
		for (var i in userPolymer) Polymer[i] = userPolymer[i];
	Polymer.Class = desugar
})();
Polymer.telemetry = {
	registrations: [],
	_regLog: function(prototype) {
		console.log("[" + prototype.is + "]: registered")
	},
	_registrate: function(prototype) {
		this.registrations.push(prototype);
		Polymer.log && this._regLog(prototype)
	},
	dumpRegistrations: function() {
		this.registrations.forEach(this._regLog)
	}
};
Object.defineProperty(window, "currentImport", {
	enumerable: true,
	configurable: true,
	get: function() {
		return (document._currentScript || document.currentScript).ownerDocument
	}
});
Polymer.RenderStatus = {
	_ready: false,
	_callbacks: [],
	whenReady: function(cb) {
		if (this._ready) cb();
		else this._callbacks.push(cb)
	},
	_makeReady: function() {
		this._ready = true;
		for (var i = 0; i < this._callbacks.length; i++) this._callbacks[i]();
		this._callbacks = []
	},
	_catchFirstRender: function() {
		requestAnimationFrame(function() {
			Polymer.RenderStatus._makeReady()
		})
	},
	_afterNextRenderQueue: [],
	_waitingNextRender: false,
	afterNextRender: function(element, fn, args) {
		this._watchNextRender();
		this._afterNextRenderQueue.push([element, fn,
			args
		])
	},
	hasRendered: function() {
		return this._ready
	},
	_watchNextRender: function() {
		if (!this._waitingNextRender) {
			this._waitingNextRender = true;
			var fn = function() {
				Polymer.RenderStatus._flushNextRender()
			};
			if (!this._ready) this.whenReady(fn);
			else requestAnimationFrame(fn)
		}
	},
	_flushNextRender: function() {
		var self = this;
		setTimeout(function() {
			self._flushRenderCallbacks(self._afterNextRenderQueue);
			self._afterNextRenderQueue = [];
			self._waitingNextRender = false
		})
	},
	_flushRenderCallbacks: function(callbacks) {
		for (var i = 0, h; i <
			callbacks.length; i++) {
			h = callbacks[i];
			h[1].apply(h[0], h[2] || Polymer.nar)
		}
	}
};
if (window.HTMLImports) HTMLImports.whenReady(function() {
	Polymer.RenderStatus._catchFirstRender()
});
else Polymer.RenderStatus._catchFirstRender();
Polymer.ImportStatus = Polymer.RenderStatus;
Polymer.ImportStatus.whenLoaded = Polymer.ImportStatus.whenReady;
(function() {
	var settings = Polymer.Settings;
	Polymer.Base = {
		__isPolymerInstance__: true,
		_addFeature: function(feature) {
			this.extend(this, feature)
		},
		registerCallback: function() {
			if (settings.lazyRegister === "max") {
				if (this.beforeRegister) this.beforeRegister()
			} else {
				this._desugarBehaviors();
				this._doBehavior("beforeRegister")
			}
			this._registerFeatures();
			if (!settings.lazyRegister) this.ensureRegisterFinished()
		},
		createdCallback: function() {
			if (!this.__hasRegisterFinished) this._ensureRegisterFinished(this.__proto__);
			Polymer.telemetry.instanceCount++;
			this.root = this;
			this._doBehavior("created");
			this._initFeatures()
		},
		ensureRegisterFinished: function() {
			this._ensureRegisterFinished(this)
		},
		_ensureRegisterFinished: function(proto) {
			if (proto.__hasRegisterFinished !== proto.is || !proto.is) {
				if (settings.lazyRegister === "max") {
					proto._desugarBehaviors();
					proto._doBehaviorOnly("beforeRegister")
				}
				proto.__hasRegisterFinished = proto.is;
				if (proto._finishRegisterFeatures) proto._finishRegisterFeatures();
				proto._doBehavior("registered");
				if (settings.usePolyfillProto && proto !==
					this) proto.extend(this, proto)
			}
		},
		attachedCallback: function() {
			var self = this;
			Polymer.RenderStatus.whenReady(function() {
				self.isAttached = true;
				self._doBehavior("attached")
			})
		},
		detachedCallback: function() {
			var self = this;
			Polymer.RenderStatus.whenReady(function() {
				self.isAttached = false;
				self._doBehavior("detached")
			})
		},
		attributeChangedCallback: function(name, oldValue, newValue) {
			this._attributeChangedImpl(name);
			this._doBehavior("attributeChanged", [name, oldValue, newValue])
		},
		_attributeChangedImpl: function(name) {
			this._setAttributeToProperty(this,
				name)
		},
		extend: function(target, source) {
			if (target && source) {
				var n$ = Object.getOwnPropertyNames(source);
				for (var i = 0, n; i < n$.length && (n = n$[i]); i++) this.copyOwnProperty(n, source, target)
			}
			return target || source
		},
		mixin: function(target, source) {
			for (var i in source) target[i] = source[i];
			return target
		},
		copyOwnProperty: function(name, source, target) {
			var pd = Object.getOwnPropertyDescriptor(source, name);
			if (pd) Object.defineProperty(target, name, pd)
		},
		_logger: function(level, args) {
			if (args.length === 1 && Array.isArray(args[0])) args =
				args[0];
			switch (level) {
				case "log":
				case "warn":
				case "error":
					console[level].apply(console, args);
					break
			}
		},
		_log: function() {
			var args = Array.prototype.slice.call(arguments, 0);
			this._logger("log", args)
		},
		_warn: function() {
			var args = Array.prototype.slice.call(arguments, 0);
			this._logger("warn", args)
		},
		_error: function() {
			var args = Array.prototype.slice.call(arguments, 0);
			this._logger("error", args)
		},
		_logf: function() {
			return this._logPrefix.concat(this.is).concat(Array.prototype.slice.call(arguments, 0))
		}
	};
	Polymer.Base._logPrefix =
		function() {
			var color = window.chrome && !/edge/i.test(navigator.userAgent) || /firefox/i.test(navigator.userAgent);
			return color ? ["%c[%s::%s]:", "font-weight: bold; background-color:#EEEE00;"] : ["[%s::%s]:"]
		}();
	Polymer.Base.chainObject = function(object, inherited) {
		if (object && inherited && object !== inherited) {
			if (!Object.__proto__) object = Polymer.Base.extend(Object.create(inherited), object);
			object.__proto__ = inherited
		}
		return object
	};
	Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
	if (window.CustomElements) Polymer["instanceof"] =
		CustomElements["instanceof"];
	else Polymer["instanceof"] = function(obj, ctor) {
		return obj instanceof ctor
	};
	Polymer.isInstance = function(obj) {
		return Boolean(obj && obj.__isPolymerInstance__)
	};
	Polymer.telemetry.instanceCount = 0
})();
(function() {
	var modules = {};
	var lcModules = {};
	var findModule = function(id) {
		return modules[id] || lcModules[id.toLowerCase()]
	};
	var DomModule = function() {
		return document.createElement("dom-module")
	};
	DomModule.prototype = Object.create(HTMLElement.prototype);
	Polymer.Base.extend(DomModule.prototype, {
		constructor: DomModule,
		createdCallback: function() {
			this.register()
		},
		register: function(id) {
			id = id || this.id || this.getAttribute("name") || this.getAttribute("is");
			if (id) {
				this.id = id;
				modules[id] = this;
				lcModules[id.toLowerCase()] =
					this
			}
		},
		"import": function(id, selector) {
			if (id) {
				var m = findModule(id);
				if (!m) {
					forceDomModulesUpgrade();
					m = findModule(id)
				}
				if (m && selector) m = m.querySelector(selector);
				return m
			}
		}
	});
	var cePolyfill = window.CustomElements && !CustomElements.useNative;
	document.registerElement("dom-module", DomModule);

	function forceDomModulesUpgrade() {
		if (cePolyfill) {
			var script = document._currentScript || document.currentScript;
			var doc = script && script.ownerDocument || document;
			var modules = doc.querySelectorAll("dom-module");
			for (var i = modules.length -
					1, m; i >= 0 && (m = modules[i]); i--)
				if (m.__upgraded__) return;
				else CustomElements.upgrade(m)
		}
	}
})();
Polymer.Base._addFeature({
	_prepIs: function() {
		if (!this.is) {
			var module = (document._currentScript || document.currentScript).parentNode;
			if (module.localName === "dom-module") {
				var id = module.id || module.getAttribute("name") || module.getAttribute("is");
				this.is = id
			}
		}
		if (this.is) this.is = this.is.toLowerCase()
	}
});
Polymer.Base._addFeature({
	behaviors: [],
	_desugarBehaviors: function() {
		if (this.behaviors.length) this.behaviors = this._desugarSomeBehaviors(this.behaviors)
	},
	_desugarSomeBehaviors: function(behaviors) {
		var behaviorSet = [];
		behaviors = this._flattenBehaviorsList(behaviors);
		for (var i = behaviors.length - 1; i >= 0; i--) {
			var b = behaviors[i];
			if (behaviorSet.indexOf(b) === -1) {
				this._mixinBehavior(b);
				behaviorSet.unshift(b)
			}
		}
		return behaviorSet
	},
	_flattenBehaviorsList: function(behaviors) {
		var flat = [];
		for (var i = 0; i < behaviors.length; i++) {
			var b =
				behaviors[i];
			if (b instanceof Array) flat = flat.concat(this._flattenBehaviorsList(b));
			else if (b) flat.push(b);
			else this._warn(this._logf("_flattenBehaviorsList", "behavior is null, check for missing or 404 import"))
		}
		return flat
	},
	_mixinBehavior: function(b) {
		var n$ = Object.getOwnPropertyNames(b);
		for (var i = 0, n; i < n$.length && (n = n$[i]); i++)
			if (!Polymer.Base._behaviorProperties[n] && !this.hasOwnProperty(n)) this.copyOwnProperty(n, b, this)
	},
	_prepBehaviors: function() {
		this._prepFlattenedBehaviors(this.behaviors)
	},
	_prepFlattenedBehaviors: function(behaviors) {
		for (var i =
				0, l = behaviors.length; i < l; i++) this._prepBehavior(behaviors[i]);
		this._prepBehavior(this)
	},
	_doBehavior: function(name, args) {
		for (var i = 0; i < this.behaviors.length; i++) this._invokeBehavior(this.behaviors[i], name, args);
		this._invokeBehavior(this, name, args)
	},
	_doBehaviorOnly: function(name, args) {
		for (var i = 0; i < this.behaviors.length; i++) this._invokeBehavior(this.behaviors[i], name, args)
	},
	_invokeBehavior: function(b, name, args) {
		var fn = b[name];
		if (fn) fn.apply(this, args || Polymer.nar)
	},
	_marshalBehaviors: function() {
		for (var i =
				0; i < this.behaviors.length; i++) this._marshalBehavior(this.behaviors[i]);
		this._marshalBehavior(this)
	}
});
Polymer.Base._behaviorProperties = {
	hostAttributes: true,
	beforeRegister: true,
	registered: true,
	properties: true,
	observers: true,
	listeners: true,
	created: true,
	attached: true,
	detached: true,
	attributeChanged: true,
	ready: true
};
Polymer.Base._addFeature({
	_getExtendedPrototype: function(tag) {
		return this._getExtendedNativePrototype(tag)
	},
	_nativePrototypes: {},
	_getExtendedNativePrototype: function(tag) {
		var p = this._nativePrototypes[tag];
		if (!p) {
			var np = this.getNativePrototype(tag);
			p = this.extend(Object.create(np), Polymer.Base);
			this._nativePrototypes[tag] = p
		}
		return p
	},
	getNativePrototype: function(tag) {
		return Object.getPrototypeOf(document.createElement(tag))
	}
});
Polymer.Base._addFeature({
	_prepConstructor: function() {
		this._factoryArgs = this["extends"] ? [this["extends"], this.is] : [this.is];
		var ctor = function() {
			return this._factory(arguments)
		};
		if (this.hasOwnProperty("extends")) ctor["extends"] = this["extends"];
		Object.defineProperty(this, "constructor", {
			value: ctor,
			writable: true,
			configurable: true
		});
		ctor.prototype = this
	},
	_factory: function(args) {
		var elt = document.createElement.apply(document, this._factoryArgs);
		if (this.factoryImpl) this.factoryImpl.apply(elt, args);
		return elt
	}
});
Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
	properties: {},
	getPropertyInfo: function(property) {
		var info = this._getPropertyInfo(property, this.properties);
		if (!info)
			for (var i = 0; i < this.behaviors.length; i++) {
				info = this._getPropertyInfo(property, this.behaviors[i].properties);
				if (info) return info
			}
		return info || Polymer.nob
	},
	_getPropertyInfo: function(property, properties) {
		var p = properties && properties[property];
		if (typeof p === "function") p = properties[property] = {
			type: p
		};
		if (p) p.defined = true;
		return p
	},
	_prepPropertyInfo: function() {
		this._propertyInfo = {};
		for (var i = 0; i < this.behaviors.length; i++) this._addPropertyInfo(this._propertyInfo, this.behaviors[i].properties);
		this._addPropertyInfo(this._propertyInfo, this.properties);
		this._addPropertyInfo(this._propertyInfo, this._propertyEffects)
	},
	_addPropertyInfo: function(target, source) {
		if (source) {
			var t, s;
			for (var i in source) {
				t = target[i];
				s = source[i];
				if (i[0] === "_" && !s.readOnly) continue;
				if (!target[i]) target[i] = {
					type: typeof s === "function" ? s : s.type,
					readOnly: s.readOnly,
					attribute: Polymer.CaseMap.camelToDashCase(i)
				};
				else {
					if (!t.type) t.type = s.type;
					if (!t.readOnly) t.readOnly = s.readOnly
				}
			}
		}
	}
});
Polymer.CaseMap = {
	_caseMap: {},
	_rx: {
		dashToCamel: /-[a-z]/g,
		camelToDash: /([A-Z])/g
	},
	dashToCamelCase: function(dash) {
		return this._caseMap[dash] || (this._caseMap[dash] = dash.indexOf("-") < 0 ? dash : dash.replace(this._rx.dashToCamel, function(m) {
			return m[1].toUpperCase()
		}))
	},
	camelToDashCase: function(camel) {
		return this._caseMap[camel] || (this._caseMap[camel] = camel.replace(this._rx.camelToDash, "-$1").toLowerCase())
	}
};
Polymer.Base._addFeature({
	_addHostAttributes: function(attributes) {
		if (!this._aggregatedAttributes) this._aggregatedAttributes = {};
		if (attributes) this.mixin(this._aggregatedAttributes, attributes)
	},
	_marshalHostAttributes: function() {
		if (this._aggregatedAttributes) this._applyAttributes(this, this._aggregatedAttributes)
	},
	_applyAttributes: function(node, attr$) {
		for (var n in attr$)
			if (!this.hasAttribute(n) && n !== "class") {
				var v = attr$[n];
				this.serializeValueToAttribute(v, n, this)
			}
	},
	_marshalAttributes: function() {
		this._takeAttributesToModel(this)
	},
	_takeAttributesToModel: function(model) {
		if (this.hasAttributes())
			for (var i in this._propertyInfo) {
				var info = this._propertyInfo[i];
				if (this.hasAttribute(info.attribute)) this._setAttributeToProperty(model, info.attribute, i, info)
			}
	},
	_setAttributeToProperty: function(model, attribute, property, info) {
		if (!this._serializing) {
			property = property || Polymer.CaseMap.dashToCamelCase(attribute);
			info = info || this._propertyInfo && this._propertyInfo[property];
			if (info && !info.readOnly) {
				var v = this.getAttribute(attribute);
				model[property] =
					this.deserialize(v, info.type)
			}
		}
	},
	_serializing: false,
	reflectPropertyToAttribute: function(property, attribute, value) {
		this._serializing = true;
		value = value === undefined ? this[property] : value;
		this.serializeValueToAttribute(value, attribute || Polymer.CaseMap.camelToDashCase(property));
		this._serializing = false
	},
	serializeValueToAttribute: function(value, attribute, node) {
		var str = this.serialize(value);
		node = node || this;
		if (str === undefined) node.removeAttribute(attribute);
		else node.setAttribute(attribute, str)
	},
	deserialize: function(value,
		type) {
		switch (type) {
			case Number:
				value = Number(value);
				break;
			case Boolean:
				value = value != null;
				break;
			case Object:
				try {
					value = JSON.parse(value)
				} catch (x) {}
				break;
			case Array:
				try {
					value = JSON.parse(value)
				} catch (x$0) {
					value = null;
					console.warn("Polymer::Attributes: couldn`t decode Array as JSON")
				}
				break;
			case Date:
				value = new Date(value);
				break;
			case String:
			default:
				break
		}
		return value
	},
	serialize: function(value) {
		switch (typeof value) {
			case "boolean":
				return value ? "" : undefined;
			case "object":
				if (value instanceof Date) return value.toString();
				else if (value) try {
					return JSON.stringify(value)
				} catch (x) {
					return ""
				}
				default: return value != null ? value : undefined
		}
	}
});
Polymer.version = "1.7.0";
Polymer.Base._addFeature({
	_registerFeatures: function() {
		this._prepIs();
		this._prepBehaviors();
		this._prepConstructor();
		this._prepPropertyInfo()
	},
	_prepBehavior: function(b) {
		this._addHostAttributes(b.hostAttributes)
	},
	_marshalBehavior: function(b) {},
	_initFeatures: function() {
		this._marshalHostAttributes();
		this._marshalBehaviors()
	}
});
Polymer.Base._addFeature({
	_prepTemplate: function() {
		if (this._template === undefined) this._template = Polymer.DomModule["import"](this.is, "template");
		if (this._template && this._template.hasAttribute("is")) this._warn(this._logf("_prepTemplate", "top-level Polymer template " + "must not be a type-extension, found", this._template, "Move inside simple <template>."));
		if (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) HTMLTemplateElement.decorate(this._template)
	},
	_stampTemplate: function() {
		if (this._template) this.root =
			this.instanceTemplate(this._template)
	},
	instanceTemplate: function(template) {
		var dom = document.importNode(template._content || template.content, true);
		return dom
	}
});
(function() {
	var baseAttachedCallback = Polymer.Base.attachedCallback;
	Polymer.Base._addFeature({
		_hostStack: [],
		ready: function() {},
		_registerHost: function(host) {
			this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
			if (host && host._clients) host._clients.push(this);
			this._clients = null;
			this._clientsReadied = false
		},
		_beginHosting: function() {
			Polymer.Base._hostStack.push(this);
			if (!this._clients) this._clients = []
		},
		_endHosting: function() {
			Polymer.Base._hostStack.pop()
		},
		_tryReady: function() {
			this._readied =
				false;
			if (this._canReady()) this._ready()
		},
		_canReady: function() {
			return !this.dataHost || this.dataHost._clientsReadied
		},
		_ready: function() {
			this._beforeClientsReady();
			if (this._template) {
				this._setupRoot();
				this._readyClients()
			}
			this._clientsReadied = true;
			this._clients = null;
			this._afterClientsReady();
			this._readySelf()
		},
		_readyClients: function() {
			this._beginDistribute();
			var c$ = this._clients;
			if (c$)
				for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) c._ready();
			this._finishDistribute()
		},
		_readySelf: function() {
			this._doBehavior("ready");
			this._readied = true;
			if (this._attachedPending) {
				this._attachedPending = false;
				this.attachedCallback()
			}
		},
		_beforeClientsReady: function() {},
		_afterClientsReady: function() {},
		_beforeAttached: function() {},
		attachedCallback: function() {
			if (this._readied) {
				this._beforeAttached();
				baseAttachedCallback.call(this)
			} else this._attachedPending = true
		}
	})
})();
Polymer.ArraySplice = function() {
	function newSplice(index, removed, addedCount) {
		return {
			index: index,
			removed: removed,
			addedCount: addedCount
		}
	}
	var EDIT_LEAVE = 0;
	var EDIT_UPDATE = 1;
	var EDIT_ADD = 2;
	var EDIT_DELETE = 3;

	function ArraySplice() {}
	ArraySplice.prototype = {
		calcEditDistances: function(current, currentStart, currentEnd, old, oldStart, oldEnd) {
			var rowCount = oldEnd - oldStart + 1;
			var columnCount = currentEnd - currentStart + 1;
			var distances = new Array(rowCount);
			for (var i = 0; i < rowCount; i++) {
				distances[i] = new Array(columnCount);
				distances[i][0] =
					i
			}
			for (var j = 0; j < columnCount; j++) distances[0][j] = j;
			for (i = 1; i < rowCount; i++)
				for (j = 1; j < columnCount; j++)
					if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1];
					else {
						var north = distances[i - 1][j] + 1;
						var west = distances[i][j - 1] + 1;
						distances[i][j] = north < west ? north : west
					}
			return distances
		},
		spliceOperationsFromEditDistances: function(distances) {
			var i = distances.length - 1;
			var j = distances[0].length - 1;
			var current = distances[i][j];
			var edits = [];
			while (i > 0 || j > 0) {
				if (i == 0) {
					edits.push(EDIT_ADD);
					j--;
					continue
				}
				if (j == 0) {
					edits.push(EDIT_DELETE);
					i--;
					continue
				}
				var northWest = distances[i - 1][j - 1];
				var west = distances[i - 1][j];
				var north = distances[i][j - 1];
				var min;
				if (west < north) min = west < northWest ? west : northWest;
				else min = north < northWest ? north : northWest;
				if (min == northWest) {
					if (northWest == current) edits.push(EDIT_LEAVE);
					else {
						edits.push(EDIT_UPDATE);
						current = northWest
					}
					i--;
					j--
				} else if (min == west) {
					edits.push(EDIT_DELETE);
					i--;
					current = west
				} else {
					edits.push(EDIT_ADD);
					j--;
					current = north
				}
			}
			edits.reverse();
			return edits
		},
		calcSplices: function(current,
			currentStart, currentEnd, old, oldStart, oldEnd) {
			var prefixCount = 0;
			var suffixCount = 0;
			var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
			if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);
			if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
			currentStart += prefixCount;
			oldStart += prefixCount;
			currentEnd -= suffixCount;
			oldEnd -= suffixCount;
			if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];
			if (currentStart ==
				currentEnd) {
				var splice = newSplice(currentStart, [], 0);
				while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);
				return [splice]
			} else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];
			var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
			splice = undefined;
			var splices = [];
			var index = currentStart;
			var oldIndex = oldStart;
			for (var i = 0; i < ops.length; i++) switch (ops[i]) {
				case EDIT_LEAVE:
					if (splice) {
						splices.push(splice);
						splice = undefined
					}
					index++;
					oldIndex++;
					break;
				case EDIT_UPDATE:
					if (!splice) splice = newSplice(index, [], 0);
					splice.addedCount++;
					index++;
					splice.removed.push(old[oldIndex]);
					oldIndex++;
					break;
				case EDIT_ADD:
					if (!splice) splice = newSplice(index, [], 0);
					splice.addedCount++;
					index++;
					break;
				case EDIT_DELETE:
					if (!splice) splice = newSplice(index, [], 0);
					splice.removed.push(old[oldIndex]);
					oldIndex++;
					break
			}
			if (splice) splices.push(splice);
			return splices
		},
		sharedPrefix: function(current, old, searchLength) {
			for (var i = 0; i < searchLength; i++)
				if (!this.equals(current[i],
						old[i])) return i;
			return searchLength
		},
		sharedSuffix: function(current, old, searchLength) {
			var index1 = current.length;
			var index2 = old.length;
			var count = 0;
			while (count < searchLength && this.equals(current[--index1], old[--index2])) count++;
			return count
		},
		calculateSplices: function(current, previous) {
			return this.calcSplices(current, 0, current.length, previous, 0, previous.length)
		},
		equals: function(currentValue, previousValue) {
			return currentValue === previousValue
		}
	};
	return new ArraySplice
}();
Polymer.domInnerHTML = function() {
	var escapeAttrRegExp = /[&\u00A0"]/g;
	var escapeDataRegExp = /[&\u00A0<>]/g;

	function escapeReplace(c) {
		switch (c) {
			case "&":
				return "&amp;";
			case "<":
				return "&lt;";
			case ">":
				return "&gt;";
			case '"':
				return "&quot;";
			case "\u00a0":
				return "&nbsp;"
		}
	}

	function escapeAttr(s) {
		return s.replace(escapeAttrRegExp, escapeReplace)
	}

	function escapeData(s) {
		return s.replace(escapeDataRegExp, escapeReplace)
	}

	function makeSet(arr) {
		var set = {};
		for (var i = 0; i < arr.length; i++) set[arr[i]] = true;
		return set
	}
	var voidElements =
		makeSet(["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"]);
	var plaintextParents = makeSet(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);

	function getOuterHTML(node, parentNode, composed) {
		switch (node.nodeType) {
			case Node.ELEMENT_NODE:
				var tagName = node.localName;
				var s = "<" + tagName;
				var attrs = node.attributes;
				for (var i = 0, attr; attr = attrs[i]; i++) s += " " + attr.name + '="' + escapeAttr(attr.value) + '"';
				s += ">";
				if (voidElements[tagName]) return s;
				return s + getInnerHTML(node, composed) + "</" + tagName + ">";
			case Node.TEXT_NODE:
				var data = node.data;
				if (parentNode && plaintextParents[parentNode.localName]) return data;
				return escapeData(data);
			case Node.COMMENT_NODE:
				return "\x3c!--" + node.data + "--\x3e";
			default:
				console.error(node);
				throw new Error("not implemented");
		}
	}

	function getInnerHTML(node, composed) {
		if (node instanceof HTMLTemplateElement) node = node.content;
		var s = "";
		var c$ = Polymer.dom(node).childNodes;
		for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) s +=
			getOuterHTML(child, node, composed);
		return s
	}
	return {
		getInnerHTML: getInnerHTML
	}
}();
(function() {
	var nativeInsertBefore = Element.prototype.insertBefore;
	var nativeAppendChild = Element.prototype.appendChild;
	var nativeRemoveChild = Element.prototype.removeChild;
	Polymer.TreeApi = {
		arrayCopyChildNodes: function(parent) {
			var copy = [],
				i = 0;
			for (var n = parent.firstChild; n; n = n.nextSibling) copy[i++] = n;
			return copy
		},
		arrayCopyChildren: function(parent) {
			var copy = [],
				i = 0;
			for (var n = parent.firstElementChild; n; n = n.nextElementSibling) copy[i++] = n;
			return copy
		},
		arrayCopy: function(a$) {
			var l = a$.length;
			var copy = new Array(l);
			for (var i = 0; i < l; i++) copy[i] = a$[i];
			return copy
		}
	};
	Polymer.TreeApi.Logical = {
		hasParentNode: function(node) {
			return Boolean(node.__dom && node.__dom.parentNode)
		},
		hasChildNodes: function(node) {
			return Boolean(node.__dom && node.__dom.childNodes !== undefined)
		},
		getChildNodes: function(node) {
			return this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes
		},
		_getChildNodes: function(node) {
			if (!node.__dom.childNodes) {
				node.__dom.childNodes = [];
				for (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) node.__dom.childNodes.push(n)
			}
			return node.__dom.childNodes
		},
		getParentNode: function(node) {
			return node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode
		},
		getFirstChild: function(node) {
			return node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild
		},
		getLastChild: function(node) {
			return node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild
		},
		getNextSibling: function(node) {
			return node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling
		},
		getPreviousSibling: function(node) {
			return node.__dom &&
				node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling
		},
		getFirstElementChild: function(node) {
			return node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild
		},
		_getFirstElementChild: function(node) {
			var n = node.__dom.firstChild;
			while (n && n.nodeType !== Node.ELEMENT_NODE) n = n.__dom.nextSibling;
			return n
		},
		getLastElementChild: function(node) {
			return node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild
		},
		_getLastElementChild: function(node) {
			var n = node.__dom.lastChild;
			while (n && n.nodeType !== Node.ELEMENT_NODE) n = n.__dom.previousSibling;
			return n
		},
		getNextElementSibling: function(node) {
			return node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling
		},
		_getNextElementSibling: function(node) {
			var n = node.__dom.nextSibling;
			while (n && n.nodeType !== Node.ELEMENT_NODE) n = n.__dom.nextSibling;
			return n
		},
		getPreviousElementSibling: function(node) {
			return node.__dom && node.__dom.previousSibling !==
				undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling
		},
		_getPreviousElementSibling: function(node) {
			var n = node.__dom.previousSibling;
			while (n && n.nodeType !== Node.ELEMENT_NODE) n = n.__dom.previousSibling;
			return n
		},
		saveChildNodes: function(node) {
			if (!this.hasChildNodes(node)) {
				node.__dom = node.__dom || {};
				node.__dom.firstChild = node.firstChild;
				node.__dom.lastChild = node.lastChild;
				node.__dom.childNodes = [];
				for (var n = node.firstChild; n; n = n.nextSibling) {
					n.__dom = n.__dom || {};
					n.__dom.parentNode = node;
					node.__dom.childNodes.push(n);
					n.__dom.nextSibling = n.nextSibling;
					n.__dom.previousSibling = n.previousSibling
				}
			}
		},
		recordInsertBefore: function(node, container, ref_node) {
			container.__dom.childNodes = null;
			if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
				for (var n = node.firstChild; n; n = n.nextSibling) this._linkNode(n, container, ref_node);
			else this._linkNode(node, container, ref_node)
		},
		_linkNode: function(node, container, ref_node) {
			node.__dom = node.__dom || {};
			container.__dom = container.__dom || {};
			if (ref_node) ref_node.__dom =
				ref_node.__dom || {};
			node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;
			if (node.__dom.previousSibling) node.__dom.previousSibling.__dom.nextSibling = node;
			node.__dom.nextSibling = ref_node || null;
			if (node.__dom.nextSibling) node.__dom.nextSibling.__dom.previousSibling = node;
			node.__dom.parentNode = container;
			if (ref_node) {
				if (ref_node === container.__dom.firstChild) container.__dom.firstChild = node
			} else {
				container.__dom.lastChild = node;
				if (!container.__dom.firstChild) container.__dom.firstChild =
					node
			}
			container.__dom.childNodes = null
		},
		recordRemoveChild: function(node, container) {
			node.__dom = node.__dom || {};
			container.__dom = container.__dom || {};
			if (node === container.__dom.firstChild) container.__dom.firstChild = node.__dom.nextSibling;
			if (node === container.__dom.lastChild) container.__dom.lastChild = node.__dom.previousSibling;
			var p = node.__dom.previousSibling;
			var n = node.__dom.nextSibling;
			if (p) p.__dom.nextSibling = n;
			if (n) n.__dom.previousSibling = p;
			node.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling =
				undefined;
			container.__dom.childNodes = null
		}
	};
	Polymer.TreeApi.Composed = {
		getChildNodes: function(node) {
			return Polymer.TreeApi.arrayCopyChildNodes(node)
		},
		getParentNode: function(node) {
			return node.parentNode
		},
		clearChildNodes: function(node) {
			node.textContent = ""
		},
		insertBefore: function(parentNode, newChild, refChild) {
			return nativeInsertBefore.call(parentNode, newChild, refChild || null)
		},
		appendChild: function(parentNode, newChild) {
			return nativeAppendChild.call(parentNode, newChild)
		},
		removeChild: function(parentNode, node) {
			return nativeRemoveChild.call(parentNode,
				node)
		}
	}
})();
Polymer.DomApi = function() {
	var Settings = Polymer.Settings;
	var TreeApi = Polymer.TreeApi;
	var DomApi = function(node) {
		this.node = needsToWrap ? DomApi.wrap(node) : node
	};
	var needsToWrap = Settings.hasShadow && !Settings.nativeShadow;
	DomApi.wrap = window.wrap ? window.wrap : function(node) {
		return node
	};
	DomApi.prototype = {
		flush: function() {
			Polymer.dom.flush()
		},
		deepContains: function(node) {
			if (this.node.contains(node)) return true;
			var n = node;
			var doc = node.ownerDocument;
			while (n && n !== doc && n !== this.node) n = Polymer.dom(n).parentNode || n.host;
			return n === this.node
		},
		queryDistributedElements: function(selector) {
			var c$ = this.getEffectiveChildNodes();
			var list = [];
			for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
				if (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) list.push(c);
			return list
		},
		getEffectiveChildNodes: function() {
			var list = [];
			var c$ = this.childNodes;
			for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
				if (c.localName === CONTENT) {
					var d$ = dom(c).getDistributedNodes();
					for (var j = 0; j < d$.length; j++) list.push(d$[j])
				} else list.push(c);
			return list
		},
		observeNodes: function(callback) {
			if (callback) {
				if (!this.observer) this.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);
				return this.observer.addListener(callback)
			}
		},
		unobserveNodes: function(handle) {
			if (this.observer) this.observer.removeListener(handle)
		},
		notifyObserver: function() {
			if (this.observer) this.observer.notify()
		},
		_query: function(matcher, node, halter) {
			node = node || this.node;
			var list = [];
			this._queryElements(TreeApi.Logical.getChildNodes(node),
				matcher, halter, list);
			return list
		},
		_queryElements: function(elements, matcher, halter, list) {
			for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++)
				if (c.nodeType === Node.ELEMENT_NODE)
					if (this._queryElement(c, matcher, halter, list)) return true
		},
		_queryElement: function(node, matcher, halter, list) {
			var result = matcher(node);
			if (result) list.push(node);
			if (halter && halter(result)) return result;
			this._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list)
		}
	};
	var CONTENT = DomApi.CONTENT = "content";
	var dom =
		DomApi.factory = function(node) {
			node = node || document;
			if (!node.__domApi) node.__domApi = new DomApi.ctor(node);
			return node.__domApi
		};
	DomApi.hasApi = function(node) {
		return Boolean(node.__domApi)
	};
	DomApi.ctor = DomApi;
	Polymer.dom = function(obj, patch) {
		if (obj instanceof Event) return Polymer.EventApi.factory(obj);
		else return DomApi.factory(obj, patch)
	};
	var p = Element.prototype;
	DomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
	return DomApi
}();
(function() {
	var Settings = Polymer.Settings;
	var DomApi = Polymer.DomApi;
	var dom = DomApi.factory;
	var TreeApi = Polymer.TreeApi;
	var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
	var CONTENT = DomApi.CONTENT;
	if (Settings.useShadow) return;
	var nativeCloneNode = Element.prototype.cloneNode;
	var nativeImportNode = Document.prototype.importNode;
	Polymer.Base.extend(DomApi.prototype, {
		_lazyDistribute: function(host) {
			if (host.shadyRoot && host.shadyRoot._distributionClean) {
				host.shadyRoot._distributionClean = false;
				Polymer.dom.addDebouncer(host.debounce("_distribute",
					host._distributeContent))
			}
		},
		appendChild: function(node) {
			return this.insertBefore(node)
		},
		insertBefore: function(node, ref_node) {
			if (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) throw Error("The ref_node to be inserted before is not a child " + "of this node");
			if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
				var parent = TreeApi.Logical.getParentNode(node);
				if (parent) {
					if (DomApi.hasApi(parent)) dom(parent).notifyObserver();
					this._removeNode(node)
				} else this._removeOwnerShadyRoot(node)
			}
			if (!this._addNode(node,
					ref_node)) {
				if (ref_node) ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
				var container = this.node._isShadyRoot ? this.node.host : this.node;
				if (ref_node) TreeApi.Composed.insertBefore(container, node, ref_node);
				else TreeApi.Composed.appendChild(container, node)
			}
			this.notifyObserver();
			return node
		},
		_addNode: function(node, ref_node) {
			var root = this.getOwnerRoot();
			if (root) {
				var ipAdded = this._maybeAddInsertionPoint(node, this.node);
				if (!root._invalidInsertionPoints) root._invalidInsertionPoints =
					ipAdded;
				this._addNodeToHost(root.host, node)
			}
			if (TreeApi.Logical.hasChildNodes(this.node)) TreeApi.Logical.recordInsertBefore(node, this.node, ref_node);
			var handled = this._maybeDistribute(node) || this.node.shadyRoot;
			if (handled)
				if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
					while (node.firstChild) TreeApi.Composed.removeChild(node, node.firstChild);
				else {
					var parent = TreeApi.Composed.getParentNode(node);
					if (parent) TreeApi.Composed.removeChild(parent, node)
				}
			return handled
		},
		removeChild: function(node) {
			if (TreeApi.Logical.getParentNode(node) !==
				this.node) throw Error("The node to be removed is not a child of this node: " + node);
			if (!this._removeNode(node)) {
				var container = this.node._isShadyRoot ? this.node.host : this.node;
				var parent = TreeApi.Composed.getParentNode(node);
				if (container === parent) TreeApi.Composed.removeChild(container, node)
			}
			this.notifyObserver();
			return node
		},
		_removeNode: function(node) {
			var logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);
			var distributed;
			var root = this._ownerShadyRootForNode(node);
			if (logicalParent) {
				distributed =
					dom(node)._maybeDistributeParent();
				TreeApi.Logical.recordRemoveChild(node, logicalParent);
				if (root && this._removeDistributedChildren(root, node)) {
					root._invalidInsertionPoints = true;
					this._lazyDistribute(root.host)
				}
			}
			this._removeOwnerShadyRoot(node);
			if (root) this._removeNodeFromHost(root.host, node);
			return distributed
		},
		replaceChild: function(node, ref_node) {
			this.insertBefore(node, ref_node);
			this.removeChild(ref_node);
			return node
		},
		_hasCachedOwnerRoot: function(node) {
			return Boolean(node._ownerShadyRoot !== undefined)
		},
		getOwnerRoot: function() {
			return this._ownerShadyRootForNode(this.node)
		},
		_ownerShadyRootForNode: function(node) {
			if (!node) return;
			var root = node._ownerShadyRoot;
			if (root === undefined) {
				if (node._isShadyRoot) root = node;
				else {
					var parent = TreeApi.Logical.getParentNode(node);
					if (parent) root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
					else root = null
				}
				if (root || document.documentElement.contains(node)) node._ownerShadyRoot = root
			}
			return root
		},
		_maybeDistribute: function(node) {
			var fragContent = node.nodeType ===
				Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);
			var wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
			var hasContent = fragContent || node.localName === CONTENT;
			if (hasContent) {
				var root = this.getOwnerRoot();
				if (root) this._lazyDistribute(root.host)
			}
			var needsDist = this._nodeNeedsDistribution(this.node);
			if (needsDist) this._lazyDistribute(this.node);
			return needsDist || hasContent && !wrappedContent
		},
		_maybeAddInsertionPoint: function(node,
			parent) {
			var added;
			if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {
				var c$ = dom(node).querySelectorAll(CONTENT);
				for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
					np = TreeApi.Logical.getParentNode(n);
					if (np === node) np = parent;
					na = this._maybeAddInsertionPoint(n, np);
					added = added || na
				}
			} else if (node.localName === CONTENT) {
				TreeApi.Logical.saveChildNodes(parent);
				TreeApi.Logical.saveChildNodes(node);
				added = true
			}
			return added
		},
		_updateInsertionPoints: function(host) {
			var i$ = host.shadyRoot._insertionPoints =
				dom(host.shadyRoot).querySelectorAll(CONTENT);
			for (var i = 0, c; i < i$.length; i++) {
				c = i$[i];
				TreeApi.Logical.saveChildNodes(c);
				TreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c))
			}
		},
		_nodeNeedsDistribution: function(node) {
			return node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot)
		},
		_addNodeToHost: function(host, node) {
			if (host._elementAdd) host._elementAdd(node)
		},
		_removeNodeFromHost: function(host, node) {
			if (host._elementRemove) host._elementRemove(node)
		},
		_removeDistributedChildren: function(root,
			container) {
			var hostNeedsDist;
			var ip$ = root._insertionPoints;
			for (var i = 0; i < ip$.length; i++) {
				var content = ip$[i];
				if (this._contains(container, content)) {
					var dc$ = dom(content).getDistributedNodes();
					for (var j = 0; j < dc$.length; j++) {
						hostNeedsDist = true;
						var node = dc$[j];
						var parent = TreeApi.Composed.getParentNode(node);
						if (parent) TreeApi.Composed.removeChild(parent, node)
					}
				}
			}
			return hostNeedsDist
		},
		_contains: function(container, node) {
			while (node) {
				if (node == container) return true;
				node = TreeApi.Logical.getParentNode(node)
			}
		},
		_removeOwnerShadyRoot: function(node) {
			if (this._hasCachedOwnerRoot(node)) {
				var c$ =
					TreeApi.Logical.getChildNodes(node);
				for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) this._removeOwnerShadyRoot(n)
			}
			node._ownerShadyRoot = undefined
		},
		_firstComposedNode: function(content) {
			var n$ = dom(content).getDistributedNodes();
			for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
				p$ = dom(n).getDestinationInsertionPoints();
				if (p$[p$.length - 1] === content) return n
			}
		},
		querySelector: function(selector) {
			var result = this._query(function(n) {
				return DomApi.matchesSelector.call(n, selector)
			}, this.node, function(n) {
				return Boolean(n)
			})[0];
			return result || null
		},
		querySelectorAll: function(selector) {
			return this._query(function(n) {
				return DomApi.matchesSelector.call(n, selector)
			}, this.node)
		},
		getDestinationInsertionPoints: function() {
			return this.node._destinationInsertionPoints || []
		},
		getDistributedNodes: function() {
			return this.node._distributedNodes || []
		},
		_clear: function() {
			while (this.childNodes.length) this.removeChild(this.childNodes[0])
		},
		setAttribute: function(name, value) {
			this.node.setAttribute(name, value);
			this._maybeDistributeParent()
		},
		removeAttribute: function(name) {
			this.node.removeAttribute(name);
			this._maybeDistributeParent()
		},
		_maybeDistributeParent: function() {
			if (this._nodeNeedsDistribution(this.parentNode)) {
				this._lazyDistribute(this.parentNode);
				return true
			}
		},
		cloneNode: function(deep) {
			var n = nativeCloneNode.call(this.node, false);
			if (deep) {
				var c$ = this.childNodes;
				var d = dom(n);
				for (var i = 0, nc; i < c$.length; i++) {
					nc = dom(c$[i]).cloneNode(true);
					d.appendChild(nc)
				}
			}
			return n
		},
		importNode: function(externalNode, deep) {
			var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
			var n = nativeImportNode.call(doc,
				externalNode, false);
			if (deep) {
				var c$ = TreeApi.Logical.getChildNodes(externalNode);
				var d = dom(n);
				for (var i = 0, nc; i < c$.length; i++) {
					nc = dom(doc).importNode(c$[i], true);
					d.appendChild(nc)
				}
			}
			return n
		},
		_getComposedInnerHTML: function() {
			return getInnerHTML(this.node, true)
		}
	});
	Object.defineProperties(DomApi.prototype, {
		activeElement: {
			get: function() {
				var active = document.activeElement;
				if (!active) return null;
				var isShadyRoot = !!this.node._isShadyRoot;
				if (this.node !== document) {
					if (!isShadyRoot) return null;
					if (this.node.host ===
						active || !this.node.host.contains(active)) return null
				}
				var activeRoot = dom(active).getOwnerRoot();
				while (activeRoot && activeRoot !== this.node) {
					active = activeRoot.host;
					activeRoot = dom(active).getOwnerRoot()
				}
				if (this.node === document) return activeRoot ? null : active;
				else return activeRoot === this.node ? active : null
			},
			configurable: true
		},
		childNodes: {
			get: function() {
				var c$ = TreeApi.Logical.getChildNodes(this.node);
				return Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node)
			},
			configurable: true
		},
		children: {
			get: function() {
				if (TreeApi.Logical.hasChildNodes(this.node)) return Array.prototype.filter.call(this.childNodes,
					function(n) {
						return n.nodeType === Node.ELEMENT_NODE
					});
				else return TreeApi.arrayCopyChildren(this.node)
			},
			configurable: true
		},
		parentNode: {
			get: function() {
				return TreeApi.Logical.getParentNode(this.node)
			},
			configurable: true
		},
		firstChild: {
			get: function() {
				return TreeApi.Logical.getFirstChild(this.node)
			},
			configurable: true
		},
		lastChild: {
			get: function() {
				return TreeApi.Logical.getLastChild(this.node)
			},
			configurable: true
		},
		nextSibling: {
			get: function() {
				return TreeApi.Logical.getNextSibling(this.node)
			},
			configurable: true
		},
		previousSibling: {
			get: function() {
				return TreeApi.Logical.getPreviousSibling(this.node)
			},
			configurable: true
		},
		firstElementChild: {
			get: function() {
				return TreeApi.Logical.getFirstElementChild(this.node)
			},
			configurable: true
		},
		lastElementChild: {
			get: function() {
				return TreeApi.Logical.getLastElementChild(this.node)
			},
			configurable: true
		},
		nextElementSibling: {
			get: function() {
				return TreeApi.Logical.getNextElementSibling(this.node)
			},
			configurable: true
		},
		previousElementSibling: {
			get: function() {
				return TreeApi.Logical.getPreviousElementSibling(this.node)
			},
			configurable: true
		},
		textContent: {
			get: function() {
				var nt = this.node.nodeType;
				if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) return this.node.textContent;
				else {
					var tc = [];
					for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++)
						if (c.nodeType !== Node.COMMENT_NODE) tc.push(c.textContent);
					return tc.join("")
				}
			},
			set: function(text) {
				var nt = this.node.nodeType;
				if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) this.node.textContent = text;
				else {
					this._clear();
					if (text) this.appendChild(document.createTextNode(text))
				}
			},
			configurable: true
		},
		innerHTML: {
			get: function() {
				var nt = this.node.nodeType;
				if (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) return null;
				else return getInnerHTML(this.node)
			},
			set: function(text) {
				var nt = this.node.nodeType;
				if (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {
					this._clear();
					var d = document.createElement("div");
					d.innerHTML = text;
					var c$ = TreeApi.arrayCopyChildNodes(d);
					for (var i = 0; i < c$.length; i++) this.appendChild(c$[i])
				}
			},
			configurable: true
		}
	});
	DomApi.hasInsertionPoint = function(root) {
		return Boolean(root && root._insertionPoints.length)
	}
})();
(function() {
	var Settings = Polymer.Settings;
	var TreeApi = Polymer.TreeApi;
	var DomApi = Polymer.DomApi;
	if (!Settings.useShadow) return;
	Polymer.Base.extend(DomApi.prototype, {
		querySelectorAll: function(selector) {
			return TreeApi.arrayCopy(this.node.querySelectorAll(selector))
		},
		getOwnerRoot: function() {
			var n = this.node;
			while (n) {
				if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) return n;
				n = n.parentNode
			}
		},
		importNode: function(externalNode, deep) {
			var doc = this.node instanceof Document ? this.node : this.node.ownerDocument;
			return doc.importNode(externalNode, deep)
		},
		getDestinationInsertionPoints: function() {
			var n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();
			return n$ ? TreeApi.arrayCopy(n$) : []
		},
		getDistributedNodes: function() {
			var n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();
			return n$ ? TreeApi.arrayCopy(n$) : []
		}
	});
	Object.defineProperties(DomApi.prototype, {
		activeElement: {
			get: function() {
				var node = DomApi.wrap(this.node);
				var activeElement = node.activeElement;
				return node.contains(activeElement) ?
					activeElement : null
			},
			configurable: true
		},
		childNodes: {
			get: function() {
				return TreeApi.arrayCopyChildNodes(this.node)
			},
			configurable: true
		},
		children: {
			get: function() {
				return TreeApi.arrayCopyChildren(this.node)
			},
			configurable: true
		},
		textContent: {
			get: function() {
				return this.node.textContent
			},
			set: function(value) {
				return this.node.textContent = value
			},
			configurable: true
		},
		innerHTML: {
			get: function() {
				return this.node.innerHTML
			},
			set: function(value) {
				return this.node.innerHTML = value
			},
			configurable: true
		}
	});
	var forwardMethods =
		function(m$) {
			for (var i = 0; i < m$.length; i++) forwardMethod(m$[i])
		};
	var forwardMethod = function(method) {
		DomApi.prototype[method] = function() {
			return this.node[method].apply(this.node, arguments)
		}
	};
	forwardMethods(["cloneNode", "appendChild", "insertBefore", "removeChild", "replaceChild", "setAttribute", "removeAttribute", "querySelector"]);
	var forwardProperties = function(f$) {
		for (var i = 0; i < f$.length; i++) forwardProperty(f$[i])
	};
	var forwardProperty = function(name) {
		Object.defineProperty(DomApi.prototype, name, {
			get: function() {
				return this.node[name]
			},
			configurable: true
		})
	};
	forwardProperties(["parentNode", "firstChild", "lastChild", "nextSibling", "previousSibling", "firstElementChild", "lastElementChild", "nextElementSibling", "previousElementSibling"])
})();
Polymer.Base.extend(Polymer.dom, {
	_flushGuard: 0,
	_FLUSH_MAX: 100,
	_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,
	_debouncers: [],
	_staticFlushList: [],
	_finishDebouncer: null,
	flush: function() {
		this._flushGuard = 0;
		this._prepareFlush();
		while (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {
			while (this._debouncers.length) this._debouncers.shift().complete();
			if (this._finishDebouncer) this._finishDebouncer.complete();
			this._prepareFlush();
			this._flushGuard++
		}
		if (this._flushGuard >= this._FLUSH_MAX) console.warn("Polymer.dom.flush aborted. Flush may not be complete.")
	},
	_prepareFlush: function() {
		if (this._needsTakeRecords) CustomElements.takeRecords();
		for (var i = 0; i < this._staticFlushList.length; i++) this._staticFlushList[i]()
	},
	addStaticFlush: function(fn) {
		this._staticFlushList.push(fn)
	},
	removeStaticFlush: function(fn) {
		var i = this._staticFlushList.indexOf(fn);
		if (i >= 0) this._staticFlushList.splice(i, 1)
	},
	addDebouncer: function(debouncer) {
		this._debouncers.push(debouncer);
		this._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush)
	},
	_finishFlush: function() {
		Polymer.dom._debouncers = []
	}
});
Polymer.EventApi = function() {
	var DomApi = Polymer.DomApi.ctor;
	var Settings = Polymer.Settings;
	DomApi.Event = function(event) {
		this.event = event
	};
	if (Settings.useShadow) DomApi.Event.prototype = {get rootTarget() {
			return this.event.path[0]
		},
		get localTarget() {
			return this.event.target
		},
		get path() {
			var path = this.event.path;
			if (!Array.isArray(path)) path = Array.prototype.slice.call(path);
			return path
		}
	};
	else DomApi.Event.prototype = {get rootTarget() {
			return this.event.target
		},
		get localTarget() {
			var current = this.event.currentTarget;
			var currentRoot =
				current && Polymer.dom(current).getOwnerRoot();
			var p$ = this.path;
			for (var i = 0; i < p$.length; i++)
				if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) return p$[i]
		},
		get path() {
			if (!this.event._path) {
				var path = [];
				var current = this.rootTarget;
				while (current) {
					path.push(current);
					var insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();
					if (insertionPoints.length) {
						for (var i = 0; i < insertionPoints.length - 1; i++) path.push(insertionPoints[i]);
						current = insertionPoints[insertionPoints.length - 1]
					} else current = Polymer.dom(current).parentNode ||
						current.host
				}
				path.push(window);
				this.event._path = path
			}
			return this.event._path
		}
	};
	var factory = function(event) {
		if (!event.__eventApi) event.__eventApi = new DomApi.Event(event);
		return event.__eventApi
	};
	return {
		factory: factory
	}
}();
(function() {
	var DomApi = Polymer.DomApi.ctor;
	var useShadow = Polymer.Settings.useShadow;
	Object.defineProperty(DomApi.prototype, "classList", {
		get: function() {
			if (!this._classList) this._classList = new DomApi.ClassList(this);
			return this._classList
		},
		configurable: true
	});
	DomApi.ClassList = function(host) {
		this.domApi = host;
		this.node = host.node
	};
	DomApi.ClassList.prototype = {
		add: function() {
			this.node.classList.add.apply(this.node.classList, arguments);
			this._distributeParent()
		},
		remove: function() {
			this.node.classList.remove.apply(this.node.classList,
				arguments);
			this._distributeParent()
		},
		toggle: function() {
			this.node.classList.toggle.apply(this.node.classList, arguments);
			this._distributeParent()
		},
		_distributeParent: function() {
			if (!useShadow) this.domApi._maybeDistributeParent()
		},
		contains: function() {
			return this.node.classList.contains.apply(this.node.classList, arguments)
		}
	}
})();
(function() {
	var DomApi = Polymer.DomApi.ctor;
	var Settings = Polymer.Settings;
	DomApi.EffectiveNodesObserver = function(domApi) {
		this.domApi = domApi;
		this.node = this.domApi.node;
		this._listeners = []
	};
	DomApi.EffectiveNodesObserver.prototype = {
		addListener: function(callback) {
			if (!this._isSetup) {
				this._setup();
				this._isSetup = true
			}
			var listener = {
				fn: callback,
				_nodes: []
			};
			this._listeners.push(listener);
			this._scheduleNotify();
			return listener
		},
		removeListener: function(handle) {
			var i = this._listeners.indexOf(handle);
			if (i >= 0) {
				this._listeners.splice(i,
					1);
				handle._nodes = []
			}
			if (!this._hasListeners()) {
				this._cleanup();
				this._isSetup = false
			}
		},
		_setup: function() {
			this._observeContentElements(this.domApi.childNodes)
		},
		_cleanup: function() {
			this._unobserveContentElements(this.domApi.childNodes)
		},
		_hasListeners: function() {
			return Boolean(this._listeners.length)
		},
		_scheduleNotify: function() {
			if (this._debouncer) this._debouncer.stop();
			this._debouncer = Polymer.Debounce(this._debouncer, this._notify);
			this._debouncer.context = this;
			Polymer.dom.addDebouncer(this._debouncer)
		},
		notify: function() {
			if (this._hasListeners()) this._scheduleNotify()
		},
		_notify: function() {
			this._beforeCallListeners();
			this._callListeners()
		},
		_beforeCallListeners: function() {
			this._updateContentElements()
		},
		_updateContentElements: function() {
			this._observeContentElements(this.domApi.childNodes)
		},
		_observeContentElements: function(elements) {
			for (var i = 0, n; i < elements.length && (n = elements[i]); i++)
				if (this._isContent(n)) {
					n.__observeNodesMap = n.__observeNodesMap || new WeakMap;
					if (!n.__observeNodesMap.has(this)) n.__observeNodesMap.set(this,
						this._observeContent(n))
				}
		},
		_observeContent: function(content) {
			var self = this;
			var h = Polymer.dom(content).observeNodes(function() {
				self._scheduleNotify()
			});
			h._avoidChangeCalculation = true;
			return h
		},
		_unobserveContentElements: function(elements) {
			for (var i = 0, n, h; i < elements.length && (n = elements[i]); i++)
				if (this._isContent(n)) {
					h = n.__observeNodesMap.get(this);
					if (h) {
						Polymer.dom(n).unobserveNodes(h);
						n.__observeNodesMap["delete"](this)
					}
				}
		},
		_isContent: function(node) {
			return node.localName === "content"
		},
		_callListeners: function() {
			var o$ =
				this._listeners;
			var nodes = this._getEffectiveNodes();
			for (var i = 0, o; i < o$.length && (o = o$[i]); i++) {
				var info = this._generateListenerInfo(o, nodes);
				if (info || o._alwaysNotify) this._callListener(o, info)
			}
		},
		_getEffectiveNodes: function() {
			return this.domApi.getEffectiveChildNodes()
		},
		_generateListenerInfo: function(listener, newNodes) {
			if (listener._avoidChangeCalculation) return true;
			var oldNodes = listener._nodes;
			var info = {
				target: this.node,
				addedNodes: [],
				removedNodes: []
			};
			var splices = Polymer.ArraySplice.calculateSplices(newNodes,
				oldNodes);
			for (var i = 0, s; i < splices.length && (s = splices[i]); i++)
				for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) info.removedNodes.push(n);
			for (i = 0, s; i < splices.length && (s = splices[i]); i++)
				for (j = s.index; j < s.index + s.addedCount; j++) info.addedNodes.push(newNodes[j]);
			listener._nodes = newNodes;
			if (info.addedNodes.length || info.removedNodes.length) return info
		},
		_callListener: function(listener, info) {
			return listener.fn.call(this.node, info)
		},
		enableShadowAttributeTracking: function() {}
	};
	if (Settings.useShadow) {
		var baseSetup =
			DomApi.EffectiveNodesObserver.prototype._setup;
		var baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;
		Polymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {
			_setup: function() {
				if (!this._observer) {
					var self = this;
					this._mutationHandler = function(mxns) {
						if (mxns && mxns.length) self._scheduleNotify()
					};
					this._observer = new MutationObserver(this._mutationHandler);
					this._boundFlush = function() {
						self._flush()
					};
					Polymer.dom.addStaticFlush(this._boundFlush);
					this._observer.observe(this.node, {
						childList: true
					})
				}
				baseSetup.call(this)
			},
			_cleanup: function() {
				this._observer.disconnect();
				this._observer = null;
				this._mutationHandler = null;
				Polymer.dom.removeStaticFlush(this._boundFlush);
				baseCleanup.call(this)
			},
			_flush: function() {
				if (this._observer) this._mutationHandler(this._observer.takeRecords())
			},
			enableShadowAttributeTracking: function() {
				if (this._observer) {
					this._makeContentListenersAlwaysNotify();
					this._observer.disconnect();
					this._observer.observe(this.node, {
						childList: true,
						attributes: true,
						subtree: true
					});
					var root = this.domApi.getOwnerRoot();
					var host = root && root.host;
					if (host && Polymer.dom(host).observer) Polymer.dom(host).observer.enableShadowAttributeTracking()
				}
			},
			_makeContentListenersAlwaysNotify: function() {
				for (var i = 0, h; i < this._listeners.length; i++) {
					h = this._listeners[i];
					h._alwaysNotify = h._isContentListener
				}
			}
		})
	}
})();
(function() {
	var DomApi = Polymer.DomApi.ctor;
	var Settings = Polymer.Settings;
	DomApi.DistributedNodesObserver = function(domApi) {
		DomApi.EffectiveNodesObserver.call(this, domApi)
	};
	DomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);
	Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
		_setup: function() {},
		_cleanup: function() {},
		_beforeCallListeners: function() {},
		_getEffectiveNodes: function() {
			return this.domApi.getDistributedNodes()
		}
	});
	if (Settings.useShadow) Polymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {
		_setup: function() {
			if (!this._observer) {
				var root = this.domApi.getOwnerRoot();
				var host = root && root.host;
				if (host) {
					var self = this;
					this._observer = Polymer.dom(host).observeNodes(function() {
						self._scheduleNotify()
					});
					this._observer._isContentListener = true;
					if (this._hasAttrSelect()) Polymer.dom(host).observer.enableShadowAttributeTracking()
				}
			}
		},
		_hasAttrSelect: function() {
			var select = this.node.getAttribute("select");
			return select && select.match(/[[.]+/)
		},
		_cleanup: function() {
			var root = this.domApi.getOwnerRoot();
			var host =
				root && root.host;
			if (host) Polymer.dom(host).unobserveNodes(this._observer);
			this._observer = null
		}
	})
})();
(function() {
	var DomApi = Polymer.DomApi;
	var TreeApi = Polymer.TreeApi;
	Polymer.Base._addFeature({
		_prepShady: function() {
			this._useContent = this._useContent || Boolean(this._template)
		},
		_setupShady: function() {
			this.shadyRoot = null;
			if (!this.__domApi) this.__domApi = null;
			if (!this.__dom) this.__dom = null;
			if (!this._ownerShadyRoot) this._ownerShadyRoot = undefined
		},
		_poolContent: function() {
			if (this._useContent) TreeApi.Logical.saveChildNodes(this)
		},
		_setupRoot: function() {
			if (this._useContent) {
				this._createLocalRoot();
				if (!this.dataHost) upgradeLogicalChildren(TreeApi.Logical.getChildNodes(this))
			}
		},
		_createLocalRoot: function() {
			this.shadyRoot = this.root;
			this.shadyRoot._distributionClean = false;
			this.shadyRoot._hasDistributed = false;
			this.shadyRoot._isShadyRoot = true;
			this.shadyRoot._dirtyRoots = [];
			var i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll("content") : [];
			TreeApi.Logical.saveChildNodes(this.shadyRoot);
			for (var i = 0, c; i < i$.length; i++) {
				c = i$[i];
				TreeApi.Logical.saveChildNodes(c);
				TreeApi.Logical.saveChildNodes(c.parentNode)
			}
			this.shadyRoot.host =
				this
		},
		get domHost() {
			var root = Polymer.dom(this).getOwnerRoot();
			return root && root.host
		},
		distributeContent: function(updateInsertionPoints) {
			if (this.shadyRoot) {
				this.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;
				var host = getTopDistributingHost(this);
				Polymer.dom(this)._lazyDistribute(host)
			}
		},
		_distributeContent: function() {
			if (this._useContent && !this.shadyRoot._distributionClean) {
				if (this.shadyRoot._invalidInsertionPoints) {
					Polymer.dom(this)._updateInsertionPoints(this);
					this.shadyRoot._invalidInsertionPoints = false
				}
				this._beginDistribute();
				this._distributeDirtyRoots();
				this._finishDistribute()
			}
		},
		_beginDistribute: function() {
			if (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {
				this._resetDistribution();
				this._distributePool(this.shadyRoot, this._collectPool())
			}
		},
		_distributeDirtyRoots: function() {
			var c$ = this.shadyRoot._dirtyRoots;
			for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) c._distributeContent();
			this.shadyRoot._dirtyRoots = []
		},
		_finishDistribute: function() {
			if (this._useContent) {
				this.shadyRoot._distributionClean =
					true;
				if (DomApi.hasInsertionPoint(this.shadyRoot)) {
					this._composeTree();
					notifyContentObservers(this.shadyRoot)
				} else if (!this.shadyRoot._hasDistributed) {
					TreeApi.Composed.clearChildNodes(this);
					this.appendChild(this.shadyRoot)
				} else {
					var children = this._composeNode(this);
					this._updateChildNodes(this, children)
				}
				if (!this.shadyRoot._hasDistributed) notifyInitialDistribution(this);
				this.shadyRoot._hasDistributed = true
			}
		},
		elementMatches: function(selector, node) {
			node = node || this;
			return DomApi.matchesSelector.call(node,
				selector)
		},
		_resetDistribution: function() {
			var children = TreeApi.Logical.getChildNodes(this);
			for (var i = 0; i < children.length; i++) {
				var child = children[i];
				if (child._destinationInsertionPoints) child._destinationInsertionPoints = undefined;
				if (isInsertionPoint(child)) clearDistributedDestinationInsertionPoints(child)
			}
			var root = this.shadyRoot;
			var p$ = root._insertionPoints;
			for (var j = 0; j < p$.length; j++) p$[j]._distributedNodes = []
		},
		_collectPool: function() {
			var pool = [];
			var children = TreeApi.Logical.getChildNodes(this);
			for (var i =
					0; i < children.length; i++) {
				var child = children[i];
				if (isInsertionPoint(child)) pool.push.apply(pool, child._distributedNodes);
				else pool.push(child)
			}
			return pool
		},
		_distributePool: function(node, pool) {
			var p$ = node._insertionPoints;
			for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
				this._distributeInsertionPoint(p, pool);
				maybeRedistributeParent(p, this)
			}
		},
		_distributeInsertionPoint: function(content, pool) {
			var anyDistributed = false;
			for (var i = 0, l = pool.length, node; i < l; i++) {
				node = pool[i];
				if (!node) continue;
				if (this._matchesContentSelect(node,
						content)) {
					distributeNodeInto(node, content);
					pool[i] = undefined;
					anyDistributed = true
				}
			}
			if (!anyDistributed) {
				var children = TreeApi.Logical.getChildNodes(content);
				for (var j = 0; j < children.length; j++) distributeNodeInto(children[j], content)
			}
		},
		_composeTree: function() {
			this._updateChildNodes(this, this._composeNode(this));
			var p$ = this.shadyRoot._insertionPoints;
			for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
				parent = TreeApi.Logical.getParentNode(p);
				if (!parent._useContent && parent !== this && parent !== this.shadyRoot) this._updateChildNodes(parent,
					this._composeNode(parent))
			}
		},
		_composeNode: function(node) {
			var children = [];
			var c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);
			for (var i = 0; i < c$.length; i++) {
				var child = c$[i];
				if (isInsertionPoint(child)) {
					var distributedNodes = child._distributedNodes;
					for (var j = 0; j < distributedNodes.length; j++) {
						var distributedNode = distributedNodes[j];
						if (isFinalDestination(child, distributedNode)) children.push(distributedNode)
					}
				} else children.push(child)
			}
			return children
		},
		_updateChildNodes: function(container, children) {
			var composed =
				TreeApi.Composed.getChildNodes(container);
			var splices = Polymer.ArraySplice.calculateSplices(children, composed);
			for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
				for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
					if (TreeApi.Composed.getParentNode(n) === container) TreeApi.Composed.removeChild(container, n);
					composed.splice(s.index + d, 1)
				}
				d -= s.addedCount
			}
			for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
				next = composed[s.index];
				for (j = s.index, n; j < s.index + s.addedCount; j++) {
					n = children[j];
					TreeApi.Composed.insertBefore(container,
						n, next);
					composed.splice(j, 0, n)
				}
			}
		},
		_matchesContentSelect: function(node, contentElement) {
			var select = contentElement.getAttribute("select");
			if (!select) return true;
			select = select.trim();
			if (!select) return true;
			if (!(node instanceof Element)) return false;
			var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
			if (!validSelectors.test(select)) return false;
			return this.elementMatches(select, node)
		},
		_elementAdd: function() {},
		_elementRemove: function() {}
	});

	function distributeNodeInto(child, insertionPoint) {
		insertionPoint._distributedNodes.push(child);
		var points = child._destinationInsertionPoints;
		if (!points) child._destinationInsertionPoints = [insertionPoint];
		else points.push(insertionPoint)
	}

	function clearDistributedDestinationInsertionPoints(content) {
		var e$ = content._distributedNodes;
		if (e$)
			for (var i = 0; i < e$.length; i++) {
				var d = e$[i]._destinationInsertionPoints;
				if (d) d.splice(d.indexOf(content) + 1, d.length)
			}
	}

	function maybeRedistributeParent(content, host) {
		var parent = TreeApi.Logical.getParentNode(content);
		if (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) &&
			parent.shadyRoot._distributionClean) {
			parent.shadyRoot._distributionClean = false;
			host.shadyRoot._dirtyRoots.push(parent)
		}
	}

	function isFinalDestination(insertionPoint, node) {
		var points = node._destinationInsertionPoints;
		return points && points[points.length - 1] === insertionPoint
	}

	function isInsertionPoint(node) {
		return node.localName == "content"
	}

	function getTopDistributingHost(host) {
		while (host && hostNeedsRedistribution(host)) host = host.domHost;
		return host
	}

	function hostNeedsRedistribution(host) {
		var c$ = TreeApi.Logical.getChildNodes(host);
		for (var i = 0, c; i < c$.length; i++) {
			c = c$[i];
			if (c.localName && c.localName === "content") return host.domHost
		}
	}

	function notifyContentObservers(root) {
		for (var i = 0, c; i < root._insertionPoints.length; i++) {
			c = root._insertionPoints[i];
			if (DomApi.hasApi(c)) Polymer.dom(c).notifyObserver()
		}
	}

	function notifyInitialDistribution(host) {
		if (DomApi.hasApi(host)) Polymer.dom(host).notifyObserver()
	}
	var needsUpgrade = window.CustomElements && !CustomElements.useNative;

	function upgradeLogicalChildren(children) {
		if (needsUpgrade && children)
			for (var i =
					0; i < children.length; i++) CustomElements.upgrade(children[i])
	}
})();
if (Polymer.Settings.useShadow) Polymer.Base._addFeature({
	_poolContent: function() {},
	_beginDistribute: function() {},
	distributeContent: function() {},
	_distributeContent: function() {},
	_finishDistribute: function() {},
	_createLocalRoot: function() {
		this.createShadowRoot();
		this.shadowRoot.appendChild(this.root);
		this.root = this.shadowRoot
	}
});
Polymer.Async = {
	_currVal: 0,
	_lastVal: 0,
	_callbacks: [],
	_twiddleContent: 0,
	_twiddle: document.createTextNode(""),
	run: function(callback, waitTime) {
		if (waitTime > 0) return ~setTimeout(callback, waitTime);
		else {
			this._twiddle.textContent = this._twiddleContent++;
			this._callbacks.push(callback);
			return this._currVal++
		}
	},
	cancel: function(handle) {
		if (handle < 0) clearTimeout(~handle);
		else {
			var idx = handle - this._lastVal;
			if (idx >= 0) {
				if (!this._callbacks[idx]) throw "invalid async handle: " + handle;
				this._callbacks[idx] = null
			}
		}
	},
	_atEndOfMicrotask: function() {
		var len =
			this._callbacks.length;
		for (var i = 0; i < len; i++) {
			var cb = this._callbacks[i];
			if (cb) try {
				cb()
			} catch (e) {
				i++;
				this._callbacks.splice(0, i);
				this._lastVal += i;
				this._twiddle.textContent = this._twiddleContent++;
				throw e;
			}
		}
		this._callbacks.splice(0, len);
		this._lastVal += len
	}
};
(new window.MutationObserver(function() {
	Polymer.Async._atEndOfMicrotask()
})).observe(Polymer.Async._twiddle, {
	characterData: true
});
Polymer.Debounce = function() {
	var Async = Polymer.Async;
	var Debouncer = function(context) {
		this.context = context;
		var self = this;
		this.boundComplete = function() {
			self.complete()
		}
	};
	Debouncer.prototype = {
		go: function(callback, wait) {
			var h;
			this.finish = function() {
				Async.cancel(h)
			};
			h = Async.run(this.boundComplete, wait);
			this.callback = callback
		},
		stop: function() {
			if (this.finish) {
				this.finish();
				this.finish = null;
				this.callback = null
			}
		},
		complete: function() {
			if (this.finish) {
				var callback = this.callback;
				this.stop();
				callback.call(this.context)
			}
		}
	};

	function debounce(debouncer, callback, wait) {
		if (debouncer) debouncer.stop();
		else debouncer = new Debouncer(this);
		debouncer.go(callback, wait);
		return debouncer
	}
	return debounce
}();
Polymer.Base._addFeature({
	_setupDebouncers: function() {
		this._debouncers = {}
	},
	debounce: function(jobName, callback, wait) {
		return this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait)
	},
	isDebouncerActive: function(jobName) {
		var debouncer = this._debouncers[jobName];
		return !!(debouncer && debouncer.finish)
	},
	flushDebouncer: function(jobName) {
		var debouncer = this._debouncers[jobName];
		if (debouncer) debouncer.complete()
	},
	cancelDebouncer: function(jobName) {
		var debouncer = this._debouncers[jobName];
		if (debouncer) debouncer.stop()
	}
});
Polymer.DomModule = document.createElement("dom-module");
Polymer.Base._addFeature({
	_registerFeatures: function() {
		this._prepIs();
		this._prepBehaviors();
		this._prepConstructor();
		this._prepTemplate();
		this._prepShady();
		this._prepPropertyInfo()
	},
	_prepBehavior: function(b) {
		this._addHostAttributes(b.hostAttributes)
	},
	_initFeatures: function() {
		this._registerHost();
		if (this._template) {
			this._poolContent();
			this._beginHosting();
			this._stampTemplate();
			this._endHosting()
		}
		this._marshalHostAttributes();
		this._setupDebouncers();
		this._marshalBehaviors();
		this._tryReady()
	},
	_marshalBehavior: function(b) {}
});
Polymer.nar = [];
Polymer.Annotations = {
	parseAnnotations: function(template) {
		var list = [];
		var content = template._content || template.content;
		this._parseNodeAnnotations(content, list, template.hasAttribute("strip-whitespace"));
		return list
	},
	_parseNodeAnnotations: function(node, list, stripWhiteSpace) {
		return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace)
	},
	_bindingRegex: function() {
		var IDENT = "(?:" + "[a-zA-Z_$][\\w.:$\\-*]*" + ")";
		var NUMBER = "(?:" + "[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?" +
			")";
		var SQUOTE_STRING = "(?:" + "'(?:[^'\\\\]|\\\\.)*'" + ")";
		var DQUOTE_STRING = "(?:" + '"(?:[^"\\\\]|\\\\.)*"' + ")";
		var STRING = "(?:" + SQUOTE_STRING + "|" + DQUOTE_STRING + ")";
		var ARGUMENT = "(?:" + IDENT + "|" + NUMBER + "|" + STRING + "\\s*" + ")";
		var ARGUMENTS = "(?:" + ARGUMENT + "(?:,\\s*" + ARGUMENT + ")*" + ")";
		var ARGUMENT_LIST = "(?:" + "\\(\\s*" + "(?:" + ARGUMENTS + "?" + ")" + "\\)\\s*" + ")";
		var BINDING = "(" + IDENT + "\\s*" + ARGUMENT_LIST + "?" + ")";
		var OPEN_BRACKET = "(\\[\\[|{{)" + "\\s*";
		var CLOSE_BRACKET = "(?:]]|}})";
		var NEGATE = "(?:(!)\\s*)?";
		var EXPRESSION =
			OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
		return new RegExp(EXPRESSION, "g")
	}(),
	_parseBindings: function(text) {
		var re = this._bindingRegex;
		var parts = [];
		var lastIndex = 0;
		var m;
		while ((m = re.exec(text)) !== null) {
			if (m.index > lastIndex) parts.push({
				literal: text.slice(lastIndex, m.index)
			});
			var mode = m[1][0];
			var negate = Boolean(m[2]);
			var value = m[3].trim();
			var customEvent, notifyEvent, colon;
			if (mode == "{" && (colon = value.indexOf("::")) > 0) {
				notifyEvent = value.substring(colon + 2);
				value = value.substring(0, colon);
				customEvent = true
			}
			parts.push({
				compoundIndex: parts.length,
				value: value,
				mode: mode,
				negate: negate,
				event: notifyEvent,
				customEvent: customEvent
			});
			lastIndex = re.lastIndex
		}
		if (lastIndex && lastIndex < text.length) {
			var literal = text.substring(lastIndex);
			if (literal) parts.push({
				literal: literal
			})
		}
		if (parts.length) return parts
	},
	_literalFromParts: function(parts) {
		var s = "";
		for (var i = 0; i < parts.length; i++) {
			var literal = parts[i].literal;
			s += literal || ""
		}
		return s
	},
	_parseTextNodeAnnotation: function(node, list) {
		var parts = this._parseBindings(node.textContent);
		if (parts) {
			node.textContent = this._literalFromParts(parts) ||
				" ";
			var annote = {
				bindings: [{
					kind: "text",
					name: "textContent",
					parts: parts,
					isCompound: parts.length !== 1
				}]
			};
			list.push(annote);
			return annote
		}
	},
	_parseElementAnnotations: function(element, list, stripWhiteSpace) {
		var annote = {
			bindings: [],
			events: []
		};
		if (element.localName === "content") list._hasContent = true;
		this._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);
		if (element.attributes) {
			this._parseNodeAttributeAnnotations(element, annote, list);
			if (this.prepElement) this.prepElement(element)
		}
		if (annote.bindings.length ||
			annote.events.length || annote.id) list.push(annote);
		return annote
	},
	_parseChildNodesAnnotations: function(root, annote, list, stripWhiteSpace) {
		if (root.firstChild) {
			var node = root.firstChild;
			var i = 0;
			while (node) {
				var next = node.nextSibling;
				if (node.localName === "template" && !node.hasAttribute("preserve-content")) this._parseTemplate(node, i, list, annote);
				if (node.localName == "slot") node = this._replaceSlotWithContent(node);
				if (node.nodeType === Node.TEXT_NODE) {
					var n = next;
					while (n && n.nodeType === Node.TEXT_NODE) {
						node.textContent +=
							n.textContent;
						next = n.nextSibling;
						root.removeChild(n);
						n = next
					}
					if (stripWhiteSpace && !node.textContent.trim()) {
						root.removeChild(node);
						i--
					}
				}
				if (node.parentNode) {
					var childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);
					if (childAnnotation) {
						childAnnotation.parent = annote;
						childAnnotation.index = i
					}
				}
				node = next;
				i++
			}
		}
	},
	_replaceSlotWithContent: function(slot) {
		var content = slot.ownerDocument.createElement("content");
		while (slot.firstChild) content.appendChild(slot.firstChild);
		var attrs = slot.attributes;
		for (var i =
				0; i < attrs.length; i++) {
			var attr = attrs[i];
			content.setAttribute(attr.name, attr.value)
		}
		var name = slot.getAttribute("name");
		var select = name ? "[slot='" + name + "']" : ":not([slot])";
		content.setAttribute("select", select);
		slot.parentNode.replaceChild(content, slot);
		return content
	},
	_parseTemplate: function(node, index, list, parent) {
		var content = document.createDocumentFragment();
		content._notes = this.parseAnnotations(node);
		content.appendChild(node.content);
		list.push({
			bindings: Polymer.nar,
			events: Polymer.nar,
			templateContent: content,
			parent: parent,
			index: index
		})
	},
	_parseNodeAttributeAnnotations: function(node, annotation) {
		var attrs = Array.prototype.slice.call(node.attributes);
		for (var i = attrs.length - 1, a; a = attrs[i]; i--) {
			var n = a.name;
			var v = a.value;
			var b;
			if (n.slice(0, 3) === "on-") {
				node.removeAttribute(n);
				annotation.events.push({
					name: n.slice(3),
					value: v
				})
			} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) annotation.bindings.push(b);
			else if (n === "id") annotation.id = v
		}
	},
	_parseNodeAttributeAnnotation: function(node, name, value) {
		var parts = this._parseBindings(value);
		if (parts) {
			var origName = name;
			var kind = "property";
			if (name[name.length - 1] == "$") {
				name = name.slice(0, -1);
				kind = "attribute"
			}
			var literal = this._literalFromParts(parts);
			if (literal && kind == "attribute") node.setAttribute(name, literal);
			if (node.localName === "input" && origName === "value") node.setAttribute(origName, "");
			node.removeAttribute(origName);
			var propertyName = Polymer.CaseMap.dashToCamelCase(name);
			if (kind === "property") name = propertyName;
			return {
				kind: kind,
				name: name,
				propertyName: propertyName,
				parts: parts,
				literal: literal,
				isCompound: parts.length !== 1
			}
		}
	},
	findAnnotatedNode: function(root, annote) {
		var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
		if (parent)
			for (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {
				if (annote.index === i++) return n
			} else return root
	}
};
(function() {
	function resolveCss(cssText, ownerDocument) {
		return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
			return pre + "'" + resolve(url.replace(/["']/g, ""), ownerDocument) + "'" + post
		})
	}

	function resolveAttrs(element, ownerDocument) {
		for (var name in URL_ATTRS) {
			var a$ = URL_ATTRS[name];
			for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++)
				if (name === "*" || element.localName === name) {
					at = element.attributes[a];
					v = at && at.value;
					if (v && v.search(BINDING_RX) < 0) at.value = a === "style" ? resolveCss(v, ownerDocument) : resolve(v,
						ownerDocument)
				}
		}
	}

	function resolve(url, ownerDocument) {
		if (url && ABS_URL.test(url)) return url;
		var resolver = getUrlResolver(ownerDocument);
		resolver.href = url;
		return resolver.href || url
	}
	var tempDoc;
	var tempDocBase;

	function resolveUrl(url, baseUri) {
		if (!tempDoc) {
			tempDoc = document.implementation.createHTMLDocument("temp");
			tempDocBase = tempDoc.createElement("base");
			tempDoc.head.appendChild(tempDocBase)
		}
		tempDocBase.href = baseUri;
		return resolve(url, tempDoc)
	}

	function getUrlResolver(ownerDocument) {
		return ownerDocument.__urlResolver ||
			(ownerDocument.__urlResolver = ownerDocument.createElement("a"))
	}
	var CSS_URL_RX = /(url\()([^)]*)(\))/g;
	var URL_ATTRS = {
		"*": ["href", "src", "style", "url"],
		form: ["action"]
	};
	var ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
	var BINDING_RX = /\{\{|\[\[/;
	Polymer.ResolveUrl = {
		resolveCss: resolveCss,
		resolveAttrs: resolveAttrs,
		resolveUrl: resolveUrl
	}
})();
Polymer.Path = {
	root: function(path) {
		var dotIndex = path.indexOf(".");
		if (dotIndex === -1) return path;
		return path.slice(0, dotIndex)
	},
	isDeep: function(path) {
		return path.indexOf(".") !== -1
	},
	isAncestor: function(base, path) {
		return base.indexOf(path + ".") === 0
	},
	isDescendant: function(base, path) {
		return path.indexOf(base + ".") === 0
	},
	translate: function(base, newBase, path) {
		return newBase + path.slice(base.length)
	},
	matches: function(base, wildcard, path) {
		return base === path || this.isAncestor(base, path) || Boolean(wildcard) && this.isDescendant(base,
			path)
	}
};
Polymer.Base._addFeature({
	_prepAnnotations: function() {
		if (!this._template) this._notes = [];
		else {
			var self = this;
			Polymer.Annotations.prepElement = function(element) {
				self._prepElement(element)
			};
			if (this._template._content && this._template._content._notes) this._notes = this._template._content._notes;
			else {
				this._notes = Polymer.Annotations.parseAnnotations(this._template);
				this._processAnnotations(this._notes)
			}
			Polymer.Annotations.prepElement = null
		}
	},
	_processAnnotations: function(notes) {
		for (var i = 0; i < notes.length; i++) {
			var note = notes[i];
			for (var j = 0; j < note.bindings.length; j++) {
				var b = note.bindings[j];
				for (var k = 0; k < b.parts.length; k++) {
					var p = b.parts[k];
					if (!p.literal) {
						var signature = this._parseMethod(p.value);
						if (signature) p.signature = signature;
						else p.model = Polymer.Path.root(p.value)
					}
				}
			}
			if (note.templateContent) {
				this._processAnnotations(note.templateContent._notes);
				var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
				var bindings = [];
				for (var prop in pp) {
					var name = "_parent_" + prop;
					bindings.push({
						index: note.index,
						kind: "property",
						name: name,
						propertyName: name,
						parts: [{
							mode: "{",
							model: prop,
							value: prop
						}]
					})
				}
				note.bindings = note.bindings.concat(bindings)
			}
		}
	},
	_discoverTemplateParentProps: function(notes) {
		var pp = {};
		for (var i = 0, n; i < notes.length && (n = notes[i]); i++) {
			for (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++)
				for (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++)
					if (p.signature) {
						var args = p.signature.args;
						for (var kk = 0; kk < args.length; kk++) {
							var model = args[kk].model;
							if (model) pp[model] = true
						}
						if (p.signature.dynamicFn) pp[p.signature.method] =
							true
					} else if (p.model) pp[p.model] = true;
			if (n.templateContent) {
				var tpp = n.templateContent._parentProps;
				Polymer.Base.mixin(pp, tpp)
			}
		}
		return pp
	},
	_prepElement: function(element) {
		Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument)
	},
	_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
	_marshalAnnotationReferences: function() {
		if (this._template) {
			this._marshalIdNodes();
			this._marshalAnnotatedNodes();
			this._marshalAnnotatedListeners()
		}
	},
	_configureAnnotationReferences: function() {
		var notes = this._notes;
		var nodes = this._nodes;
		for (var i = 0; i < notes.length; i++) {
			var note = notes[i];
			var node = nodes[i];
			this._configureTemplateContent(note, node);
			this._configureCompoundBindings(note, node)
		}
	},
	_configureTemplateContent: function(note, node) {
		if (note.templateContent) node._content = note.templateContent
	},
	_configureCompoundBindings: function(note, node) {
		var bindings = note.bindings;
		for (var i = 0; i < bindings.length; i++) {
			var binding = bindings[i];
			if (binding.isCompound) {
				var storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});
				var parts = binding.parts;
				var literals = new Array(parts.length);
				for (var j = 0; j < parts.length; j++) literals[j] = parts[j].literal;
				var name = binding.name;
				storage[name] = literals;
				if (binding.literal && binding.kind == "property")
					if (node._configValue) node._configValue(name, binding.literal);
					else node[name] = binding.literal
			}
		}
	},
	_marshalIdNodes: function() {
		this.$ = {};
		for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++)
			if (a.id) this.$[a.id] = this._findAnnotatedNode(this.root, a)
	},
	_marshalAnnotatedNodes: function() {
		if (this._notes &&
			this._notes.length) {
			var r = new Array(this._notes.length);
			for (var i = 0; i < this._notes.length; i++) r[i] = this._findAnnotatedNode(this.root, this._notes[i]);
			this._nodes = r
		}
	},
	_marshalAnnotatedListeners: function() {
		for (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++)
			if (a.events && a.events.length) {
				var node = this._findAnnotatedNode(this.root, a);
				for (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) this.listen(node, e.name, e.value)
			}
	}
});
Polymer.Base._addFeature({
	listeners: {},
	_listenListeners: function(listeners) {
		var node, name, eventName;
		for (eventName in listeners) {
			if (eventName.indexOf(".") < 0) {
				node = this;
				name = eventName
			} else {
				name = eventName.split(".");
				node = this.$[name[0]];
				name = name[1]
			}
			this.listen(node, name, listeners[eventName])
		}
	},
	listen: function(node, eventName, methodName) {
		var handler = this._recallEventHandler(this, eventName, node, methodName);
		if (!handler) handler = this._createEventHandler(node, eventName, methodName);
		if (handler._listening) return;
		this._listen(node, eventName, handler);
		handler._listening = true
	},
	_boundListenerKey: function(eventName, methodName) {
		return eventName + ":" + methodName
	},
	_recordEventHandler: function(host, eventName, target, methodName, handler) {
		var hbl = host.__boundListeners;
		if (!hbl) hbl = host.__boundListeners = new WeakMap;
		var bl = hbl.get(target);
		if (!bl) {
			bl = {};
			hbl.set(target, bl)
		}
		var key = this._boundListenerKey(eventName, methodName);
		bl[key] = handler
	},
	_recallEventHandler: function(host, eventName, target, methodName) {
		var hbl = host.__boundListeners;
		if (!hbl) return;
		var bl = hbl.get(target);
		if (!bl) return;
		var key = this._boundListenerKey(eventName, methodName);
		return bl[key]
	},
	_createEventHandler: function(node, eventName, methodName) {
		var host = this;
		var handler = function(e) {
			if (host[methodName]) host[methodName](e, e.detail);
			else host._warn(host._logf("_createEventHandler", "listener method `" + methodName + "` not defined"))
		};
		handler._listening = false;
		this._recordEventHandler(host, eventName, node, methodName, handler);
		return handler
	},
	unlisten: function(node, eventName,
		methodName) {
		var handler = this._recallEventHandler(this, eventName, node, methodName);
		if (handler) {
			this._unlisten(node, eventName, handler);
			handler._listening = false
		}
	},
	_listen: function(node, eventName, handler) {
		node.addEventListener(eventName, handler)
	},
	_unlisten: function(node, eventName, handler) {
		node.removeEventListener(eventName, handler)
	}
});
(function() {
	var wrap = Polymer.DomApi.wrap;
	var HAS_NATIVE_TA = typeof document.head.style.touchAction === "string";
	var GESTURE_KEY = "__polymerGestures";
	var HANDLED_OBJ = "__polymerGesturesHandled";
	var TOUCH_ACTION = "__polymerGesturesTouchAction";
	var TAP_DISTANCE = 25;
	var TRACK_DISTANCE = 5;
	var TRACK_LENGTH = 2;
	var MOUSE_TIMEOUT = 2500;
	var MOUSE_EVENTS = ["mousedown", "mousemove", "mouseup", "click"];
	var MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
	var MOUSE_HAS_BUTTONS = function() {
		try {
			return (new MouseEvent("test", {
					buttons: 1
				})).buttons ===
				1
		} catch (e) {
			return false
		}
	}();
	var IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);
	var mouseCanceller = function(mouseEvent) {
		var sc = mouseEvent.sourceCapabilities;
		if (sc && !sc.firesTouchEvents) return;
		mouseEvent[HANDLED_OBJ] = {
			skip: true
		};
		if (mouseEvent.type === "click") {
			var path = Polymer.dom(mouseEvent).path;
			for (var i = 0; i < path.length; i++)
				if (path[i] === POINTERSTATE.mouse.target) return;
			mouseEvent.preventDefault();
			mouseEvent.stopPropagation()
		}
	};

	function setupTeardownMouseCanceller(setup) {
		var events =
			IS_TOUCH_ONLY ? ["click"] : MOUSE_EVENTS;
		for (var i = 0, en; i < events.length; i++) {
			en = events[i];
			if (setup) document.addEventListener(en, mouseCanceller, true);
			else document.removeEventListener(en, mouseCanceller, true)
		}
	}

	function ignoreMouse() {
		if (!POINTERSTATE.mouse.mouseIgnoreJob) setupTeardownMouseCanceller(true);
		var unset = function() {
			setupTeardownMouseCanceller();
			POINTERSTATE.mouse.target = null;
			POINTERSTATE.mouse.mouseIgnoreJob = null
		};
		POINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob,
			unset, MOUSE_TIMEOUT)
	}

	function hasLeftMouseButton(ev) {
		var type = ev.type;
		if (MOUSE_EVENTS.indexOf(type) === -1) return false;
		if (type === "mousemove") {
			var buttons = ev.buttons === undefined ? 1 : ev.buttons;
			if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
			return Boolean(buttons & 1)
		} else {
			var button = ev.button === undefined ? 0 : ev.button;
			return button === 0
		}
	}

	function isSyntheticClick(ev) {
		if (ev.type === "click") {
			if (ev.detail === 0) return true;
			var t = Gestures.findOriginalTarget(ev);
			var bcr = t.getBoundingClientRect();
			var x = ev.pageX,
				y = ev.pageY;
			return !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom))
		}
		return false
	}
	var POINTERSTATE = {
		mouse: {
			target: null,
			mouseIgnoreJob: null
		},
		touch: {
			x: 0,
			y: 0,
			id: -1,
			scrollDecided: false
		}
	};

	function firstTouchAction(ev) {
		var path = Polymer.dom(ev).path;
		var ta = "auto";
		for (var i = 0, n; i < path.length; i++) {
			n = path[i];
			if (n[TOUCH_ACTION]) {
				ta = n[TOUCH_ACTION];
				break
			}
		}
		return ta
	}

	function trackDocument(stateObj, movefn, upfn) {
		stateObj.movefn = movefn;
		stateObj.upfn = upfn;
		document.addEventListener("mousemove",
			movefn);
		document.addEventListener("mouseup", upfn)
	}

	function untrackDocument(stateObj) {
		document.removeEventListener("mousemove", stateObj.movefn);
		document.removeEventListener("mouseup", stateObj.upfn);
		stateObj.movefn = null;
		stateObj.upfn = null
	}
	var Gestures = {
		gestures: {},
		recognizers: [],
		deepTargetFind: function(x, y) {
			var node = document.elementFromPoint(x, y);
			var next = node;
			while (next && next.shadowRoot) {
				next = next.shadowRoot.elementFromPoint(x, y);
				if (next) node = next
			}
			return node
		},
		findOriginalTarget: function(ev) {
			if (ev.path) return ev.path[0];
			return ev.target
		},
		handleNative: function(ev) {
			var handled;
			var type = ev.type;
			var node = wrap(ev.currentTarget);
			var gobj = node[GESTURE_KEY];
			if (!gobj) return;
			var gs = gobj[type];
			if (!gs) return;
			if (!ev[HANDLED_OBJ]) {
				ev[HANDLED_OBJ] = {};
				if (type.slice(0, 5) === "touch") {
					var t = ev.changedTouches[0];
					if (type === "touchstart")
						if (ev.touches.length === 1) POINTERSTATE.touch.id = t.identifier;
					if (POINTERSTATE.touch.id !== t.identifier) return;
					if (!HAS_NATIVE_TA)
						if (type === "touchstart" || type === "touchmove") Gestures.handleTouchAction(ev);
					if (type ===
						"touchend") {
						POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
						ignoreMouse()
					}
				}
			}
			handled = ev[HANDLED_OBJ];
			if (handled.skip) return;
			var recognizers = Gestures.recognizers;
			for (var i = 0, r; i < recognizers.length; i++) {
				r = recognizers[i];
				if (gs[r.name] && !handled[r.name])
					if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) r.reset()
			}
			for (i = 0, r; i < recognizers.length; i++) {
				r = recognizers[i];
				if (gs[r.name] && !handled[r.name]) {
					handled[r.name] = true;
					r[type](ev)
				}
			}
		},
		handleTouchAction: function(ev) {
			var t = ev.changedTouches[0];
			var type =
				ev.type;
			if (type === "touchstart") {
				POINTERSTATE.touch.x = t.clientX;
				POINTERSTATE.touch.y = t.clientY;
				POINTERSTATE.touch.scrollDecided = false
			} else if (type === "touchmove") {
				if (POINTERSTATE.touch.scrollDecided) return;
				POINTERSTATE.touch.scrollDecided = true;
				var ta = firstTouchAction(ev);
				var prevent = false;
				var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
				var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
				if (!ev.cancelable);
				else if (ta === "none") prevent = true;
				else if (ta === "pan-x") prevent = dy > dx;
				else if (ta === "pan-y") prevent = dx >
					dy;
				if (prevent) ev.preventDefault();
				else Gestures.prevent("track")
			}
		},
		add: function(node, evType, handler) {
			node = wrap(node);
			var recognizer = this.gestures[evType];
			var deps = recognizer.deps;
			var name = recognizer.name;
			var gobj = node[GESTURE_KEY];
			if (!gobj) node[GESTURE_KEY] = gobj = {};
			for (var i = 0, dep, gd; i < deps.length; i++) {
				dep = deps[i];
				if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== "click") continue;
				gd = gobj[dep];
				if (!gd) gobj[dep] = gd = {
					_count: 0
				};
				if (gd._count === 0) node.addEventListener(dep, this.handleNative);
				gd[name] =
					(gd[name] || 0) + 1;
				gd._count = (gd._count || 0) + 1
			}
			node.addEventListener(evType, handler);
			if (recognizer.touchAction) this.setTouchAction(node, recognizer.touchAction)
		},
		remove: function(node, evType, handler) {
			node = wrap(node);
			var recognizer = this.gestures[evType];
			var deps = recognizer.deps;
			var name = recognizer.name;
			var gobj = node[GESTURE_KEY];
			if (gobj)
				for (var i = 0, dep, gd; i < deps.length; i++) {
					dep = deps[i];
					gd = gobj[dep];
					if (gd && gd[name]) {
						gd[name] = (gd[name] || 1) - 1;
						gd._count = (gd._count || 1) - 1;
						if (gd._count === 0) node.removeEventListener(dep,
							this.handleNative)
					}
				}
			node.removeEventListener(evType, handler)
		},
		register: function(recog) {
			this.recognizers.push(recog);
			for (var i = 0; i < recog.emits.length; i++) this.gestures[recog.emits[i]] = recog
		},
		findRecognizerByEvent: function(evName) {
			for (var i = 0, r; i < this.recognizers.length; i++) {
				r = this.recognizers[i];
				for (var j = 0, n; j < r.emits.length; j++) {
					n = r.emits[j];
					if (n === evName) return r
				}
			}
			return null
		},
		setTouchAction: function(node, value) {
			if (HAS_NATIVE_TA) node.style.touchAction = value;
			node[TOUCH_ACTION] = value
		},
		fire: function(target,
			type, detail) {
			var ev = Polymer.Base.fire(type, detail, {
				node: target,
				bubbles: true,
				cancelable: true
			});
			if (ev.defaultPrevented) {
				var preventer = detail.preventer || detail.sourceEvent;
				if (preventer && preventer.preventDefault) preventer.preventDefault()
			}
		},
		prevent: function(evName) {
			var recognizer = this.findRecognizerByEvent(evName);
			if (recognizer.info) recognizer.info.prevent = true
		},
		resetMouseCanceller: function() {
			if (POINTERSTATE.mouse.mouseIgnoreJob) POINTERSTATE.mouse.mouseIgnoreJob.complete()
		}
	};
	Gestures.register({
		name: "downup",
		deps: ["mousedown", "touchstart", "touchend"],
		flow: {
			start: ["mousedown", "touchstart"],
			end: ["mouseup", "touchend"]
		},
		emits: ["down", "up"],
		info: {
			movefn: null,
			upfn: null
		},
		reset: function() {
			untrackDocument(this.info)
		},
		mousedown: function(e) {
			if (!hasLeftMouseButton(e)) return;
			var t = Gestures.findOriginalTarget(e);
			var self = this;
			var movefn = function movefn(e) {
				if (!hasLeftMouseButton(e)) {
					self.fire("up", t, e);
					untrackDocument(self.info)
				}
			};
			var upfn = function upfn(e) {
				if (hasLeftMouseButton(e)) self.fire("up", t, e);
				untrackDocument(self.info)
			};
			trackDocument(this.info, movefn, upfn);
			this.fire("down", t, e)
		},
		touchstart: function(e) {
			this.fire("down", Gestures.findOriginalTarget(e), e.changedTouches[0], e)
		},
		touchend: function(e) {
			this.fire("up", Gestures.findOriginalTarget(e), e.changedTouches[0], e)
		},
		fire: function(type, target, event, preventer) {
			Gestures.fire(target, type, {
				x: event.clientX,
				y: event.clientY,
				sourceEvent: event,
				preventer: preventer,
				prevent: function(e) {
					return Gestures.prevent(e)
				}
			})
		}
	});
	Gestures.register({
		name: "track",
		touchAction: "none",
		deps: ["mousedown",
			"touchstart", "touchmove", "touchend"
		],
		flow: {
			start: ["mousedown", "touchstart"],
			end: ["mouseup", "touchend"]
		},
		emits: ["track"],
		info: {
			x: 0,
			y: 0,
			state: "start",
			started: false,
			moves: [],
			addMove: function(move) {
				if (this.moves.length > TRACK_LENGTH) this.moves.shift();
				this.moves.push(move)
			},
			movefn: null,
			upfn: null,
			prevent: false
		},
		reset: function() {
			this.info.state = "start";
			this.info.started = false;
			this.info.moves = [];
			this.info.x = 0;
			this.info.y = 0;
			this.info.prevent = false;
			untrackDocument(this.info)
		},
		hasMovedEnough: function(x, y) {
			if (this.info.prevent) return false;
			if (this.info.started) return true;
			var dx = Math.abs(this.info.x - x);
			var dy = Math.abs(this.info.y - y);
			return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE
		},
		mousedown: function(e) {
			if (!hasLeftMouseButton(e)) return;
			var t = Gestures.findOriginalTarget(e);
			var self = this;
			var movefn = function movefn(e) {
				var x = e.clientX,
					y = e.clientY;
				if (self.hasMovedEnough(x, y)) {
					self.info.state = self.info.started ? e.type === "mouseup" ? "end" : "track" : "start";
					if (self.info.state === "start") Gestures.prevent("tap");
					self.info.addMove({
						x: x,
						y: y
					});
					if (!hasLeftMouseButton(e)) {
						self.info.state =
							"end";
						untrackDocument(self.info)
					}
					self.fire(t, e);
					self.info.started = true
				}
			};
			var upfn = function upfn(e) {
				if (self.info.started) movefn(e);
				untrackDocument(self.info)
			};
			trackDocument(this.info, movefn, upfn);
			this.info.x = e.clientX;
			this.info.y = e.clientY
		},
		touchstart: function(e) {
			var ct = e.changedTouches[0];
			this.info.x = ct.clientX;
			this.info.y = ct.clientY
		},
		touchmove: function(e) {
			var t = Gestures.findOriginalTarget(e);
			var ct = e.changedTouches[0];
			var x = ct.clientX,
				y = ct.clientY;
			if (this.hasMovedEnough(x, y)) {
				if (this.info.state ===
					"start") Gestures.prevent("tap");
				this.info.addMove({
					x: x,
					y: y
				});
				this.fire(t, ct);
				this.info.state = "track";
				this.info.started = true
			}
		},
		touchend: function(e) {
			var t = Gestures.findOriginalTarget(e);
			var ct = e.changedTouches[0];
			if (this.info.started) {
				this.info.state = "end";
				this.info.addMove({
					x: ct.clientX,
					y: ct.clientY
				});
				this.fire(t, ct, e)
			}
		},
		fire: function(target, touch, preventer) {
			var secondlast = this.info.moves[this.info.moves.length - 2];
			var lastmove = this.info.moves[this.info.moves.length - 1];
			var dx = lastmove.x - this.info.x;
			var dy = lastmove.y - this.info.y;
			var ddx, ddy = 0;
			if (secondlast) {
				ddx = lastmove.x - secondlast.x;
				ddy = lastmove.y - secondlast.y
			}
			return Gestures.fire(target, "track", {
				state: this.info.state,
				x: touch.clientX,
				y: touch.clientY,
				dx: dx,
				dy: dy,
				ddx: ddx,
				ddy: ddy,
				sourceEvent: touch,
				preventer: preventer,
				hover: function() {
					return Gestures.deepTargetFind(touch.clientX, touch.clientY)
				}
			})
		}
	});
	Gestures.register({
		name: "tap",
		deps: ["mousedown", "click", "touchstart", "touchend"],
		flow: {
			start: ["mousedown", "touchstart"],
			end: ["click", "touchend"]
		},
		emits: ["tap"],
		info: {
			x: NaN,
			y: NaN,
			prevent: false
		},
		reset: function() {
			this.info.x = NaN;
			this.info.y = NaN;
			this.info.prevent = false
		},
		save: function(e) {
			this.info.x = e.clientX;
			this.info.y = e.clientY
		},
		mousedown: function(e) {
			if (hasLeftMouseButton(e)) this.save(e)
		},
		click: function(e) {
			if (hasLeftMouseButton(e)) this.forward(e)
		},
		touchstart: function(e) {
			this.save(e.changedTouches[0], e)
		},
		touchend: function(e) {
			this.forward(e.changedTouches[0], e)
		},
		forward: function(e, preventer) {
			var dx = Math.abs(e.clientX - this.info.x);
			var dy = Math.abs(e.clientY -
				this.info.y);
			var t = Gestures.findOriginalTarget(e);
			if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e))
				if (!this.info.prevent) Gestures.fire(t, "tap", {
					x: e.clientX,
					y: e.clientY,
					sourceEvent: e,
					preventer: preventer
				})
		}
	});
	var DIRECTION_MAP = {
		x: "pan-x",
		y: "pan-y",
		none: "none",
		all: "auto"
	};
	Polymer.Base._addFeature({
		_setupGestures: function() {
			this.__polymerGestures = null
		},
		_listen: function(node, eventName, handler) {
			if (Gestures.gestures[eventName]) Gestures.add(node, eventName, handler);
			else node.addEventListener(eventName,
				handler)
		},
		_unlisten: function(node, eventName, handler) {
			if (Gestures.gestures[eventName]) Gestures.remove(node, eventName, handler);
			else node.removeEventListener(eventName, handler)
		},
		setScrollDirection: function(direction, node) {
			node = node || this;
			Gestures.setTouchAction(node, DIRECTION_MAP[direction] || "auto")
		}
	});
	Polymer.Gestures = Gestures
})();
(function() {
	Polymer.Base._addFeature({
		$$: function(slctr) {
			return Polymer.dom(this.root).querySelector(slctr)
		},
		toggleClass: function(name, bool, node) {
			node = node || this;
			if (arguments.length == 1) bool = !node.classList.contains(name);
			if (bool) Polymer.dom(node).classList.add(name);
			else Polymer.dom(node).classList.remove(name)
		},
		toggleAttribute: function(name, bool, node) {
			node = node || this;
			if (arguments.length == 1) bool = !node.hasAttribute(name);
			if (bool) Polymer.dom(node).setAttribute(name, "");
			else Polymer.dom(node).removeAttribute(name)
		},
		classFollows: function(name, toElement, fromElement) {
			if (fromElement) Polymer.dom(fromElement).classList.remove(name);
			if (toElement) Polymer.dom(toElement).classList.add(name)
		},
		attributeFollows: function(name, toElement, fromElement) {
			if (fromElement) Polymer.dom(fromElement).removeAttribute(name);
			if (toElement) Polymer.dom(toElement).setAttribute(name, "")
		},
		getEffectiveChildNodes: function() {
			return Polymer.dom(this).getEffectiveChildNodes()
		},
		getEffectiveChildren: function() {
			var list = Polymer.dom(this).getEffectiveChildNodes();
			return list.filter(function(n) {
				return n.nodeType === Node.ELEMENT_NODE
			})
		},
		getEffectiveTextContent: function() {
			var cn = this.getEffectiveChildNodes();
			var tc = [];
			for (var i = 0, c; c = cn[i]; i++)
				if (c.nodeType !== Node.COMMENT_NODE) tc.push(Polymer.dom(c).textContent);
			return tc.join("")
		},
		queryEffectiveChildren: function(slctr) {
			var e$ = Polymer.dom(this).queryDistributedElements(slctr);
			return e$ && e$[0]
		},
		queryAllEffectiveChildren: function(slctr) {
			return Polymer.dom(this).queryDistributedElements(slctr)
		},
		getContentChildNodes: function(slctr) {
			var content =
				Polymer.dom(this.root).querySelector(slctr || "content");
			return content ? Polymer.dom(content).getDistributedNodes() : []
		},
		getContentChildren: function(slctr) {
			return this.getContentChildNodes(slctr).filter(function(n) {
				return n.nodeType === Node.ELEMENT_NODE
			})
		},
		fire: function(type, detail, options) {
			options = options || Polymer.nob;
			var node = options.node || this;
			detail = detail === null || detail === undefined ? {} : detail;
			var bubbles = options.bubbles === undefined ? true : options.bubbles;
			var cancelable = Boolean(options.cancelable);
			var useCache =
				options._useCache;
			var event = this._getEvent(type, bubbles, cancelable, useCache);
			event.detail = detail;
			if (useCache) this.__eventCache[type] = null;
			node.dispatchEvent(event);
			if (useCache) this.__eventCache[type] = event;
			return event
		},
		__eventCache: {},
		_getEvent: function(type, bubbles, cancelable, useCache) {
			var event = useCache && this.__eventCache[type];
			if (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) event = new Event(type, {
				bubbles: Boolean(bubbles),
				cancelable: cancelable
			});
			return event
		},
		async: function(callback,
			waitTime) {
			var self = this;
			return Polymer.Async.run(function() {
				callback.call(self)
			}, waitTime)
		},
		cancelAsync: function(handle) {
			Polymer.Async.cancel(handle)
		},
		arrayDelete: function(path, item) {
			var index;
			if (Array.isArray(path)) {
				index = path.indexOf(item);
				if (index >= 0) return path.splice(index, 1)
			} else {
				var arr = this._get(path);
				index = arr.indexOf(item);
				if (index >= 0) return this.splice(path, index, 1)
			}
		},
		transform: function(transform, node) {
			node = node || this;
			node.style.webkitTransform = transform;
			node.style.transform = transform
		},
		translate3d: function(x, y, z, node) {
			node = node || this;
			this.transform("translate3d(" + x + "," + y + "," + z + ")", node)
		},
		importHref: function(href, onload, onerror, optAsync) {
			var link = document.createElement("link");
			link.rel = "import";
			link.href = href;
			var list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};
			var cached = list[link.href];
			var imprt = cached || link;
			var self = this;
			if (onload) {
				var loadListener = function(e) {
					e.target.__firedLoad = true;
					e.target.removeEventListener("load", loadListener);
					return onload.call(self,
						e)
				};
				imprt.addEventListener("load", loadListener)
			}
			if (onerror) {
				var errorListener = function(e) {
					e.target.__firedError = true;
					e.target.removeEventListener("error", errorListener);
					return onerror.call(self, e)
				};
				imprt.addEventListener("error", errorListener)
			}
			if (cached) {
				if (cached.__firedLoad) cached.dispatchEvent(new Event("load"));
				if (cached.__firedError) cached.dispatchEvent(new Event("error"))
			} else {
				list[link.href] = link;
				optAsync = Boolean(optAsync);
				if (optAsync) link.setAttribute("async", "");
				document.head.appendChild(link)
			}
			return imprt
		},
		create: function(tag, props) {
			var elt = document.createElement(tag);
			if (props)
				for (var n in props) elt[n] = props[n];
			return elt
		},
		isLightDescendant: function(node) {
			return this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot()
		},
		isLocalDescendant: function(node) {
			return this.root === Polymer.dom(node).getOwnerRoot()
		}
	});
	if (!Polymer.Settings.useNativeCustomElements) {
		var importHref = Polymer.Base.importHref;
		Polymer.Base.importHref = function(href, onload, onerror, optAsync) {
			CustomElements.ready =
				false;
			var loadFn = function(e) {
				CustomElements.upgradeDocumentTree(document);
				CustomElements.ready = true;
				if (onload) return onload.call(this, e)
			};
			return importHref.call(this, href, loadFn, onerror, optAsync)
		}
	}
})();
Polymer.Bind = {
	prepareModel: function(model) {
		Polymer.Base.mixin(model, this._modelApi)
	},
	_modelApi: {
		_notifyChange: function(source, event, value) {
			value = value === undefined ? this[source] : value;
			event = event || Polymer.CaseMap.camelToDashCase(source) + "-changed";
			this.fire(event, {
				value: value
			}, {
				bubbles: false,
				cancelable: false,
				_useCache: true
			})
		},
		_propertySetter: function(property, value, effects, fromAbove) {
			var old = this.__data__[property];
			if (old !== value && (old === old || value === value)) {
				this.__data__[property] = value;
				if (typeof value ==
					"object") this._clearPath(property);
				if (this._propertyChanged) this._propertyChanged(property, value, old);
				if (effects) this._effectEffects(property, value, effects, old, fromAbove)
			}
			return old
		},
		__setProperty: function(property, value, quiet, node) {
			node = node || this;
			var effects = node._propertyEffects && node._propertyEffects[property];
			if (effects) node._propertySetter(property, value, effects, quiet);
			else if (node[property] !== value) node[property] = value
		},
		_effectEffects: function(property, value, effects, old, fromAbove) {
			for (var i =
					0, l = effects.length, fx; i < l && (fx = effects[i]); i++) fx.fn.call(this, property, this[property], fx.effect, old, fromAbove)
		},
		_clearPath: function(path) {
			for (var prop in this.__data__)
				if (Polymer.Path.isDescendant(path, prop)) this.__data__[prop] = undefined
		}
	},
	ensurePropertyEffects: function(model, property) {
		if (!model._propertyEffects) model._propertyEffects = {};
		var fx = model._propertyEffects[property];
		if (!fx) fx = model._propertyEffects[property] = [];
		return fx
	},
	addPropertyEffect: function(model, property, kind, effect) {
		var fx = this.ensurePropertyEffects(model,
			property);
		var propEffect = {
			kind: kind,
			effect: effect,
			fn: Polymer.Bind["_" + kind + "Effect"]
		};
		fx.push(propEffect);
		return propEffect
	},
	createBindings: function(model) {
		var fx$ = model._propertyEffects;
		if (fx$)
			for (var n in fx$) {
				var fx = fx$[n];
				fx.sort(this._sortPropertyEffects);
				this._createAccessors(model, n, fx)
			}
	},
	_sortPropertyEffects: function() {
		var EFFECT_ORDER = {
			"compute": 0,
			"annotation": 1,
			"annotatedComputation": 2,
			"reflect": 3,
			"notify": 4,
			"observer": 5,
			"complexObserver": 6,
			"function": 7
		};
		return function(a, b) {
			return EFFECT_ORDER[a.kind] -
				EFFECT_ORDER[b.kind]
		}
	}(),
	_createAccessors: function(model, property, effects) {
		var defun = {
			get: function() {
				return this.__data__[property]
			}
		};
		var setter = function(value) {
			this._propertySetter(property, value, effects)
		};
		var info = model.getPropertyInfo && model.getPropertyInfo(property);
		if (info && info.readOnly) {
			if (!info.computed) model["_set" + this.upper(property)] = setter
		} else defun.set = setter;
		Object.defineProperty(model, property, defun)
	},
	upper: function(name) {
		return name[0].toUpperCase() + name.substring(1)
	},
	_addAnnotatedListener: function(model,
		index, property, path, event, negated) {
		if (!model._bindListeners) model._bindListeners = [];
		var fn = this._notedListenerFactory(property, path, Polymer.Path.isDeep(path), negated);
		var eventName = event || Polymer.CaseMap.camelToDashCase(property) + "-changed";
		model._bindListeners.push({
			index: index,
			property: property,
			path: path,
			changedFn: fn,
			event: eventName
		})
	},
	_isEventBogus: function(e, target) {
		return e.path && e.path[0] !== target
	},
	_notedListenerFactory: function(property, path, isStructured, negated) {
		return function(target, value,
			targetPath) {
			if (targetPath) {
				var newPath = Polymer.Path.translate(property, path, targetPath);
				this._notifyPath(newPath, value)
			} else {
				value = target[property];
				if (negated) value = !value;
				if (!isStructured) this[path] = value;
				else if (this.__data__[path] != value) this.set(path, value)
			}
		}
	},
	prepareInstance: function(inst) {
		inst.__data__ = Object.create(null)
	},
	setupBindListeners: function(inst) {
		var b$ = inst._bindListeners;
		for (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {
			var node = inst._nodes[info.index];
			this._addNotifyListener(node,
				inst, info.event, info.changedFn)
		}
	},
	_addNotifyListener: function(element, context, event, changedFn) {
		element.addEventListener(event, function(e) {
			return context._notifyListener(changedFn, e)
		})
	}
};
Polymer.Base.extend(Polymer.Bind, {
	_shouldAddListener: function(effect) {
		return effect.name && effect.kind != "attribute" && effect.kind != "text" && !effect.isCompound && effect.parts[0].mode === "{"
	},
	_annotationEffect: function(source, value, effect) {
		if (source != effect.value) {
			value = this._get(effect.value);
			this.__data__[effect.value] = value
		}
		this._applyEffectValue(effect, value)
	},
	_reflectEffect: function(source, value, effect) {
		this.reflectPropertyToAttribute(source, effect.attribute, value)
	},
	_notifyEffect: function(source, value,
		effect, old, fromAbove) {
		if (!fromAbove) this._notifyChange(source, effect.event, value)
	},
	_functionEffect: function(source, value, fn, old, fromAbove) {
		fn.call(this, source, value, old, fromAbove)
	},
	_observerEffect: function(source, value, effect, old) {
		var fn = this[effect.method];
		if (fn) fn.call(this, value, old);
		else this._warn(this._logf("_observerEffect", "observer method `" + effect.method + "` not defined"))
	},
	_complexObserverEffect: function(source, value, effect) {
		var fn = this[effect.method];
		if (fn) {
			var args = Polymer.Bind._marshalArgs(this.__data__,
				effect, source, value);
			if (args) fn.apply(this, args)
		} else if (effect.dynamicFn);
		else this._warn(this._logf("_complexObserverEffect", "observer method `" + effect.method + "` not defined"))
	},
	_computeEffect: function(source, value, effect) {
		var fn = this[effect.method];
		if (fn) {
			var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
			if (args) {
				var computedvalue = fn.apply(this, args);
				this.__setProperty(effect.name, computedvalue)
			}
		} else if (effect.dynamicFn);
		else this._warn(this._logf("_computeEffect", "compute method `" +
			effect.method + "` not defined"))
	},
	_annotatedComputationEffect: function(source, value, effect) {
		var computedHost = this._rootDataHost || this;
		var fn = computedHost[effect.method];
		if (fn) {
			var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
			if (args) {
				var computedvalue = fn.apply(computedHost, args);
				this._applyEffectValue(effect, computedvalue)
			}
		} else if (effect.dynamicFn);
		else computedHost._warn(computedHost._logf("_annotatedComputationEffect", "compute method `" + effect.method + "` not defined"))
	},
	_marshalArgs: function(model,
		effect, path, value) {
		var values = [];
		var args = effect.args;
		var bailoutEarly = args.length > 1 || effect.dynamicFn;
		for (var i = 0, l = args.length; i < l; i++) {
			var arg = args[i];
			var name = arg.name;
			var v;
			if (arg.literal) v = arg.value;
			else if (path === name) v = value;
			else {
				v = model[name];
				if (v === undefined && arg.structured) v = Polymer.Base._get(name, model)
			}
			if (bailoutEarly && v === undefined) return;
			if (arg.wildcard) {
				var matches = Polymer.Path.isAncestor(path, name);
				values[i] = {
					path: matches ? path : name,
					value: matches ? value : v,
					base: v
				}
			} else values[i] = v
		}
		return values
	}
});
Polymer.Base._addFeature({
	_addPropertyEffect: function(property, kind, effect) {
		var prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);
		prop.pathFn = this["_" + prop.kind + "PathEffect"]
	},
	_prepEffects: function() {
		Polymer.Bind.prepareModel(this);
		this._addAnnotationEffects(this._notes)
	},
	_prepBindings: function() {
		Polymer.Bind.createBindings(this)
	},
	_addPropertyEffects: function(properties) {
		if (properties)
			for (var p in properties) {
				var prop = properties[p];
				if (prop.observer) this._addObserverEffect(p, prop.observer);
				if (prop.computed) {
					prop.readOnly = true;
					this._addComputedEffect(p, prop.computed)
				}
				if (prop.notify) this._addPropertyEffect(p, "notify", {
					event: Polymer.CaseMap.camelToDashCase(p) + "-changed"
				});
				if (prop.reflectToAttribute) {
					var attr = Polymer.CaseMap.camelToDashCase(p);
					if (attr[0] === "-") this._warn(this._logf("_addPropertyEffects", "Property " + p + " cannot be reflected to attribute " + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));
					else this._addPropertyEffect(p,
						"reflect", {
							attribute: attr
						})
				}
				if (prop.readOnly) Polymer.Bind.ensurePropertyEffects(this, p)
			}
	},
	_addComputedEffect: function(name, expression) {
		var sig = this._parseMethod(expression);
		var dynamicFn = sig.dynamicFn;
		for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) this._addPropertyEffect(arg.model, "compute", {
			method: sig.method,
			args: sig.args,
			trigger: arg,
			name: name,
			dynamicFn: dynamicFn
		});
		if (dynamicFn) this._addPropertyEffect(sig.method, "compute", {
			method: sig.method,
			args: sig.args,
			trigger: null,
			name: name,
			dynamicFn: dynamicFn
		})
	},
	_addObserverEffect: function(property, observer) {
		this._addPropertyEffect(property, "observer", {
			method: observer,
			property: property
		})
	},
	_addComplexObserverEffects: function(observers) {
		if (observers)
			for (var i = 0, o; i < observers.length && (o = observers[i]); i++) this._addComplexObserverEffect(o)
	},
	_addComplexObserverEffect: function(observer) {
		var sig = this._parseMethod(observer);
		if (!sig) throw new Error("Malformed observer expression '" + observer + "'");
		var dynamicFn = sig.dynamicFn;
		for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) this._addPropertyEffect(arg.model,
			"complexObserver", {
				method: sig.method,
				args: sig.args,
				trigger: arg,
				dynamicFn: dynamicFn
			});
		if (dynamicFn) this._addPropertyEffect(sig.method, "complexObserver", {
			method: sig.method,
			args: sig.args,
			trigger: null,
			dynamicFn: dynamicFn
		})
	},
	_addAnnotationEffects: function(notes) {
		for (var i = 0, note; i < notes.length && (note = notes[i]); i++) {
			var b$ = note.bindings;
			for (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) this._addAnnotationEffect(binding, i)
		}
	},
	_addAnnotationEffect: function(note, index) {
		if (Polymer.Bind._shouldAddListener(note)) Polymer.Bind._addAnnotatedListener(this,
			index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);
		for (var i = 0; i < note.parts.length; i++) {
			var part = note.parts[i];
			if (part.signature) this._addAnnotatedComputationEffect(note, part, index);
			else if (!part.literal)
				if (note.kind === "attribute" && note.name[0] === "-") this._warn(this._logf("_addAnnotationEffect", "Cannot set attribute " + note.name + ' because "-" is not a valid attribute starting character'));
				else this._addPropertyEffect(part.model, "annotation", {
					kind: note.kind,
					index: index,
					name: note.name,
					propertyName: note.propertyName,
					value: part.value,
					isCompound: note.isCompound,
					compoundIndex: part.compoundIndex,
					event: part.event,
					customEvent: part.customEvent,
					negate: part.negate
				})
		}
	},
	_addAnnotatedComputationEffect: function(note, part, index) {
		var sig = part.signature;
		if (sig["static"]) this.__addAnnotatedComputationEffect("__static__", index, note, part, null);
		else {
			for (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++)
				if (!arg.literal) this.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);
			if (sig.dynamicFn) this.__addAnnotatedComputationEffect(sig.method,
				index, note, part, null)
		}
	},
	__addAnnotatedComputationEffect: function(property, index, note, part, trigger) {
		this._addPropertyEffect(property, "annotatedComputation", {
			index: index,
			isCompound: note.isCompound,
			compoundIndex: part.compoundIndex,
			kind: note.kind,
			name: note.name,
			negate: part.negate,
			method: part.signature.method,
			args: part.signature.args,
			trigger: trigger,
			dynamicFn: part.signature.dynamicFn
		})
	},
	_parseMethod: function(expression) {
		var m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
		if (m) {
			var sig = {
				method: m[1],
				"static": true
			};
			if (this.getPropertyInfo(sig.method) !== Polymer.nob) {
				sig["static"] = false;
				sig.dynamicFn = true
			}
			if (m[2].trim()) {
				var args = m[2].replace(/\\,/g, "&comma;").split(",");
				return this._parseArgs(args, sig)
			} else {
				sig.args = Polymer.nar;
				return sig
			}
		}
	},
	_parseArgs: function(argList, sig) {
		sig.args = argList.map(function(rawArg) {
			var arg = this._parseArg(rawArg);
			if (!arg.literal) sig["static"] = false;
			return arg
		}, this);
		return sig
	},
	_parseArg: function(rawArg) {
		var arg = rawArg.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1");
		var a = {
			name: arg
		};
		var fc = arg[0];
		if (fc === "-") fc = arg[1];
		if (fc >= "0" && fc <= "9") fc = "#";
		switch (fc) {
			case "'":
			case '"':
				a.value = arg.slice(1, -1);
				a.literal = true;
				break;
			case "#":
				a.value = Number(arg);
				a.literal = true;
				break
		}
		if (!a.literal) {
			a.model = Polymer.Path.root(arg);
			a.structured = Polymer.Path.isDeep(arg);
			if (a.structured) {
				a.wildcard = arg.slice(-2) == ".*";
				if (a.wildcard) a.name = arg.slice(0, -2)
			}
		}
		return a
	},
	_marshalInstanceEffects: function() {
		Polymer.Bind.prepareInstance(this);
		if (this._bindListeners) Polymer.Bind.setupBindListeners(this)
	},
	_applyEffectValue: function(info,
		value) {
		var node = this._nodes[info.index];
		var property = info.name;
		value = this._computeFinalAnnotationValue(node, property, value, info);
		if (info.kind == "attribute") this.serializeValueToAttribute(value, property, node);
		else {
			var pinfo = node._propertyInfo && node._propertyInfo[property];
			if (pinfo && pinfo.readOnly) return;
			this.__setProperty(property, value, false, node)
		}
	},
	_computeFinalAnnotationValue: function(node, property, value, info) {
		if (info.negate) value = !value;
		if (info.isCompound) {
			var storage = node.__compoundStorage__[property];
			storage[info.compoundIndex] = value;
			value = storage.join("")
		}
		if (info.kind !== "attribute") {
			if (property === "className") value = this._scopeElementClass(node, value);
			if (property === "textContent" || node.localName == "input" && property == "value") value = value == undefined ? "" : value
		}
		return value
	},
	_executeStaticEffects: function() {
		if (this._propertyEffects && this._propertyEffects.__static__) this._effectEffects("__static__", null, this._propertyEffects.__static__)
	}
});
(function() {
	var usePolyfillProto = Polymer.Settings.usePolyfillProto;
	Polymer.Base._addFeature({
		_setupConfigure: function(initialConfig) {
			this._config = {};
			this._handlers = [];
			this._aboveConfig = null;
			if (initialConfig)
				for (var i in initialConfig)
					if (initialConfig[i] !== undefined) this._config[i] = initialConfig[i]
		},
		_marshalAttributes: function() {
			this._takeAttributesToModel(this._config)
		},
		_attributeChangedImpl: function(name) {
			var model = this._clientsReadied ? this : this._config;
			this._setAttributeToProperty(model, name)
		},
		_configValue: function(name, value) {
			var info = this._propertyInfo[name];
			if (!info || !info.readOnly) this._config[name] = value
		},
		_beforeClientsReady: function() {
			this._configure()
		},
		_configure: function() {
			this._configureAnnotationReferences();
			this._configureInstanceProperties();
			this._aboveConfig = this.mixin({}, this._config);
			var config = {};
			for (var i = 0; i < this.behaviors.length; i++) this._configureProperties(this.behaviors[i].properties, config);
			this._configureProperties(this.properties, config);
			this.mixin(config, this._aboveConfig);
			this._config = config;
			if (this._clients && this._clients.length) this._distributeConfig(this._config)
		},
		_configureInstanceProperties: function() {
			for (var i in this._propertyEffects)
				if (!usePolyfillProto && this.hasOwnProperty(i)) {
					this._configValue(i, this[i]);
					delete this[i]
				}
		},
		_configureProperties: function(properties, config) {
			for (var i in properties) {
				var c = properties[i];
				if (c.value !== undefined) {
					var value = c.value;
					if (typeof value == "function") value = value.call(this, this._config);
					config[i] = value
				}
			}
		},
		_distributeConfig: function(config) {
			var fx$ =
				this._propertyEffects;
			if (fx$)
				for (var p in config) {
					var fx = fx$[p];
					if (fx)
						for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++)
							if (x.kind === "annotation") {
								var node = this._nodes[x.effect.index];
								var name = x.effect.propertyName;
								var isAttr = x.effect.kind == "attribute";
								var hasEffect = node._propertyEffects && node._propertyEffects[name];
								if (node._configValue && (hasEffect || !isAttr)) {
									var value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);
									value = this._computeFinalAnnotationValue(node, name, value, x.effect);
									if (isAttr) value =
										node.deserialize(this.serialize(value), node._propertyInfo[name].type);
									node._configValue(name, value)
								}
							}
				}
		},
		_afterClientsReady: function() {
			this._executeStaticEffects();
			this._applyConfig(this._config, this._aboveConfig);
			this._flushHandlers()
		},
		_applyConfig: function(config, aboveConfig) {
			for (var n in config)
				if (this[n] === undefined) this.__setProperty(n, config[n], n in aboveConfig)
		},
		_notifyListener: function(fn, e) {
			if (!Polymer.Bind._isEventBogus(e, e.target)) {
				var value, path;
				if (e.detail) {
					value = e.detail.value;
					path = e.detail.path
				}
				if (!this._clientsReadied) this._queueHandler([fn,
					e.target, value, path
				]);
				else return fn.call(this, e.target, value, path)
			}
		},
		_queueHandler: function(args) {
			this._handlers.push(args)
		},
		_flushHandlers: function() {
			var h$ = this._handlers;
			for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) h[0].call(this, h[1], h[2], h[3]);
			this._handlers = []
		}
	})
})();
(function() {
	var Path = Polymer.Path;
	Polymer.Base._addFeature({
		notifyPath: function(path, value, fromAbove) {
			var info = {};
			var v = this._get(path, this, info);
			if (arguments.length === 1) value = v;
			if (info.path) this._notifyPath(info.path, value, fromAbove)
		},
		_notifyPath: function(path, value, fromAbove) {
			var old = this._propertySetter(path, value);
			if (old !== value && (old === old || value === value)) {
				this._pathEffector(path, value);
				if (!fromAbove) this._notifyPathUp(path, value);
				return true
			}
		},
		_getPathParts: function(path) {
			if (Array.isArray(path)) {
				var parts = [];
				for (var i = 0; i < path.length; i++) {
					var args = path[i].toString().split(".");
					for (var j = 0; j < args.length; j++) parts.push(args[j])
				}
				return parts
			} else return path.toString().split(".")
		},
		set: function(path, value, root) {
			var prop = root || this;
			var parts = this._getPathParts(path);
			var array;
			var last = parts[parts.length - 1];
			if (parts.length > 1) {
				for (var i = 0; i < parts.length - 1; i++) {
					var part = parts[i];
					if (array && part[0] == "#") prop = Polymer.Collection.get(array).getItem(part);
					else {
						prop = prop[part];
						if (array && parseInt(part, 10) == part) parts[i] =
							Polymer.Collection.get(array).getKey(prop)
					}
					if (!prop) return;
					array = Array.isArray(prop) ? prop : null
				}
				if (array) {
					var coll = Polymer.Collection.get(array);
					var old, key;
					if (last[0] == "#") {
						key = last;
						old = coll.getItem(key);
						last = array.indexOf(old);
						coll.setItem(key, value)
					} else if (parseInt(last, 10) == last) {
						old = prop[last];
						key = coll.getKey(old);
						parts[i] = key;
						coll.setItem(key, value)
					}
				}
				prop[last] = value;
				if (!root) this._notifyPath(parts.join("."), value)
			} else prop[path] = value
		},
		get: function(path, root) {
			return this._get(path, root)
		},
		_get: function(path, root, info) {
			var prop = root || this;
			var parts = this._getPathParts(path);
			var array;
			for (var i = 0; i < parts.length; i++) {
				if (!prop) return;
				var part = parts[i];
				if (array && part[0] == "#") prop = Polymer.Collection.get(array).getItem(part);
				else {
					prop = prop[part];
					if (info && array && parseInt(part, 10) == part) parts[i] = Polymer.Collection.get(array).getKey(prop)
				}
				array = Array.isArray(prop) ? prop : null
			}
			if (info) info.path = parts.join(".");
			return prop
		},
		_pathEffector: function(path, value) {
			var model = Path.root(path);
			var fx$ = this._propertyEffects &&
				this._propertyEffects[model];
			if (fx$)
				for (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {
					var fxFn = fx.pathFn;
					if (fxFn) fxFn.call(this, path, value, fx.effect)
				}
			if (this._boundPaths) this._notifyBoundPaths(path, value)
		},
		_annotationPathEffect: function(path, value, effect) {
			if (Path.matches(effect.value, false, path)) Polymer.Bind._annotationEffect.call(this, path, value, effect);
			else if (!effect.negate && Path.isDescendant(effect.value, path)) {
				var node = this._nodes[effect.index];
				if (node && node._notifyPath) {
					var newPath = Path.translate(effect.value,
						effect.name, path);
					node._notifyPath(newPath, value, true)
				}
			}
		},
		_complexObserverPathEffect: function(path, value, effect) {
			if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) Polymer.Bind._complexObserverEffect.call(this, path, value, effect)
		},
		_computePathEffect: function(path, value, effect) {
			if (Path.matches(effect.trigger.name, effect.trigger.wildcard, path)) Polymer.Bind._computeEffect.call(this, path, value, effect)
		},
		_annotatedComputationPathEffect: function(path, value, effect) {
			if (Path.matches(effect.trigger.name,
					effect.trigger.wildcard, path)) Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect)
		},
		linkPaths: function(to, from) {
			this._boundPaths = this._boundPaths || {};
			if (from) this._boundPaths[to] = from;
			else this.unlinkPaths(to)
		},
		unlinkPaths: function(path) {
			if (this._boundPaths) delete this._boundPaths[path]
		},
		_notifyBoundPaths: function(path, value) {
			for (var a in this._boundPaths) {
				var b = this._boundPaths[a];
				if (Path.isDescendant(a, path)) this._notifyPath(Path.translate(a, b, path), value);
				else if (Path.isDescendant(b,
						path)) this._notifyPath(Path.translate(b, a, path), value)
			}
		},
		_notifyPathUp: function(path, value) {
			var rootName = Path.root(path);
			var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
			var eventName = dashCaseName + this._EVENT_CHANGED;
			this.fire(eventName, {
				path: path,
				value: value
			}, {
				bubbles: false,
				_useCache: true
			})
		},
		_EVENT_CHANGED: "-changed",
		notifySplices: function(path, splices) {
			var info = {};
			var array = this._get(path, this, info);
			this._notifySplices(array, info.path, splices)
		},
		_notifySplices: function(array, path, splices) {
			var change = {
				keySplices: Polymer.Collection.applySplices(array, splices),
				indexSplices: splices
			};
			var splicesPath = path + ".splices";
			this._notifyPath(splicesPath, change);
			this._notifyPath(path + ".length", array.length);
			this.__data__[splicesPath] = {
				keySplices: null,
				indexSplices: null
			}
		},
		_notifySplice: function(array, path, index, added, removed) {
			this._notifySplices(array, path, [{
				index: index,
				addedCount: added,
				removed: removed,
				object: array,
				type: "splice"
			}])
		},
		push: function(path) {
			var info = {};
			var array = this._get(path, this, info);
			var args =
				Array.prototype.slice.call(arguments, 1);
			var len = array.length;
			var ret = array.push.apply(array, args);
			if (args.length) this._notifySplice(array, info.path, len, args.length, []);
			return ret
		},
		pop: function(path) {
			var info = {};
			var array = this._get(path, this, info);
			var hadLength = Boolean(array.length);
			var args = Array.prototype.slice.call(arguments, 1);
			var ret = array.pop.apply(array, args);
			if (hadLength) this._notifySplice(array, info.path, array.length, 0, [ret]);
			return ret
		},
		splice: function(path, start) {
			var info = {};
			var array = this._get(path,
				this, info);
			if (start < 0) start = array.length - Math.floor(-start);
			else start = Math.floor(start);
			if (!start) start = 0;
			var args = Array.prototype.slice.call(arguments, 1);
			var ret = array.splice.apply(array, args);
			var addedCount = Math.max(args.length - 2, 0);
			if (addedCount || ret.length) this._notifySplice(array, info.path, start, addedCount, ret);
			return ret
		},
		shift: function(path) {
			var info = {};
			var array = this._get(path, this, info);
			var hadLength = Boolean(array.length);
			var args = Array.prototype.slice.call(arguments, 1);
			var ret = array.shift.apply(array,
				args);
			if (hadLength) this._notifySplice(array, info.path, 0, 0, [ret]);
			return ret
		},
		unshift: function(path) {
			var info = {};
			var array = this._get(path, this, info);
			var args = Array.prototype.slice.call(arguments, 1);
			var ret = array.unshift.apply(array, args);
			if (args.length) this._notifySplice(array, info.path, 0, args.length, []);
			return ret
		},
		prepareModelNotifyPath: function(model) {
			this.mixin(model, {
				fire: Polymer.Base.fire,
				_getEvent: Polymer.Base._getEvent,
				__eventCache: Polymer.Base.__eventCache,
				notifyPath: Polymer.Base.notifyPath,
				_get: Polymer.Base._get,
				_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,
				_notifyPath: Polymer.Base._notifyPath,
				_notifyPathUp: Polymer.Base._notifyPathUp,
				_pathEffector: Polymer.Base._pathEffector,
				_annotationPathEffect: Polymer.Base._annotationPathEffect,
				_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,
				_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,
				_computePathEffect: Polymer.Base._computePathEffect,
				_notifyBoundPaths: Polymer.Base._notifyBoundPaths,
				_getPathParts: Polymer.Base._getPathParts
			})
		}
	})
})();
Polymer.Base._addFeature({
	resolveUrl: function(url) {
		var module = Polymer.DomModule["import"](this.is);
		var root = "";
		if (module) {
			var assetPath = module.getAttribute("assetpath") || "";
			root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI)
		}
		return Polymer.ResolveUrl.resolveUrl(url, root)
	}
});
Polymer.CssParse = function() {
	return {
		parse: function(text) {
			text = this._clean(text);
			return this._parseCss(this._lex(text), text)
		},
		_clean: function(cssText) {
			return cssText.replace(this._rx.comments, "").replace(this._rx.port, "")
		},
		_lex: function(text) {
			var root = {
				start: 0,
				end: text.length
			};
			var n = root;
			for (var i = 0, l = text.length; i < l; i++) switch (text[i]) {
				case this.OPEN_BRACE:
					if (!n.rules) n.rules = [];
					var p = n;
					var previous = p.rules[p.rules.length - 1];
					n = {
						start: i + 1,
						parent: p,
						previous: previous
					};
					p.rules.push(n);
					break;
				case this.CLOSE_BRACE:
					n.end =
						i + 1;
					n = n.parent || root;
					break
			}
			return root
		},
		_parseCss: function(node, text) {
			var t = text.substring(node.start, node.end - 1);
			node.parsedCssText = node.cssText = t.trim();
			if (node.parent) {
				var ss = node.previous ? node.previous.end : node.parent.start;
				t = text.substring(ss, node.start - 1);
				t = this._expandUnicodeEscapes(t);
				t = t.replace(this._rx.multipleSpaces, " ");
				t = t.substring(t.lastIndexOf(";") + 1);
				var s = node.parsedSelector = node.selector = t.trim();
				node.atRule = s.indexOf(this.AT_START) === 0;
				if (node.atRule)
					if (s.indexOf(this.MEDIA_START) ===
						0) node.type = this.types.MEDIA_RULE;
					else {
						if (s.match(this._rx.keyframesRule)) {
							node.type = this.types.KEYFRAMES_RULE;
							node.keyframesName = node.selector.split(this._rx.multipleSpaces).pop()
						}
					}
				else if (s.indexOf(this.VAR_START) === 0) node.type = this.types.MIXIN_RULE;
				else node.type = this.types.STYLE_RULE
			}
			var r$ = node.rules;
			if (r$)
				for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) this._parseCss(r, text);
			return node
		},
		_expandUnicodeEscapes: function(s) {
			return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
				var code = arguments[1],
					repeat = 6 - code.length;
				while (repeat--) code = "0" + code;
				return "\\" + code
			})
		},
		stringify: function(node, preserveProperties, text) {
			text = text || "";
			var cssText = "";
			if (node.cssText || node.rules) {
				var r$ = node.rules;
				if (r$ && !this._hasMixinRules(r$))
					for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) cssText = this.stringify(r, preserveProperties, cssText);
				else {
					cssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);
					cssText = cssText.trim();
					if (cssText) cssText = "  " + cssText + "\n"
				}
			}
			if (cssText) {
				if (node.selector) text +=
					node.selector + " " + this.OPEN_BRACE + "\n";
				text += cssText;
				if (node.selector) text += this.CLOSE_BRACE + "\n\n"
			}
			return text
		},
		_hasMixinRules: function(rules) {
			return rules[0].selector.indexOf(this.VAR_START) === 0
		},
		removeCustomProps: function(cssText) {
			cssText = this.removeCustomPropAssignment(cssText);
			return this.removeCustomPropApply(cssText)
		},
		removeCustomPropAssignment: function(cssText) {
			return cssText.replace(this._rx.customProp, "").replace(this._rx.mixinProp, "")
		},
		removeCustomPropApply: function(cssText) {
			return cssText.replace(this._rx.mixinApply,
				"").replace(this._rx.varApply, "")
		},
		types: {
			STYLE_RULE: 1,
			KEYFRAMES_RULE: 7,
			MEDIA_RULE: 4,
			MIXIN_RULE: 1E3
		},
		OPEN_BRACE: "{",
		CLOSE_BRACE: "}",
		_rx: {
			comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
			port: /@import[^;]*;/gim,
			customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
			mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
			mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
			varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
			keyframesRule: /^@[^\s]*keyframes/,
			multipleSpaces: /\s+/g
		},
		VAR_START: "--",
		MEDIA_START: "@media",
		AT_START: "@"
	}
}();
Polymer.StyleUtil = function() {
	var settings = Polymer.Settings;
	return {
		NATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,
		MODULE_STYLES_SELECTOR: "style, link[rel=import][type~=css], template",
		INCLUDE_ATTR: "include",
		toCssText: function(rules, callback) {
			if (typeof rules === "string") rules = this.parser.parse(rules);
			if (callback) this.forEachRule(rules, callback);
			return this.parser.stringify(rules, this.NATIVE_VARIABLES)
		},
		forRulesInStyles: function(styles, styleRuleCallback, keyframesRuleCallback) {
			if (styles)
				for (var i =
						0, l = styles.length, s; i < l && (s = styles[i]); i++) this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback)
		},
		forActiveRulesInStyles: function(styles, styleRuleCallback, keyframesRuleCallback) {
			if (styles)
				for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) this.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true)
		},
		rulesForStyle: function(style) {
			if (!style.__cssRules && style.textContent) style.__cssRules = this.parser.parse(style.textContent);
			return style.__cssRules
		},
		isKeyframesSelector: function(rule) {
			return rule.parent &&
				rule.parent.type === this.ruleTypes.KEYFRAMES_RULE
		},
		forEachRuleInStyle: function(style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
			var rules = this.rulesForStyle(style);
			var styleCallback, keyframeCallback;
			if (styleRuleCallback) styleCallback = function(rule) {
				styleRuleCallback(rule, style)
			};
			if (keyframesRuleCallback) keyframeCallback = function(rule) {
				keyframesRuleCallback(rule, style)
			};
			this.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules)
		},
		forEachRule: function(node, styleRuleCallback,
			keyframesRuleCallback, onlyActiveRules) {
			if (!node) return;
			var skipRules = false;
			if (onlyActiveRules)
				if (node.type === this.ruleTypes.MEDIA_RULE) {
					var matchMedia = node.selector.match(this.rx.MEDIA_MATCH);
					if (matchMedia)
						if (!window.matchMedia(matchMedia[1]).matches) skipRules = true
				}
			if (node.type === this.ruleTypes.STYLE_RULE) styleRuleCallback(node);
			else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) keyframesRuleCallback(node);
			else if (node.type === this.ruleTypes.MIXIN_RULE) skipRules = true;
			var r$ = node.rules;
			if (r$ && !skipRules)
				for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) this.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules)
		},
		applyCss: function(cssText, moniker, target, contextNode) {
			var style = this.createScopeStyle(cssText, moniker);
			return this.applyStyle(style, target, contextNode)
		},
		applyStyle: function(style, target, contextNode) {
			target = target || document.head;
			var after = contextNode && contextNode.nextSibling || target.firstChild;
			this.__lastHeadApplyNode = style;
			return target.insertBefore(style, after)
		},
		createScopeStyle: function(cssText, moniker) {
			var style = document.createElement("style");
			if (moniker) style.setAttribute("scope", moniker);
			style.textContent = cssText;
			return style
		},
		__lastHeadApplyNode: null,
		applyStylePlaceHolder: function(moniker) {
			var placeHolder = document.createComment(" Shady DOM styles for " + moniker + " ");
			var after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;
			var scope = document.head;
			scope.insertBefore(placeHolder, after || scope.firstChild);
			this.__lastHeadApplyNode = placeHolder;
			return placeHolder
		},
		cssFromModules: function(moduleIds, warnIfNotFound) {
			var modules = moduleIds.trim().split(" ");
			var cssText = "";
			for (var i = 0; i < modules.length; i++) cssText += this.cssFromModule(modules[i], warnIfNotFound);
			return cssText
		},
		cssFromModule: function(moduleId, warnIfNotFound) {
			var m = Polymer.DomModule["import"](moduleId);
			if (m && !m._cssText) m._cssText = this.cssFromElement(m);
			if (!m && warnIfNotFound) console.warn("Could not find style data in module named", moduleId);
			return m && m._cssText || ""
		},
		cssFromElement: function(element) {
			var cssText =
				"";
			var content = element.content || element;
			var e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));
			for (var i = 0, e; i < e$.length; i++) {
				e = e$[i];
				if (e.localName === "template") {
					if (!e.hasAttribute("preserve-content")) cssText += this.cssFromElement(e)
				} else if (e.localName === "style") {
					var include = e.getAttribute(this.INCLUDE_ATTR);
					if (include) cssText += this.cssFromModules(include, true);
					e = e.__appliedElement || e;
					e.parentNode.removeChild(e);
					cssText += this.resolveCss(e.textContent, element.ownerDocument)
				} else if (e["import"] &&
					e["import"].body) cssText += this.resolveCss(e["import"].body.textContent, e["import"])
			}
			return cssText
		},
		isTargetedBuild: function(buildType) {
			return settings.useNativeShadow ? buildType === "shadow" : buildType === "shady"
		},
		cssBuildTypeForModule: function(module) {
			var dm = Polymer.DomModule["import"](module);
			if (dm) return this.getCssBuildType(dm)
		},
		getCssBuildType: function(element) {
			return element.getAttribute("css-build")
		},
		_findMatchingParen: function(text, start) {
			var level = 0;
			for (var i = start, l = text.length; i < l; i++) switch (text[i]) {
				case "(":
					level++;
					break;
				case ")":
					if (--level === 0) return i;
					break
			}
			return -1
		},
		processVariableAndFallback: function(str, callback) {
			var start = str.indexOf("var(");
			if (start === -1) return callback(str, "", "", "");
			var end = this._findMatchingParen(str, start + 3);
			var inner = str.substring(start + 4, end);
			var prefix = str.substring(0, start);
			var suffix = this.processVariableAndFallback(str.substring(end + 1), callback);
			var comma = inner.indexOf(",");
			if (comma === -1) return callback(prefix, inner.trim(), "", suffix);
			var value = inner.substring(0, comma).trim();
			var fallback = inner.substring(comma + 1).trim();
			return callback(prefix, value, fallback, suffix)
		},
		rx: {
			VAR_ASSIGN: /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\s}])|$)/gi,
			MIXIN_MATCH: /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
			VAR_CONSUMED: /(--[\w-]+)\s*([:,;)]|$)/gi,
			ANIMATION_MATCH: /(animation\s*:)|(animation-name\s*:)/,
			MEDIA_MATCH: /@media[^(]*(\([^)]*\))/,
			IS_VAR: /^--/,
			BRACKETED: /\{[^}]*\}/g,
			HOST_PREFIX: "(?:^|[^.#[:])",
			HOST_SUFFIX: "($|[.:[\\s>+~])"
		},
		resolveCss: Polymer.ResolveUrl.resolveCss,
		parser: Polymer.CssParse,
		ruleTypes: Polymer.CssParse.types
	}
}();
Polymer.StyleTransformer = function() {
	var styleUtil = Polymer.StyleUtil;
	var settings = Polymer.Settings;
	var api = {
		dom: function(node, scope, useAttr, shouldRemoveScope) {
			this._transformDom(node, scope || "", useAttr, shouldRemoveScope)
		},
		_transformDom: function(node, selector, useAttr, shouldRemoveScope) {
			if (node.setAttribute) this.element(node, selector, useAttr, shouldRemoveScope);
			var c$ = Polymer.dom(node).childNodes;
			for (var i = 0; i < c$.length; i++) this._transformDom(c$[i], selector, useAttr, shouldRemoveScope)
		},
		element: function(element,
			scope, useAttr, shouldRemoveScope) {
			if (useAttr)
				if (shouldRemoveScope) element.removeAttribute(SCOPE_NAME);
				else element.setAttribute(SCOPE_NAME, scope);
			else if (scope)
				if (element.classList)
					if (shouldRemoveScope) {
						element.classList.remove(SCOPE_NAME);
						element.classList.remove(scope)
					} else {
						element.classList.add(SCOPE_NAME);
						element.classList.add(scope)
					}
			else if (element.getAttribute) {
				var c = element.getAttribute(CLASS);
				if (shouldRemoveScope) {
					if (c) element.setAttribute(CLASS, c.replace(SCOPE_NAME, "").replace(scope, ""))
				} else element.setAttribute(CLASS,
					(c ? c + " " : "") + SCOPE_NAME + " " + scope)
			}
		},
		elementStyles: function(element, callback) {
			var styles = element._styles;
			var cssText = "";
			var cssBuildType = element.__cssBuild;
			var passthrough = settings.useNativeShadow || cssBuildType === "shady";
			var cb;
			if (passthrough) {
				var self = this;
				cb = function(rule) {
					rule.selector = self._slottedToContent(rule.selector);
					rule.selector = rule.selector.replace(ROOT, ":host > *");
					if (callback) callback(rule)
				}
			}
			for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
				var rules = styleUtil.rulesForStyle(s);
				cssText += passthrough ? styleUtil.toCssText(rules, cb) : this.css(rules, element.is, element["extends"], callback, element._scopeCssViaAttr) + "\n\n"
			}
			return cssText.trim()
		},
		css: function(rules, scope, ext, callback, useAttr) {
			var hostScope = this._calcHostScope(scope, ext);
			scope = this._calcElementScope(scope, useAttr);
			var self = this;
			return styleUtil.toCssText(rules, function(rule) {
				if (!rule.isScoped) {
					self.rule(rule, scope, hostScope);
					rule.isScoped = true
				}
				if (callback) callback(rule, scope, hostScope)
			})
		},
		_calcElementScope: function(scope,
			useAttr) {
			if (scope) return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
			else return ""
		},
		_calcHostScope: function(scope, ext) {
			return ext ? "[is=" + scope + "]" : scope
		},
		rule: function(rule, scope, hostScope) {
			this._transformRule(rule, this._transformComplexSelector, scope, hostScope)
		},
		_transformRule: function(rule, transformer, scope, hostScope) {
			rule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope)
		},
		_transformRuleCss: function(rule, transformer, scope, hostScope) {
			var p$ =
				rule.selector.split(COMPLEX_SELECTOR_SEP);
			if (!styleUtil.isKeyframesSelector(rule))
				for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) p$[i] = transformer.call(this, p, scope, hostScope);
			return p$.join(COMPLEX_SELECTOR_SEP)
		},
		_transformComplexSelector: function(selector, scope, hostScope) {
			var stop = false;
			var hostContext = false;
			var self = this;
			selector = selector.trim();
			selector = this._slottedToContent(selector);
			selector = selector.replace(ROOT, ":host > *");
			selector = selector.replace(CONTENT_START, HOST + " $1");
			selector = selector.replace(SIMPLE_SELECTOR_SEP,
				function(m, c, s) {
					if (!stop) {
						var info = self._transformCompoundSelector(s, c, scope, hostScope);
						stop = stop || info.stop;
						hostContext = hostContext || info.hostContext;
						c = info.combinator;
						s = info.value
					} else s = s.replace(SCOPE_JUMP, " ");
					return c + s
				});
			if (hostContext) selector = selector.replace(HOST_CONTEXT_PAREN, function(m, pre, paren, post) {
				return pre + paren + " " + hostScope + post + COMPLEX_SELECTOR_SEP + " " + pre + hostScope + paren + post
			});
			return selector
		},
		_transformCompoundSelector: function(selector, combinator, scope, hostScope) {
			var jumpIndex =
				selector.search(SCOPE_JUMP);
			var hostContext = false;
			if (selector.indexOf(HOST_CONTEXT) >= 0) hostContext = true;
			else if (selector.indexOf(HOST) >= 0) selector = this._transformHostSelector(selector, hostScope);
			else if (jumpIndex !== 0) selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
			if (selector.indexOf(CONTENT) >= 0) combinator = "";
			var stop;
			if (jumpIndex >= 0) {
				selector = selector.replace(SCOPE_JUMP, " ");
				stop = true
			}
			return {
				value: selector,
				combinator: combinator,
				stop: stop,
				hostContext: hostContext
			}
		},
		_transformSimpleSelector: function(selector,
			scope) {
			var p$ = selector.split(PSEUDO_PREFIX);
			p$[0] += scope;
			return p$.join(PSEUDO_PREFIX)
		},
		_transformHostSelector: function(selector, hostScope) {
			var m = selector.match(HOST_PAREN);
			var paren = m && m[2].trim() || "";
			if (paren)
				if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
					var typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];
					if (typeSelector === hostScope) return paren;
					else return SELECTOR_NO_MATCH
				} else return selector.replace(HOST_PAREN, function(m, host, paren) {
					return hostScope + paren
				});
			else return selector.replace(HOST,
				hostScope)
		},
		documentRule: function(rule) {
			rule.selector = rule.parsedSelector;
			this.normalizeRootSelector(rule);
			if (!settings.useNativeShadow) this._transformRule(rule, this._transformDocumentSelector)
		},
		normalizeRootSelector: function(rule) {
			rule.selector = rule.selector.replace(ROOT, "html")
		},
		_transformDocumentSelector: function(selector) {
			return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR)
		},
		_slottedToContent: function(cssText) {
			return cssText.replace(SLOTTED_PAREN,
				CONTENT + "> $1")
		},
		SCOPE_NAME: "style-scope"
	};
	var SCOPE_NAME = api.SCOPE_NAME;
	var SCOPE_DOC_SELECTOR = ":not([" + SCOPE_NAME + "])" + ":not(." + SCOPE_NAME + ")";
	var COMPLEX_SELECTOR_SEP = ",";
	var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=\[])+)/g;
	var SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
	var HOST = ":host";
	var ROOT = ":root";
	var HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
	var HOST_CONTEXT = ":host-context";
	var HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))(.*)/;
	var CONTENT = "::content";
	var SCOPE_JUMP = /::content|::shadow|\/deep\//;
	var CSS_CLASS_PREFIX = ".";
	var CSS_ATTR_PREFIX = "[" + SCOPE_NAME + "~=";
	var CSS_ATTR_SUFFIX = "]";
	var PSEUDO_PREFIX = ":";
	var CLASS = "class";
	var CONTENT_START = new RegExp("^(" + CONTENT + ")");
	var SELECTOR_NO_MATCH = "should_not_match";
	var SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
	return api
}();
Polymer.StyleExtends = function() {
	var styleUtil = Polymer.StyleUtil;
	return {
		hasExtends: function(cssText) {
			return Boolean(cssText.match(this.rx.EXTEND))
		},
		transform: function(style) {
			var rules = styleUtil.rulesForStyle(style);
			var self = this;
			styleUtil.forEachRule(rules, function(rule) {
				self._mapRuleOntoParent(rule);
				if (rule.parent) {
					var m;
					while (m = self.rx.EXTEND.exec(rule.cssText)) {
						var extend = m[1];
						var extendor = self._findExtendor(extend, rule);
						if (extendor) self._extendRule(rule, extendor)
					}
				}
				rule.cssText = rule.cssText.replace(self.rx.EXTEND,
					"")
			});
			return styleUtil.toCssText(rules, function(rule) {
				if (rule.selector.match(self.rx.STRIP)) rule.cssText = ""
			}, true)
		},
		_mapRuleOntoParent: function(rule) {
			if (rule.parent) {
				var map = rule.parent.map || (rule.parent.map = {});
				var parts = rule.selector.split(",");
				for (var i = 0, p; i < parts.length; i++) {
					p = parts[i];
					map[p.trim()] = rule
				}
				return map
			}
		},
		_findExtendor: function(extend, rule) {
			return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent)
		},
		_extendRule: function(target, source) {
			if (target.parent !==
				source.parent) this._cloneAndAddRuleToParent(source, target.parent);
			target["extends"] = target["extends"] || [];
			target["extends"].push(source);
			source.selector = source.selector.replace(this.rx.STRIP, "");
			source.selector = (source.selector && source.selector + ",\n") + target.selector;
			if (source["extends"]) source["extends"].forEach(function(e) {
				this._extendRule(target, e)
			}, this)
		},
		_cloneAndAddRuleToParent: function(rule, parent) {
			rule = Object.create(rule);
			rule.parent = parent;
			if (rule["extends"]) rule["extends"] = rule["extends"].slice();
			parent.rules.push(rule)
		},
		rx: {
			EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
			STRIP: /%[^,]*$/
		}
	}
}();
Polymer.ApplyShim = function() {
	var styleUtil = Polymer.StyleUtil;
	var MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;
	var VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;
	var BAD_VAR = /var\(\s*(--[^,]*),\s*(--[^)]*)\)/g;
	var APPLY_NAME_CLEAN = /;\s*/m;
	var INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;
	var MIXIN_VAR_SEP = "_-_";
	var mixinMap = {};

	function mapSet(name, props) {
		name = name.trim();
		mixinMap[name] = {
			properties: props,
			dependants: {}
		}
	}

	function mapGet(name) {
		name = name.trim();
		return mixinMap[name]
	}

	function replaceInitialOrInherit(property,
		value) {
		var match = INITIAL_INHERIT.exec(value);
		if (match)
			if (match[1]) value = ApplyShim._getInitialValueForProperty(property);
			else value = "apply-shim-inherit";
		return value
	}

	function cssTextToMap(text) {
		var props = text.split(";");
		var property, value;
		var out = {};
		for (var i = 0, p, sp; i < props.length; i++) {
			p = props[i];
			if (p) {
				sp = p.split(":");
				if (sp.length > 1) {
					property = sp[0].trim();
					value = replaceInitialOrInherit(property, sp.slice(1).join(":"));
					out[property] = value
				}
			}
		}
		return out
	}

	function invalidateMixinEntry(mixinEntry) {
		var currentProto =
			ApplyShim.__currentElementProto;
		var currentElementName = currentProto && currentProto.is;
		for (var elementName in mixinEntry.dependants)
			if (elementName !== currentElementName) mixinEntry.dependants[elementName].__applyShimInvalid = true
	}

	function produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
		if (valueProperty) styleUtil.processVariableAndFallback(valueProperty, function(prefix, value) {
			if (value && mapGet(value)) valueMixin = "@apply " + value + ";"
		});
		if (!valueMixin) return matchText;
		var mixinAsProperties =
			consumeCssProperties(valueMixin);
		var prefix = matchText.slice(0, matchText.indexOf("--"));
		var mixinValues = cssTextToMap(mixinAsProperties);
		var combinedProps = mixinValues;
		var mixinEntry = mapGet(propertyName);
		var oldProps = mixinEntry && mixinEntry.properties;
		if (oldProps) {
			combinedProps = Object.create(oldProps);
			combinedProps = Polymer.Base.mixin(combinedProps, mixinValues)
		} else mapSet(propertyName, combinedProps);
		var out = [];
		var p, v;
		var needToInvalidate = false;
		for (p in combinedProps) {
			v = mixinValues[p];
			if (v === undefined) v =
				"initial";
			if (oldProps && !(p in oldProps)) needToInvalidate = true;
			out.push(propertyName + MIXIN_VAR_SEP + p + ": " + v)
		}
		if (needToInvalidate) invalidateMixinEntry(mixinEntry);
		if (mixinEntry) mixinEntry.properties = combinedProps;
		if (valueProperty) prefix = matchText + ";" + prefix;
		return prefix + out.join("; ") + ";"
	}

	function fixVars(matchText, varA, varB) {
		return "var(" + varA + "," + "var(" + varB + "))"
	}

	function atApplyToCssProperties(mixinName, fallbacks) {
		mixinName = mixinName.replace(APPLY_NAME_CLEAN, "");
		var vars = [];
		var mixinEntry = mapGet(mixinName);
		if (!mixinEntry) {
			mapSet(mixinName, {});
			mixinEntry = mapGet(mixinName)
		}
		if (mixinEntry) {
			var currentProto = ApplyShim.__currentElementProto;
			if (currentProto) mixinEntry.dependants[currentProto.is] = currentProto;
			var p, parts, f;
			for (p in mixinEntry.properties) {
				f = fallbacks && fallbacks[p];
				parts = [p, ": var(", mixinName, MIXIN_VAR_SEP, p];
				if (f) parts.push(",", f);
				parts.push(")");
				vars.push(parts.join(""))
			}
		}
		return vars.join("; ")
	}

	function consumeCssProperties(text) {
		var m;
		while (m = MIXIN_MATCH.exec(text)) {
			var matchText = m[0];
			var mixinName =
				m[1];
			var idx = m.index;
			var applyPos = idx + matchText.indexOf("@apply");
			var afterApplyPos = idx + matchText.length;
			var textBeforeApply = text.slice(0, applyPos);
			var textAfterApply = text.slice(afterApplyPos);
			var defaults = cssTextToMap(textBeforeApply);
			var replacement = atApplyToCssProperties(mixinName, defaults);
			text = [textBeforeApply, replacement, textAfterApply].join("");
			MIXIN_MATCH.lastIndex = idx + replacement.length
		}
		return text
	}
	var ApplyShim = {
		_measureElement: null,
		_map: mixinMap,
		_separator: MIXIN_VAR_SEP,
		transform: function(styles,
			elementProto) {
			this.__currentElementProto = elementProto;
			styleUtil.forRulesInStyles(styles, this._boundFindDefinitions);
			styleUtil.forRulesInStyles(styles, this._boundFindApplications);
			if (elementProto) elementProto.__applyShimInvalid = false;
			this.__currentElementProto = null
		},
		_findDefinitions: function(rule) {
			var cssText = rule.parsedCssText;
			cssText = cssText.replace(BAD_VAR, fixVars);
			cssText = cssText.replace(VAR_ASSIGN, produceCssProperties);
			rule.cssText = cssText;
			if (rule.selector === ":root") rule.selector = ":host > *"
		},
		_findApplications: function(rule) {
			rule.cssText = consumeCssProperties(rule.cssText)
		},
		transformRule: function(rule) {
			this._findDefinitions(rule);
			this._findApplications(rule)
		},
		_getInitialValueForProperty: function(property) {
			if (!this._measureElement) {
				this._measureElement = document.createElement("meta");
				this._measureElement.style.all = "initial";
				document.head.appendChild(this._measureElement)
			}
			return window.getComputedStyle(this._measureElement).getPropertyValue(property)
		}
	};
	ApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);
	ApplyShim._boundFindDefinitions = ApplyShim._findDefinitions.bind(ApplyShim);
	ApplyShim._boundFindApplications = ApplyShim._findApplications.bind(ApplyShim);
	return ApplyShim
}();
(function() {
	var prepElement = Polymer.Base._prepElement;
	var nativeShadow = Polymer.Settings.useNativeShadow;
	var styleUtil = Polymer.StyleUtil;
	var styleTransformer = Polymer.StyleTransformer;
	var styleExtends = Polymer.StyleExtends;
	var applyShim = Polymer.ApplyShim;
	var settings = Polymer.Settings;
	Polymer.Base._addFeature({
		_prepElement: function(element) {
			if (this._encapsulateStyle && this.__cssBuild !== "shady") styleTransformer.element(element, this.is, this._scopeCssViaAttr);
			prepElement.call(this, element)
		},
		_prepStyles: function() {
			if (this._encapsulateStyle ===
				undefined) this._encapsulateStyle = !nativeShadow;
			if (!nativeShadow) this._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);
			this.__cssBuild = styleUtil.cssBuildTypeForModule(this.is)
		},
		_prepShimStyles: function() {
			if (this._template) {
				var hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);
				if (settings.useNativeCSSProperties && this.__cssBuild === "shadow" && hasTargetedCssBuild) return;
				this._styles = this._styles || this._collectStyles();
				if (settings.useNativeCSSProperties && !this.__cssBuild) applyShim.transform(this._styles,
					this);
				var cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);
				this._prepStyleProperties();
				if (!this._needsStyleProperties() && cssText) styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle)
			} else this._styles = []
		},
		_collectStyles: function() {
			var styles = [];
			var cssText = "",
				m$ = this.styleModules;
			if (m$)
				for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) cssText += styleUtil.cssFromModule(m);
			cssText += styleUtil.cssFromModule(this.is);
			var p = this._template && this._template.parentNode;
			if (this._template && (!p || p.id.toLowerCase() !== this.is)) cssText += styleUtil.cssFromElement(this._template);
			if (cssText) {
				var style = document.createElement("style");
				style.textContent = cssText;
				if (styleExtends.hasExtends(style.textContent)) cssText = styleExtends.transform(style);
				styles.push(style)
			}
			return styles
		},
		_elementAdd: function(node) {
			if (this._encapsulateStyle)
				if (node.__styleScoped) node.__styleScoped = false;
				else styleTransformer.dom(node,
					this.is, this._scopeCssViaAttr)
		},
		_elementRemove: function(node) {
			if (this._encapsulateStyle) styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true)
		},
		scopeSubtree: function(container, shouldObserve) {
			if (nativeShadow) return;
			var self = this;
			var scopify = function(node) {
				if (node.nodeType === Node.ELEMENT_NODE) {
					var className = node.getAttribute("class");
					node.setAttribute("class", self._scopeElementClass(node, className));
					var n$ = node.querySelectorAll("*");
					for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
						className = n.getAttribute("class");
						n.setAttribute("class", self._scopeElementClass(n, className))
					}
				}
			};
			scopify(container);
			if (shouldObserve) {
				var mo = new MutationObserver(function(mxns) {
					for (var i = 0, m; i < mxns.length && (m = mxns[i]); i++)
						if (m.addedNodes)
							for (var j = 0; j < m.addedNodes.length; j++) scopify(m.addedNodes[j])
				});
				mo.observe(container, {
					childList: true,
					subtree: true
				});
				return mo
			}
		}
	})
})();
Polymer.StyleProperties = function() {
	var matchesSelector = Polymer.DomApi.matchesSelector;
	var styleUtil = Polymer.StyleUtil;
	var styleTransformer = Polymer.StyleTransformer;
	var IS_IE = navigator.userAgent.match("Trident");
	var settings = Polymer.Settings;
	return {
		decorateStyles: function(styles, scope) {
			var self = this,
				props = {},
				keyframes = [],
				ruleIndex = 0;
			var scopeSelector = styleTransformer._calcHostScope(scope.is, scope["extends"]);
			styleUtil.forRulesInStyles(styles, function(rule, style) {
				self.decorateRule(rule);
				rule.index =
					ruleIndex++;
				self.whenHostOrRootRule(scope, rule, style, function(info) {
					if (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) scope.__notStyleScopeCacheable = true;
					if (info.isHost) {
						var hostContextOrFunction = info.selector.split(" ").some(function(s) {
							return s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length
						});
						scope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction
					}
				});
				self.collectPropertiesInCssText(rule.propertyInfo.cssText, props)
			}, function onKeyframesRule(rule) {
				keyframes.push(rule)
			});
			styles._keyframes = keyframes;
			var names = [];
			for (var i in props) names.push(i);
			return names
		},
		decorateRule: function(rule) {
			if (rule.propertyInfo) return rule.propertyInfo;
			var info = {},
				properties = {};
			var hasProperties = this.collectProperties(rule, properties);
			if (hasProperties) {
				info.properties = properties;
				rule.rules = null
			}
			info.cssText = this.collectCssText(rule);
			rule.propertyInfo = info;
			return info
		},
		collectProperties: function(rule, properties) {
			var info = rule.propertyInfo;
			if (info) {
				if (info.properties) {
					Polymer.Base.mixin(properties,
						info.properties);
					return true
				}
			} else {
				var m, rx = this.rx.VAR_ASSIGN;
				var cssText = rule.parsedCssText;
				var value;
				var any;
				while (m = rx.exec(cssText)) {
					value = (m[2] || m[3]).trim();
					if (value !== "inherit") properties[m[1].trim()] = value;
					any = true
				}
				return any
			}
		},
		collectCssText: function(rule) {
			return this.collectConsumingCssText(rule.parsedCssText)
		},
		collectConsumingCssText: function(cssText) {
			return cssText.replace(this.rx.BRACKETED, "").replace(this.rx.VAR_ASSIGN, "")
		},
		collectPropertiesInCssText: function(cssText, props) {
			var m;
			while (m =
				this.rx.VAR_CONSUMED.exec(cssText)) {
				var name = m[1];
				if (m[2] !== ":") props[name] = true
			}
		},
		reify: function(props) {
			var names = Object.getOwnPropertyNames(props);
			for (var i = 0, n; i < names.length; i++) {
				n = names[i];
				props[n] = this.valueForProperty(props[n], props)
			}
		},
		valueForProperty: function(property, props) {
			if (property)
				if (property.indexOf(";") >= 0) property = this.valueForProperties(property, props);
				else {
					var self = this;
					var fn = function(prefix, value, fallback, suffix) {
						var propertyValue = self.valueForProperty(props[value], props);
						if (!propertyValue ||
							propertyValue === "initial") propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
						else if (propertyValue === "apply-shim-inherit") propertyValue = "inherit";
						return prefix + (propertyValue || "") + suffix
					};
					property = styleUtil.processVariableAndFallback(property, fn)
				}
			return property && property.trim() || ""
		},
		valueForProperties: function(property, props) {
			var parts = property.split(";");
			for (var i = 0, p, m; i < parts.length; i++)
				if (p = parts[i]) {
					this.rx.MIXIN_MATCH.lastIndex = 0;
					m = this.rx.MIXIN_MATCH.exec(p);
					if (m) p =
						this.valueForProperty(props[m[1]], props);
					else {
						var colon = p.indexOf(":");
						if (colon !== -1) {
							var pp = p.substring(colon);
							pp = pp.trim();
							pp = this.valueForProperty(pp, props) || pp;
							p = p.substring(0, colon) + pp
						}
					}
					parts[i] = p && p.lastIndexOf(";") === p.length - 1 ? p.slice(0, -1) : p || ""
				}
			return parts.join(";")
		},
		applyProperties: function(rule, props) {
			var output = "";
			if (!rule.propertyInfo) this.decorateRule(rule);
			if (rule.propertyInfo.cssText) output = this.valueForProperties(rule.propertyInfo.cssText, props);
			rule.cssText = output
		},
		applyKeyframeTransforms: function(rule,
			keyframeTransforms) {
			var input = rule.cssText;
			var output = rule.cssText;
			if (rule.hasAnimations == null) rule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);
			if (rule.hasAnimations) {
				var transform;
				if (rule.keyframeNamesToTransform == null) {
					rule.keyframeNamesToTransform = [];
					for (var keyframe in keyframeTransforms) {
						transform = keyframeTransforms[keyframe];
						output = transform(input);
						if (input !== output) {
							input = output;
							rule.keyframeNamesToTransform.push(keyframe)
						}
					}
				} else {
					for (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
						transform =
							keyframeTransforms[rule.keyframeNamesToTransform[i]];
						input = transform(input)
					}
					output = input
				}
			}
			rule.cssText = output
		},
		propertyDataFromStyles: function(styles, element) {
			var props = {},
				self = this;
			var o = [];
			styleUtil.forActiveRulesInStyles(styles, function(rule) {
				if (!rule.propertyInfo) self.decorateRule(rule);
				var selectorToMatch = rule.transformedSelector || rule.parsedSelector;
				if (element && rule.propertyInfo.properties && selectorToMatch)
					if (matchesSelector.call(element, selectorToMatch)) {
						self.collectProperties(rule, props);
						addToBitMask(rule.index, o)
					}
			});
			return {
				properties: props,
				key: o
			}
		},
		_rootSelector: /:root|:host\s*>\s*\*/,
		_checkRoot: function(hostScope, selector) {
			return Boolean(selector.match(this._rootSelector)) || hostScope === "html" && selector.indexOf("html") > -1
		},
		whenHostOrRootRule: function(scope, rule, style, callback) {
			if (!rule.propertyInfo) self.decorateRule(rule);
			if (!rule.propertyInfo.properties) return;
			var hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope["extends"]) : "html";
			var parsedSelector = rule.parsedSelector;
			var isRoot = this._checkRoot(hostScope, parsedSelector);
			var isHost = !isRoot && parsedSelector.indexOf(":host") === 0;
			var cssBuild = scope.__cssBuild || style.__cssBuild;
			if (cssBuild === "shady") {
				isRoot = parsedSelector === hostScope + " > *." + hostScope || parsedSelector.indexOf("html") > -1;
				isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0
			}
			if (!isRoot && !isHost) return;
			var selectorToMatch = hostScope;
			if (isHost) {
				if (settings.useNativeShadow && !rule.transformedSelector) rule.transformedSelector = styleTransformer._transformRuleCss(rule,
					styleTransformer._transformComplexSelector, scope.is, hostScope);
				selectorToMatch = rule.transformedSelector || rule.parsedSelector
			}
			if (isRoot && hostScope === "html") selectorToMatch = rule.transformedSelector || rule.parsedSelector;
			callback({
				selector: selectorToMatch,
				isHost: isHost,
				isRoot: isRoot
			})
		},
		hostAndRootPropertiesForScope: function(scope) {
			var hostProps = {},
				rootProps = {},
				self = this;
			styleUtil.forActiveRulesInStyles(scope._styles, function(rule, style) {
				self.whenHostOrRootRule(scope, rule, style, function(info) {
					var element =
						scope._element || scope;
					if (matchesSelector.call(element, info.selector))
						if (info.isHost) self.collectProperties(rule, hostProps);
						else self.collectProperties(rule, rootProps)
				})
			});
			return {
				rootProps: rootProps,
				hostProps: hostProps
			}
		},
		transformStyles: function(element, properties, scopeSelector) {
			var self = this;
			var hostSelector = styleTransformer._calcHostScope(element.is, element["extends"]);
			var rxHostSelector = element["extends"] ? "\\" + hostSelector.slice(0, -1) + "\\]" : hostSelector;
			var hostRx = new RegExp(this.rx.HOST_PREFIX +
				rxHostSelector + this.rx.HOST_SUFFIX);
			var keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);
			return styleTransformer.elementStyles(element, function(rule) {
				self.applyProperties(rule, properties);
				if (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {
					self.applyKeyframeTransforms(rule, keyframeTransforms);
					self._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector)
				}
			})
		},
		_elementKeyframeTransforms: function(element, scopeSelector) {
			var keyframesRules =
				element._styles._keyframes;
			var keyframeTransforms = {};
			if (!settings.useNativeShadow && keyframesRules)
				for (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
					this._scopeKeyframes(keyframesRule, scopeSelector);
					keyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule)
				}
			return keyframeTransforms
		},
		_keyframesRuleTransformer: function(keyframesRule) {
			return function(cssText) {
				return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName)
			}
		},
		_scopeKeyframes: function(rule, scopeId) {
			rule.keyframesNameRx = new RegExp(rule.keyframesName, "g");
			rule.transformedKeyframesName = rule.keyframesName + "-" + scopeId;
			rule.transformedSelector = rule.transformedSelector || rule.selector;
			rule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName)
		},
		_scopeSelector: function(rule, hostRx, hostSelector, viaAttr, scopeId) {
			rule.transformedSelector = rule.transformedSelector || rule.selector;
			var selector = rule.transformedSelector;
			var scope = viaAttr ?
				"[" + styleTransformer.SCOPE_NAME + "~=" + scopeId + "]" : "." + scopeId;
			var parts = selector.split(",");
			for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + " " + p;
			rule.selector = parts.join(",")
		},
		applyElementScopeSelector: function(element, selector, old, viaAttr) {
			var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute("class") || "";
			var v = old ? c.replace(old, selector) : (c ? c + " " : "") + this.XSCOPE_NAME + " " + selector;
			if (c !== v)
				if (viaAttr) element.setAttribute(styleTransformer.SCOPE_NAME,
					v);
				else element.setAttribute("class", v)
		},
		applyElementStyle: function(element, properties, selector, style) {
			var cssText = style ? style.textContent || "" : this.transformStyles(element, properties, selector);
			var s = element._customStyle;
			if (s && !settings.useNativeShadow && s !== style) {
				s._useCount--;
				if (s._useCount <= 0 && s.parentNode) s.parentNode.removeChild(s)
			}
			if (settings.useNativeShadow)
				if (element._customStyle) {
					element._customStyle.textContent = cssText;
					style = element._customStyle
				} else {
					if (cssText) style = styleUtil.applyCss(cssText,
						selector, element.root, element._scopeStyle)
				}
			else if (!style) {
				if (cssText) style = styleUtil.applyCss(cssText, selector, null, element._scopeStyle)
			} else if (!style.parentNode) {
				if (IS_IE && cssText.indexOf("@media") > -1) style.textContent = cssText;
				styleUtil.applyStyle(style, null, element._scopeStyle)
			}
			if (style) {
				style._useCount = style._useCount || 0;
				if (element._customStyle != style) style._useCount++;
				element._customStyle = style
			}
			return style
		},
		mixinCustomStyle: function(props, customStyle) {
			var v;
			for (var i in customStyle) {
				v = customStyle[i];
				if (v || v === 0) props[i] = v
			}
		},
		updateNativeStyleProperties: function(element, properties) {
			var oldPropertyNames = element.__customStyleProperties;
			if (oldPropertyNames)
				for (var i = 0; i < oldPropertyNames.length; i++) element.style.removeProperty(oldPropertyNames[i]);
			var propertyNames = [];
			for (var p in properties)
				if (properties[p] !== null) {
					element.style.setProperty(p, properties[p]);
					propertyNames.push(p)
				}
			element.__customStyleProperties = propertyNames
		},
		rx: styleUtil.rx,
		XSCOPE_NAME: "x-scope"
	};

	function addToBitMask(n, bits) {
		var o =
			parseInt(n / 32);
		var v = 1 << n % 32;
		bits[o] = (bits[o] || 0) | v
	}
}();
(function() {
	Polymer.StyleCache = function() {
		this.cache = {}
	};
	Polymer.StyleCache.prototype = {
		MAX: 100,
		store: function(is, data, keyValues, keyStyles) {
			data.keyValues = keyValues;
			data.styles = keyStyles;
			var s$ = this.cache[is] = this.cache[is] || [];
			s$.push(data);
			if (s$.length > this.MAX) s$.shift()
		},
		retrieve: function(is, keyValues, keyStyles) {
			var cache = this.cache[is];
			if (cache)
				for (var i = cache.length - 1, data; i >= 0; i--) {
					data = cache[i];
					if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) return data
				}
		},
		clear: function() {
			this.cache = {}
		},
		_objectsEqual: function(target, source) {
			var t, s;
			for (var i in target) {
				t = target[i], s = source[i];
				if (!(typeof t === "object" && t ? this._objectsStrictlyEqual(t, s) : t === s)) return false
			}
			if (Array.isArray(target)) return target.length === source.length;
			return true
		},
		_objectsStrictlyEqual: function(target, source) {
			return this._objectsEqual(target, source) && this._objectsEqual(source, target)
		}
	}
})();
Polymer.StyleDefaults = function() {
	var styleProperties = Polymer.StyleProperties;
	var StyleCache = Polymer.StyleCache;
	var nativeVariables = Polymer.Settings.useNativeCSSProperties;
	var api = {
		_styles: [],
		_properties: null,
		customStyle: {},
		_styleCache: new StyleCache,
		_element: Polymer.DomApi.wrap(document.documentElement),
		addStyle: function(style) {
			this._styles.push(style);
			this._properties = null
		},
		get _styleProperties() {
			if (!this._properties) {
				styleProperties.decorateStyles(this._styles, this);
				this._styles._scopeStyleProperties =
					null;
				this._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;
				styleProperties.mixinCustomStyle(this._properties, this.customStyle);
				styleProperties.reify(this._properties)
			}
			return this._properties
		},
		hasStyleProperties: function() {
			return Boolean(this._properties)
		},
		_needsStyleProperties: function() {},
		_computeStyleProperties: function() {
			return this._styleProperties
		},
		updateStyles: function(properties) {
			this._properties = null;
			if (properties) Polymer.Base.mixin(this.customStyle, properties);
			this._styleCache.clear();
			for (var i = 0, s; i < this._styles.length; i++) {
				s = this._styles[i];
				s = s.__importElement || s;
				s._apply()
			}
			if (nativeVariables) styleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle)
		}
	};
	return api
}();
(function() {
	var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
	var propertyUtils = Polymer.StyleProperties;
	var styleTransformer = Polymer.StyleTransformer;
	var styleDefaults = Polymer.StyleDefaults;
	var nativeShadow = Polymer.Settings.useNativeShadow;
	var nativeVariables = Polymer.Settings.useNativeCSSProperties;
	Polymer.Base._addFeature({
		_prepStyleProperties: function() {
			if (!nativeVariables) this._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles,
				this) : null
		},
		customStyle: null,
		getComputedStyleValue: function(property) {
			return !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property)
		},
		_setupStyleProperties: function() {
			this.customStyle = {};
			this._styleCache = null;
			this._styleProperties = null;
			this._scopeSelector = null;
			this._ownStyleProperties = null;
			this._customStyle = null
		},
		_needsStyleProperties: function() {
			return Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length)
		},
		_validateApplyShim: function() {
			if (this.__applyShimInvalid) {
				Polymer.ApplyShim.transform(this._styles, this.__proto__);
				var cssText = styleTransformer.elementStyles(this);
				if (nativeShadow) {
					var templateStyle = this._template.content.querySelector("style");
					if (templateStyle) templateStyle.textContent = cssText
				} else {
					var shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;
					if (shadyStyle) shadyStyle.textContent = cssText
				}
			}
		},
		_beforeAttached: function() {
			if ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {
				this.__stylePropertiesInvalid =
					false;
				this._updateStyleProperties()
			}
		},
		_findStyleHost: function() {
			var e = this,
				root;
			while (root = Polymer.dom(e).getOwnerRoot()) {
				if (Polymer.isInstance(root.host)) return root.host;
				e = root.host
			}
			return styleDefaults
		},
		_updateStyleProperties: function() {
			var info, scope = this._findStyleHost();
			if (!scope._styleProperties) scope._computeStyleProperties();
			if (!scope._styleCache) scope._styleCache = new Polymer.StyleCache;
			var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
			var scopeCacheable = !this.__notStyleScopeCacheable;
			if (scopeCacheable) {
				scopeData.key.customStyle = this.customStyle;
				info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles)
			}
			var scopeCached = Boolean(info);
			if (scopeCached) this._styleProperties = info._styleProperties;
			else this._computeStyleProperties(scopeData.properties);
			this._computeOwnStyleProperties();
			if (!scopeCached) info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
			var globalCached = Boolean(info) && !scopeCached;
			var style = this._applyStyleProperties(info);
			if (!scopeCached) {
				style =
					style && nativeShadow ? style.cloneNode(true) : style;
				info = {
					style: style,
					_scopeSelector: this._scopeSelector,
					_styleProperties: this._styleProperties
				};
				if (scopeCacheable) {
					scopeData.key.customStyle = {};
					this.mixin(scopeData.key.customStyle, this.customStyle);
					scope._styleCache.store(this.is, info, scopeData.key, this._styles)
				}
				if (!globalCached) styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles)
			}
		},
		_computeStyleProperties: function(scopeProps) {
			var scope = this._findStyleHost();
			if (!scope._styleProperties) scope._computeStyleProperties();
			var props = Object.create(scope._styleProperties);
			var hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);
			this.mixin(props, hostAndRootProps.hostProps);
			scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
			this.mixin(props, scopeProps);
			this.mixin(props, hostAndRootProps.rootProps);
			propertyUtils.mixinCustomStyle(props, this.customStyle);
			propertyUtils.reify(props);
			this._styleProperties = props
		},
		_computeOwnStyleProperties: function() {
			var props = {};
			for (var i =
					0, n; i < this._ownStylePropertyNames.length; i++) {
				n = this._ownStylePropertyNames[i];
				props[n] = this._styleProperties[n]
			}
			this._ownStyleProperties = props
		},
		_scopeCount: 0,
		_applyStyleProperties: function(info) {
			var oldScopeSelector = this._scopeSelector;
			this._scopeSelector = info ? info._scopeSelector : this.is + "-" + this.__proto__._scopeCount++;
			var style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
			if (!nativeShadow) propertyUtils.applyElementScopeSelector(this, this._scopeSelector,
				oldScopeSelector, this._scopeCssViaAttr);
			return style
		},
		serializeValueToAttribute: function(value, attribute, node) {
			node = node || this;
			if (attribute === "class" && !nativeShadow) {
				var host = node === this ? this.domHost || this.dataHost : this;
				if (host) value = host._scopeElementClass(node, value)
			}
			node = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;
			serializeValueToAttribute.call(this, value, attribute, node)
		},
		_scopeElementClass: function(element, selector) {
			if (!nativeShadow && !this._scopeCssViaAttr) selector = (selector ?
				selector + " " : "") + SCOPE_NAME + " " + this.is + (element._scopeSelector ? " " + XSCOPE_NAME + " " + element._scopeSelector : "");
			return selector
		},
		updateStyles: function(properties) {
			if (properties) this.mixin(this.customStyle, properties);
			if (nativeVariables) propertyUtils.updateNativeStyleProperties(this, this.customStyle);
			else {
				if (this.isAttached)
					if (this._needsStyleProperties()) this._updateStyleProperties();
					else this._styleProperties = null;
				else this.__stylePropertiesInvalid = true;
				if (this._styleCache) this._styleCache.clear();
				this._updateRootStyles()
			}
		},
		_updateRootStyles: function(root) {
			root = root || this.root;
			var c$ = Polymer.dom(root)._query(function(e) {
				return e.shadyRoot || e.shadowRoot
			});
			for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++)
				if (c.updateStyles) c.updateStyles()
		}
	});
	Polymer.updateStyles = function(properties) {
		styleDefaults.updateStyles(properties);
		Polymer.Base._updateRootStyles(document)
	};
	var styleCache = new Polymer.StyleCache;
	Polymer.customStyleCache = styleCache;
	var SCOPE_NAME = styleTransformer.SCOPE_NAME;
	var XSCOPE_NAME = propertyUtils.XSCOPE_NAME
})();
Polymer.Base._addFeature({
	_registerFeatures: function() {
		this._prepIs();
		this._prepConstructor();
		this._prepStyles()
	},
	_finishRegisterFeatures: function() {
		this._prepTemplate();
		this._prepShimStyles();
		this._prepAnnotations();
		this._prepEffects();
		this._prepBehaviors();
		this._prepPropertyInfo();
		this._prepBindings();
		this._prepShady()
	},
	_prepBehavior: function(b) {
		this._addPropertyEffects(b.properties);
		this._addComplexObserverEffects(b.observers);
		this._addHostAttributes(b.hostAttributes)
	},
	_initFeatures: function() {
		this._setupGestures();
		this._setupConfigure();
		this._setupStyleProperties();
		this._setupDebouncers();
		this._setupShady();
		this._registerHost();
		if (this._template) {
			this._validateApplyShim();
			this._poolContent();
			this._beginHosting();
			this._stampTemplate();
			this._endHosting();
			this._marshalAnnotationReferences()
		}
		this._marshalInstanceEffects();
		this._marshalBehaviors();
		this._marshalHostAttributes();
		this._marshalAttributes();
		this._tryReady()
	},
	_marshalBehavior: function(b) {
		if (b.listeners) this._listenListeners(b.listeners)
	}
});
(function() {
	var propertyUtils = Polymer.StyleProperties;
	var styleUtil = Polymer.StyleUtil;
	var cssParse = Polymer.CssParse;
	var styleDefaults = Polymer.StyleDefaults;
	var styleTransformer = Polymer.StyleTransformer;
	var applyShim = Polymer.ApplyShim;
	var debounce = Polymer.Debounce;
	var settings = Polymer.Settings;
	var updateDebouncer;
	Polymer({
		is: "custom-style",
		"extends": "style",
		_template: null,
		properties: {
			include: String
		},
		ready: function() {
			this.__appliedElement = this.__appliedElement || this;
			this.__cssBuild = styleUtil.getCssBuildType(this);
			if (this.__appliedElement !== this) this.__appliedElement.__cssBuild = this.__cssBuild;
			this._tryApply()
		},
		attached: function() {
			this._tryApply()
		},
		_tryApply: function() {
			if (!this._appliesToDocument)
				if (this.parentNode && this.parentNode.localName !== "dom-module") {
					this._appliesToDocument = true;
					var e = this.__appliedElement;
					if (!settings.useNativeCSSProperties) {
						this.__needsUpdateStyles = styleDefaults.hasStyleProperties();
						styleDefaults.addStyle(e)
					}
					if (e.textContent || this.include) this._apply(true);
					else {
						var self = this;
						var observer =
							new MutationObserver(function() {
								observer.disconnect();
								self._apply(true)
							});
						observer.observe(e, {
							childList: true
						})
					}
				}
		},
		_updateStyles: function() {
			Polymer.updateStyles()
		},
		_apply: function(initialApply) {
			var e = this.__appliedElement;
			if (this.include) e.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;
			if (!e.textContent) return;
			var buildType = this.__cssBuild;
			var targetedBuild = styleUtil.isTargetedBuild(buildType);
			if (settings.useNativeCSSProperties && targetedBuild) return;
			var styleRules = styleUtil.rulesForStyle(e);
			if (!targetedBuild) {
				styleUtil.forEachRule(styleRules, function(rule) {
					styleTransformer.documentRule(rule)
				});
				if (settings.useNativeCSSProperties && !buildType) applyShim.transform([e])
			}
			if (settings.useNativeCSSProperties) e.textContent = styleUtil.toCssText(styleRules);
			else {
				var self = this;
				var fn = function fn() {
					self._flushCustomProperties()
				};
				if (initialApply) Polymer.RenderStatus.whenReady(fn);
				else fn()
			}
		},
		_flushCustomProperties: function() {
			if (this.__needsUpdateStyles) {
				this.__needsUpdateStyles = false;
				updateDebouncer =
					debounce(updateDebouncer, this._updateStyles)
			} else this._applyCustomProperties()
		},
		_applyCustomProperties: function() {
			var element = this.__appliedElement;
			this._computeStyleProperties();
			var props = this._styleProperties;
			var rules = styleUtil.rulesForStyle(element);
			if (!rules) return;
			element.textContent = styleUtil.toCssText(rules, function(rule) {
				var css = rule.cssText = rule.parsedCssText;
				if (rule.propertyInfo && rule.propertyInfo.cssText) {
					css = cssParse.removeCustomPropAssignment(css);
					rule.cssText = propertyUtils.valueForProperties(css,
						props)
				}
			})
		}
	})
})();
Polymer.Templatizer = {
	properties: {
		__hideTemplateChildren__: {
			observer: "_showHideChildren"
		}
	},
	_instanceProps: Polymer.nob,
	_parentPropPrefix: "_parent_",
	templatize: function(template) {
		this._templatized = template;
		if (!template._content) template._content = template.content;
		if (template._content._ctor) {
			this.ctor = template._content._ctor;
			this._prepParentProperties(this.ctor.prototype, template);
			return
		}
		var archetype = Object.create(Polymer.Base);
		this._customPrepAnnotations(archetype, template);
		this._prepParentProperties(archetype, template);
		archetype._prepEffects();
		this._customPrepEffects(archetype);
		archetype._prepBehaviors();
		archetype._prepPropertyInfo();
		archetype._prepBindings();
		archetype._notifyPathUp = this._notifyPathUpImpl;
		archetype._scopeElementClass = this._scopeElementClassImpl;
		archetype.listen = this._listenImpl;
		archetype._showHideChildren = this._showHideChildrenImpl;
		archetype.__setPropertyOrig = this.__setProperty;
		archetype.__setProperty = this.__setPropertyImpl;
		var _constructor = this._constructorImpl;
		var ctor = function TemplateInstance(model,
			host) {
			_constructor.call(this, model, host)
		};
		ctor.prototype = archetype;
		archetype.constructor = ctor;
		template._content._ctor = ctor;
		this.ctor = ctor
	},
	_getRootDataHost: function() {
		return this.dataHost && this.dataHost._rootDataHost || this.dataHost
	},
	_showHideChildrenImpl: function(hide) {
		var c = this._children;
		for (var i = 0; i < c.length; i++) {
			var n = c[i];
			if (Boolean(hide) != Boolean(n.__hideTemplateChildren__))
				if (n.nodeType === Node.TEXT_NODE)
					if (hide) {
						n.__polymerTextContent__ = n.textContent;
						n.textContent = ""
					} else n.textContent = n.__polymerTextContent__;
			else if (n.style)
				if (hide) {
					n.__polymerDisplay__ = n.style.display;
					n.style.display = "none"
				} else n.style.display = n.__polymerDisplay__;
			n.__hideTemplateChildren__ = hide
		}
	},
	__setPropertyImpl: function(property, value, fromAbove, node) {
		if (node && node.__hideTemplateChildren__ && property == "textContent") property = "__polymerTextContent__";
		this.__setPropertyOrig(property, value, fromAbove, node)
	},
	_debounceTemplate: function(fn) {
		Polymer.dom.addDebouncer(this.debounce("_debounceTemplate", fn))
	},
	_flushTemplates: function() {
		Polymer.dom.flush()
	},
	_customPrepEffects: function(archetype) {
		var parentProps = archetype._parentProps;
		for (var prop in parentProps) archetype._addPropertyEffect(prop, "function", this._createHostPropEffector(prop));
		for (prop in this._instanceProps) archetype._addPropertyEffect(prop, "function", this._createInstancePropEffector(prop))
	},
	_customPrepAnnotations: function(archetype, template) {
		archetype._template = template;
		var c = template._content;
		if (!c._notes) {
			var rootDataHost = archetype._rootDataHost;
			if (rootDataHost) Polymer.Annotations.prepElement =
				function() {
					rootDataHost._prepElement()
				};
			c._notes = Polymer.Annotations.parseAnnotations(template);
			Polymer.Annotations.prepElement = null;
			this._processAnnotations(c._notes)
		}
		archetype._notes = c._notes;
		archetype._parentProps = c._parentProps
	},
	_prepParentProperties: function(archetype, template) {
		var parentProps = this._parentProps = archetype._parentProps;
		if (this._forwardParentProp && parentProps) {
			var proto = archetype._parentPropProto;
			var prop;
			if (!proto) {
				for (prop in this._instanceProps) delete parentProps[prop];
				proto =
					archetype._parentPropProto = Object.create(null);
				if (template != this) {
					Polymer.Bind.prepareModel(proto);
					Polymer.Base.prepareModelNotifyPath(proto)
				}
				for (prop in parentProps) {
					var parentProp = this._parentPropPrefix + prop;
					var effects = [{
						kind: "function",
						effect: this._createForwardPropEffector(prop),
						fn: Polymer.Bind._functionEffect
					}, {
						kind: "notify",
						fn: Polymer.Bind._notifyEffect,
						effect: {
							event: Polymer.CaseMap.camelToDashCase(parentProp) + "-changed"
						}
					}];
					Polymer.Bind._createAccessors(proto, parentProp, effects)
				}
			}
			var self =
				this;
			if (template != this) {
				Polymer.Bind.prepareInstance(template);
				template._forwardParentProp = function(source, value) {
					self._forwardParentProp(source, value)
				}
			}
			this._extendTemplate(template, proto);
			template._pathEffector = function(path, value, fromAbove) {
				return self._pathEffectorImpl(path, value, fromAbove)
			}
		}
	},
	_createForwardPropEffector: function(prop) {
		return function(source, value) {
			this._forwardParentProp(prop, value)
		}
	},
	_createHostPropEffector: function(prop) {
		var prefix = this._parentPropPrefix;
		return function(source,
			value) {
			this.dataHost._templatized[prefix + prop] = value
		}
	},
	_createInstancePropEffector: function(prop) {
		return function(source, value, old, fromAbove) {
			if (!fromAbove) this.dataHost._forwardInstanceProp(this, prop, value)
		}
	},
	_extendTemplate: function(template, proto) {
		var n$ = Object.getOwnPropertyNames(proto);
		if (proto._propertySetter) template._propertySetter = proto._propertySetter;
		for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
			var val = template[n];
			var pd = Object.getOwnPropertyDescriptor(proto, n);
			Object.defineProperty(template,
				n, pd);
			if (val !== undefined) template._propertySetter(n, val)
		}
	},
	_showHideChildren: function(hidden) {},
	_forwardInstancePath: function(inst, path, value) {},
	_forwardInstanceProp: function(inst, prop, value) {},
	_notifyPathUpImpl: function(path, value) {
		var dataHost = this.dataHost;
		var root = Polymer.Path.root(path);
		dataHost._forwardInstancePath.call(dataHost, this, path, value);
		if (root in dataHost._parentProps) dataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value)
	},
	_pathEffectorImpl: function(path, value, fromAbove) {
		if (this._forwardParentPath)
			if (path.indexOf(this._parentPropPrefix) ===
				0) {
				var subPath = path.substring(this._parentPropPrefix.length);
				var model = Polymer.Path.root(subPath);
				if (model in this._parentProps) this._forwardParentPath(subPath, value)
			}
		Polymer.Base._pathEffector.call(this._templatized, path, value, fromAbove)
	},
	_constructorImpl: function(model, host) {
		this._rootDataHost = host._getRootDataHost();
		this._setupConfigure(model);
		this._registerHost(host);
		this._beginHosting();
		this.root = this.instanceTemplate(this._template);
		this.root.__noContent = !this._notes._hasContent;
		this.root.__styleScoped =
			true;
		this._endHosting();
		this._marshalAnnotatedNodes();
		this._marshalInstanceEffects();
		this._marshalAnnotatedListeners();
		var children = [];
		for (var n = this.root.firstChild; n; n = n.nextSibling) {
			children.push(n);
			n._templateInstance = this
		}
		this._children = children;
		if (host.__hideTemplateChildren__) this._showHideChildren(true);
		this._tryReady()
	},
	_listenImpl: function(node, eventName, methodName) {
		var model = this;
		var host = this._rootDataHost;
		var handler = host._createEventHandler(node, eventName, methodName);
		var decorated = function(e) {
			e.model =
				model;
			handler(e)
		};
		host._listen(node, eventName, decorated)
	},
	_scopeElementClassImpl: function(node, value) {
		var host = this._rootDataHost;
		if (host) return host._scopeElementClass(node, value);
		return value
	},
	stamp: function(model) {
		model = model || {};
		if (this._parentProps) {
			var templatized = this._templatized;
			for (var prop in this._parentProps)
				if (model[prop] === undefined) model[prop] = templatized[this._parentPropPrefix + prop]
		}
		return new this.ctor(model, this)
	},
	modelForElement: function(el) {
		var model;
		while (el)
			if (model = el._templateInstance)
				if (model.dataHost !=
					this) el = model.dataHost;
				else return model;
		else el = el.parentNode
	}
};
Polymer({
	is: "dom-template",
	"extends": "template",
	_template: null,
	behaviors: [Polymer.Templatizer],
	ready: function() {
		this.templatize(this)
	}
});
Polymer._collections = new WeakMap;
Polymer.Collection = function(userArray) {
	Polymer._collections.set(userArray, this);
	this.userArray = userArray;
	this.store = userArray.slice();
	this.initMap()
};
Polymer.Collection.prototype = {
	constructor: Polymer.Collection,
	initMap: function() {
		var omap = this.omap = new WeakMap;
		var pmap = this.pmap = {};
		var s = this.store;
		for (var i = 0; i < s.length; i++) {
			var item = s[i];
			if (item && typeof item == "object") omap.set(item, i);
			else pmap[item] = i
		}
	},
	add: function(item) {
		var key = this.store.push(item) - 1;
		if (item && typeof item == "object") this.omap.set(item, key);
		else this.pmap[item] = key;
		return "#" + key
	},
	removeKey: function(key) {
		if (key = this._parseKey(key)) {
			this._removeFromMap(this.store[key]);
			delete this.store[key]
		}
	},
	_removeFromMap: function(item) {
		if (item && typeof item == "object") this.omap["delete"](item);
		else delete this.pmap[item]
	},
	remove: function(item) {
		var key = this.getKey(item);
		this.removeKey(key);
		return key
	},
	getKey: function(item) {
		var key;
		if (item && typeof item == "object") key = this.omap.get(item);
		else key = this.pmap[item];
		if (key != undefined) return "#" + key
	},
	getKeys: function() {
		return Object.keys(this.store).map(function(key) {
			return "#" + key
		})
	},
	_parseKey: function(key) {
		if (key && key[0] == "#") return key.slice(1)
	},
	setItem: function(key,
		item) {
		if (key = this._parseKey(key)) {
			var old = this.store[key];
			if (old) this._removeFromMap(old);
			if (item && typeof item == "object") this.omap.set(item, key);
			else this.pmap[item] = key;
			this.store[key] = item
		}
	},
	getItem: function(key) {
		if (key = this._parseKey(key)) return this.store[key]
	},
	getItems: function() {
		var items = [],
			store = this.store;
		for (var key in store) items.push(store[key]);
		return items
	},
	_applySplices: function(splices) {
		var keyMap = {},
			key;
		for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
			s.addedKeys = [];
			for (var j =
					0; j < s.removed.length; j++) {
				key = this.getKey(s.removed[j]);
				keyMap[key] = keyMap[key] ? null : -1
			}
			for (j = 0; j < s.addedCount; j++) {
				var item = this.userArray[s.index + j];
				key = this.getKey(item);
				key = key === undefined ? this.add(item) : key;
				keyMap[key] = keyMap[key] ? null : 1;
				s.addedKeys.push(key)
			}
		}
		var removed = [];
		var added = [];
		for (key in keyMap) {
			if (keyMap[key] < 0) {
				this.removeKey(key);
				removed.push(key)
			}
			if (keyMap[key] > 0) added.push(key)
		}
		return [{
			removed: removed,
			added: added
		}]
	}
};
Polymer.Collection.get = function(userArray) {
	return Polymer._collections.get(userArray) || new Polymer.Collection(userArray)
};
Polymer.Collection.applySplices = function(userArray, splices) {
	var coll = Polymer._collections.get(userArray);
	return coll ? coll._applySplices(splices) : null
};
Polymer({
	is: "dom-repeat",
	"extends": "template",
	_template: null,
	properties: {
		items: {
			type: Array
		},
		as: {
			type: String,
			value: "item"
		},
		indexAs: {
			type: String,
			value: "index"
		},
		sort: {
			type: Function,
			observer: "_sortChanged"
		},
		filter: {
			type: Function,
			observer: "_filterChanged"
		},
		observe: {
			type: String,
			observer: "_observeChanged"
		},
		delay: Number,
		renderedItemCount: {
			type: Number,
			notify: true,
			readOnly: true
		},
		initialCount: {
			type: Number,
			observer: "_initializeChunking"
		},
		targetFramerate: {
			type: Number,
			value: 20
		},
		_targetFrameTime: {
			type: Number,
			computed: "_computeFrameTime(targetFramerate)"
		}
	},
	behaviors: [Polymer.Templatizer],
	observers: ["_itemsChanged(items.*)"],
	created: function() {
		this._instances = [];
		this._pool = [];
		this._limit = Infinity;
		var self = this;
		this._boundRenderChunk = function() {
			self._renderChunk()
		}
	},
	detached: function() {
		this.__isDetached = true;
		for (var i = 0; i < this._instances.length; i++) this._detachInstance(i)
	},
	attached: function() {
		if (this.__isDetached) {
			this.__isDetached = false;
			var parent = Polymer.dom(Polymer.dom(this).parentNode);
			for (var i = 0; i < this._instances.length; i++) this._attachInstance(i,
				parent)
		}
	},
	ready: function() {
		this._instanceProps = {
			__key__: true
		};
		this._instanceProps[this.as] = true;
		this._instanceProps[this.indexAs] = true;
		if (!this.ctor) this.templatize(this)
	},
	_sortChanged: function(sort) {
		var dataHost = this._getRootDataHost();
		this._sortFn = sort && (typeof sort == "function" ? sort : function() {
			return dataHost[sort].apply(dataHost, arguments)
		});
		this._needFullRefresh = true;
		if (this.items) this._debounceTemplate(this._render)
	},
	_filterChanged: function(filter) {
		var dataHost = this._getRootDataHost();
		this._filterFn =
			filter && (typeof filter == "function" ? filter : function() {
				return dataHost[filter].apply(dataHost, arguments)
			});
		this._needFullRefresh = true;
		if (this.items) this._debounceTemplate(this._render)
	},
	_computeFrameTime: function(rate) {
		return Math.ceil(1E3 / rate)
	},
	_initializeChunking: function() {
		if (this.initialCount) {
			this._limit = this.initialCount;
			this._chunkCount = this.initialCount;
			this._lastChunkTime = performance.now()
		}
	},
	_tryRenderChunk: function() {
		if (this.items && this._limit < this.items.length) this.debounce("renderChunk",
			this._requestRenderChunk)
	},
	_requestRenderChunk: function() {
		requestAnimationFrame(this._boundRenderChunk)
	},
	_renderChunk: function() {
		var currChunkTime = performance.now();
		var ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);
		this._chunkCount = Math.round(this._chunkCount * ratio) || 1;
		this._limit += this._chunkCount;
		this._lastChunkTime = currChunkTime;
		this._debounceTemplate(this._render)
	},
	_observeChanged: function() {
		this._observePaths = this.observe && this.observe.replace(".*", ".").split(" ")
	},
	_itemsChanged: function(change) {
		if (change.path ==
			"items") {
			if (Array.isArray(this.items)) this.collection = Polymer.Collection.get(this.items);
			else if (!this.items) this.collection = null;
			else this._error(this._logf("dom-repeat", "expected array for `items`," + " found", this.items));
			this._keySplices = [];
			this._indexSplices = [];
			this._needFullRefresh = true;
			this._initializeChunking();
			this._debounceTemplate(this._render)
		} else if (change.path == "items.splices") {
			this._keySplices = this._keySplices.concat(change.value.keySplices);
			this._indexSplices = this._indexSplices.concat(change.value.indexSplices);
			this._debounceTemplate(this._render)
		} else {
			var subpath = change.path.slice(6);
			this._forwardItemPath(subpath, change.value);
			this._checkObservedPaths(subpath)
		}
	},
	_checkObservedPaths: function(path) {
		if (this._observePaths) {
			path = path.substring(path.indexOf(".") + 1);
			var paths = this._observePaths;
			for (var i = 0; i < paths.length; i++)
				if (path.indexOf(paths[i]) === 0) {
					this._needFullRefresh = true;
					if (this.delay) this.debounce("render", this._render, this.delay);
					else this._debounceTemplate(this._render);
					return
				}
		}
	},
	render: function() {
		this._needFullRefresh =
			true;
		this._debounceTemplate(this._render);
		this._flushTemplates()
	},
	_render: function() {
		if (this._needFullRefresh) {
			this._applyFullRefresh();
			this._needFullRefresh = false
		} else if (this._keySplices.length)
			if (this._sortFn) this._applySplicesUserSort(this._keySplices);
			else if (this._filterFn) this._applyFullRefresh();
		else this._applySplicesArrayOrder(this._indexSplices);
		else;
		this._keySplices = [];
		this._indexSplices = [];
		var keyToIdx = this._keyToInstIdx = {};
		for (var i = this._instances.length - 1; i >= 0; i--) {
			var inst = this._instances[i];
			if (inst.isPlaceholder && i < this._limit) inst = this._insertInstance(i, inst.__key__);
			else if (!inst.isPlaceholder && i >= this._limit) inst = this._downgradeInstance(i, inst.__key__);
			keyToIdx[inst.__key__] = i;
			if (!inst.isPlaceholder) inst.__setProperty(this.indexAs, i, true)
		}
		this._pool.length = 0;
		this._setRenderedItemCount(this._instances.length);
		this.fire("dom-change");
		this._tryRenderChunk()
	},
	_applyFullRefresh: function() {
		var c = this.collection;
		var keys;
		if (this._sortFn) keys = c ? c.getKeys() : [];
		else {
			keys = [];
			var items = this.items;
			if (items)
				for (var i = 0; i < items.length; i++) keys.push(c.getKey(items[i]))
		}
		var self = this;
		if (this._filterFn) keys = keys.filter(function(a) {
			return self._filterFn(c.getItem(a))
		});
		if (this._sortFn) keys.sort(function(a, b) {
			return self._sortFn(c.getItem(a), c.getItem(b))
		});
		for (i = 0; i < keys.length; i++) {
			var key = keys[i];
			var inst = this._instances[i];
			if (inst) {
				inst.__key__ = key;
				if (!inst.isPlaceholder && i < this._limit) inst.__setProperty(this.as, c.getItem(key), true)
			} else if (i < this._limit) this._insertInstance(i, key);
			else this._insertPlaceholder(i,
				key)
		}
		for (var j = this._instances.length - 1; j >= i; j--) this._detachAndRemoveInstance(j)
	},
	_numericSort: function(a, b) {
		return a - b
	},
	_applySplicesUserSort: function(splices) {
		var c = this.collection;
		var keyMap = {};
		var key;
		for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
			for (var j = 0; j < s.removed.length; j++) {
				key = s.removed[j];
				keyMap[key] = keyMap[key] ? null : -1
			}
			for (j = 0; j < s.added.length; j++) {
				key = s.added[j];
				keyMap[key] = keyMap[key] ? null : 1
			}
		}
		var removedIdxs = [];
		var addedKeys = [];
		for (key in keyMap) {
			if (keyMap[key] === -1) removedIdxs.push(this._keyToInstIdx[key]);
			if (keyMap[key] === 1) addedKeys.push(key)
		}
		if (removedIdxs.length) {
			removedIdxs.sort(this._numericSort);
			for (i = removedIdxs.length - 1; i >= 0; i--) {
				var idx = removedIdxs[i];
				if (idx !== undefined) this._detachAndRemoveInstance(idx)
			}
		}
		var self = this;
		if (addedKeys.length) {
			if (this._filterFn) addedKeys = addedKeys.filter(function(a) {
				return self._filterFn(c.getItem(a))
			});
			addedKeys.sort(function(a, b) {
				return self._sortFn(c.getItem(a), c.getItem(b))
			});
			var start = 0;
			for (i = 0; i < addedKeys.length; i++) start = this._insertRowUserSort(start, addedKeys[i])
		}
	},
	_insertRowUserSort: function(start, key) {
		var c = this.collection;
		var item = c.getItem(key);
		var end = this._instances.length - 1;
		var idx = -1;
		while (start <= end) {
			var mid = start + end >> 1;
			var midKey = this._instances[mid].__key__;
			var cmp = this._sortFn(c.getItem(midKey), item);
			if (cmp < 0) start = mid + 1;
			else if (cmp > 0) end = mid - 1;
			else {
				idx = mid;
				break
			}
		}
		if (idx < 0) idx = end + 1;
		this._insertPlaceholder(idx, key);
		return idx
	},
	_applySplicesArrayOrder: function(splices) {
		for (var i = 0, s; i < splices.length && (s = splices[i]); i++) {
			for (var j = 0; j < s.removed.length; j++) this._detachAndRemoveInstance(s.index);
			for (j = 0; j < s.addedKeys.length; j++) this._insertPlaceholder(s.index + j, s.addedKeys[j])
		}
	},
	_detachInstance: function(idx) {
		var inst = this._instances[idx];
		if (!inst.isPlaceholder) {
			for (var i = 0; i < inst._children.length; i++) {
				var el = inst._children[i];
				Polymer.dom(inst.root).appendChild(el)
			}
			return inst
		}
	},
	_attachInstance: function(idx, parent) {
		var inst = this._instances[idx];
		if (!inst.isPlaceholder) parent.insertBefore(inst.root, this)
	},
	_detachAndRemoveInstance: function(idx) {
		var inst = this._detachInstance(idx);
		if (inst) this._pool.push(inst);
		this._instances.splice(idx, 1)
	},
	_insertPlaceholder: function(idx, key) {
		this._instances.splice(idx, 0, {
			isPlaceholder: true,
			__key__: key
		})
	},
	_stampInstance: function(idx, key) {
		var model = {
			__key__: key
		};
		model[this.as] = this.collection.getItem(key);
		model[this.indexAs] = idx;
		return this.stamp(model)
	},
	_insertInstance: function(idx, key) {
		var inst = this._pool.pop();
		if (inst) {
			inst.__setProperty(this.as, this.collection.getItem(key), true);
			inst.__setProperty("__key__", key, true)
		} else inst = this._stampInstance(idx, key);
		var beforeRow =
			this._instances[idx + 1];
		var beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;
		var parentNode = Polymer.dom(this).parentNode;
		Polymer.dom(parentNode).insertBefore(inst.root, beforeNode);
		this._instances[idx] = inst;
		return inst
	},
	_downgradeInstance: function(idx, key) {
		var inst = this._detachInstance(idx);
		if (inst) this._pool.push(inst);
		inst = {
			isPlaceholder: true,
			__key__: key
		};
		this._instances[idx] = inst;
		return inst
	},
	_showHideChildren: function(hidden) {
		for (var i = 0; i < this._instances.length; i++) this._instances[i]._showHideChildren(hidden)
	},
	_forwardInstanceProp: function(inst, prop, value) {
		if (prop == this.as) {
			var idx;
			if (this._sortFn || this._filterFn) idx = this.items.indexOf(this.collection.getItem(inst.__key__));
			else idx = inst[this.indexAs];
			this.set("items." + idx, value)
		}
	},
	_forwardInstancePath: function(inst, path, value) {
		if (path.indexOf(this.as + ".") === 0) this._notifyPath("items." + inst.__key__ + "." + path.slice(this.as.length + 1), value)
	},
	_forwardParentProp: function(prop, value) {
		var i$ = this._instances;
		for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++)
			if (!inst.isPlaceholder) inst.__setProperty(prop,
				value, true)
	},
	_forwardParentPath: function(path, value) {
		var i$ = this._instances;
		for (var i = 0, inst; i < i$.length && (inst = i$[i]); i++)
			if (!inst.isPlaceholder) inst._notifyPath(path, value, true)
	},
	_forwardItemPath: function(path, value) {
		if (this._keyToInstIdx) {
			var dot = path.indexOf(".");
			var key = path.substring(0, dot < 0 ? path.length : dot);
			var idx = this._keyToInstIdx[key];
			var inst = this._instances[idx];
			if (inst && !inst.isPlaceholder)
				if (dot >= 0) {
					path = this.as + "." + path.substring(dot + 1);
					inst._notifyPath(path, value, true)
				} else inst.__setProperty(this.as,
					value, true)
		}
	},
	itemForElement: function(el) {
		var instance = this.modelForElement(el);
		return instance && instance[this.as]
	},
	keyForElement: function(el) {
		var instance = this.modelForElement(el);
		return instance && instance.__key__
	},
	indexForElement: function(el) {
		var instance = this.modelForElement(el);
		return instance && instance[this.indexAs]
	}
});
Polymer({
	is: "array-selector",
	_template: null,
	properties: {
		items: {
			type: Array,
			observer: "clearSelection"
		},
		multi: {
			type: Boolean,
			value: false,
			observer: "clearSelection"
		},
		selected: {
			type: Object,
			notify: true
		},
		selectedItem: {
			type: Object,
			notify: true
		},
		toggle: {
			type: Boolean,
			value: false
		}
	},
	clearSelection: function() {
		if (Array.isArray(this.selected))
			for (var i = 0; i < this.selected.length; i++) this.unlinkPaths("selected." + i);
		else {
			this.unlinkPaths("selected");
			this.unlinkPaths("selectedItem")
		}
		if (this.multi) {
			if (!this.selected || this.selected.length) {
				this.selected = [];
				this._selectedColl = Polymer.Collection.get(this.selected)
			}
		} else {
			this.selected = null;
			this._selectedColl = null
		}
		this.selectedItem = null
	},
	isSelected: function(item) {
		if (this.multi) return this._selectedColl.getKey(item) !== undefined;
		else return this.selected == item
	},
	deselect: function(item) {
		if (this.multi) {
			if (this.isSelected(item)) {
				var skey = this._selectedColl.getKey(item);
				this.arrayDelete("selected", item);
				this.unlinkPaths("selected." + skey)
			}
		} else {
			this.selected = null;
			this.selectedItem = null;
			this.unlinkPaths("selected");
			this.unlinkPaths("selectedItem")
		}
	},
	select: function(item) {
		var icol = Polymer.Collection.get(this.items);
		var key = icol.getKey(item);
		if (this.multi)
			if (this.isSelected(item)) {
				if (this.toggle) this.deselect(item)
			} else {
				this.push("selected", item);
				var skey = this._selectedColl.getKey(item);
				this.linkPaths("selected." + skey, "items." + key)
			}
		else if (this.toggle && item == this.selected) this.deselect();
		else {
			this.selected = item;
			this.selectedItem = item;
			this.linkPaths("selected", "items." + key);
			this.linkPaths("selectedItem", "items." +
				key)
		}
	}
});
Polymer({
	is: "dom-if",
	"extends": "template",
	_template: null,
	properties: {
		"if": {
			type: Boolean,
			value: false,
			observer: "_queueRender"
		},
		restamp: {
			type: Boolean,
			value: false,
			observer: "_queueRender"
		}
	},
	behaviors: [Polymer.Templatizer],
	_queueRender: function() {
		this._debounceTemplate(this._render)
	},
	detached: function() {
		if (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(this.parentNode instanceof ShadowRoot))) this._teardownInstance()
	},
	attached: function() {
		if (this["if"] && this.ctor) this.async(this._ensureInstance)
	},
	render: function() {
		this._flushTemplates()
	},
	_render: function() {
		if (this["if"]) {
			if (!this.ctor) this.templatize(this);
			this._ensureInstance();
			this._showHideChildren()
		} else if (this.restamp) this._teardownInstance();
		if (!this.restamp && this._instance) this._showHideChildren();
		if (this["if"] != this._lastIf) {
			this.fire("dom-change");
			this._lastIf = this["if"]
		}
	},
	_ensureInstance: function() {
		var parentNode = Polymer.dom(this).parentNode;
		if (parentNode) {
			var parent = Polymer.dom(parentNode);
			if (!this._instance) {
				this._instance = this.stamp();
				var root = this._instance.root;
				parent.insertBefore(root, this)
			} else {
				var c$ = this._instance._children;
				if (c$ && c$.length) {
					var lastChild = Polymer.dom(this).previousSibling;
					if (lastChild !== c$[c$.length - 1])
						for (var i = 0, n; i < c$.length && (n = c$[i]); i++) parent.insertBefore(n, this)
				}
			}
		}
	},
	_teardownInstance: function() {
		if (this._instance) {
			var c$ = this._instance._children;
			if (c$ && c$.length) {
				var parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);
				for (var i = 0, n; i < c$.length && (n = c$[i]); i++) parent.removeChild(n)
			}
			this._instance = null
		}
	},
	_showHideChildren: function() {
		var hidden = this.__hideTemplateChildren__ || !this["if"];
		if (this._instance) this._instance._showHideChildren(hidden)
	},
	_forwardParentProp: function(prop, value) {
		if (this._instance) this._instance.__setProperty(prop, value, true)
	},
	_forwardParentPath: function(path, value) {
		if (this._instance) this._instance._notifyPath(path, value, true)
	}
});
Polymer({
	is: "dom-bind",
	"extends": "template",
	_template: null,
	created: function() {
		var self = this;
		Polymer.RenderStatus.whenReady(function() {
			if (document.readyState == "loading") document.addEventListener("DOMContentLoaded", function() {
				self._markImportsReady()
			});
			else self._markImportsReady()
		})
	},
	_ensureReady: function() {
		if (!this._readied) this._readySelf()
	},
	_markImportsReady: function() {
		this._importsReady = true;
		this._ensureReady()
	},
	_registerFeatures: function() {
		this._prepConstructor()
	},
	_insertChildren: function() {
		var parentDom =
			Polymer.dom(Polymer.dom(this).parentNode);
		parentDom.insertBefore(this.root, this)
	},
	_removeChildren: function() {
		if (this._children)
			for (var i = 0; i < this._children.length; i++) this.root.appendChild(this._children[i])
	},
	_initFeatures: function() {},
	_scopeElementClass: function(element, selector) {
		if (this.dataHost) return this.dataHost._scopeElementClass(element, selector);
		else return selector
	},
	_configureInstanceProperties: function() {},
	_prepConfigure: function() {
		var config = {};
		for (var prop in this._propertyEffects) config[prop] =
			this[prop];
		var setupConfigure = this._setupConfigure;
		this._setupConfigure = function() {
			setupConfigure.call(this, config)
		}
	},
	attached: function() {
		if (this._importsReady) this.render()
	},
	detached: function() {
		this._removeChildren()
	},
	render: function() {
		this._ensureReady();
		if (!this._children) {
			this._template = this;
			this._prepAnnotations();
			this._prepEffects();
			this._prepBehaviors();
			this._prepConfigure();
			this._prepBindings();
			this._prepPropertyInfo();
			Polymer.Base._initFeatures.call(this);
			this._children = Polymer.TreeApi.arrayCopyChildNodes(this.root)
		}
		this._insertChildren();
		this.fire("dom-change")
	}
});
var q, F = {
	scope: {}
};
F.defineProperty = "function" == typeof Object.defineProperties ? Object.defineProperty : function(a, b, c) {
	if (c.get || c.set) throw new TypeError("ES3 does not support getters and setters.");
	a != Array.prototype && a != Object.prototype && (a[b] = c.value)
};
F.getGlobal = function(a) {
	return "undefined" != typeof window && window === a ? a : "undefined" != typeof global && null != global ? global : a
};
F.global = F.getGlobal(this);
F.SYMBOL_PREFIX = "jscomp_symbol_";
F.initSymbol = function() {
	F.initSymbol = function() {};
	F.global.Symbol || (F.global.Symbol = F.Symbol)
};
F.symbolCounter_ = 0;
F.Symbol = function(a) {
	return F.SYMBOL_PREFIX + (a || "") + F.symbolCounter_++
};
F.initSymbolIterator = function() {
	F.initSymbol();
	var a = F.global.Symbol.iterator;
	a || (a = F.global.Symbol.iterator = F.global.Symbol("iterator"));
	"function" != typeof Array.prototype[a] && F.defineProperty(Array.prototype, a, {
		configurable: !0,
		writable: !0,
		value: function() {
			return F.arrayIterator(this)
		}
	});
	F.initSymbolIterator = function() {}
};
F.arrayIterator = function(a) {
	var b = 0;
	return F.iteratorPrototype(function() {
		return b < a.length ? {
			done: !1,
			value: a[b++]
		} : {
			done: !0
		}
	})
};
F.iteratorPrototype = function(a) {
	F.initSymbolIterator();
	a = {
		next: a
	};
	a[F.global.Symbol.iterator] = function() {
		return this
	};
	return a
};
F.makeIterator = function(a) {
	F.initSymbolIterator();
	var b = a[Symbol.iterator];
	return b ? b.call(a) : F.arrayIterator(a)
};
F.arrayFromIterator = function(a) {
	for (var b, c = []; !(b = a.next()).done;) c.push(b.value);
	return c
};
F.arrayFromIterable = function(a) {
	return a instanceof Array ? a : F.arrayFromIterator(F.makeIterator(a))
};
F.inherits = function(a, b) {
	function c() {}
	c.prototype = b.prototype;
	a.prototype = new c;
	a.prototype.constructor = a;
	for (var d in b)
		if (Object.defineProperties) {
			var e = Object.getOwnPropertyDescriptor(b, d);
			e && Object.defineProperty(a, d, e)
		} else a[d] = b[d]
};
F.array = F.array || {};
F.iteratorFromArray = function(a, b) {
	F.initSymbolIterator();
	a instanceof String && (a += "");
	var c = 0,
		d = {
			next: function() {
				if (c < a.length) {
					var e = c++;
					return {
						value: b(e, a[e]),
						done: !1
					}
				}
				d.next = function() {
					return {
						done: !0,
						value: void 0
					}
				};
				return d.next()
			}
		};
	d[Symbol.iterator] = function() {
		return d
	};
	return d
};
F.polyfill = function(a, b, c, d) {
	if (b) {
		c = F.global;
		a = a.split(".");
		for (d = 0; d < a.length - 1; d++) {
			var e = a[d];
			e in c || (c[e] = {});
			c = c[e]
		}
		a = a[a.length - 1];
		d = c[a];
		b = b(d);
		b != d && null != b && F.defineProperty(c, a, {
			configurable: !0,
			writable: !0,
			value: b
		})
	}
};
F.polyfill("Array.prototype.keys", function(a) {
	return a ? a : a = function() {
		return F.iteratorFromArray(this, function(a) {
			return a
		})
	}
}, "es6-impl", "es3");
F.polyfill("Array.prototype.fill", function(a) {
	return a ? a : a = function(a, c, d) {
		var b = this.length || 0;
		0 > c && (c = Math.max(0, b + c));
		if (null == d || d > b) d = b;
		d = Number(d);
		0 > d && (d = Math.max(0, b + d));
		for (c = Number(c || 0); c < d; c++) this[c] = a;
		return this
	}
}, "es6-impl", "es3");
F.polyfill("Array.from", function(a) {
	return a ? a : a = function(a, c, d) {
		F.initSymbolIterator();
		c = null != c ? c : function(a) {
			return a
		};
		var b = [],
			f = a[Symbol.iterator];
		if ("function" == typeof f)
			for (a = f.call(a); !(f = a.next()).done;) b.push(c.call(d, f.value));
		else
			for (var f = a.length, g = 0; g < f; g++) b.push(c.call(d, a[g]));
		return b
	}
}, "es6-impl", "es3");
F.EXPOSE_ASYNC_EXECUTOR = !0;
F.FORCE_POLYFILL_PROMISE = !1;
F.polyfill("Promise", function(a) {
	function b() {
		this.batch_ = null
	}
	if (a && !F.FORCE_POLYFILL_PROMISE) return a;
	b.prototype.asyncExecute = function(a) {
		null == this.batch_ && (this.batch_ = [], this.asyncExecuteBatch_());
		this.batch_.push(a);
		return this
	};
	b.prototype.asyncExecuteBatch_ = function() {
		var a = this;
		this.asyncExecuteFunction(function() {
			a.executeBatch_()
		})
	};
	var c = F.global.setTimeout;
	b.prototype.asyncExecuteFunction = function(a) {
		c(a, 0)
	};
	b.prototype.executeBatch_ = function() {
		for (; this.batch_ && this.batch_.length;) {
			var a =
				this.batch_;
			this.batch_ = [];
			for (var b = 0; b < a.length; ++b) {
				var c = a[b];
				delete a[b];
				try {
					c()
				} catch (l) {
					this.asyncThrow_(l)
				}
			}
		}
		this.batch_ = null
	};
	b.prototype.asyncThrow_ = function(a) {
		this.asyncExecuteFunction(function() {
			throw a;
		})
	};
	var d = {
			PENDING: 0,
			FULFILLED: 1,
			REJECTED: 2
		},
		e = function(a) {
			this.state_ = d.PENDING;
			this.result_ = void 0;
			this.onSettledCallbacks_ = [];
			var b = this.createResolveAndReject_();
			try {
				a(b.resolve, b.reject)
			} catch (k) {
				b.reject(k)
			}
		};
	e.prototype.createResolveAndReject_ = function() {
		function a(a) {
			return function(d) {
				c ||
					(c = !0, a.call(b, d))
			}
		}
		var b = this,
			c = !1;
		return {
			resolve: a(this.resolveTo_),
			reject: a(this.reject_)
		}
	};
	e.prototype.resolveTo_ = function(a) {
		if (a === this) this.reject_(new TypeError("A Promise cannot resolve to itself"));
		else if (a instanceof e) this.settleSameAsPromise_(a);
		else {
			var b;
			a: {
				switch (typeof a) {
					case "object":
						b = null != a;
						break a;
					case "function":
						b = !0;
						break a;
					default:
						b = !1;
						break a
				}
				b = void 0
			}
			b ? this.resolveToNonPromiseObj_(a) : this.fulfill_(a)
		}
	};
	e.prototype.resolveToNonPromiseObj_ = function(a) {
		var b = void 0;
		try {
			b =
				a.then
		} catch (k) {
			this.reject_(k);
			return
		}
		"function" == typeof b ? this.settleSameAsThenable_(b, a) : this.fulfill_(a)
	};
	e.prototype.reject_ = function(a) {
		this.settle_(d.REJECTED, a)
	};
	e.prototype.fulfill_ = function(a) {
		this.settle_(d.FULFILLED, a)
	};
	e.prototype.settle_ = function(a, b) {
		if (this.state_ != d.PENDING) throw Error("Cannot settle(" + a + ", " + b | "): Promise already settled in state" + this.state_);
		this.state_ = a;
		this.result_ = b;
		this.executeOnSettledCallbacks_()
	};
	e.prototype.executeOnSettledCallbacks_ = function() {
		if (null !=
			this.onSettledCallbacks_) {
			for (var a = this.onSettledCallbacks_, b = 0; b < a.length; ++b) a[b].call(), a[b] = null;
			this.onSettledCallbacks_ = null
		}
	};
	var f = new b;
	e.prototype.settleSameAsPromise_ = function(a) {
		var b = this.createResolveAndReject_();
		a.callWhenSettled_(b.resolve, b.reject)
	};
	e.prototype.settleSameAsThenable_ = function(a, b) {
		var c = this.createResolveAndReject_();
		try {
			a.call(b, c.resolve, c.reject)
		} catch (l) {
			c.reject(l)
		}
	};
	e.prototype.then = function(a, b) {
		function c(a, b) {
			return "function" == typeof a ? function(b) {
					try {
						d(a(b))
					} catch (w) {
						f(w)
					}
				} :
				b
		}
		var d, f, g = new e(function(a, b) {
			d = a;
			f = b
		});
		this.callWhenSettled_(c(a, d), c(b, f));
		return g
	};
	e.prototype.catch = function(a) {
		return this.then(void 0, a)
	};
	e.prototype.callWhenSettled_ = function(a, b) {
		function c() {
			switch (e.state_) {
				case d.FULFILLED:
					a(e.result_);
					break;
				case d.REJECTED:
					b(e.result_);
					break;
				default:
					throw Error("Unexpected state: " + e.state_);
			}
		}
		var e = this;
		null == this.onSettledCallbacks_ ? f.asyncExecute(c) : this.onSettledCallbacks_.push(function() {
			f.asyncExecute(c)
		})
	};
	e.resolve = function(a) {
		return a instanceof
		e ? a : new e(function(b, c) {
			b(a)
		})
	};
	e.reject = function(a) {
		return new e(function(b, c) {
			c(a)
		})
	};
	e.race = function(a) {
		return new e(function(b, c) {
			for (var d = F.makeIterator(a), f = d.next(); !f.done; f = d.next()) e.resolve(f.value).callWhenSettled_(b, c)
		})
	};
	e.all = function(a) {
		var b = F.makeIterator(a),
			c = b.next();
		return c.done ? e.resolve([]) : new e(function(a, d) {
			function f(b) {
				return function(c) {
					g[b] = c;
					h--;
					0 == h && a(g)
				}
			}
			var g = [],
				h = 0;
			do g.push(void 0), h++, e.resolve(c.value).callWhenSettled_(f(g.length - 1), d), c = b.next(); while (!c.done)
		})
	};
	F.EXPOSE_ASYNC_EXECUTOR && (e.$jscomp$new$AsyncExecutor = function() {
		return new b
	});
	return e
}, "es6-impl", "es3");
F.polyfill("Math.sign", function(a) {
	return a ? a : a = function(a) {
		a = Number(a);
		return 0 === a || isNaN(a) ? a : 0 < a ? 1 : -1
	}
}, "es6-impl", "es3");
F.polyfill("Array.prototype.values", function(a) {
	return a ? a : a = function() {
		return F.iteratorFromArray(this, function(a, c) {
			return c
		})
	}
}, "es6", "es3");
F.polyfill("Array.prototype.entries", function(a) {
	return a ? a : a = function() {
		return F.iteratorFromArray(this, function(a, c) {
			return [a, c]
		})
	}
}, "es6-impl", "es3");
F.findInternal = function(a, b, c) {
	a instanceof String && (a = String(a));
	for (var d = a.length, e = 0; e < d; e++) {
		var f = a[e];
		if (b.call(c, f, e, a)) return {
			i: e,
			v: f
		}
	}
	return {
		i: -1,
		v: void 0
	}
};
F.polyfill("Array.prototype.find", function(a) {
	return a ? a : a = function(a, c) {
		return F.findInternal(this, a, c).v
	}
}, "es6-impl", "es3");
F.polyfill("Number.EPSILON", function(a) {
	return Math.pow(2, -52)
}, "es6-impl", "es3");
F.owns = function(a, b) {
	return Object.prototype.hasOwnProperty.call(a, b)
};
F.polyfill("Object.assign", function(a) {
	return a ? a : a = function(a, c) {
		for (var b = 1; b < arguments.length; b++) {
			var e = arguments[b];
			if (e)
				for (var f in e) F.owns(e, f) && (a[f] = e[f])
		}
		return a
	}
}, "es6-impl", "es3");
F.checkStringArgs = function(a, b, c) {
	if (null == a) throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined");
	if (b instanceof RegExp) throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression");
	return a + ""
};
F.polyfill("String.prototype.repeat", function(a) {
	return a ? a : a = function(a) {
		var b = F.checkStringArgs(this, null, "repeat");
		if (0 > a || 1342177279 < a) throw new RangeError("Invalid count value");
		a |= 0;
		for (var d = ""; a;)
			if (a & 1 && (d += b), a >>>= 1) b += b;
		return d
	}
}, "es6-impl", "es3");
var N = N || {};
N.global = this;
N.isDef = function(a) {
	return void 0 !== a
};
N.exportPath_ = function(a, b, c) {
	a = a.split(".");
	c = c || N.global;
	a[0] in c || !c.execScript || c.execScript("var " + a[0]);
	for (var d; a.length && (d = a.shift());) !a.length && N.isDef(b) ? c[d] = b : c = c[d] ? c[d] : c[d] = {}
};
N.define = function(a, b) {
	N.exportPath_(a, b)
};
N.DEBUG = !0;
N.LOCALE = "en";
N.TRUSTED_SITE = !0;
N.STRICT_MODE_COMPATIBLE = !1;
N.DISALLOW_TEST_ONLY_CODE = !N.DEBUG;
N.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = !1;
N.provide = function(a) {
	if (N.isInModuleLoader_()) throw Error("goog.provide can not be used within a goog.module.");
	N.constructNamespace_(a)
};
N.constructNamespace_ = function(a, b) {
	N.exportPath_(a, b)
};
N.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
N.module = function(a) {
	if (!N.isString(a) || !a || -1 == a.search(N.VALID_MODULE_RE_)) throw Error("Invalid module identifier");
	if (!N.isInModuleLoader_()) throw Error("Module " + a + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
	if (N.moduleLoaderState_.moduleName) throw Error("goog.module may only be called once per module.");
	N.moduleLoaderState_.moduleName = a
};
N.module.get = function(a) {
	return N.module.getInternal_(a)
};
N.module.getInternal_ = function(a) {
	return null
};
N.moduleLoaderState_ = null;
N.isInModuleLoader_ = function() {
	return null != N.moduleLoaderState_
};
N.module.declareLegacyNamespace = function() {
	N.moduleLoaderState_.declareLegacyNamespace = !0
};
N.setTestOnly = function(a) {
	if (N.DISALLOW_TEST_ONLY_CODE) throw a = a || "", Error("Importing test-only code into non-debug environment" + (a ? ": " + a : "."));
};
N.forwardDeclare = function(a) {};
N.getObjectByName = function(a, b) {
	a = a.split(".");
	b = b || N.global;
	for (var c; c = a.shift();)
		if (N.isDefAndNotNull(b[c])) b = b[c];
		else return null;
	return b
};
N.globalize = function(a, b) {
	b = b || N.global;
	for (var c in a) b[c] = a[c]
};
N.addDependency = function(a, b, c, d) {
	if (N.DEPENDENCIES_ENABLED) {
		var e;
		a = a.replace(/\\/g, "/");
		var f = N.dependencies_;
		d && "boolean" !== typeof d || (d = d ? {
			module: "goog"
		} : {});
		for (var g = 0; e = b[g]; g++) f.nameToPath[e] = a, f.loadFlags[a] = d;
		for (d = 0; b = c[d]; d++) a in f.requires || (f.requires[a] = {}), f.requires[a][b] = !0
	}
};
N.useStrictRequires = !1;
N.ENABLE_DEBUG_LOADER = !0;
N.logToConsole_ = function(a) {
	N.global.console && N.global.console.error(a)
};
N.require = function(a) {};
N.basePath = "";
N.nullFunction = function() {};
N.abstractMethod = function() {
	throw Error("unimplemented abstract method");
};
N.addSingletonGetter = function(a) {
	a.getInstance = function() {
		if (a.instance_) return a.instance_;
		N.DEBUG && (N.instantiatedSingletons_[N.instantiatedSingletons_.length] = a);
		return a.instance_ = new a
	}
};
N.instantiatedSingletons_ = [];
N.LOAD_MODULE_USING_EVAL = !0;
N.SEAL_MODULE_EXPORTS = N.DEBUG;
N.loadedModules_ = {};
N.DEPENDENCIES_ENABLED = !1;
N.TRANSPILE = "detect";
N.TRANSPILER = "transpile.js";
N.DEPENDENCIES_ENABLED && (N.dependencies_ = {
		loadFlags: {},
		nameToPath: {},
		requires: {},
		visited: {},
		written: {},
		deferred: {}
	}, N.inHtmlDocument_ = function() {
		var a = N.global.document;
		return null != a && "write" in a
	}, N.findBasePath_ = function() {
		if (N.isDef(N.global.CLOSURE_BASE_PATH)) N.basePath = N.global.CLOSURE_BASE_PATH;
		else if (N.inHtmlDocument_())
			for (var a = N.global.document, a = a.getElementsByTagName("SCRIPT"), b = a.length - 1; 0 <= b; --b) {
				var c = a[b],
					c = c.src,
					d = c.lastIndexOf("?"),
					d = -1 == d ? c.length : d;
				if ("base.js" == c.substr(d - 7,
						7)) {
					N.basePath = c.substr(0, d - 7);
					break
				}
			}
	}, N.importScript_ = function(a, b) {
		var c = N.global.CLOSURE_IMPORT_SCRIPT || N.writeScriptTag_;
		c(a, b) && (N.dependencies_.written[a] = !0)
	}, N.IS_OLD_IE_ = !(N.global.atob || !N.global.document || !N.global.document.all), N.importProcessedScript_ = function(a, b, c) {
		a = 'goog.retrieveAndExec_("' + a + '", ' + b + ", " + c + ");";
		N.importScript_("", a)
	}, N.queuedModules_ = [], N.wrapModule_ = function(a, b) {
		return N.LOAD_MODULE_USING_EVAL && N.isDef(N.global.JSON) ? "goog.loadModule(" + N.global.JSON.stringify(b +
			"\n//# sourceURL=" + a + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + b + "\n;return exports});\n//# sourceURL=" + a + "\n"
	}, N.loadQueuedModules_ = function() {
		var a = N.queuedModules_.length;
		if (0 < a) {
			var b = N.queuedModules_;
			N.queuedModules_ = [];
			for (var c = 0; c < a; c++) {
				var d = b[c];
				N.maybeProcessDeferredPath_(d)
			}
		}
	}, N.maybeProcessDeferredDep_ = function(a) {
		N.isDeferredModule_(a) && N.allDepsAreAvailable_(a) && (a = N.getPathFromDeps_(a), N.maybeProcessDeferredPath_(N.basePath + a))
	}, N.isDeferredModule_ = function(a) {
		var b =
			(a = N.getPathFromDeps_(a)) && N.dependencies_.loadFlags[a] || {},
			c = b.lang || "es3";
		return a && ("goog" == b.module || N.needsTranspile_(c)) ? (a = N.basePath + a, a in N.dependencies_.deferred) : !1
	}, N.allDepsAreAvailable_ = function(a) {
		if ((a = N.getPathFromDeps_(a)) && a in N.dependencies_.requires)
			for (var b in N.dependencies_.requires[a])
				if (!N.isProvided_(b) && !N.isDeferredModule_(b)) return !1;
		return !0
	}, N.maybeProcessDeferredPath_ = function(a) {
		if (a in N.dependencies_.deferred) {
			var b = N.dependencies_.deferred[a];
			delete N.dependencies_.deferred[a];
			N.globalEval(b)
		}
	}, N.loadModuleFromUrl = function(a) {
		N.retrieveAndExec_(a, !0, !1)
	}, N.writeScriptSrcNode_ = function(a) {
		N.global.document.write('<script type="text/javascript" src="' + a + '">\x3c/script>')
	}, N.appendScriptSrcNode_ = function(a) {
		var b = N.global.document,
			c = b.createElement("script");
		c.type = "text/javascript";
		c.src = a;
		c.defer = !1;
		c.async = !1;
		b.head.appendChild(c)
	}, N.writeScriptTag_ = function(a, b) {
		if (N.inHtmlDocument_()) {
			var c = N.global.document;
			if (!N.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && "complete" == c.readyState) {
				if (c =
					/\bdeps.js$/.test(a)) return !1;
				throw Error('Cannot write "' + a + '" after document load');
			}
			void 0 === b ? N.IS_OLD_IE_ ? (b = " onreadystatechange='goog.onScriptLoad_(this, " + ++N.lastNonModuleScriptIndex_ + ")' ", c.write('<script type="text/javascript" src="' + a + '"' + b + ">\x3c/script>")) : N.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING ? N.appendScriptSrcNode_(a) : N.writeScriptSrcNode_(a) : c.write('<script type="text/javascript">' + N.protectScriptTag_(b) + "\x3c/script>");
			return !0
		}
		return !1
	}, N.protectScriptTag_ = function(a) {
		return a.replace(/<\/(SCRIPT)/ig,
			"\\x3c\\$1")
	}, N.needsTranspile_ = function(a) {
		if ("always" == N.TRANSPILE) return !0;
		if ("never" == N.TRANSPILE) return !1;
		N.requiresTranspilation_ || (N.requiresTranspilation_ = N.createRequiresTranspilation_());
		if (a in N.requiresTranspilation_) return N.requiresTranspilation_[a];
		throw Error("Unknown language mode: " + a);
	}, N.requiresTranspilation_ = null, N.lastNonModuleScriptIndex_ = 0, N.onScriptLoad_ = function(a, b) {
		"complete" == a.readyState && N.lastNonModuleScriptIndex_ == b && N.loadQueuedModules_();
		return !0
	}, N.writeScripts_ =
	function(a) {
		function b(a) {
			if (!(a in e.written || a in e.visited)) {
				e.visited[a] = !0;
				if (a in e.requires)
					for (var f in e.requires[a])
						if (!N.isProvided_(f))
							if (f in e.nameToPath) b(e.nameToPath[f]);
							else throw Error("Undefined nameToPath for " + f);
				a in d || (d[a] = !0, c.push(a))
			}
		}
		var c = [],
			d = {},
			e = N.dependencies_;
		b(a);
		for (a = 0; a < c.length; a++) {
			var f = c[a];
			N.dependencies_.written[f] = !0
		}
		var g = N.moduleLoaderState_;
		N.moduleLoaderState_ = null;
		for (a = 0; a < c.length; a++)
			if (f = c[a]) {
				var h = e.loadFlags[f] || {},
					k = h.lang || "es3",
					k = N.needsTranspile_(k);
				"goog" == h.module || k ? N.importProcessedScript_(N.basePath + f, "goog" == h.module, k) : N.importScript_(N.basePath + f)
			} else throw N.moduleLoaderState_ = g, Error("Undefined script input");
		N.moduleLoaderState_ = g
	}, N.getPathFromDeps_ = function(a) {
		return a in N.dependencies_.nameToPath ? N.dependencies_.nameToPath[a] : null
	}, N.findBasePath_(), N.global.CLOSURE_NO_DEPS || N.importScript_(N.basePath + "deps.js"));
N.loadModule = function(a) {
	var b = N.moduleLoaderState_;
	try {
		N.moduleLoaderState_ = {
			moduleName: void 0,
			declareLegacyNamespace: !1
		};
		var c;
		if (N.isFunction(a)) c = a.call(void 0, {});
		else if (N.isString(a)) c = N.loadModuleFromSource_.call(void 0, a);
		else throw Error("Invalid module definition");
		var d = N.moduleLoaderState_.moduleName;
		if (!N.isString(d) || !d) throw Error('Invalid module name "' + d + '"');
		N.moduleLoaderState_.declareLegacyNamespace ? N.constructNamespace_(d, c) : N.SEAL_MODULE_EXPORTS && Object.seal && N.isObject(c) &&
			Object.seal(c);
		N.loadedModules_[d] = c
	} finally {
		N.moduleLoaderState_ = b
	}
};
N.loadModuleFromSource_ = function(a) {
	var b = {};
	eval(a);
	return b
};
N.normalizePath_ = function(a) {
	a = a.split("/");
	for (var b = 0; b < a.length;) "." == a[b] ? a.splice(b, 1) : b && ".." == a[b] && a[b - 1] && ".." != a[b - 1] ? a.splice(--b, 2) : b++;
	return a.join("/")
};
N.loadFileSync_ = function(a) {
	if (N.global.CLOSURE_LOAD_FILE_SYNC) return N.global.CLOSURE_LOAD_FILE_SYNC(a);
	try {
		var b = new N.global.XMLHttpRequest;
		b.open("get", a, !1);
		b.send();
		return 0 == b.status || 200 == b.status ? b.responseText : null
	} catch (c) {
		return null
	}
};
N.retrieveAndExec_ = function(a, b, c) {};
N.transpile_ = function(a, b) {
	var c = N.global.$jscomp;
	c || (N.global.$jscomp = c = {});
	var d = c.transpile;
	if (!d) {
		var e = N.basePath + N.TRANSPILER,
			f = N.loadFileSync_(e);
		if (f) {
			eval(f + "\n//# sourceURL=" + e);
			if (N.global.$gwtExport && N.global.$gwtExport.$jscomp && !N.global.$gwtExport.$jscomp.transpile) throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(N.global.$gwtExport));
			N.global.$jscomp.transpile = N.global.$gwtExport.$jscomp.transpile;
			c = N.global.$jscomp;
			d = c.transpile
		}
	}
	if (!d) var g =
		" requires transpilation but no transpiler was found.",
		g = g + ' Please add "//javascript/closure:transpiler" as a data dependency to ensure it is included.',
		d = c.transpile = function(a, b) {
			N.logToConsole_(b + g);
			return a
		};
	return d(a, b)
};
N.typeOf = function(a) {
	var b = typeof a;
	if ("object" == b)
		if (a) {
			if (a instanceof Array) return "array";
			if (a instanceof Object) return b;
			var c = Object.prototype.toString.call(a);
			if ("[object Window]" == c) return "object";
			if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";
			if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function"
		} else return "null";
	else if ("function" == b && "undefined" == typeof a.call) return "object";
	return b
};
N.isNull = function(a) {
	return null === a
};
N.isDefAndNotNull = function(a) {
	return null != a
};
N.isArray = function(a) {
	return "array" == N.typeOf(a)
};
N.isArrayLike = function(a) {
	var b = N.typeOf(a);
	return "array" == b || "object" == b && "number" == typeof a.length
};
N.isDateLike = function(a) {
	return N.isObject(a) && "function" == typeof a.getFullYear
};
N.isString = function(a) {
	return "string" == typeof a
};
N.isBoolean = function(a) {
	return "boolean" == typeof a
};
N.isNumber = function(a) {
	return "number" == typeof a
};
N.isFunction = function(a) {
	return "function" == N.typeOf(a)
};
N.isObject = function(a) {
	var b = typeof a;
	return "object" == b && null != a || "function" == b
};
N.getUid = function(a) {
	return a[N.UID_PROPERTY_] || (a[N.UID_PROPERTY_] = ++N.uidCounter_)
};
N.hasUid = function(a) {
	return !!a[N.UID_PROPERTY_]
};
N.removeUid = function(a) {
	null !== a && "removeAttribute" in a && a.removeAttribute(N.UID_PROPERTY_);
	try {
		delete a[N.UID_PROPERTY_]
	} catch (b) {}
};
N.UID_PROPERTY_ = "closure_uid_" + (1E9 * Math.random() >>> 0);
N.uidCounter_ = 0;
N.getHashCode = N.getUid;
N.removeHashCode = N.removeUid;
N.cloneObject = function(a) {
	var b = N.typeOf(a);
	if ("object" == b || "array" == b) {
		if (a.clone) return a.clone();
		var b = "array" == b ? [] : {},
			c;
		for (c in a) b[c] = N.cloneObject(a[c]);
		return b
	}
	return a
};
N.bindNative_ = function(a, b, c) {
	return a.call.apply(a.bind, arguments)
};
N.bindJs_ = function(a, b, c) {
	if (!a) throw Error();
	if (2 < arguments.length) {
		var d = Array.prototype.slice.call(arguments, 2);
		return function() {
			var c = Array.prototype.slice.call(arguments);
			Array.prototype.unshift.apply(c, d);
			return a.apply(b, c)
		}
	}
	return function() {
		return a.apply(b, arguments)
	}
};
N.bind = function(a, b, c) {
	Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? N.bind = N.bindNative_ : N.bind = N.bindJs_;
	return N.bind.apply(null, arguments)
};
N.partial = function(a, b) {
	var c = Array.prototype.slice.call(arguments, 1);
	return function() {
		var b = c.slice();
		b.push.apply(b, arguments);
		return a.apply(this, b)
	}
};
N.mixin = function(a, b) {
	for (var c in b) a[c] = b[c]
};
N.now = N.TRUSTED_SITE && Date.now || function() {
	return +new Date
};
N.globalEval = function(a) {
	if (N.global.execScript) N.global.execScript(a, "JavaScript");
	else if (N.global.eval) {
		if (null == N.evalWorksForGlobals_)
			if (N.global.eval("var _evalTest_ = 1;"), "undefined" != typeof N.global._evalTest_) {
				try {
					delete N.global._evalTest_
				} catch (d) {}
				N.evalWorksForGlobals_ = !0
			} else N.evalWorksForGlobals_ = !1;
		if (N.evalWorksForGlobals_) N.global.eval(a);
		else {
			var b = N.global.document,
				c = b.createElement("SCRIPT");
			c.type = "text/javascript";
			c.defer = !1;
			c.appendChild(b.createTextNode(a));
			b.body.appendChild(c);
			b.body.removeChild(c)
		}
	} else throw Error("goog.globalEval not available");
};
N.evalWorksForGlobals_ = null;
N.getCssName = function(a, b) {
	if ("." == String(a).charAt(0)) throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + a);
	var c = function(a) {
			return N.cssNameMapping_[a] || a
		},
		d = function(a) {
			a = a.split("-");
			for (var b = [], d = 0; d < a.length; d++) b.push(c(a[d]));
			return b.join("-")
		},
		d = N.cssNameMapping_ ? "BY_WHOLE" == N.cssNameMappingStyle_ ? c : d : function(a) {
			return a
		};
	a = b ? a + "-" + d(b) : d(a);
	return N.global.CLOSURE_CSS_NAME_MAP_FN ? N.global.CLOSURE_CSS_NAME_MAP_FN(a) : a
};
N.setCssNameMapping = function(a, b) {
	N.cssNameMapping_ = a;
	N.cssNameMappingStyle_ = b
};
N.getMsg = function(a, b) {
	b && (a = a.replace(/\{\$([^}]+)}/g, function(a, d) {
		return null != b && d in b ? b[d] : a
	}));
	return a
};
N.getMsgWithFallback = function(a, b) {
	return a
};
N.exportSymbol = function(a, b, c) {
	N.exportPath_(a, b, c)
};
N.exportProperty = function(a, b, c) {
	a[b] = c
};
N.inherits = function(a, b) {
	function c() {}
	c.prototype = b.prototype;
	a.superClass_ = b.prototype;
	a.prototype = new c;
	a.prototype.constructor = a;
	a.base = function(a, c, f) {
		for (var d = Array(arguments.length - 2), e = 2; e < arguments.length; e++) d[e - 2] = arguments[e];
		return b.prototype[c].apply(a, d)
	}
};
N.base = function(a, b, c) {
	var d = arguments.callee.caller;
	if (N.STRICT_MODE_COMPATIBLE || N.DEBUG && !d) throw Error("arguments.caller not defined.  goog.base() cannot be used with strict mode code. See http://www.ecma-international.org/ecma-262/5.1/#sec-C");
	if (d.superClass_) {
		for (var e = Array(arguments.length - 1), f = 1; f < arguments.length; f++) e[f - 1] = arguments[f];
		return d.superClass_.constructor.apply(a, e)
	}
	e = Array(arguments.length - 2);
	for (f = 2; f < arguments.length; f++) e[f - 2] = arguments[f];
	for (var f = !1, g = a.constructor; g; g =
		g.superClass_ && g.superClass_.constructor)
		if (g.prototype[b] === d) f = !0;
		else if (f) return g.prototype[b].apply(a, e);
	if (a[b] === d) return a.constructor.prototype[b].apply(a, e);
	throw Error("goog.base called from a method of one name to a method of a different name");
};
N.scope = function(a) {
	if (N.isInModuleLoader_()) throw Error("goog.scope is not supported within a goog.module.");
	a.call(N.global)
};
N.defineClass = function(a, b) {
	var c = b.constructor,
		d = b.statics;
	c && c != Object.prototype.constructor || (c = function() {
		throw Error("cannot instantiate an interface (no constructor defined).");
	});
	c = N.defineClass.createSealingConstructor_(c, a);
	a && N.inherits(c, a);
	delete b.constructor;
	delete b.statics;
	N.defineClass.applyProperties_(c.prototype, b);
	null != d && (d instanceof Function ? d(c) : N.defineClass.applyProperties_(c, d));
	return c
};
N.defineClass.SEAL_CLASS_INSTANCES = N.DEBUG;
N.defineClass.createSealingConstructor_ = function(a, b) {
	if (!N.defineClass.SEAL_CLASS_INSTANCES) return a;
	var c = !N.defineClass.isUnsealable_(b),
		d = function() {
			var b = a.apply(this, arguments) || this;
			b[N.UID_PROPERTY_] = b[N.UID_PROPERTY_];
			this.constructor === d && c && Object.seal instanceof Function && Object.seal(b);
			return b
		};
	return d
};
N.defineClass.isUnsealable_ = function(a) {
	return a && a.prototype && a.prototype[N.UNSEALABLE_CONSTRUCTOR_PROPERTY_]
};
N.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
N.defineClass.applyProperties_ = function(a, b) {
	for (var c in b) Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c]);
	for (var d = 0; d < N.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; d++) c = N.defineClass.OBJECT_PROTOTYPE_FIELDS_[d], Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c])
};
N.tagUnsealableClass = function(a) {};
N.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
N.createRequiresTranspilation_ = function() {
	function a(a, b) {
		d ? c[a] = !0 : b() ? c[a] = !1 : d = c[a] = !0
	}

	function b(a) {
		try {
			return !!eval(a)
		} catch (f) {
			return !1
		}
	}
	var c = {
			es3: !1
		},
		d = !1;
	a("es5", function() {
		return b("[1,].length==1")
	});
	a("es6", function() {
		return b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()')
	});
	a("es6-impl", function() {
		return !0
	});
	a("es7", function() {
		return b("2 ** 2 == 4")
	});
	a("es8", function() {
		return b("async () => 1, true")
	});
	return c
};
var U = {
	IronResizableBehavior: {}
};
U.IronResizableBehavior.IronResizableBehavior = {};
Polymer.IronResizableBehavior = {
	properties: {
		_parentResizable: {
			type: Object,
			observer: "_parentResizableChanged"
		},
		_notifyingDescendant: {
			type: Boolean,
			value: !1
		}
	},
	listeners: {
		"iron-request-resize-notifications": "_onIronRequestResizeNotifications"
	},
	created: function() {
		this._interestedResizables = [];
		this._boundNotifyResize = this.notifyResize.bind(this)
	},
	attached: function() {
		this.fire("iron-request-resize-notifications", null, {
			node: this,
			bubbles: !0,
			cancelable: !0
		});
		this._parentResizable || (window.addEventListener("resize",
			this._boundNotifyResize), this.notifyResize())
	},
	detached: function() {
		this._parentResizable ? this._parentResizable.stopResizeNotificationsFor(this) : window.removeEventListener("resize", this._boundNotifyResize);
		this._parentResizable = null
	},
	notifyResize: function() {
		this.isAttached && (this._interestedResizables.forEach(function(a) {
			this.resizerShouldNotify(a) && this._notifyDescendant(a)
		}, this), this._fireResize())
	},
	assignParentResizable: function(a) {
		this._parentResizable = a
	},
	stopResizeNotificationsFor: function(a) {
		var b =
			this._interestedResizables.indexOf(a); - 1 < b && (this._interestedResizables.splice(b, 1), this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
	},
	resizerShouldNotify: function(a) {
		return !0
	},
	_onDescendantIronResize: function(a) {
		this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
	},
	_fireResize: function() {
		this.fire("iron-resize", null, {
			node: this,
			bubbles: !1
		})
	},
	_onIronRequestResizeNotifications: function(a) {
		var b = a.path ? a.path[0] : a.target;
		b !== this && (-1 === this._interestedResizables.indexOf(b) &&
			(this._interestedResizables.push(b), this.listen(b, "iron-resize", "_onDescendantIronResize")), b.assignParentResizable(this), this._notifyDescendant(b), a.stopPropagation())
	},
	_parentResizableChanged: function(a) {
		a && window.removeEventListener("resize", this._boundNotifyResize)
	},
	_notifyDescendant: function(a) {
		this.isAttached && (this._notifyingDescendant = !0, a.notifyResize(), this._notifyingDescendant = !1)
	}
};
U.IronCollapse = {};
U.IronCollapse.IronCollapse = {};
var wa = function() {};
q = wa.prototype;
q.notifyResize = function() {
	this.isAttached && (this._interestedResizables.forEach(function(a) {
		this.resizerShouldNotify(a) && this._notifyDescendant(a)
	}, this), this._fireResize())
};
q.assignParentResizable = function(a) {
	this._parentResizable = a
};
q.stopResizeNotificationsFor = function(a) {
	var b = this._interestedResizables.indexOf(a); - 1 < b && (this._interestedResizables.splice(b, 1), this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
};
q.resizerShouldNotify = function(a) {
	return !0
};
q._onDescendantIronResize = function(a) {
	this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
};
q._fireResize = function() {
	this.fire("iron-resize", null, {
		node: this,
		bubbles: !1
	})
};
q._onIronRequestResizeNotifications = function(a) {
	var b = a.path ? a.path[0] : a.target;
	b !== this && (-1 === this._interestedResizables.indexOf(b) && (this._interestedResizables.push(b), this.listen(b, "iron-resize", "_onDescendantIronResize")), b.assignParentResizable(this), this._notifyDescendant(b), a.stopPropagation())
};
q._parentResizableChanged = function(a) {
	a && window.removeEventListener("resize", this._boundNotifyResize)
};
q._notifyDescendant = function(a) {
	this.isAttached && (this._notifyingDescendant = !0, a.notifyResize(), this._notifyingDescendant = !1)
};
Polymer({
	is: "iron-collapse",
	behaviors: [Polymer.IronResizableBehavior],
	properties: {
		horizontal: {
			type: Boolean,
			value: !1,
			observer: "_horizontalChanged"
		},
		opened: {
			type: Boolean,
			value: !1,
			notify: !0,
			observer: "_openedChanged"
		},
		noAnimation: {
			type: Boolean
		}
	},
	get dimension() {
		return this.horizontal ? "width" : "height"
	},
	hostAttributes: {
		role: "group",
		"aria-hidden": "true",
		"aria-expanded": "false"
	},
	listeners: {
		transitionend: "_transitionEnd"
	},
	attached: function() {
		this._transitionEnd()
	},
	toggle: function() {
		this.opened = !this.opened
	},
	show: function() {
		this.opened = !0
	},
	hide: function() {
		this.opened = !1
	},
	updateSize: function(a, b) {
		this.style[this.dimension] !== a && (this._updateTransition(!1), b && !this.noAnimation && this._isDisplayed && (b = this._calcSize(), "auto" === a && (this.style[this.dimension] = a, a = this._calcSize()), this.style[this.dimension] = b, this.offsetHeight = this.offsetHeight, this._updateTransition(!0)), this.style[this.dimension] = a)
	},
	enableTransition: function(a) {
		console.warn("`enableTransition()` is deprecated, use `noAnimation` instead.");
		this.noAnimation = !a
	},
	_updateTransition: function(a) {
		this.style.transitionDuration = a && !this.noAnimation ? "" : "0s"
	},
	_horizontalChanged: function() {
		this.style.transitionProperty = this.dimension;
		var a = "width" === this.dimension ? "height" : "width";
		this.style[a] = "";
		this.updateSize(this.opened ? "auto" : "0px", !1)
	},
	_openedChanged: function() {
		this.setAttribute("aria-expanded", this.opened);
		this.setAttribute("aria-hidden", !this.opened);
		this.toggleClass("iron-collapse-closed", !1);
		this.toggleClass("iron-collapse-opened", !1);
		this.updateSize(this.opened ? "auto" : "0px", !0);
		this.opened && this.focus();
		this.noAnimation && this._transitionEnd()
	},
	_transitionEnd: function() {
		this.opened && (this.style[this.dimension] = "auto");
		this.toggleClass("iron-collapse-closed", !this.opened);
		this.toggleClass("iron-collapse-opened", this.opened);
		this._updateTransition(!1);
		this.notifyResize()
	},
	get _isDisplayed() {
		var a = this.getBoundingClientRect(),
			b;
		for (b in a)
			if (0 !== a[b]) return !0;
		return !1
	},
	_calcSize: function() {
		return this.getBoundingClientRect()[this.dimension] +
			"px"
	}
});
U.IronFlexLayout = {};
U.IronFlexLayout.Classes = {};
U.IronFlexLayout.Classes.IronShadowFlexLayout = {};
console.warn("This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead");
U.IronFlexLayout.Classes.IronFlexLayout = {};
console.warn("This file is deprecated. Please use `iron-flex-layout/iron-flex-layout-classes.html`, and one of the specific dom-modules instead");
U.IronFlexLayout.IronFlexLayoutClasses = {};
U.IronFlexLayout.IronFlexLayout = {};
U.IronMeta = {};
U.IronMeta.IronMeta = {};
(function() {
	var a = {},
		b = {},
		c = null;
	Polymer.IronMeta = function(a) {
		if (a)
			for (var b in a) switch (b) {
				case "type":
				case "key":
				case "value":
					this[b] = a[b]
			}
	};
	Polymer.IronMeta = Polymer({
		is: "iron-meta",
		properties: {
			type: {
				type: String,
				value: "default",
				observer: "_typeChanged"
			},
			key: {
				type: String,
				observer: "_keyChanged"
			},
			value: {
				type: Object,
				notify: !0,
				observer: "_valueChanged"
			},
			self: {
				type: Boolean,
				observer: "_selfChanged"
			},
			list: {
				type: Array,
				notify: !0
			}
		},
		hostAttributes: {
			hidden: !0
		},
		factoryImpl: function(a) {
			if (a)
				for (var b in a) switch (b) {
					case "type":
					case "key":
					case "value":
						this[b] = a[b]
				}
		},
		created: function() {
			this._metaDatas = a;
			this._metaArrays = b
		},
		_keyChanged: function(a, b) {
			this._resetRegistration(b)
		},
		_valueChanged: function(a) {
			this._resetRegistration(this.key)
		},
		_selfChanged: function(a) {
			a && (this.value = this)
		},
		_typeChanged: function(c) {
			this._unregisterKey(this.key);
			a[c] || (a[c] = {});
			this._metaData = a[c];
			b[c] || (b[c] = []);
			this.list = b[c];
			this._registerKeyValue(this.key, this.value)
		},
		byKey: function(a) {
			return this._metaData && this._metaData[a]
		},
		_resetRegistration: function(a) {
			this._unregisterKey(a);
			this._registerKeyValue(this.key,
				this.value)
		},
		_unregisterKey: function(a) {
			this._unregister(a, this._metaData, this.list)
		},
		_registerKeyValue: function(a, b) {
			this._register(a, b, this._metaData, this.list)
		},
		_register: function(a, b, c, g) {
			a && c && void 0 !== b && (c[a] = b, g.push(b))
		},
		_unregister: function(a, b, c) {
			if (a && b && a in b) {
				var d = b[a];
				delete b[a];
				this.arrayDelete(c, d)
			}
		}
	});
	Polymer.IronMeta.getIronMeta = function e() {
		null === c && (c = new Polymer.IronMeta);
		return c
	};
	Polymer.IronMetaQuery = function(a) {
		if (a)
			for (var b in a) switch (b) {
				case "type":
				case "key":
					this[b] =
						a[b]
			}
	};
	Polymer.IronMetaQuery.prototype._setValue = function(a) {};
	Polymer.IronMetaQuery = Polymer({
		is: "iron-meta-query",
		properties: {
			type: {
				type: String,
				value: "default",
				observer: "_typeChanged"
			},
			key: {
				type: String,
				observer: "_keyChanged"
			},
			value: {
				type: Object,
				notify: !0,
				readOnly: !0
			},
			list: {
				type: Array,
				notify: !0
			}
		},
		factoryImpl: function(a) {
			if (a)
				for (var b in a) switch (b) {
					case "type":
					case "key":
						this[b] = a[b]
				}
		},
		created: function() {
			this._metaDatas = a;
			this._metaArrays = b
		},
		_keyChanged: function(a) {
			this._setValue(this._metaData &&
				this._metaData[a])
		},
		_typeChanged: function(c) {
			this._metaData = a[c];
			this.list = b[c];
			this.key && this._keyChanged(this.key)
		},
		byKey: function(a) {
			return this._metaData && this._metaData[a]
		}
	})
})();
U.IronIcon = {};
U.IronIcon.IronIcon = {};
var xa = function() {};
Polymer({
	is: "iron-icon",
	properties: {
		icon: {
			type: String
		},
		theme: {
			type: String
		},
		src: {
			type: String
		},
		_meta: {
			value: Polymer.Base.create("iron-meta", {
				type: "iconset"
			})
		}
	},
	observers: ["_updateIcon(_meta, isAttached)", "_updateIcon(theme, isAttached)", "_srcChanged(src, isAttached)", "_iconChanged(icon, isAttached)"],
	_DEFAULT_ICONSET: "icons",
	_iconChanged: function(a) {
		a = (a || "").split(":");
		this._iconName = a.pop();
		this._iconsetName = a.pop() || this._DEFAULT_ICONSET;
		this._updateIcon()
	},
	_srcChanged: function(a) {
		this._updateIcon()
	},
	_usesIconset: function() {
		return this.icon || !this.src
	},
	_updateIcon: function() {
		this._usesIconset() ? (this._img && this._img.parentNode && Polymer.dom(this.root).removeChild(this._img), "" === this._iconName ? this._iconset && this._iconset.removeIcon(this) : this._iconsetName && this._meta && ((this._iconset = this._meta.byKey(this._iconsetName)) ? (this._iconset.applyIcon(this, this._iconName, this.theme), this.unlisten(window, "iron-iconset-added", "_updateIcon")) : this.listen(window, "iron-iconset-added", "_updateIcon"))) : (this._iconset &&
			this._iconset.removeIcon(this), this._img || (this._img = document.createElement("img"), this._img.style.width = "100%", this._img.style.height = "100%", this._img.draggable = !1), this._img.src = this.src, Polymer.dom(this.root).appendChild(this._img))
	}
});
U.IronIconsetSvg = {};
U.IronIconsetSvg.IronIconsetSvg = {};
var za = function() {};
Polymer({
	is: "iron-iconset-svg",
	properties: {
		name: {
			type: String,
			observer: "_nameChanged"
		},
		size: {
			type: Number,
			value: 24
		},
		rtlMirroring: {
			type: Boolean,
			value: !1
		}
	},
	attached: function() {
		this.style.display = "none"
	},
	getIconNames: function() {
		this._icons = this._createIconMap();
		return Object.keys(this._icons).map(function(a) {
			return this.name + ":" + a
		}, this)
	},
	applyIcon: function(a, b) {
		a = a.root || a;
		this.removeIcon(a);
		if (b = this._cloneIcon(b, this.rtlMirroring && this._targetIsRTL(a))) {
			var c = Polymer.dom(a);
			c.insertBefore(b, c.childNodes[0]);
			return a._svgIcon = b
		}
		return null
	},
	removeIcon: function(a) {
		a = a.root || a;
		a._svgIcon && (Polymer.dom(a).removeChild(a._svgIcon), a._svgIcon = null)
	},
	_targetIsRTL: function(a) {
		null == this.__targetIsRTL && (a && a.nodeType !== Node.ELEMENT_NODE && (a = a.host), this.__targetIsRTL = a && "rtl" === window.getComputedStyle(a).direction);
		return this.__targetIsRTL
	},
	_nameChanged: function() {
		new Polymer.IronMeta({
			type: "iconset",
			key: this.name,
			value: this
		});
		this.async(function() {
			this.fire("iron-iconset-added", this, {
				node: window
			})
		})
	},
	_createIconMap: function() {
		var a =
			Object.create(null);
		Polymer.dom(this).querySelectorAll("[id]").forEach(function(b) {
			a[b.id] = b
		});
		return a
	},
	_cloneIcon: function(a, b) {
		this._icons = this._icons || this._createIconMap();
		return this._prepareSvgClone(this._icons[a], this.size, b)
	},
	_prepareSvgClone: function(a, b, c) {
		if (a) {
			a = a.cloneNode(!0);
			var d = document.createElementNS("http://www.w3.org/2000/svg", "svg");
			b = a.getAttribute("viewBox") || "0 0 " + b + " " + b;
			var e = "pointer-events: none; display: block; width: 100%; height: 100%;";
			c && a.hasAttribute("mirror-in-rtl") &&
				(e += "-webkit-transform:scale(-1,1);transform:scale(-1,1);");
			d.setAttribute("viewBox", b);
			d.setAttribute("preserveAspectRatio", "xMidYMid meet");
			d.style.cssText = e;
			d.appendChild(a).removeAttribute("id");
			return d
		}
		return null
	}
});
U.IronIcons = {};
U.IronIcons.AvIcons = {};
U.IronIcons.CommunicationIcons = {};
U.IronIcons.DeviceIcons = {};
U.IronIcons.EditorIcons = {};
U.IronIcons.HardwareIcons = {};
U.IronIcons.ImageIcons = {};
U.IronIcons.IronIcons = {};
U.IronIcons.MapsIcons = {};
U.IronIcons.NotificationIcons = {};
U.IronIcons.PlacesIcons = {};
U.IronIcons.SocialIcons = {};
U.IronA11yKeysBehavior = {};
U.IronA11yKeysBehavior.IronA11yKeysBehavior = {};
(function() {
	function a(a, b) {
		var c = "";
		if (a)
			if (a = a.toLowerCase(), " " === a || m.test(a)) c = "space";
			else if (n.test(a)) c = "esc";
		else if (1 == a.length) {
			if (!b || h.test(a)) c = a
		} else c = l.test(a) ? a.replace("arrow", "") : "multiply" == a ? "*" : a;
		return c
	}

	function b(b, c) {
		var d;
		d = c;
		var g = b.hasModifiers,
			h;
		if (!(h = a(d.key, g))) {
			h = d.keyIdentifier;
			var l = "";
			h && (h in e ? l = e[h] : k.test(h) ? (h = parseInt(h.replace("U+", "0x"), 16), l = String.fromCharCode(h).toLowerCase()) : l = h.toLowerCase());
			h = l
		}
		h || (h = d.keyCode, l = "", Number(h) && (l = 65 <= h && 90 >= h ? String.fromCharCode(32 +
			h) : 112 <= h && 123 >= h ? "f" + (h - 112) : 48 <= h && 57 >= h ? String(h - 48) : 96 <= h && 105 >= h ? String(h - 96) : f[h]), h = l);
		d = h || a(d.detail ? d.detail.key : d.detail, g) || "";
		return d === b.key && (!b.hasModifiers || !!c.shiftKey === !!b.shiftKey && !!c.ctrlKey === !!b.ctrlKey && !!c.altKey === !!b.altKey && !!c.metaKey === !!b.metaKey)
	}

	function c(a) {
		return 1 === a.length ? {
			combo: a,
			key: a,
			event: "keydown"
		} : a.split("+").reduce(function(a, b) {
			var c = b.split(":");
			b = c[0];
			c = c[1];
			b in g ? (a[g[b]] = !0, a.hasModifiers = !0) : (a.key = b, a.event = c || "keydown");
			return a
		}, {
			combo: a.split(":").shift()
		})
	}

	function d(a) {
		return a.trim().split(" ").map(function(a) {
			return c(a)
		})
	}
	var e = {
			"U+0008": "backspace",
			"U+0009": "tab",
			"U+001B": "esc",
			"U+0020": "space",
			"U+007F": "del"
		},
		f = {
			8: "backspace",
			9: "tab",
			13: "enter",
			27: "esc",
			33: "pageup",
			34: "pagedown",
			35: "end",
			36: "home",
			32: "space",
			37: "left",
			38: "up",
			39: "right",
			40: "down",
			46: "del",
			106: "*"
		},
		g = {
			shift: "shiftKey",
			ctrl: "ctrlKey",
			alt: "altKey",
			meta: "metaKey"
		},
		h = /[a-z0-9*]/,
		k = /U\+/,
		l = /^arrow/,
		m = /^space(bar)?/,
		n = /^escape$/;
	Polymer.IronA11yKeysBehavior = {
		properties: {
			keyEventTarget: {
				type: Object,
				value: function() {
					return this
				}
			},
			stopKeyboardEventPropagation: {
				type: Boolean,
				value: !1
			},
			_boundKeyHandlers: {
				type: Array,
				value: function() {
					return []
				}
			},
			_imperativeKeyBindings: {
				type: Object,
				value: function() {
					return {}
				}
			}
		},
		observers: ["_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)"],
		keyBindings: {},
		registered: function() {
			this._prepKeyBindings()
		},
		attached: function() {
			this._listenKeyEventListeners()
		},
		detached: function() {
			this._unlistenKeyEventListeners()
		},
		addOwnKeyBinding: function(a, b) {
			this._imperativeKeyBindings[a] =
				b;
			this._prepKeyBindings();
			this._resetKeyEventListeners()
		},
		removeOwnKeyBindings: function() {
			this._imperativeKeyBindings = {};
			this._prepKeyBindings();
			this._resetKeyEventListeners()
		},
		keyboardEventMatchesKeys: function(a, c) {
			c = d(c);
			for (var e = 0; e < c.length; ++e)
				if (b(c[e], a)) return !0;
			return !1
		},
		_collectKeyBindings: function() {
			var a = this.behaviors.map(function(a) {
				return a.keyBindings
			}); - 1 === a.indexOf(this.keyBindings) && a.push(this.keyBindings);
			return a
		},
		_prepKeyBindings: function() {
			this._keyBindings = {};
			this._collectKeyBindings().forEach(function(a) {
				for (var b in a) this._addKeyBinding(b,
					a[b])
			}, this);
			for (var a in this._imperativeKeyBindings) this._addKeyBinding(a, this._imperativeKeyBindings[a]);
			for (var b in this._keyBindings) this._keyBindings[b].sort(function(a, b) {
				a = a[0].hasModifiers;
				b = b[0].hasModifiers;
				return a === b ? 0 : a ? -1 : 1
			})
		},
		_addKeyBinding: function(a, b) {
			d(a).forEach(function(a) {
				this._keyBindings[a.event] = this._keyBindings[a.event] || [];
				this._keyBindings[a.event].push([a, b])
			}, this)
		},
		_resetKeyEventListeners: function() {
			this._unlistenKeyEventListeners();
			this.isAttached && this._listenKeyEventListeners()
		},
		_listenKeyEventListeners: function() {
			this.keyEventTarget && Object.keys(this._keyBindings).forEach(function(a) {
				var b = this._keyBindings[a],
					b = this._onKeyBindingEvent.bind(this, b);
				this._boundKeyHandlers.push([this.keyEventTarget, a, b]);
				this.keyEventTarget.addEventListener(a, b)
			}, this)
		},
		_unlistenKeyEventListeners: function() {
			for (var a, b, c; this._boundKeyHandlers.length;) a = this._boundKeyHandlers.pop(), b = a[0], c = a[1], a = a[2], b.removeEventListener(c, a)
		},
		_onKeyBindingEvent: function(a, c) {
			this.stopKeyboardEventPropagation &&
				c.stopPropagation();
			if (!c.defaultPrevented)
				for (var d = 0; d < a.length; d++) {
					var e = a[d][0],
						f = a[d][1];
					if (b(e, c) && (this._triggerKeyHandler(e, f, c), c.defaultPrevented)) break
				}
		},
		_triggerKeyHandler: function(a, b, c) {
			var d = Object.create(a);
			d.keyboardEvent = c;
			a = new CustomEvent(a.event, {
				detail: d,
				cancelable: !0
			});
			this[b].call(this, a);
			a.defaultPrevented && c.preventDefault()
		}
	}
})();
var Ga = function() {};
q = Ga.prototype;
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._setAnimating = function(a) {};
U.PaperRipple = {};
U.PaperRipple.PaperRipple = {};
(function() {
	function a(a) {
		this.element = a;
		this.width = this.boundingRect.width;
		this.height = this.boundingRect.height;
		this.size = Math.max(this.width, this.height)
	}

	function b(a) {
		this.element = a;
		this.color = window.getComputedStyle(a).color;
		this.wave = document.createElement("div");
		this.waveContainer = document.createElement("div");
		this.wave.style.backgroundColor = this.color;
		this.wave.classList.add("wave");
		this.waveContainer.classList.add("wave-container");
		Polymer.dom(this.waveContainer).appendChild(this.wave);
		this.resetInteractionState()
	}
	var c = {
		distance: function(a, b, c, g) {
			a -= c;
			b -= g;
			return Math.sqrt(a * a + b * b)
		},
		now: window.performance && window.performance.now ? window.performance.now.bind(window.performance) : Date.now
	};
	a.prototype = {get boundingRect() {
			return this.element.getBoundingClientRect()
		},
		furthestCornerDistanceFrom: function(a, b) {
			var d = c.distance(a, b, 0, 0),
				e = c.distance(a, b, this.width, 0),
				h = c.distance(a, b, 0, this.height);
			a = c.distance(a, b, this.width, this.height);
			return Math.max(d, e, h, a)
		}
	};
	b.MAX_RADIUS = 300;
	b.prototype = {get recenters() {
			return this.element.recenters
		},
		get center() {
			return this.element.center
		},
		get mouseDownElapsed() {
			var a;
			if (!this.mouseDownStart) return 0;
			a = c.now() - this.mouseDownStart;
			this.mouseUpStart && (a -= this.mouseUpElapsed);
			return a
		},
		get mouseUpElapsed() {
			return this.mouseUpStart ? c.now() - this.mouseUpStart : 0
		},
		get mouseDownElapsedSeconds() {
			return this.mouseDownElapsed / 1E3
		},
		get mouseUpElapsedSeconds() {
			return this.mouseUpElapsed / 1E3
		},
		get mouseInteractionSeconds() {
			return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds
		},
		get initialOpacity() {
			return this.element.initialOpacity
		},
		get opacityDecayVelocity() {
			return this.element.opacityDecayVelocity
		},
		get radius() {
			var a = this.containerMetrics.width * this.containerMetrics.width,
				c = this.containerMetrics.height * this.containerMetrics.height,
				a = 1.1 * Math.min(Math.sqrt(a + c), b.MAX_RADIUS) + 5,
				c = 1.1 - a / b.MAX_RADIUS * .2,
				c = this.mouseInteractionSeconds / c,
				a = a * (1 - Math.pow(80, -c));
			return Math.abs(a)
		},
		get opacity() {
			return this.mouseUpStart ? Math.max(0, this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity) : this.initialOpacity
		},
		get outerOpacity() {
			var a =
				.3 * this.mouseUpElapsedSeconds,
				b = this.opacity;
			return Math.max(0, Math.min(a, b))
		},
		get isOpacityFullyDecayed() {
			return .01 > this.opacity && this.radius >= Math.min(this.maxRadius, b.MAX_RADIUS)
		},
		get isRestingAtMaxRadius() {
			return this.opacity >= this.initialOpacity && this.radius >= Math.min(this.maxRadius, b.MAX_RADIUS)
		},
		get isAnimationComplete() {
			return this.mouseUpStart ? this.isOpacityFullyDecayed : this.isRestingAtMaxRadius
		},
		get translationFraction() {
			return Math.min(1, this.radius / this.containerMetrics.size * 2 / Math.sqrt(2))
		},
		get xNow() {
			return this.xEnd ? this.xStart + this.translationFraction * (this.xEnd - this.xStart) : this.xStart
		},
		get yNow() {
			return this.yEnd ? this.yStart + this.translationFraction * (this.yEnd - this.yStart) : this.yStart
		},
		get isMouseDown() {
			return this.mouseDownStart && !this.mouseUpStart
		},
		resetInteractionState: function() {
			this.slideDistance = this.yEnd = this.xEnd = this.yStart = this.xStart = this.mouseUpStart = this.mouseDownStart = this.maxRadius = 0;
			this.containerMetrics = new a(this.element)
		},
		draw: function() {
			var a, b, c;
			this.wave.style.opacity =
				this.opacity;
			a = this.radius / (this.containerMetrics.size / 2);
			b = this.xNow - this.containerMetrics.width / 2;
			c = this.yNow - this.containerMetrics.height / 2;
			this.waveContainer.style.webkitTransform = "translate(" + b + "px, " + c + "px)";
			this.waveContainer.style.transform = "translate3d(" + b + "px, " + c + "px, 0)";
			this.wave.style.webkitTransform = "scale(" + a + "," + a + ")";
			this.wave.style.transform = "scale3d(" + a + "," + a + ",1)"
		},
		downAction: function(a) {
			var b = this.containerMetrics.width / 2,
				d = this.containerMetrics.height / 2;
			this.resetInteractionState();
			this.mouseDownStart = c.now();
			this.center ? (this.xStart = b, this.yStart = d, this.slideDistance = c.distance(this.xStart, this.yStart, this.xEnd, this.yEnd)) : (this.xStart = a ? a.detail.x - this.containerMetrics.boundingRect.left : this.containerMetrics.width / 2, this.yStart = a ? a.detail.y - this.containerMetrics.boundingRect.top : this.containerMetrics.height / 2);
			this.recenters && (this.xEnd = b, this.yEnd = d, this.slideDistance = c.distance(this.xStart, this.yStart, this.xEnd, this.yEnd));
			this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(this.xStart,
				this.yStart);
			this.waveContainer.style.top = (this.containerMetrics.height - this.containerMetrics.size) / 2 + "px";
			this.waveContainer.style.left = (this.containerMetrics.width - this.containerMetrics.size) / 2 + "px";
			this.waveContainer.style.width = this.containerMetrics.size + "px";
			this.waveContainer.style.height = this.containerMetrics.size + "px"
		},
		upAction: function(a) {
			this.isMouseDown && (this.mouseUpStart = c.now())
		},
		remove: function() {
			Polymer.dom(this.waveContainer.parentNode).removeChild(this.waveContainer)
		}
	};
	Polymer({
		is: "paper-ripple",
		behaviors: [Polymer.IronA11yKeysBehavior],
		properties: {
			initialOpacity: {
				type: Number,
				value: .25
			},
			opacityDecayVelocity: {
				type: Number,
				value: .8
			},
			recenters: {
				type: Boolean,
				value: !1
			},
			center: {
				type: Boolean,
				value: !1
			},
			ripples: {
				type: Array,
				value: function() {
					return []
				}
			},
			animating: {
				type: Boolean,
				readOnly: !0,
				reflectToAttribute: !0,
				value: !1
			},
			holdDown: {
				type: Boolean,
				value: !1,
				observer: "_holdDownChanged"
			},
			noink: {
				type: Boolean,
				value: !1
			},
			_animating: {
				type: Boolean
			},
			_boundAnimate: {
				type: Function,
				value: function() {
					return this.animate.bind(this)
				}
			}
		},
		get target() {
			var a = Polymer.dom(this).getOwnerRoot();
			return a = 11 == this.parentNode.nodeType ? a.host : this.parentNode
		},
		keyBindings: {
			"enter:keydown": "_onEnterKeydown",
			"space:keydown": "_onSpaceKeydown",
			"space:keyup": "_onSpaceKeyup"
		},
		attached: function() {
			this.keyEventTarget = this.target;
			this.listen(this.target, "up", "uiUpAction");
			this.listen(this.target, "down", "uiDownAction")
		},
		detached: function() {
			this.unlisten(this.target, "up", "uiUpAction");
			this.unlisten(this.target, "down", "uiDownAction")
		},
		get shouldKeepAnimating() {
			for (var a =
					0; a < this.ripples.length; ++a)
				if (!this.ripples[a].isAnimationComplete) return !0;
			return !1
		},
		simulatedRipple: function() {
			this.downAction(null);
			this.async(function() {
				this.upAction()
			}, 1)
		},
		uiDownAction: function(a) {
			this.noink || this.downAction(a)
		},
		downAction: function(a) {
			if (!(this.holdDown && 0 < this.ripples.length)) {
				var b = this.addRipple();
				b.downAction(a);
				this._animating || this.animate()
			}
		},
		uiUpAction: function(a) {
			this.noink || this.upAction(a)
		},
		upAction: function(a) {
			this.holdDown || (this.ripples.forEach(function(b) {
					b.upAction(a)
				}),
				this.animate())
		},
		onAnimationComplete: function() {
			this._animating = !1;
			this.$.background.style.backgroundColor = null;
			this.fire("transitionend")
		},
		addRipple: function() {
			var a = new b(this);
			Polymer.dom(this.$.waves).appendChild(a.waveContainer);
			this.$.background.style.backgroundColor = a.color;
			this.ripples.push(a);
			this._setAnimating(!0);
			return a
		},
		removeRipple: function(a) {
			var b = this.ripples.indexOf(a);
			0 > b || (this.ripples.splice(b, 1), a.remove(), this.ripples.length || this._setAnimating(!1))
		},
		animate: function() {
			var a,
				b;
			this._animating = !0;
			for (a = 0; a < this.ripples.length; ++a) b = this.ripples[a], b.draw(), this.$.background.style.opacity = b.outerOpacity, b.isOpacityFullyDecayed && !b.isRestingAtMaxRadius && this.removeRipple(b);
			if (this.shouldKeepAnimating || 0 !== this.ripples.length) window.requestAnimationFrame(this._boundAnimate);
			else this.onAnimationComplete()
		},
		_onEnterKeydown: function() {
			this.uiDownAction();
			this.async(this.uiUpAction, 1)
		},
		_onSpaceKeydown: function() {
			this.uiDownAction()
		},
		_onSpaceKeyup: function() {
			this.uiUpAction()
		},
		_holdDownChanged: function(a, b) {
			void 0 !== b && (a ? this.downAction() : this.upAction())
		}
	})
})();
U.PaperBehaviors = {};
U.PaperBehaviors.PaperRippleBehavior = {};
Polymer.PaperRippleBehavior = {
	properties: {
		noink: {
			type: Boolean,
			observer: "_noinkChanged"
		},
		_rippleContainer: {
			type: Object
		}
	},
	_buttonStateChanged: function() {
		this.focused && this.ensureRipple()
	},
	_downHandler: function(a) {
		Polymer.IronButtonStateImpl._downHandler.call(this, a);
		this.pressed && this.ensureRipple(a)
	},
	ensureRipple: function(a) {
		if (!this.hasRipple()) {
			this._ripple = this._createRipple();
			this._ripple.noink = this.noink;
			var b = this._rippleContainer || this.root;
			b && Polymer.dom(b).appendChild(this._ripple);
			if (a) {
				var b =
					Polymer.dom(this._rippleContainer || this),
					c = Polymer.dom(a).rootTarget;
				b.deepContains(c) && this._ripple.uiDownAction(a)
			}
		}
	},
	getRipple: function() {
		this.ensureRipple();
		return this._ripple
	},
	hasRipple: function() {
		return !!this._ripple
	},
	_createRipple: function() {
		return document.createElement("paper-ripple")
	},
	_noinkChanged: function(a) {
		this.hasRipple() && (this._ripple.noink = a)
	}
};
U.IronBehaviors = {};
U.IronBehaviors.IronControlState = {};
Polymer.IronControlState = {
	properties: {
		focused: {
			type: Boolean,
			value: !1,
			notify: !0,
			readOnly: !0,
			reflectToAttribute: !0
		},
		disabled: {
			type: Boolean,
			value: !1,
			notify: !0,
			observer: "_disabledChanged",
			reflectToAttribute: !0
		},
		_oldTabIndex: {
			type: Number
		},
		_boundFocusBlurHandler: {
			type: Function,
			value: function() {
				return this._focusBlurHandler.bind(this)
			}
		}
	},
	observers: ["_changedControlState(focused, disabled)"],
	ready: function() {
		this.addEventListener("focus", this._boundFocusBlurHandler, !0);
		this.addEventListener("blur", this._boundFocusBlurHandler, !0)
	},
	_focusBlurHandler: function(a) {
		if (a.target === this) this._setFocused("focus" === a.type);
		else if (!this.shadowRoot) {
			var b = Polymer.dom(a).localTarget;
			this.isLightDescendant(b) || this.fire(a.type, {
				sourceEvent: a
			}, {
				node: this,
				bubbles: a.bubbles,
				cancelable: a.cancelable
			})
		}
	},
	_disabledChanged: function(a, b) {
		this.setAttribute("aria-disabled", a ? "true" : "false");
		this.style.pointerEvents = a ? "none" : "";
		a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex =
			this._oldTabIndex)
	},
	_changedControlState: function() {
		this._controlStateChanged && this._controlStateChanged()
	}
};
U.IronBehaviors.IronButtonState = {};
Polymer.IronButtonStateImpl = {
	properties: {
		pressed: {
			type: Boolean,
			readOnly: !0,
			value: !1,
			reflectToAttribute: !0,
			observer: "_pressedChanged"
		},
		toggles: {
			type: Boolean,
			value: !1,
			reflectToAttribute: !0
		},
		active: {
			type: Boolean,
			value: !1,
			notify: !0,
			reflectToAttribute: !0
		},
		pointerDown: {
			type: Boolean,
			readOnly: !0,
			value: !1
		},
		receivedFocusFromKeyboard: {
			type: Boolean,
			readOnly: !0
		},
		ariaActiveAttribute: {
			type: String,
			value: "aria-pressed",
			observer: "_ariaActiveAttributeChanged"
		}
	},
	listeners: {
		down: "_downHandler",
		up: "_upHandler",
		tap: "_tapHandler"
	},
	observers: ["_detectKeyboardFocus(focused)", "_activeChanged(active, ariaActiveAttribute)"],
	keyBindings: {
		"enter:keydown": "_asyncClick",
		"space:keydown": "_spaceKeyDownHandler",
		"space:keyup": "_spaceKeyUpHandler"
	},
	_mouseEventRe: /^mouse/,
	_tapHandler: function() {
		this.toggles ? this._userActivate(!this.active) : this.active = !1
	},
	_detectKeyboardFocus: function(a) {
		this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
	},
	_userActivate: function(a) {
		this.active !== a && (this.active = a, this.fire("change"))
	},
	_downHandler: function(a) {
		this._setPointerDown(!0);
		this._setPressed(!0);
		this._setReceivedFocusFromKeyboard(!1)
	},
	_upHandler: function() {
		this._setPointerDown(!1);
		this._setPressed(!1)
	},
	_spaceKeyDownHandler: function(a) {
		a = a.detail.keyboardEvent;
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
	},
	_spaceKeyUpHandler: function(a) {
		a = a.detail.keyboardEvent;
		a = Polymer.dom(a).localTarget;
		this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
	},
	_asyncClick: function() {
		this.async(function() {
				this.click()
			},
			1)
	},
	_pressedChanged: function(a) {
		this._changedButtonState()
	},
	_ariaActiveAttributeChanged: function(a, b) {
		b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
	},
	_activeChanged: function(a, b) {
		this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
		this._changedButtonState()
	},
	_controlStateChanged: function() {
		this.disabled ? this._setPressed(!1) : this._changedButtonState()
	},
	_changedButtonState: function() {
		this._buttonStateChanged && this._buttonStateChanged()
	}
};
Polymer.IronButtonState = [Polymer.IronA11yKeysBehavior, Polymer.IronButtonStateImpl];
U.PaperBehaviors.PaperButtonBehavior = {};
Polymer.PaperButtonBehaviorImpl = {
	properties: {
		elevation: {
			type: Number,
			reflectToAttribute: !0,
			readOnly: !0
		}
	},
	observers: ["_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)", "_computeKeyboardClass(receivedFocusFromKeyboard)"],
	hostAttributes: {
		role: "button",
		tabindex: "0",
		animated: !0
	},
	_calculateElevation: function() {
		var a = 1;
		this.disabled ? a = 0 : this.active || this.pressed ? a = 4 : this.receivedFocusFromKeyboard && (a = 3);
		this._setElevation(a)
	},
	_computeKeyboardClass: function(a) {
		this.toggleClass("keyboard-focus", a)
	},
	_spaceKeyDownHandler: function(a) {
		Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, a);
		this.hasRipple() && 1 > this.getRipple().ripples.length && this._ripple.uiDownAction()
	},
	_spaceKeyUpHandler: function(a) {
		Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, a);
		this.hasRipple() && this._ripple.uiUpAction()
	}
};
Polymer.PaperButtonBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperButtonBehaviorImpl];
U.PaperBehaviors.PaperInkyFocusBehavior = {};
Polymer.PaperInkyFocusBehaviorImpl = {
	observers: ["_focusedChanged(receivedFocusFromKeyboard)"],
	_focusedChanged: function(a) {
		a && this.ensureRipple();
		this.hasRipple() && (this._ripple.holdDown = a)
	},
	_createRipple: function() {
		var a = Polymer.PaperRippleBehavior._createRipple();
		a.id = "ink";
		a.setAttribute("center", "");
		a.classList.add("circle");
		return a
	}
};
Polymer.PaperInkyFocusBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.PaperInkyFocusBehaviorImpl];
U.IronFormElementBehavior = {};
U.IronFormElementBehavior.IronFormElementBehavior = {};
Polymer.IronFormElementBehavior = {
	properties: {
		name: {
			type: String
		},
		value: {
			notify: !0,
			type: String
		},
		required: {
			type: Boolean,
			value: !1
		},
		_parentForm: {
			type: Object
		}
	},
	attached: function() {
		this.fire("iron-form-element-register")
	},
	detached: function() {
		this._parentForm && this._parentForm.fire("iron-form-element-unregister", {
			target: this
		})
	}
};
U.IronValidatableBehavior = {};
U.IronValidatableBehavior.IronValidatableBehavior = {};
Polymer.IronValidatableBehaviorMeta = null;
Polymer.IronValidatableBehavior = {
	properties: {
		validator: {
			type: String
		},
		invalid: {
			notify: !0,
			reflectToAttribute: !0,
			type: Boolean,
			value: !1
		},
		_validatorMeta: {
			type: Object
		},
		validatorType: {
			type: String,
			value: "validator"
		},
		_validator: {
			type: Object,
			computed: "__computeValidator(validator)"
		}
	},
	observers: ["_invalidChanged(invalid)"],
	registered: function() {
		Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({
			type: "validator"
		})
	},
	_invalidChanged: function() {
		this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")
	},
	hasValidator: function() {
		return null != this._validator
	},
	validate: function(a) {
		this.invalid = !this._getValidity(a);
		return !this.invalid
	},
	_getValidity: function(a) {
		return this.hasValidator() ? this._validator.validate(a) : !0
	},
	__computeValidator: function() {
		return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator)
	}
};
U.IronCheckedElementBehavior = {};
U.IronCheckedElementBehavior.IronCheckedElementBehavior = {};
Polymer.IronCheckedElementBehaviorImpl = {
	properties: {
		checked: {
			type: Boolean,
			value: !1,
			reflectToAttribute: !0,
			notify: !0,
			observer: "_checkedChanged"
		},
		toggles: {
			type: Boolean,
			value: !0,
			reflectToAttribute: !0
		},
		value: {
			type: String,
			value: "on",
			observer: "_valueChanged"
		}
	},
	observers: ["_requiredChanged(required)"],
	created: function() {
		this._hasIronCheckedElementBehavior = !0
	},
	_getValidity: function(a) {
		return this.disabled || !this.required || this.required && this.checked
	},
	_requiredChanged: function() {
		this.required ? this.setAttribute("aria-required",
			"true") : this.removeAttribute("aria-required")
	},
	_checkedChanged: function() {
		this.active = this.checked;
		this.fire("iron-change")
	},
	_valueChanged: function() {
		if (void 0 === this.value || null === this.value) this.value = "on"
	}
};
Polymer.IronCheckedElementBehavior = [Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior, Polymer.IronCheckedElementBehaviorImpl];
U.PaperBehaviors.PaperCheckedElementBehavior = {};
Polymer.PaperCheckedElementBehaviorImpl = {
	_checkedChanged: function() {
		Polymer.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
		this.hasRipple() && (this.checked ? this._ripple.setAttribute("checked", "") : this._ripple.removeAttribute("checked"))
	},
	_buttonStateChanged: function() {
		Polymer.PaperRippleBehavior._buttonStateChanged.call(this);
		!this.disabled && this.isAttached && (this.checked = this.active)
	}
};
Polymer.PaperCheckedElementBehavior = [Polymer.PaperInkyFocusBehavior, Polymer.IronCheckedElementBehavior, Polymer.PaperCheckedElementBehaviorImpl];
U.PaperStyles = {};
U.PaperStyles.Classes = {};
U.PaperStyles.Classes.Shadow = {};
U.FontRoboto = {};
U.FontRoboto.Roboto = {};
U.PaperStyles.Classes.Typography = {};
U.PaperStyles.PaperStylesClasses = {};
U.PaperStyles.Classes.Global = {};
U.PaperStyles.Classes.ShadowLayout = {};
U.PaperStyles.Color = {};
U.PaperStyles.DefaultTheme = {};
U.PaperStyles.Shadow = {};
U.PaperStyles.Typography = {};
U.PaperStyles.DemoPages = {};
U.PaperStyles.PaperStyles = {};
U.PaperMaterial = {};
U.PaperMaterial.PaperMaterialSharedStyles = {};
U.PaperMaterial.PaperMaterial = {};
var Va = function() {};
Polymer({
	is: "paper-material",
	properties: {
		elevation: {
			type: Number,
			reflectToAttribute: !0,
			value: 1
		},
		animated: {
			type: Boolean,
			reflectToAttribute: !0,
			value: !1
		}
	}
});
U.PaperButton = {};
U.PaperButton.PaperButton = {};
var cb = function() {};
q = cb.prototype;
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._buttonStateChanged = function() {
	this.focused && this.ensureRipple()
};
q._downHandler = function(a) {
	Polymer.IronButtonStateImpl._downHandler.call(this, a);
	this.pressed && this.ensureRipple(a)
};
q.ensureRipple = function(a) {
	if (!this.hasRipple()) {
		this._ripple = this._createRipple();
		this._ripple.noink = this.noink;
		var b = this._rippleContainer || this.root;
		b && Polymer.dom(b).appendChild(this._ripple);
		if (a) {
			var b = Polymer.dom(this._rippleContainer || this),
				c = Polymer.dom(a).rootTarget;
			b.deepContains(c) && this._ripple.uiDownAction(a)
		}
	}
};
q.getRipple = function() {
	this.ensureRipple();
	return this._ripple
};
q.hasRipple = function() {
	return !!this._ripple
};
q._createRipple = function() {
	return document.createElement("paper-ripple")
};
q._noinkChanged = function(a) {
	this.hasRipple() && (this._ripple.noink = a)
};
q._computeKeyboardClass = function(a) {
	this.toggleClass("keyboard-focus", a)
};
q._spaceKeyDownHandler = function(a) {
	Polymer.IronButtonStateImpl._spaceKeyDownHandler.call(this, a);
	this.hasRipple() && 1 > this.getRipple().ripples.length && this._ripple.uiDownAction()
};
q._spaceKeyUpHandler = function(a) {
	Polymer.IronButtonStateImpl._spaceKeyUpHandler.call(this, a);
	this.hasRipple() && this._ripple.uiUpAction()
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
q._setElevation = function(a) {};
Polymer({
	is: "paper-button",
	behaviors: [Polymer.PaperButtonBehavior],
	properties: {
		raised: {
			type: Boolean,
			reflectToAttribute: !0,
			value: !1,
			observer: "_calculateElevation"
		}
	},
	_calculateElevation: function() {
		this.raised ? Polymer.PaperButtonBehaviorImpl._calculateElevation.apply(this) : this._setElevation(0)
	}
});
U.PaperCheckbox = {};
U.PaperCheckbox.PaperCheckbox = {};
var fb = function() {};
q = fb.prototype;
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._downHandler = function(a) {
	Polymer.IronButtonStateImpl._downHandler.call(this, a);
	this.pressed && this.ensureRipple(a)
};
q.ensureRipple = function(a) {
	if (!this.hasRipple()) {
		this._ripple = this._createRipple();
		this._ripple.noink = this.noink;
		var b = this._rippleContainer || this.root;
		b && Polymer.dom(b).appendChild(this._ripple);
		if (a) {
			var b = Polymer.dom(this._rippleContainer || this),
				c = Polymer.dom(a).rootTarget;
			b.deepContains(c) && this._ripple.uiDownAction(a)
		}
	}
};
q.getRipple = function() {
	this.ensureRipple();
	return this._ripple
};
q.hasRipple = function() {
	return !!this._ripple
};
q._noinkChanged = function(a) {
	this.hasRipple() && (this._ripple.noink = a)
};
q._focusedChanged = function(a) {
	a && this.ensureRipple();
	this.hasRipple() && (this._ripple.holdDown = a)
};
q.registered = function() {
	Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({
		type: "validator"
	})
};
q._invalidChanged = function() {
	this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")
};
q.hasValidator = function() {
	return null != this._validator
};
q.validate = function(a) {
	this.invalid = !this._getValidity(a);
	return !this.invalid
};
q.__computeValidator = function() {
	return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator)
};
q._getValidity = function(a) {
	return this.disabled || !this.required || this.required && this.checked
};
q._requiredChanged = function() {
	this.required ? this.setAttribute("aria-required", "true") : this.removeAttribute("aria-required")
};
q._valueChanged = function() {
	if (void 0 === this.value || null === this.value) this.value = "on"
};
q._checkedChanged = function() {
	Polymer.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
	this.hasRipple() && (this.checked ? this._ripple.setAttribute("checked", "") : this._ripple.removeAttribute("checked"))
};
q._buttonStateChanged = function() {
	Polymer.PaperRippleBehavior._buttonStateChanged.call(this);
	!this.disabled && this.isAttached && (this.checked = this.active)
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
Polymer({
	is: "paper-checkbox",
	behaviors: [Polymer.PaperCheckedElementBehavior],
	hostAttributes: {
		role: "checkbox",
		"aria-checked": !1,
		tabindex: 0
	},
	properties: {
		ariaActiveAttribute: {
			type: String,
			value: "aria-checked"
		}
	},
	attached: function() {
		var a = this.getComputedStyleValue("--calculated-paper-checkbox-ink-size");
		if ("-1px" === a) {
			var a = parseFloat(this.getComputedStyleValue("--calculated-paper-checkbox-size")),
				b = Math.floor(8 / 3 * a);
			b % 2 !== a % 2 && b++;
			this.customStyle["--paper-checkbox-ink-size"] = b + "px";
			this.updateStyles()
		}
	},
	_computeCheckboxClass: function(a, b) {
		var c = "";
		a && (c += "checked ");
		b && (c += "invalid");
		return c
	},
	_computeCheckmarkClass: function(a) {
		return a ? "" : "hidden"
	},
	_createRipple: function() {
		this._rippleContainer = this.$.checkboxContainer;
		return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this)
	}
});
U.NeonAnimation = {};
U.NeonAnimation.NeonAnimationBehavior = {};
Polymer.NeonAnimationBehavior = {
	properties: {
		animationTiming: {
			type: Object,
			value: function() {
				return {
					duration: 500,
					easing: "cubic-bezier(0.4, 0, 0.2, 1)",
					fill: "both"
				}
			}
		}
	},
	isNeonAnimation: !0,
	timingFromConfig: function(a) {
		if (a.timing)
			for (var b in a.timing) this.animationTiming[b] = a.timing[b];
		return this.animationTiming
	},
	setPrefixedProperty: function(a, b, c) {
		for (var d = {
				transform: ["webkitTransform"],
				transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
			}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
		a.style[b] = c
	},
	complete: function() {}
};
/*

 Copyright 2014 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
     You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     See the License for the specific language governing permissions and
 limitations under the License.
*/
(function() {
	! function(a, b) {
		var c = {},
			d = {},
			e = {};
		! function(a, b) {
			function c(a) {
				if ("number" == typeof a) return a;
				var b = {},
					c;
				for (c in a) b[c] = a[c];
				return b
			}

			function d() {
				this._endDelay = this._delay = 0;
				this._fill = "none";
				this._iterationStart = 0;
				this._iterations = 1;
				this._duration = 0;
				this._playbackRate = 1;
				this._direction = "normal";
				this._easing = "linear";
				this._easingFunction = G
			}

			function e() {
				return a.isDeprecated("Invalid timing inputs", "2016-03-02", "TypeError exceptions will be thrown instead.", !0)
			}

			function f(b, c, e) {
				var f =
					new d;
				return c && (f.fill = "both", f.duration = "auto"), "number" != typeof b || isNaN(b) ? void 0 !== b && Object.getOwnPropertyNames(b).forEach(function(c) {
					"auto" == b[c] || ("number" == typeof f[c] || "duration" == c) && ("number" != typeof b[c] || isNaN(b[c])) || "fill" == c && -1 == D.indexOf(b[c]) || "direction" == c && -1 == z.indexOf(b[c]) || "playbackRate" == c && 1 !== b[c] && a.isDeprecated("AnimationEffectTiming.playbackRate", "2014-11-28", "Use Animation.playbackRate instead.") || (f[c] = b[c])
				}) : f.duration = b, f
			}

			function g(a) {
				return "number" == typeof a &&
					(a = isNaN(a) ? {
						duration: 0
					} : {
						duration: a
					}), a
			}

			function r(b, c) {
				return b = a.numericTimingToObject(b), f(b, c)
			}

			function t(a, b, c, d) {
				return 0 > a || 1 < a || 0 > c || 1 < c ? G : function(e) {
					if (0 == e || 1 == e) return e;
					for (var f = 0, g = 1;;) {
						var h = (f + g) / 2,
							k = 3 * a * (1 - h) * (1 - h) * h + 3 * c * (1 - h) * h * h + h * h * h;
						if (1E-4 > Math.abs(e - k)) return 3 * b * (1 - h) * (1 - h) * h + 3 * d * (1 - h) * h * h + h * h * h;
						e > k ? f = h : g = h
					}
				}
			}

			function u(a, b) {
				return function(c) {
					if (1 <= c) return 1;
					var d = 1 / a;
					return c += b * d, c - c % d
				}
			}

			function w(a) {
				J || (J = document.createElement("div").style);
				J.animationTimingFunction =
					"";
				J.animationTimingFunction = a;
				var b = J.animationTimingFunction;
				if ("" == b && e()) throw new TypeError(a + " is not a valid value for easing");
				return (a = P.exec(b)) ? t.apply(this, a.slice(1).map(Number)) : (a = L.exec(b)) ? u(Number(a[1]), {
					start: A,
					middle: H,
					end: O
				}[a[2]]) : (b = M[b]) ? b : G
			}

			function v(a) {
				return Math.abs(a.duration * a.iterations / a.playbackRate)
			}

			function x(a, b, c) {
				return null == b ? Q : b < c.delay ? S : b >= c.delay + a ? K : X
			}

			function y(a, b, c) {
				var d = x(a, b, c);
				a: {
					var e = c.fill;
					switch (d) {
						case S:
							b = "backwards" == e || "both" == e ? 0 : null;
							break a;
						case X:
							b -= c.delay;
							break a;
						case K:
							b = "forwards" == e || "both" == e ? a : null;
							break a;
						case Q:
							b = null;
							break a
					}
					b = void 0
				}
				if (null === b) return null;
				if (0 === a) return d === S ? 0 : 1;
				d = c.iterationStart * c.duration;
				b = (0 > c.playbackRate ? b - a : b) * c.playbackRate + d;
				a = c.duration;
				a = b === 1 / 0 || b === -(1 / 0) || b - d == c.duration * c.iterations && c.iterations && 0 == (c.iterations + c.iterationStart) % 1 ? a : b % a;
				d = c.duration;
				b = 0 === b ? 0 : a == d ? c.iterationStart + c.iterations - 1 : Math.floor(b / d);
				d = c.duration;
				b = 1 <= b % 2;
				a = (b = "normal" == c.direction || c.direction == (b ?
					"alternate-reverse" : "alternate")) ? a : d - a;
				a /= d;
				a = d * c._easingFunction(a);
				return a / c.duration
			}
			var D = ["backwards", "forwards", "both", "none"],
				z = ["reverse", "alternate", "alternate-reverse"],
				G = function(a) {
					return a
				};
			d.prototype = {
				_setMember: function(b, c) {
					this["_" + b] = c;
					this._effect && (this._effect._timingInput[b] = c, this._effect._timing = a.normalizeTimingInput(this._effect._timingInput), this._effect.activeDuration = a.calculateActiveDuration(this._effect._timing), this._effect._animation && this._effect._animation._rebuildUnderlyingAnimation())
				},
				get playbackRate() {
					return this._playbackRate
				},
				set delay(a) {
					this._setMember("delay", a)
				},
				get delay() {
					return this._delay
				},
				set endDelay(a) {
					this._setMember("endDelay", a)
				},
				get endDelay() {
					return this._endDelay
				},
				set fill(a) {
					this._setMember("fill", a)
				},
				get fill() {
					return this._fill
				},
				set iterationStart(a) {
					if ((isNaN(a) || 0 > a) && e()) throw new TypeError("iterationStart must be a non-negative number, received: " + timing.iterationStart);
					this._setMember("iterationStart", a)
				},
				get iterationStart() {
					return this._iterationStart
				},
				set duration(a) {
					if ("auto" != a && (isNaN(a) || 0 > a) && e()) throw new TypeError("duration must be non-negative or auto, received: " + a);
					this._setMember("duration", a)
				},
				get duration() {
					return this._duration
				},
				set direction(a) {
					this._setMember("direction", a)
				},
				get direction() {
					return this._direction
				},
				set easing(a) {
					this._easingFunction = w(a);
					this._setMember("easing", a)
				},
				get easing() {
					return this._easing
				},
				set iterations(a) {
					if ((isNaN(a) || 0 > a) && e()) throw new TypeError("iterations must be non-negative, received: " + a);
					this._setMember("iterations",
						a)
				},
				get iterations() {
					return this._iterations
				}
			};
			var A = 1,
				H = .5,
				O = 0,
				M = {
					ease: t(.25, .1, .25, 1),
					"ease-in": t(.42, 0, 1, 1),
					"ease-out": t(0, 0, .58, 1),
					"ease-in-out": t(.42, 0, .58, 1),
					"step-start": u(1, A),
					"step-middle": u(1, H),
					"step-end": u(1, O)
				},
				J = null,
				P = /cubic-bezier\(\s*(-?\d+\.?\d*|-?\.\d+)\s*,\s*(-?\d+\.?\d*|-?\.\d+)\s*,\s*(-?\d+\.?\d*|-?\.\d+)\s*,\s*(-?\d+\.?\d*|-?\.\d+)\s*\)/,
				L = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,
				Q = 0,
				S = 1,
				K = 2,
				X = 3;
			a.cloneTimingInput = c;
			a.makeTiming = f;
			a.numericTimingToObject = g;
			a.normalizeTimingInput =
				r;
			a.calculateActiveDuration = v;
			a.calculateTimeFraction = y;
			a.calculatePhase = x;
			a.toTimingFunction = w
		}(c, null);
		(function(a, b) {
			function c(a) {
				var b = [],
					c;
				for (c in a)
					if (!(c in ["easing", "offset", "composite"])) {
						var d = a[c];
						Array.isArray(d) || (d = [d]);
						for (var e, f = d.length, g = 0; f > g; g++) e = {}, "offset" in a ? e.offset = a.offset : 1 == f ? e.offset = 1 : e.offset = g / (f - 1), "easing" in a && (e.easing = a.easing), "composite" in a && (e.composite = a.composite), e[c] = d[g], b.push(e)
					}
				return b.sort(function(a, b) {
					return a.offset - b.offset
				}), b
			}

			function d(a) {
				function b() {
					var a =
						d.length;
					null == d[a - 1].offset && (d[a - 1].offset = 1);
					1 < a && null == d[0].offset && (d[0].offset = 0);
					for (var b = 0, c = d[0].offset, e = 1; a > e; e++) {
						var f = d[e].offset;
						if (null != f) {
							for (var g = 1; e - b > g; g++) d[b + g].offset = c + (f - c) * g / (e - b);
							b = e;
							c = f
						}
					}
				}
				if (null == a) return [];
				window.Symbol && Symbol.iterator && Array.prototype.from && a[Symbol.iterator] && (a = Array.from(a));
				Array.isArray(a) || (a = c(a));
				var d = a.map(function(a) {
					var b = {},
						c;
					for (c in a) {
						var d = a[c];
						if ("offset" == c) {
							if (null != d && (d = Number(d), !isFinite(d))) throw new TypeError("keyframe offsets must be numbers.");
						} else {
							if ("composite" == c) throw {
								type: DOMException.NOT_SUPPORTED_ERR,
								name: "NotSupportedError",
								message: "add compositing is not supported"
							};
							d = "" + d
						}
						var h = void 0,
							k = c,
							l = d,
							d = b,
							m = e[k];
						if (m)
							for (h in f.style[k] = l, m) k = m[h], l = f.style[k], d[k] = k in g ? g[k][l] || l : l;
						else d[k] = k in g ? g[k][l] || l : l
					}
					return void 0 == b.offset && (b.offset = null), b
				});
				a = !0;
				for (var h = -(1 / 0), k = 0; k < d.length; k++) {
					var l = d[k].offset;
					if (null != l) {
						if (h > l) throw {
							code: DOMException.INVALID_MODIFICATION_ERR,
							name: "InvalidModificationError",
							message: "Keyframes are not loosely sorted by offset. Sort or specify offsets."
						};
						h = l
					} else a = !1
				}
				return d = d.filter(function(a) {
					return 0 <= a.offset && 1 >= a.offset
				}), a || b(), d
			}
			var e = {
					background: "backgroundImage backgroundPosition backgroundSize backgroundRepeat backgroundAttachment backgroundOrigin backgroundClip backgroundColor".split(" "),
					border: "borderTopColor borderTopStyle borderTopWidth borderRightColor borderRightStyle borderRightWidth borderBottomColor borderBottomStyle borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth".split(" "),
					borderBottom: ["borderBottomWidth",
						"borderBottomStyle", "borderBottomColor"
					],
					borderColor: ["borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor"],
					borderLeft: ["borderLeftWidth", "borderLeftStyle", "borderLeftColor"],
					borderRadius: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
					borderRight: ["borderRightWidth", "borderRightStyle", "borderRightColor"],
					borderTop: ["borderTopWidth", "borderTopStyle", "borderTopColor"],
					borderWidth: ["borderTopWidth", "borderRightWidth", "borderBottomWidth",
						"borderLeftWidth"
					],
					flex: ["flexGrow", "flexShrink", "flexBasis"],
					font: "fontFamily fontSize fontStyle fontVariant fontWeight lineHeight".split(" "),
					margin: ["marginTop", "marginRight", "marginBottom", "marginLeft"],
					outline: ["outlineColor", "outlineStyle", "outlineWidth"],
					padding: ["paddingTop", "paddingRight", "paddingBottom", "paddingLeft"]
				},
				f = document.createElementNS("http://www.w3.org/1999/xhtml", "div");
			b = {
				thin: "1px",
				medium: "3px",
				thick: "5px"
			};
			var g = {
				borderBottomWidth: b,
				borderLeftWidth: b,
				borderRightWidth: b,
				borderTopWidth: b,
				fontSize: {
					"xx-small": "60%",
					"x-small": "75%",
					small: "89%",
					medium: "100%",
					large: "120%",
					"x-large": "150%",
					"xx-large": "200%"
				},
				fontWeight: {
					normal: "400",
					bold: "700"
				},
				outlineWidth: b,
				textShadow: {
					none: "0px 0px 0px transparent"
				},
				boxShadow: {
					none: "0px 0px 0px 0px transparent"
				}
			};
			a.convertToArrayForm = c;
			a.normalizeKeyframes = d
		})(c, null);
		(function(a) {
			var b = {};
			a.isDeprecated = function(a, c, d, e) {
				e = e ? "are" : "is";
				var f = new Date;
				c = new Date(c);
				return c.setMonth(c.getMonth() + 3), c > f ? (a in b || console.warn("Web Animations: " + a + " " +
					e + " deprecated and will stop working on " + c.toDateString() + ". " + d), b[a] = !0, !1) : !0
			};
			a.deprecated = function(b, c, d, e) {
				var f = e ? "are" : "is";
				if (a.isDeprecated(b, c, d, e)) throw Error(b + " " + f + " no longer supported. " + d);
			}
		})(c);
		(function() {
			if (document.documentElement.animate) {
				var a = document.documentElement.animate([], 0),
					b = !0;
				if (a && (b = !1, "play currentTime pause reverse playbackRate cancel finish startTime playState".split(" ").forEach(function(c) {
						void 0 === a[c] && (b = !0)
					})), !b) return
			}! function(a, b, c) {
				function d(a) {
					for (var b = {}, c = 0; c < a.length; c++)
						for (var d in a[c])
							if ("offset" != d && "easing" != d && "composite" != d) {
								var e = {
									offset: a[c].offset,
									easing: a[c].easing,
									value: a[c][d]
								};
								b[d] = b[d] || [];
								b[d].push(e)
							}
					for (var f in b)
						if (a = b[f], 0 != a[0].offset || 1 != a[a.length - 1].offset) throw {
							type: DOMException.NOT_SUPPORTED_ERR,
							name: "NotSupportedError",
							message: "Partial keyframes are not supported"
						};
					return b
				}

				function e(c) {
					var d = [],
						e;
					for (e in c)
						for (var f = c[e], g = 0; g < f.length - 1; g++) {
							var h = f[g].offset,
								k = f[g + 1].offset,
								l = f[g].value,
								m = f[g + 1].value,
								n = f[g].easing;
							h == k && (1 == k ? l = m : m = l);
							d.push({
								startTime: h,
								endTime: k,
								easing: a.toTimingFunction(n ? n : "linear"),
								property: e,
								interpolation: b.propertyInterpolation(e, l, m)
							})
						}
					return d.sort(function(a, b) {
						return a.startTime - b.startTime
					}), d
				}
				b.convertEffectInput = function(c) {
					c = a.normalizeKeyframes(c);
					var f = d(c),
						g = e(f);
					return function(a, c) {
						if (null != c) g.filter(function(a) {
							return 0 >= c && 0 == a.startTime || 1 <= c && 1 == a.endTime || c >= a.startTime && c <= a.endTime
						}).forEach(function(d) {
							var e = c - d.startTime,
								f = d.endTime - d.startTime,
								e = 0 == f ? 0 : d.easing(e /
									f);
							b.apply(a, d.property, d.interpolation(e))
						});
						else
							for (var d in f) "offset" != d && "easing" != d && "composite" != d && b.clear(a, d)
					}
				}
			}(c, d, null);
			(function(a, b, c) {
				function d(a) {
					return a.replace(/-(.)/g, function(a, b) {
						return b.toUpperCase()
					})
				}

				function e(a, b, c) {
					for (var e = 0; e < c.length; e++) {
						var f = c[e],
							h = a,
							k = b,
							f = d(f);
						g[f] = g[f] || [];
						g[f].push([h, k])
					}
				}

				function f(c, e, f) {
					var k = c;
					/-/.test(c) && !a.isDeprecated("Hyphenated property names", "2016-03-22", "Use camelCase instead.", !0) && (k = d(c));
					"initial" != e && "initial" != f || ("initial" ==
						e && (e = h[k]), "initial" == f && (f = h[k]));
					c = e == f ? [] : g[k];
					for (k = 0; c && k < c.length; k++) {
						var l = c[k][0](e),
							m = c[k][0](f);
						if (void 0 !== l && void 0 !== m && (l = c[k][1](l, m))) {
							var n = b.Interpolation.apply(null, l);
							return function(a) {
								return 0 == a ? e : 1 == a ? f : n(a)
							}
						}
					}
					return b.Interpolation(!1, !0, function(a) {
						return a ? f : e
					})
				}
				var g = {};
				b.addPropertiesHandler = e;
				var h = {
					backgroundColor: "transparent",
					backgroundPosition: "0% 0%",
					borderBottomColor: "currentColor",
					borderBottomLeftRadius: "0px",
					borderBottomRightRadius: "0px",
					borderBottomWidth: "3px",
					borderLeftColor: "currentColor",
					borderLeftWidth: "3px",
					borderRightColor: "currentColor",
					borderRightWidth: "3px",
					borderSpacing: "2px",
					borderTopColor: "currentColor",
					borderTopLeftRadius: "0px",
					borderTopRightRadius: "0px",
					borderTopWidth: "3px",
					bottom: "auto",
					clip: "rect(0px, 0px, 0px, 0px)",
					color: "black",
					fontSize: "100%",
					fontWeight: "400",
					height: "auto",
					left: "auto",
					letterSpacing: "normal",
					lineHeight: "120%",
					marginBottom: "0px",
					marginLeft: "0px",
					marginRight: "0px",
					marginTop: "0px",
					maxHeight: "none",
					maxWidth: "none",
					minHeight: "0px",
					minWidth: "0px",
					opacity: "1.0",
					outlineColor: "invert",
					outlineOffset: "0px",
					outlineWidth: "3px",
					paddingBottom: "0px",
					paddingLeft: "0px",
					paddingRight: "0px",
					paddingTop: "0px",
					right: "auto",
					textIndent: "0px",
					textShadow: "0px 0px 0px transparent",
					top: "auto",
					transform: "",
					verticalAlign: "0px",
					visibility: "visible",
					width: "auto",
					wordSpacing: "normal",
					zIndex: "auto"
				};
				b.propertyInterpolation = f
			})(c, d, null);
			(function(a, b, c) {
				function d(b) {
					var c = a.calculateActiveDuration(b),
						d = function(d) {
							return a.calculateTimeFraction(c, d, b)
						};
					return d._totalDuration = b.delay + c + b.endDelay, d._isCurrent = function(d) {
						d = a.calculatePhase(c, d, b);
						return d === PhaseActive || d === PhaseBefore
					}, d
				}
				b.KeyframeEffect = function(c, e, f, g) {
					var h, k = d(a.normalizeTimingInput(f)),
						l = b.convertEffectInput(e);
					e = function() {
						l(c, h)
					};
					return e._update = function(a) {
						return h = k(a), null !== h
					}, e._clear = function() {
						l(c, null)
					}, e._hasSameTarget = function(a) {
						return c === a
					}, e._isCurrent = k._isCurrent, e._totalDuration = k._totalDuration, e._id = g, e
				};
				b.NullEffect = function(a) {
					var b = function() {
						a &&
							(a(), a = null)
					};
					return b._update = function() {
						return null
					}, b._totalDuration = 0, b._isCurrent = function() {
						return !1
					}, b._hasSameTarget = function() {
						return !1
					}, b
				}
			})(c, d, null);
			(function(a, b) {
				a.apply = function(b, c, d) {
					b.style[a.propertyName(c)] = d
				};
				a.clear = function(b, c) {
					b.style[a.propertyName(c)] = ""
				}
			})(d, null);
			(function(a) {
				window.Element.prototype.animate = function(b, c) {
					var d = "";
					return c && c.id && (d = c.id), a.timeline._play(a.KeyframeEffect(this, b, c, d))
				}
			})(d);
			(function(a, b) {
				function c(a, b, d) {
					if ("number" == typeof a && "number" ==
						typeof b) return a * (1 - d) + b * d;
					if ("boolean" == typeof a && "boolean" == typeof b) return .5 > d ? a : b;
					if (a.length == b.length) {
						for (var e = [], f = 0; f < a.length; f++) e.push(c(a[f], b[f], d));
						return e
					}
					throw "Mismatched interpolation arguments " + a + ":" + b;
				}
				a.Interpolation = function(a, b, d) {
					return function(e) {
						return d(c(a, b, e))
					}
				}
			})(d, null);
			(function(a, b, c) {
				a.sequenceNumber = 0;
				var d = function(a, b, c) {
					this.target = a;
					this.currentTime = b;
					this.timelineTime = c;
					this.type = "finish";
					this.cancelable = this.bubbles = !1;
					this.currentTarget = a;
					this.defaultPrevented = !1;
					this.eventPhase = Event.AT_TARGET;
					this.timeStamp = Date.now()
				};
				b.Animation = function(b) {
					this.id = "";
					b && b._id && (this.id = b._id);
					this._sequenceNumber = a.sequenceNumber++;
					this._currentTime = 0;
					this._startTime = null;
					this._paused = !1;
					this._playbackRate = 1;
					this._finishedFlag = this._inTimeline = !0;
					this.onfinish = null;
					this._finishHandlers = [];
					this._effect = b;
					this._inEffect = this._effect._update(0);
					this._idle = !0;
					this._currentTimePending = !1
				};
				b.Animation.prototype = {
					_ensureAlive: function() {
						0 > this.playbackRate && 0 === this.currentTime ?
							this._inEffect = this._effect._update(-1) : this._inEffect = this._effect._update(this.currentTime);
						this._inTimeline || !this._inEffect && this._finishedFlag || (this._inTimeline = !0, b.timeline._animations.push(this))
					},
					_tickCurrentTime: function(a, b) {
						a != this._currentTime && (this._currentTime = a, this._isFinished && !b && (this._currentTime = 0 < this._playbackRate ? this._totalDuration : 0), this._ensureAlive())
					},
					get currentTime() {
						return this._idle || this._currentTimePending ? null : this._currentTime
					},
					set currentTime(a) {
						a = +a;
						isNaN(a) ||
							(b.restart(), this._paused || null == this._startTime || (this._startTime = this._timeline.currentTime - a / this._playbackRate), this._currentTimePending = !1, this._currentTime != a && (this._tickCurrentTime(a, !0), b.invalidateEffects()))
					},
					get startTime() {
						return this._startTime
					},
					set startTime(a) {
						a = +a;
						isNaN(a) || this._paused || this._idle || (this._startTime = a, this._tickCurrentTime((this._timeline.currentTime - this._startTime) * this.playbackRate), b.invalidateEffects())
					},
					get playbackRate() {
						return this._playbackRate
					},
					set playbackRate(a) {
						if (a !=
							this._playbackRate) {
							var b = this.currentTime;
							this._playbackRate = a;
							this._startTime = null;
							"paused" != this.playState && "idle" != this.playState && this.play();
							null != b && (this.currentTime = b)
						}
					},
					get _isFinished() {
						return !this._idle && (0 < this._playbackRate && this._currentTime >= this._totalDuration || 0 > this._playbackRate && 0 >= this._currentTime)
					},
					get _totalDuration() {
						return this._effect._totalDuration
					},
					get playState() {
						return this._idle ? "idle" : null == this._startTime && !this._paused && 0 != this.playbackRate || this._currentTimePending ?
							"pending" : this._paused ? "paused" : this._isFinished ? "finished" : "running"
					},
					play: function() {
						this._paused = !1;
						(this._isFinished || this._idle) && (this._currentTime = 0 < this._playbackRate ? 0 : this._totalDuration, this._startTime = null);
						this._idle = this._finishedFlag = !1;
						this._ensureAlive();
						b.invalidateEffects()
					},
					pause: function() {
						this._isFinished || this._paused || this._idle || (this._currentTimePending = !0);
						this._startTime = null;
						this._paused = !0
					},
					finish: function() {
						this._idle || (this.currentTime = 0 < this._playbackRate ? this._totalDuration :
							0, this._startTime = this._totalDuration - this.currentTime, this._currentTimePending = !1, b.invalidateEffects())
					},
					cancel: function() {
						this._inEffect && (this._inEffect = !1, this._idle = !0, this._finishedFlag = !0, this.currentTime = 0, this._startTime = null, this._effect._update(null), b.invalidateEffects())
					},
					reverse: function() {
						this.playbackRate *= -1;
						this.play()
					},
					addEventListener: function(a, b) {
						"function" == typeof b && "finish" == a && this._finishHandlers.push(b)
					},
					removeEventListener: function(a, b) {
						"finish" == a && (a = this._finishHandlers.indexOf(b),
							0 <= a && this._finishHandlers.splice(a, 1))
					},
					_fireEvents: function(a) {
						if (this._isFinished) {
							if (!this._finishedFlag) {
								var b = new d(this, this._currentTime, a),
									c = this._finishHandlers.concat(this.onfinish ? [this.onfinish] : []);
								setTimeout(function() {
									c.forEach(function(a) {
										a.call(b.target, b)
									})
								}, 0);
								this._finishedFlag = !0
							}
						} else this._finishedFlag = !1
					},
					_tick: function(a, b) {
						this._idle || this._paused || (null == this._startTime ? b && (this.startTime = a - this._currentTime / this.playbackRate) : this._isFinished || this._tickCurrentTime((a -
							this._startTime) * this.playbackRate));
						b && (this._currentTimePending = !1, this._fireEvents(a))
					},
					get _needsTick() {
						return this.playState in {
							pending: 1,
							running: 1
						} || !this._finishedFlag
					}
				}
			})(c, d, null);
			(function(a, b, c) {
				function d(a) {
					var b = l;
					l = [];
					a < A.currentTime && (a = A.currentTime);
					h(a, !0);
					b.forEach(function(b) {
						b[1](a)
					});
					g();
					y = void 0
				}

				function e(a, b) {
					return a._sequenceNumber - b._sequenceNumber
				}

				function f() {
					this._animations = [];
					this.currentTime = window.performance && performance.now ? performance.now() : 0
				}

				function g() {
					G.forEach(function(a) {
						a()
					});
					G.length = 0
				}

				function h(a, c) {
					z = !1;
					var d = b.timeline;
					d.currentTime = a;
					d._animations.sort(e);
					D = !1;
					var f = d._animations;
					d._animations = [];
					var g = [],
						h = [],
						f = f.filter(function(b) {
							b._tick(a, c);
							b._inEffect ? h.push(b._effect) : g.push(b._effect);
							b._needsTick && (D = !0);
							var d = b._inEffect || b._needsTick;
							return b._inTimeline = d, d
						});
					G.push.apply(G, g);
					G.push.apply(G, h);
					d._animations.push.apply(d._animations, f);
					D && requestAnimationFrame(function() {})
				}
				var k = window.requestAnimationFrame,
					l = [],
					x = 0;
				window.requestAnimationFrame = function(a) {
					var b =
						x++;
					return 0 == l.length && k(d), l.push([b, a]), b
				};
				window.cancelAnimationFrame = function(a) {
					l.forEach(function(b) {
						b[0] == a && (b[1] = function() {})
					})
				};
				f.prototype = {
					_play: function(c) {
						c._timing = a.normalizeTimingInput(c.timing);
						c = new b.Animation(c);
						return c._idle = !1, c._timeline = this, this._animations.push(c), b.restart(), b.invalidateEffects(), c
					}
				};
				var y = void 0,
					D = !1,
					z = !1;
				b.restart = function() {
					return D || (D = !0, requestAnimationFrame(function() {}), z = !0), z
				};
				b.invalidateEffects = function() {
					h(b.timeline.currentTime, !1);
					g()
				};
				var G = [],
					A = new f;
				b.timeline = A
			})(c, d, null);
			(function(a) {
				function b(a, b) {
					var c = a.exec(b);
					return c ? (c = a.ignoreCase ? c[0].toLowerCase() : c[0], [c, b.substr(c.length)]) : void 0
				}

				function c(a, b) {
					b = b.replace(/^\s*/, "");
					return (a = a(b)) ? [a[0], a[1].replace(/^\s*/, "")] : void 0
				}

				function d(a, d, e) {
					a = c.bind(null, a);
					for (var f = [];;) {
						var g = a(e);
						if (!g || (f.push(g[0]), e = g[1], g = b(d, e), !g || "" == g[1])) return [f, e];
						e = g[1]
					}
				}

				function e(a, b) {
					for (var c = 0, d = 0; d < b.length && (!/\s|,/.test(b[d]) || 0 != c); d++)
						if ("(" == b[d]) c++;
						else if (")" == b[d] &&
						(c--, 0 == c && d++, 0 >= c)) break;
					a = a(b.substr(0, d));
					return void 0 == a ? void 0 : [a, b.substr(d)]
				}

				function f(a, b) {
					for (var c = a, d = b; c && d;) c > d ? c %= d : d %= c;
					return c = a * b / (c + d)
				}

				function g(a) {
					return function(b) {
						b = a(b);
						return b && (b[0] = void 0), b
					}
				}

				function h(a, b) {
					return function(c) {
						var d = a(c);
						return d ? d : [b, c]
					}
				}

				function w(b, c) {
					for (var d = [], e = 0; e < b.length; e++) {
						c = a.consumeTrimmed(b[e], c);
						if (!c || "" == c[0]) return;
						void 0 !== c[0] && d.push(c[0]);
						c = c[1]
					}
					return "" == c ? d : void 0
				}

				function v(a, b, c, d, e) {
					for (var g = [], h = [], k = [], l = f(d.length,
							e.length), m = 0; l > m; m++) {
						var n = b(d[m % d.length], e[m % e.length]);
						if (!n) return;
						g.push(n[0]);
						h.push(n[1]);
						k.push(n[2])
					}
					return [g, h, function(b) {
						b = b.map(function(a, b) {
							return k[b](a)
						}).join(c);
						return a ? a(b) : b
					}]
				}

				function x(a, b, c) {
					for (var d = [], e = [], f = [], g = 0, h = 0; h < c.length; h++)
						if ("function" == typeof c[h]) {
							var k = c[h](a[g], b[g++]);
							d.push(k[0]);
							e.push(k[1]);
							f.push(k[2])
						} else ! function(a) {
							d.push(!1);
							e.push(!1);
							f.push(function() {
								return c[a]
							})
						}(h);
					return [d, e, function(a) {
						for (var b = "", c = 0; c < a.length; c++) b += f[c](a[c]);
						return b
					}]
				}
				a.consumeToken = b;
				a.consumeTrimmed = c;
				a.consumeRepeated = d;
				a.consumeParenthesised = e;
				a.ignore = g;
				a.optional = h;
				a.consumeList = w;
				a.mergeNestedRepeated = v.bind(null, null);
				a.mergeWrappedNestedRepeated = v;
				a.mergeList = x
			})(d);
			(function(a) {
				function b(b) {
					function c(b) {
						var c = a.consumeToken(/^inset/i, b);
						return c ? (d.inset = !0, c) : (c = a.consumeLengthOrPercent(b)) ? (d.lengths.push(c[0]), c) : (c = a.consumeColor(b)) ? (d.color = c[0], c) : void 0
					}
					var d = {
						inset: !1,
						lengths: [],
						color: null
					};
					return (b = a.consumeRepeated(c, /^/, b)) && b[0].length ? [d, b[1]] : void 0
				}

				function c(c) {
					return (c = a.consumeRepeated(b, /^,/, c)) && "" == c[1] ? c[0] : void 0
				}

				function d(b, c) {
					for (; b.lengths.length < Math.max(b.lengths.length, c.lengths.length);) b.lengths.push({
						px: 0
					});
					for (; c.lengths.length < Math.max(b.lengths.length, c.lengths.length);) c.lengths.push({
						px: 0
					});
					if (b.inset == c.inset && !!b.color == !!c.color) {
						for (var d, e = [], f = [
								[], 0
							], g = [
								[], 0
							], h = 0; h < b.lengths.length; h++) {
							var k = a.mergeDimensions(b.lengths[h], c.lengths[h], 2 == h);
							f[0].push(k[0]);
							g[0].push(k[1]);
							e.push(k[2])
						}
						b.color && c.color &&
							(c = a.mergeColors(b.color, c.color), f[1] = c[0], g[1] = c[1], d = c[2]);
						return [f, g, function(a) {
							for (var c = b.inset ? "inset " : " ", f = 0; f < e.length; f++) c += e[f](a[0][f]) + " ";
							return d && (c += d(a[1])), c
						}]
					}
				}

				function e(b, c, d, e) {
					function f(a) {
						return {
							inset: a,
							color: [0, 0, 0, 0],
							lengths: [{
								px: 0
							}, {
								px: 0
							}, {
								px: 0
							}, {
								px: 0
							}]
						}
					}
					for (var g = [], h = [], k = 0; k < d.length || k < e.length; k++) {
						var l = d[k] || f(e[k].inset),
							m = e[k] || f(d[k].inset);
						g.push(l);
						h.push(m)
					}
					return a.mergeNestedRepeated(b, c, g, h)
				}
				var f = e.bind(null, d, ", ");
				a.addPropertiesHandler(c, f, ["box-shadow",
					"text-shadow"
				])
			})(d);
			(function(a, b) {
				function c(a) {
					return a.toFixed(3).replace(".000", "")
				}

				function d(a, b, c) {
					return Math.min(b, Math.max(a, c))
				}

				function e(a) {
					return /^\s*[-+]?(\d*\.)?\d+\s*$/.test(a) ? Number(a) : void 0
				}

				function f(a, b) {
					return [a, b, c]
				}

				function g(a, b) {
					return 0 != a ? k(0, 1 / 0)(a, b) : void 0
				}

				function h(a, b) {
					return [a, b, function(a) {
						return Math.round(d(1, 1 / 0, a))
					}]
				}

				function k(a, b) {
					return function(e, f) {
						return [e, f, function(e) {
							return c(d(a, b, e))
						}]
					}
				}

				function v(a, b) {
					return [a, b, Math.round]
				}
				a.clamp = d;
				a.addPropertiesHandler(e,
					k(0, 1 / 0), ["border-image-width", "line-height"]);
				a.addPropertiesHandler(e, k(0, 1), ["opacity", "shape-image-threshold"]);
				a.addPropertiesHandler(e, g, ["flex-grow", "flex-shrink"]);
				a.addPropertiesHandler(e, h, ["orphans", "widows"]);
				a.addPropertiesHandler(e, v, ["z-index"]);
				a.parseNumber = e;
				a.mergeNumbers = f;
				a.numberToString = c
			})(d, null);
			(function(a, b) {
				function c(a, b) {
					return "visible" == a || "visible" == b ? [0, 1, function(c) {
						return 0 >= c ? a : 1 <= c ? b : "visible"
					}] : void 0
				}
				a.addPropertiesHandler(String, c, ["visibility"])
			})(d);
			(function(a,
				b) {
				function c(a) {
					a = a.trim();
					e.fillStyle = "#000";
					e.fillStyle = a;
					var b = e.fillStyle;
					if (e.fillStyle = "#fff", e.fillStyle = a, b == e.fillStyle) return e.fillRect(0, 0, 1, 1), a = e.getImageData(0, 0, 1, 1).data, e.clearRect(0, 0, 1, 1), b = a[3] / 255, [a[0] * b, a[1] * b, a[2] * b, b]
				}

				function d(b, c) {
					return [b, c, function(b) {
						if (b[3])
							for (var c = 0; 3 > c; c++) b[c] = Math.round(Math.max(0, Math.min(255, b[c] / b[3])));
						return b[3] = a.numberToString(a.clamp(0, 1, b[3])), "rgba(" + b.join(",") + ")"
					}]
				}
				b = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
				b.width = b.height = 1;
				var e = b.getContext("2d");
				a.addPropertiesHandler(c, d, "background-color border-bottom-color border-left-color border-right-color border-top-color color outline-color text-decoration-color".split(" "));
				a.consumeColor = a.consumeParenthesised.bind(null, c);
				a.mergeColors = d
			})(d, null);
			(function(a, b) {
				function c(a, b) {
					if (b = b.trim().toLowerCase(), "0" == b && 0 <= "px".search(a)) return {
						px: 0
					};
					if (/^[^(]*$|^calc/.test(b)) {
						b = b.replace(/calc\(/g, "(");
						var c = {};
						b = b.replace(a, function(a) {
							return c[a] = null, "U" +
								a
						});
						a = "U(" + a.source + ")";
						for (var d = b.replace(/[-+]?(\d*\.)?\d+/g, "N").replace(new RegExp("N" + a, "g"), "D").replace(/\s[+-]\s/g, "O").replace(/\s/g, ""), e = [/N\*(D)/g, /(N|D)[*\/]N/g, /(N|D)O\1/g, /\((N|D)\)/g], f = 0; f < e.length;) e[f].test(d) ? (d = d.replace(e[f], "$1"), f = 0) : f++;
						if ("D" == d) {
							for (var g in c) {
								d = eval(b.replace(new RegExp("U" + g, "g"), "").replace(new RegExp(a, "g"), "*0"));
								if (!isFinite(d)) return;
								c[g] = d
							}
							return c
						}
					}
				}

				function d(a, b) {
					return e(a, b, !0)
				}

				function e(b, c, d) {
					var e, f = [];
					for (e in b) f.push(e);
					for (e in c) 0 >
						f.indexOf(e) && f.push(e);
					return b = f.map(function(a) {
						return b[a] || 0
					}), c = f.map(function(a) {
						return c[a] || 0
					}), [b, c, function(b) {
						var c = b.map(function(c, e) {
							return 1 == b.length && d && (c = Math.max(c, 0)), a.numberToString(c) + f[e]
						}).join(" + ");
						return 1 < b.length ? "calc(" + c + ")" : c
					}]
				}
				var f = c.bind(null, /px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc/g);
				b = c.bind(null, /px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|%/g);
				var g = c.bind(null, /deg|rad|grad|turn/g);
				a.parseLength = f;
				a.parseLengthOrPercent = b;
				a.consumeLengthOrPercent =
					a.consumeParenthesised.bind(null, b);
				a.parseAngle = g;
				a.mergeDimensions = e;
				var f = a.consumeParenthesised.bind(null, f),
					f = a.consumeRepeated.bind(void 0, f, /^/),
					h = a.consumeRepeated.bind(void 0, f, /^,/);
				a.consumeSizePairList = h;
				var f = function(a) {
						return (a = h(a)) && "" == a[1] ? a[0] : void 0
					},
					g = a.mergeNestedRepeated.bind(void 0, d, " "),
					k = a.mergeNestedRepeated.bind(void 0, g, ",");
				a.mergeNonNegativeSizePair = g;
				a.addPropertiesHandler(f, k, ["background-size"]);
				a.addPropertiesHandler(b, d, "border-bottom-width border-image-width border-left-width border-right-width border-top-width flex-basis font-size height line-height max-height max-width outline-width width".split(" "));
				a.addPropertiesHandler(b, e, "border-bottom-left-radius border-bottom-right-radius border-top-left-radius border-top-right-radius bottom left letter-spacing margin-bottom margin-left margin-right margin-top min-height min-width outline-offset padding-bottom padding-left padding-right padding-top perspective right shape-margin text-indent top vertical-align word-spacing".split(" "))
			})(d, null);
			(function(a, b) {
				function c(b) {
					return a.consumeLengthOrPercent(b) || a.consumeToken(/^auto/, b)
				}

				function d(b) {
					return (b =
						a.consumeList([a.ignore(a.consumeToken.bind(null, /^rect/)), a.ignore(a.consumeToken.bind(null, /^\(/)), a.consumeRepeated.bind(null, c, /^,/), a.ignore(a.consumeToken.bind(null, /^\)/))], b)) && 4 == b[0].length ? b[0] : void 0
				}

				function e(b, c) {
					return "auto" == b || "auto" == c ? [!0, !1, function(d) {
						d = d ? b : c;
						if ("auto" == d) return "auto";
						d = a.mergeDimensions(d, d);
						return d[2](d[0])
					}] : a.mergeDimensions(b, c)
				}

				function f(a) {
					return "rect(" + a + ")"
				}
				b = a.mergeWrappedNestedRepeated.bind(null, f, e, ", ");
				a.parseBox = d;
				a.mergeBoxes = b;
				a.addPropertiesHandler(d,
					b, ["clip"])
			})(d, null);
			(function(a, b) {
				function c(a) {
					return function(b) {
						var c = 0;
						return a.map(function(a) {
							return a === v ? b[c++] : a
						})
					}
				}

				function d(a) {
					return a
				}

				function e(b) {
					if (b = b.toLowerCase().trim(), "none" == b) return [];
					for (var c, d = /\s*(\w+)\(([^)]*)\)/g, e = [], f = 0;
						(c = d.exec(b)) && c.index == f;) {
						var f = c.index + c[0].length,
							g = c[1],
							h = D[g];
						if (!h) break;
						c = c[2].split(",");
						h = h[0];
						if (h.length < c.length) break;
						for (var k = [], l = 0; l < h.length; l++) {
							var m, n = c[l],
								r = h[l];
							if (m = n ? {
									A: function(b) {
										return "0" == b.trim() ? y : a.parseAngle(b)
									},
									N: a.parseNumber,
									T: a.parseLengthOrPercent,
									L: a.parseLength
								}[r.toUpperCase()](n) : {
									a: y,
									n: k[0],
									t: x
								}[r], void 0 === m) return;
							k.push(m)
						}
						if (e.push({
								t: g,
								d: k
							}), d.lastIndex == b.length) return e
					}
				}

				function f(a) {
					return a.toFixed(6).replace(".000000", "")
				}

				function g(b, c) {
					if (b.decompositionPair !== c) {
						b.decompositionPair = c;
						var d = a.makeMatrixDecomposition(b)
					}
					if (c.decompositionPair !== b) {
						c.decompositionPair = b;
						var e = a.makeMatrixDecomposition(c)
					}
					return null == d[0] || null == e[0] ? [
						[!1],
						[!0],
						function(a) {
							return a ? c[0].d : b[0].d
						}
					] : (d[0].push(0),
						e[0].push(1), [d, e, function(b) {
							var c = a.quat(d[0][3], e[0][3], b[5]);
							b = a.composeMatrix(b[0], b[1], b[2], c, b[4]);
							return b = b.map(f).join(",")
						}])
				}

				function h(a) {
					return a.replace(/(x|y|z|3d)?$/, "3d")
				}

				function k(b, c) {
					var d = a.makeMatrixDecomposition && !0,
						e = !1;
					if (!b.length || !c.length) {
						b.length || (e = !0, b = c, c = []);
						for (var f = 0; f < b.length; f++) {
							var k = b[f].t,
								l = b[f].d,
								m = "scale" == k.substr(0, 5) ? 1 : 0;
							c.push({
								t: k,
								d: l.map(function(a) {
									if ("number" == typeof a) return m;
									var b = {},
										c;
									for (c in a) b[c] = m;
									return b
								})
							})
						}
					}
					var l = [],
						n = [],
						r = [];
					if (b.length != c.length) {
						if (!d) return;
						var t = g(b, c),
							l = [t[0]],
							n = [t[1]],
							r = [
								["matrix", [t[2]]]
							]
					} else
						for (f = 0; f < b.length; f++) {
							var k = b[f].t,
								u = c[f].t,
								v = b[f].d,
								w = c[f].d,
								x = D[k],
								y = D[u];
							if ("perspective" == k && "perspective" == u || !("matrix" != k && "matrix3d" != k || "matrix" != u && "matrix3d" != u)) {
								if (!d) return;
								t = g([b[f]], [c[f]]);
								l.push(t[0]);
								n.push(t[1]);
								r.push(["matrix", [t[2]]])
							} else {
								if (k != u)
									if (x[2] && y[2] && k.replace(/[xy]/, "") == u.replace(/[xy]/, "")) k = k.replace(/[xy]/, ""), v = x[2](v), w = y[2](w);
									else {
										if (!x[1] || !y[1] || h(k) != h(u)) {
											if (!d) return;
											t = g(b, c);
											l = [t[0]];
											n = [t[1]];
											r = [
												["matrix", [t[2]]]
											];
											break
										}
										k = h(k);
										v = x[1](v);
										w = y[1](w)
									}
								for (var x = [], y = [], u = [], z = 0; z < v.length; z++) t = "number" == typeof v[z] ? a.mergeNumbers : a.mergeDimensions, t = t(v[z], w[z]), x[z] = t[0], y[z] = t[1], u.push(t[2]);
								l.push(x);
								n.push(y);
								r.push([k, u])
							}
						}
					e && (b = l, l = n, n = b);
					return [l, n, function(a) {
						return a.map(function(a, b) {
							a = a.map(function(a, c) {
								return r[b][1][c](a)
							}).join(",");
							return "matrix" == r[b][0] && 16 == a.split(",").length && (r[b][0] = "matrix3d"), r[b][0] + "(" + a + ")"
						}).join(" ")
					}]
				}
				var v = null,
					x = {
						px: 0
					},
					y = {
						deg: 0
					},
					D = {
						matrix: ["NNNNNN", [v, v, 0, 0, v, v, 0, 0, 0, 0, 1, 0, v, v, 0, 1], d],
						matrix3d: ["NNNNNNNNNNNNNNNN", d],
						rotate: ["A"],
						rotatex: ["A"],
						rotatey: ["A"],
						rotatez: ["A"],
						rotate3d: ["NNNA"],
						perspective: ["L"],
						scale: ["Nn", c([v, v, 1]), d],
						scalex: ["N", c([v, 1, 1]), c([v, 1])],
						scaley: ["N", c([1, v, 1]), c([1, v])],
						scalez: ["N", c([1, 1, v])],
						scale3d: ["NNN", d],
						skew: ["Aa", null, d],
						skewx: ["A", null, c([v, y])],
						skewy: ["A", null, c([y, v])],
						translate: ["Tt", c([v, v, x]), d],
						translatex: ["T", c([v, x, x]), c([v, x])],
						translatey: ["T", c([x, v, x]), c([x,
							v
						])],
						translatez: ["L", c([x, x, v])],
						translate3d: ["TTL", d]
					};
				a.addPropertiesHandler(e, k, ["transform"])
			})(d, null);
			(function(a, b) {
				function c(a, b) {
					b.concat([a]).forEach(function(b) {
						b in document.documentElement.style && (d[a] = b)
					})
				}
				var d = {};
				c("transform", ["webkitTransform", "msTransform"]);
				c("transformOrigin", ["webkitTransformOrigin"]);
				c("perspective", ["webkitPerspective"]);
				c("perspectiveOrigin", ["webkitPerspectiveOrigin"]);
				a.propertyName = function(a) {
					return d[a] || a
				}
			})(d, null)
		})();
		! function() {
			if (void 0 === document.createElement("div").animate([]).oncancel) {
				var a;
				a = window.performance && performance.now ? function() {
					return performance.now()
				} : function() {
					return Date.now()
				};
				var b = function(a, b, c) {
						this.target = a;
						this.currentTime = b;
						this.timelineTime = c;
						this.type = "cancel";
						this.cancelable = this.bubbles = !1;
						this.currentTarget = a;
						this.defaultPrevented = !1;
						this.eventPhase = Event.AT_TARGET;
						this.timeStamp = Date.now()
					},
					c = window.Element.prototype.animate;
				window.Element.prototype.animate = function(d, e) {
					d = c.call(this, d, e);
					d._cancelHandlers = [];
					d.oncancel = null;
					var f = d.cancel;
					d.cancel = function() {
						f.call(this);
						var c = new b(this, null, a()),
							d = this._cancelHandlers.concat(this.oncancel ? [this.oncancel] : []);
						setTimeout(function() {
							d.forEach(function(a) {
								a.call(c.target, c)
							})
						}, 0)
					};
					var g = d.addEventListener;
					d.addEventListener = function(a, b) {
						"function" == typeof b && "cancel" == a ? this._cancelHandlers.push(b) : g.call(this, a, b)
					};
					var h = d.removeEventListener;
					return d.removeEventListener = function(a, b) {
						"cancel" == a ? (a = this._cancelHandlers.indexOf(b), 0 <= a && this._cancelHandlers.splice(a, 1)) : h.call(this, a, b)
					}, d
				}
			}
		}();
		(function(a) {
			var b =
				document.documentElement,
				c = null,
				d = !1;
			try {
				var e = getComputedStyle(b).getPropertyValue("opacity"),
					e = "0" == e ? "1" : "0",
					c = b.animate({
						opacity: [e, e]
					}, {
						duration: 1
					});
				c.currentTime = 0;
				d = getComputedStyle(b).getPropertyValue("opacity") == e
			} catch (n) {} finally {
				c && c.cancel()
			}
			if (!d) {
				var f = window.Element.prototype.animate;
				window.Element.prototype.animate = function(b, c) {
					return window.Symbol && Symbol.iterator && Array.prototype.from && b[Symbol.iterator] && (b = Array.from(b)), Array.isArray(b) || null === b || (b = a.convertToArrayForm(b)),
						f.call(this, b, c)
				}
			}
		})(c);
		! function(a, b, c) {
			function d(a) {
				var b = window.document.timeline;
				b.currentTime = a;
				b._discardAnimations();
				0 == b._animations.length ? f = !1 : requestAnimationFrame(d)
			}
			var e = window.requestAnimationFrame;
			window.requestAnimationFrame = function(a) {
				return e(function(b) {
					window.document.timeline._updateAnimationsPromises();
					a(b);
					window.document.timeline._updateAnimationsPromises()
				})
			};
			b.AnimationTimeline = function() {
				this._animations = [];
				this.currentTime = void 0
			};
			b.AnimationTimeline.prototype = {
				getAnimations: function() {
					return this._discardAnimations(),
						this._animations.slice()
				},
				_updateAnimationsPromises: function() {
					b.animationsWithPromises = b.animationsWithPromises.filter(function(a) {
						return a._updatePromises()
					})
				},
				_discardAnimations: function() {
					this._updateAnimationsPromises();
					this._animations = this._animations.filter(function(a) {
						return "finished" != a.playState && "idle" != a.playState
					})
				},
				_play: function(a) {
					a = new b.Animation(a, this);
					return this._animations.push(a), b.restartWebAnimationsNextTick(), a._updatePromises(), a._animation.play(), a._updatePromises(),
						a
				},
				play: function(a) {
					return a && a.remove(), this._play(a)
				}
			};
			var f = !1;
			b.restartWebAnimationsNextTick = function() {
				f || (f = !0, requestAnimationFrame(d))
			};
			var g = new b.AnimationTimeline;
			b.timeline = g;
			try {
				Object.defineProperty(window.document, "timeline", {
					configurable: !0,
					get: function() {
						return g
					}
				})
			} catch (r) {}
			try {
				window.document.timeline = g
			} catch (r) {}
		}(c, e, null);
		(function(a, b, c) {
			b.animationsWithPromises = [];
			b.Animation = function(b, c) {
				if (this.id = "", b && b._id && (this.id = b._id), this.effect = b, b && (b._animation = this), !c) throw Error("Animation with null timeline is not supported");
				this._timeline = c;
				this._sequenceNumber = a.sequenceNumber++;
				this._holdTime = 0;
				this._isGroup = this._paused = !1;
				this._animation = null;
				this._childAnimations = [];
				this._callback = null;
				this._oldPlayState = "idle";
				this._rebuildUnderlyingAnimation();
				this._animation.cancel();
				this._updatePromises()
			};
			b.Animation.prototype = {
				_updatePromises: function() {
					var a = this._oldPlayState,
						b = this.playState;
					return this._readyPromise && b !== a && ("idle" == b ? (this._rejectReadyPromise(), this._readyPromise = void 0) : "pending" == a ? this._resolveReadyPromise() :
						"pending" == b && (this._readyPromise = void 0)), this._finishedPromise && b !== a && ("idle" == b ? (this._rejectFinishedPromise(), this._finishedPromise = void 0) : "finished" == b ? this._resolveFinishedPromise() : "finished" == a && (this._finishedPromise = void 0)), this._oldPlayState = this.playState, this._readyPromise || this._finishedPromise
				},
				_rebuildUnderlyingAnimation: function() {
					this._updatePromises();
					var a, c, d, e, f = !!this._animation;
					f && (a = this.playbackRate, c = this._paused, d = this.startTime, e = this.currentTime, this._animation.cancel(),
						this._animation._wrapper = null, this._animation = null);
					(!this.effect || this.effect instanceof window.KeyframeEffect) && (this._animation = b.newUnderlyingAnimationForKeyframeEffect(this.effect), b.bindAnimationForKeyframeEffect(this));
					(this.effect instanceof window.SequenceEffect || this.effect instanceof window.GroupEffect) && (this._animation = b.newUnderlyingAnimationForGroup(this.effect), b.bindAnimationForGroup(this));
					this.effect && this.effect._onsample && b.bindAnimationForCustomEffect(this);
					f && (1 != a && (this.playbackRate =
						a), null !== d ? this.startTime = d : null !== e ? this.currentTime = e : null !== this._holdTime && (this.currentTime = this._holdTime), c && this.pause());
					this._updatePromises()
				},
				_updateChildren: function() {
					if (this.effect && "idle" != this.playState) {
						var a = this.effect._timing.delay;
						this._childAnimations.forEach(function(c) {
							this._arrangeChildren(c, a);
							this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c.effect))
						}.bind(this))
					}
				},
				_setExternalAnimation: function(a) {
					if (this.effect && this._isGroup)
						for (var b = 0; b < this.effect.children.length; b++) this.effect.children[b]._animation =
							a, this._childAnimations[b]._setExternalAnimation(a)
				},
				_constructChildAnimations: function() {
					if (this.effect && this._isGroup) {
						var a = this.effect._timing.delay;
						this._removeChildAnimations();
						this.effect.children.forEach(function(c) {
							var d = window.document.timeline._play(c);
							this._childAnimations.push(d);
							d.playbackRate = this.playbackRate;
							this._paused && d.pause();
							c._animation = this.effect._animation;
							this._arrangeChildren(d, a);
							this.effect instanceof window.SequenceEffect && (a += b.groupChildDuration(c))
						}.bind(this))
					}
				},
				_arrangeChildren: function(a, b) {
					null === this.startTime ? a.currentTime = this.currentTime - b / this.playbackRate : a.startTime !== this.startTime + b / this.playbackRate && (a.startTime = this.startTime + b / this.playbackRate)
				},
				get timeline() {
					return this._timeline
				},
				get playState() {
					return this._animation ? this._animation.playState : "idle"
				},
				get finished() {
					return window.Promise ? (this._finishedPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this), this._finishedPromise = new Promise(function(a,
						b) {
						this._resolveFinishedPromise = function() {
							a(this)
						};
						this._rejectFinishedPromise = function() {
							b({
								type: DOMException.ABORT_ERR,
								name: "AbortError"
							})
						}
					}.bind(this)), "finished" == this.playState && this._resolveFinishedPromise()), this._finishedPromise) : (console.warn("Animation Promises require JavaScript Promise constructor"), null)
				},
				get ready() {
					return window.Promise ? (this._readyPromise || (-1 == b.animationsWithPromises.indexOf(this) && b.animationsWithPromises.push(this), this._readyPromise = new Promise(function(a, b) {
						this._resolveReadyPromise =
							function() {
								a(this)
							};
						this._rejectReadyPromise = function() {
							b({
								type: DOMException.ABORT_ERR,
								name: "AbortError"
							})
						}
					}.bind(this)), "pending" !== this.playState && this._resolveReadyPromise()), this._readyPromise) : (console.warn("Animation Promises require JavaScript Promise constructor"), null)
				},
				get onfinish() {
					return this._animation.onfinish
				},
				set onfinish(a) {
					"function" == typeof a ? this._animation.onfinish = function(b) {
						b.target = this;
						a.call(this, b)
					}.bind(this) : this._animation.onfinish = a
				},
				get oncancel() {
					return this._animation.oncancel
				},
				set oncancel(a) {
					"function" == typeof a ? this._animation.oncancel = function(b) {
						b.target = this;
						a.call(this, b)
					}.bind(this) : this._animation.oncancel = a
				},
				get currentTime() {
					this._updatePromises();
					var a = this._animation.currentTime;
					return this._updatePromises(), a
				},
				set currentTime(a) {
					this._updatePromises();
					this._animation.currentTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE;
					this._register();
					this._forEachChild(function(b, c) {
						b.currentTime = a - c
					});
					this._updatePromises()
				},
				get startTime() {
					return this._animation.startTime
				},
				set startTime(a) {
					this._updatePromises();
					this._animation.startTime = isFinite(a) ? a : Math.sign(a) * Number.MAX_VALUE;
					this._register();
					this._forEachChild(function(b, c) {
						b.startTime = a + c
					});
					this._updatePromises()
				},
				get playbackRate() {
					return this._animation.playbackRate
				},
				set playbackRate(a) {
					this._updatePromises();
					var b = this.currentTime;
					this._animation.playbackRate = a;
					this._forEachChild(function(b) {
						b.playbackRate = a
					});
					"paused" != this.playState && "idle" != this.playState && this.play();
					null !== b && (this.currentTime = b);
					this._updatePromises()
				},
				play: function() {
					this._updatePromises();
					this._paused = !1;
					this._animation.play(); - 1 == this._timeline._animations.indexOf(this) && this._timeline._animations.push(this);
					this._register();
					b.awaitStartTime(this);
					this._forEachChild(function(a) {
						var b = a.currentTime;
						a.play();
						a.currentTime = b
					});
					this._updatePromises()
				},
				pause: function() {
					this._updatePromises();
					this.currentTime && (this._holdTime = this.currentTime);
					this._animation.pause();
					this._register();
					this._forEachChild(function(a) {
						a.pause()
					});
					this._paused = !0;
					this._updatePromises()
				},
				finish: function() {
					this._updatePromises();
					this._animation.finish();
					this._register();
					this._updatePromises()
				},
				cancel: function() {
					this._updatePromises();
					this._animation.cancel();
					this._register();
					this._removeChildAnimations();
					this._updatePromises()
				},
				reverse: function() {
					this._updatePromises();
					var a = this.currentTime;
					this._animation.reverse();
					this._forEachChild(function(a) {
						a.reverse()
					});
					null !== a && (this.currentTime = a);
					this._updatePromises()
				},
				addEventListener: function(a, b) {
					var c = b;
					"function" == typeof b && (c = function(a) {
						a.target =
							this;
						b.call(this, a)
					}.bind(this), b._wrapper = c);
					this._animation.addEventListener(a, c)
				},
				removeEventListener: function(a, b) {
					this._animation.removeEventListener(a, b && b._wrapper || b)
				},
				_removeChildAnimations: function() {
					for (; this._childAnimations.length;) this._childAnimations.pop().cancel()
				},
				_forEachChild: function(b) {
					var c = 0;
					if (this.effect.children && this._childAnimations.length < this.effect.children.length && this._constructChildAnimations(), this._childAnimations.forEach(function(a) {
							b.call(this, a, c);
							this.effect instanceof
							window.SequenceEffect && (c += a.effect.activeDuration)
						}.bind(this)), "pending" != this.playState) {
						var d = this.effect._timing,
							e = this.currentTime;
						null !== e && (e = a.calculateTimeFraction(a.calculateActiveDuration(d), e, d));
						(null == e || isNaN(e)) && this._removeChildAnimations()
					}
				}
			};
			window.Animation = b.Animation
		})(c, e, null);
		(function(a, b, c) {
			function d(b) {
				this._frames = a.normalizeKeyframes(b)
			}

			function e() {
				for (var a = !1; t.length;) a = t.shift(), a._updateChildren(), a = !0;
				return a
			}
			var f = function(a) {
				if (a._animation = void 0, a instanceof window.SequenceEffect || a instanceof window.GroupEffect)
					for (var b = 0; b < a.children.length; b++) f(a.children[b])
			};
			b.removeMulti = function(a) {
				for (var b = [], c = 0; c < a.length; c++) {
					var d = a[c];
					d._parent ? (-1 == b.indexOf(d._parent) && b.push(d._parent), d._parent.children.splice(d._parent.children.indexOf(d), 1), d._parent = null, f(d)) : d._animation && d._animation.effect == d && (d._animation.cancel(), d._animation.effect = new KeyframeEffect(null, []), d._animation._callback && (d._animation._callback._animation = null), d._animation._rebuildUnderlyingAnimation(),
						f(d))
				}
				for (c = 0; c < b.length; c++) b[c]._rebuild()
			};
			b.KeyframeEffect = function(b, c, e, f) {
				return this.target = b, this._parent = null, e = a.numericTimingToObject(e), this._timingInput = a.cloneTimingInput(e), this._timing = a.normalizeTimingInput(e), this.timing = a.makeTiming(e, !1, this), this.timing._effect = this, "function" == typeof c ? (a.deprecated("Custom KeyframeEffect", "2015-06-22", "Use KeyframeEffect.onsample instead."), this._normalizedKeyframes = c) : this._normalizedKeyframes = new d(c), this._keyframes = c, this.activeDuration =
					a.calculateActiveDuration(this._timing), this._id = f, this
			};
			b.KeyframeEffect.prototype = {
				getFrames: function() {
					return "function" == typeof this._normalizedKeyframes ? this._normalizedKeyframes : this._normalizedKeyframes._frames
				},
				set onsample(a) {
					if ("function" == typeof this.getFrames()) throw Error("Setting onsample on custom effect KeyframeEffect is not supported.");
					this._onsample = a;
					this._animation && this._animation._rebuildUnderlyingAnimation()
				},
				get parent() {
					return this._parent
				},
				clone: function() {
					if ("function" ==
						typeof this.getFrames()) throw Error("Cloning custom effects is not supported.");
					var b = new KeyframeEffect(this.target, [], a.cloneTimingInput(this._timingInput), this._id);
					return b._normalizedKeyframes = this._normalizedKeyframes, b._keyframes = this._keyframes, b
				},
				remove: function() {
					b.removeMulti([this])
				}
			};
			var g = Element.prototype.animate;
			Element.prototype.animate = function(a, c) {
				var d = "";
				return c && c.id && (d = c.id), b.timeline._play(new b.KeyframeEffect(this, a, c, d))
			};
			var h = document.createElementNS("http://www.w3.org/1999/xhtml",
				"div");
			b.newUnderlyingAnimationForKeyframeEffect = function(a) {
				if (a) {
					var b = a.target || h,
						c = a._keyframes;
					"function" == typeof c && (c = []);
					var d = a._timingInput;
					d.id = a._id
				} else b = h, c = [], d = 0;
				return g.apply(b, [c, d])
			};
			b.bindAnimationForKeyframeEffect = function(a) {
				a.effect && "function" == typeof a.effect._normalizedKeyframes && b.bindAnimationForCustomEffect(a)
			};
			var t = [];
			b.awaitStartTime = function(a) {
				null === a.startTime && a._isGroup && (0 == t.length && requestAnimationFrame(e), t.push(a))
			};
			var u = window.getComputedStyle;
			Object.defineProperty(window,
				"getComputedStyle", {
					configurable: !0,
					enumerable: !0,
					value: function() {
						window.document.timeline._updateAnimationsPromises();
						var a = u.apply(this, arguments);
						return e() && (a = u.apply(this, arguments)), window.document.timeline._updateAnimationsPromises(), a
					}
				});
			window.KeyframeEffect = b.KeyframeEffect;
			window.Element.prototype.getAnimations = function() {
				return document.timeline.getAnimations().filter(function(a) {
					return null !== a.effect && a.effect.target == this
				}.bind(this))
			}
		})(c, e, null);
		(function(a, b, c) {
			function d(a) {
				a._registered ||
					(a._registered = !0, g.push(a), h || (h = !0, requestAnimationFrame(e)))
			}

			function e(a) {
				a = g;
				g = [];
				a.sort(function(a, b) {
					return a._sequenceNumber - b._sequenceNumber
				});
				a = a.filter(function(a) {
					a();
					var b = a._animation ? a._animation.playState : "idle";
					return "running" != b && "pending" != b && (a._registered = !1), a._registered
				});
				g.push.apply(g, a);
				g.length ? (h = !0, requestAnimationFrame(e)) : h = !1
			}
			var f = (document.createElementNS("http://www.w3.org/1999/xhtml", "div"), 0);
			b.bindAnimationForCustomEffect = function(b) {
				var c, e = b.effect.target,
					g = "function" == typeof b.effect.getFrames();
				c = g ? b.effect.getFrames() : b.effect._onsample;
				var h = b.effect.timing,
					k = null,
					h = a.normalizeTimingInput(h),
					l = function() {
						var d = l._animation ? l._animation.currentTime : null;
						null !== d && (d = a.calculateTimeFraction(a.calculateActiveDuration(h), d, h), isNaN(d) && (d = null));
						d !== k && (g ? c(d, e, b.effect) : c(d, b.effect, b.effect._animation));
						k = d
					};
				l._animation = b;
				l._registered = !1;
				l._sequenceNumber = f++;
				b._callback = l;
				d(l)
			};
			var g = [],
				h = !1;
			b.Animation.prototype._register = function() {
				this._callback &&
					d(this._callback)
			}
		})(c, e, null);
		(function(a, b, c) {
			function d(a) {
				return a._timing.delay + a.activeDuration + a._timing.endDelay
			}

			function e(b, c, d) {
				this._id = d;
				this._parent = null;
				this.children = b || [];
				this._reparent(this.children);
				c = a.numericTimingToObject(c);
				this._timingInput = a.cloneTimingInput(c);
				this._timing = a.normalizeTimingInput(c, !0);
				this.timing = a.makeTiming(c, !0, this);
				this.timing._effect = this;
				"auto" === this._timing.duration && (this._timing.duration = this.activeDuration)
			}
			window.SequenceEffect = function() {
				e.apply(this,
					arguments)
			};
			window.GroupEffect = function() {
				e.apply(this, arguments)
			};
			e.prototype = {
				_isAncestor: function(a) {
					for (var b = this; null !== b;) {
						if (b == a) return !0;
						b = b._parent
					}
					return !1
				},
				_rebuild: function() {
					for (var a = this; a;) "auto" === a.timing.duration && (a._timing.duration = a.activeDuration), a = a._parent;
					this._animation && this._animation._rebuildUnderlyingAnimation()
				},
				_reparent: function(a) {
					b.removeMulti(a);
					for (var c = 0; c < a.length; c++) a[c]._parent = this
				},
				_putChild: function(a, b) {
					for (var c = b ? "Cannot append an ancestor or self" :
							"Cannot prepend an ancestor or self", d = 0; d < a.length; d++)
						if (this._isAncestor(a[d])) throw {
							type: DOMException.HIERARCHY_REQUEST_ERR,
							name: "HierarchyRequestError",
							message: c
						};
					for (d = 0; d < a.length; d++) b ? this.children.push(a[d]) : this.children.unshift(a[d]);
					this._reparent(a);
					this._rebuild()
				},
				append: function() {
					this._putChild(arguments, !0)
				},
				prepend: function() {
					this._putChild(arguments, !1)
				},
				get parent() {
					return this._parent
				},
				get firstChild() {
					return this.children.length ? this.children[0] : null
				},
				get lastChild() {
					return this.children.length ?
						this.children[this.children.length - 1] : null
				},
				clone: function() {
					for (var b = a.cloneTimingInput(this._timingInput), c = [], d = 0; d < this.children.length; d++) c.push(this.children[d].clone());
					return this instanceof GroupEffect ? new GroupEffect(c, b) : new SequenceEffect(c, b)
				},
				remove: function() {
					b.removeMulti([this])
				}
			};
			window.SequenceEffect.prototype = Object.create(e.prototype);
			Object.defineProperty(window.SequenceEffect.prototype, "activeDuration", {
				get: function() {
					var a = 0;
					return this.children.forEach(function(b) {
							a += d(b)
						}),
						Math.max(a, 0)
				}
			});
			window.GroupEffect.prototype = Object.create(e.prototype);
			Object.defineProperty(window.GroupEffect.prototype, "activeDuration", {
				get: function() {
					var a = 0;
					return this.children.forEach(function(b) {
						a = Math.max(a, d(b))
					}), a
				}
			});
			b.newUnderlyingAnimationForGroup = function(c) {
				var d, e = null,
					f = function(b) {
						var c = d._wrapper;
						return c && "pending" != c.playState && c.effect ? null == b ? void c._removeChildAnimations() : 0 == b && 0 > c.playbackRate && (e || (e = a.normalizeTimingInput(c.effect.timing)), b = a.calculateTimeFraction(a.calculateActiveDuration(e), -1, e), isNaN(b) || null == b) ? (c._forEachChild(function(a) {
							a.currentTime = -1
						}), void c._removeChildAnimations()) : void 0 : void 0
					};
				c = new KeyframeEffect(null, [], c._timing, c._id);
				return c.onsample = f, d = b.timeline._play(c)
			};
			b.bindAnimationForGroup = function(a) {
				a._animation._wrapper = a;
				a._isGroup = !0;
				b.awaitStartTime(a);
				a._constructChildAnimations();
				a._setExternalAnimation(a)
			};
			b.groupChildDuration = d
		})(c, e, null);
		b["true"] = a
	}({}, function() {
		return this
	}())
})();
U.NeonAnimation.Animations = {};
U.NeonAnimation.Animations.CascadedAnimation = {};
var gb = function() {};
gb.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
gb.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Polymer({
	is: "cascaded-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		this._animations = [];
		var b = a.nodes,
			c = [],
			d = a.nodeDelay || 50;
		a.timing = a.timing || {};
		a.timing.delay = a.timing.delay || 0;
		for (var e = a.timing.delay, f, g, h = 0; g = b[h]; h++)
			if (a.timing.delay += d, a.node = g, g = document.createElement(a.animation), g.isNeonAnimation) {
				var k = g.configure(a);
				this._animations.push(g);
				c.push(k)
			} else {
				Polymer.Base._warn(this.is + ":", a.animation, "not found!");
				f = !0;
				break
			}
		a.timing.delay = e;
		a.node = null;
		if (!f) return this._effect =
			new GroupEffect(c)
	},
	complete: function() {
		for (var a, b = 0; a = this._animations[b]; b++) a.complete(a.config)
	}
});
U.NeonAnimation.Animations.FadeInAnimation = {};
var rb = function() {};
rb.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
rb.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
rb.prototype.complete = function() {};
Polymer({
	is: "fade-in-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		return this._effect = new KeyframeEffect(b, [{
			opacity: "0"
		}, {
			opacity: "1"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.FadeOutAnimation = {};
var Bb = function() {};
Bb.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Bb.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Bb.prototype.complete = function() {};
Polymer({
	is: "fade-out-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		return this._effect = new KeyframeEffect(b, [{
			opacity: "1"
		}, {
			opacity: "0"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.NeonSharedElementAnimationBehavior = {};
Polymer.NeonSharedElementAnimationBehaviorImpl = {
	properties: {
		sharedElements: {
			type: Object
		}
	},
	findSharedElements: function(a) {
		var b = a.fromPage,
			c = a.toPage;
		if (!b || !c) return Polymer.Base._warn(this.is + ":", b ? "toPage" : "fromPage", "is undefined!"), null;
		if (!b.sharedElements || !c.sharedElements) return Polymer.Base._warn(this.is + ":", "sharedElements are undefined for", b.sharedElements ? c : b), null;
		var d = b.sharedElements[a.id],
			e = c.sharedElements[a.id];
		return d && e ? this.sharedElements = {
			from: d,
			to: e
		} : (Polymer.Base._warn(this.is +
			":", "sharedElement with id", a.id, "not found in", d ? c : b), null)
	}
};
Polymer.NeonSharedElementAnimationBehavior = [Polymer.NeonAnimationBehavior, Polymer.NeonSharedElementAnimationBehaviorImpl];
U.NeonAnimation.Animations.HeroAnimation = {};
var Jb = function() {};
Jb.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Jb.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Jb.prototype.findSharedElements = function(a) {
	var b = a.fromPage,
		c = a.toPage;
	if (!b || !c) return Polymer.Base._warn(this.is + ":", b ? "toPage" : "fromPage", "is undefined!"), null;
	if (!b.sharedElements || !c.sharedElements) return Polymer.Base._warn(this.is + ":", "sharedElements are undefined for", b.sharedElements ? c : b), null;
	var d = b.sharedElements[a.id],
		e = c.sharedElements[a.id];
	return d && e ? this.sharedElements = {
		from: d,
		to: e
	} : (Polymer.Base._warn(this.is + ":", "sharedElement with id", a.id, "not found in", d ? c : b), null)
};
Polymer({
	is: "hero-animation",
	behaviors: [Polymer.NeonSharedElementAnimationBehavior],
	configure: function(a) {
		var b = this.findSharedElements(a);
		if (b) {
			var c = b.from.getBoundingClientRect(),
				d = b.to.getBoundingClientRect(),
				e = c.left - d.left,
				f = c.top - d.top,
				g = c.width / d.width,
				c = c.height / d.height;
			this.setPrefixedProperty(b.to, "transformOrigin", "0 0");
			b.to.style.zIndex = 1E4;
			b.from.style.visibility = "hidden";
			return this._effect = new KeyframeEffect(b.to, [{
					transform: "translate(" + e + "px," + f + "px) scale(" + g + "," + c + ")"
				}, {
					transform: "none"
				}],
				this.timingFromConfig(a))
		}
	},
	complete: function(a) {
		a = this.findSharedElements(a);
		if (!a) return null;
		a.to.style.zIndex = "";
		a.from.style.visibility = ""
	}
});
U.NeonAnimation.Animations.OpaqueAnimation = {};
var Kb = function() {};
Kb.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Kb.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Polymer({
	is: "opaque-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		b.style.opacity = "0";
		return this._effect = new KeyframeEffect(b, [{
			opacity: "1"
		}, {
			opacity: "1"
		}], this.timingFromConfig(a))
	},
	complete: function(a) {
		a.node.style.opacity = ""
	}
});
U.NeonAnimation.Animations.ReverseRippleAnimation = {};
var Lb = function() {};
Lb.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Lb.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Lb.prototype.findSharedElements = function(a) {
	var b = a.fromPage,
		c = a.toPage;
	if (!b || !c) return Polymer.Base._warn(this.is + ":", b ? "toPage" : "fromPage", "is undefined!"), null;
	if (!b.sharedElements || !c.sharedElements) return Polymer.Base._warn(this.is + ":", "sharedElements are undefined for", b.sharedElements ? c : b), null;
	var d = b.sharedElements[a.id],
		e = c.sharedElements[a.id];
	return d && e ? this.sharedElements = {
		from: d,
		to: e
	} : (Polymer.Base._warn(this.is + ":", "sharedElement with id", a.id, "not found in", d ? c : b), null)
};
Polymer({
	is: "reverse-ripple-animation",
	behaviors: [Polymer.NeonSharedElementAnimationBehavior],
	configure: function(a) {
		var b = this.findSharedElements(a);
		if (!b) return null;
		var c, d, e = b.from.getBoundingClientRect();
		if (a.gesture) c = a.gesture.x - (e.left + e.width / 2), d = a.gesture.y - (e.top + e.height / 2);
		else {
			var f = b.to.getBoundingClientRect();
			c = f.left + f.width / 2 - (e.left + e.width / 2);
			d = f.top + f.height / 2 - (e.top + e.height / 2)
		}
		f = "translate(" + c + "px," + d + "px)";
		c = Math.max(e.width + 2 * Math.abs(c), e.height + 2 * Math.abs(d));
		d = Math.sqrt(2 *
			c * c);
		c = d / e.width;
		e = d / e.height;
		e = "scale(" + c + "," + e + ")";
		this.setPrefixedProperty(b.from, "transformOrigin", "50% 50%");
		b.from.style.borderRadius = "50%";
		return this._effect = new KeyframeEffect(b.from, [{
			transform: f + " " + e
		}, {
			transform: f + " scale(0)"
		}], this.timingFromConfig(a))
	},
	complete: function() {
		this.sharedElements && (this.setPrefixedProperty(this.sharedElements.from, "transformOrigin", ""), this.sharedElements.from.style.borderRadius = "")
	}
});
U.NeonAnimation.Animations.RippleAnimation = {};
var Zb = function() {};
Zb.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Zb.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Zb.prototype.findSharedElements = function(a) {
	var b = a.fromPage,
		c = a.toPage;
	if (!b || !c) return Polymer.Base._warn(this.is + ":", b ? "toPage" : "fromPage", "is undefined!"), null;
	if (!b.sharedElements || !c.sharedElements) return Polymer.Base._warn(this.is + ":", "sharedElements are undefined for", b.sharedElements ? c : b), null;
	var d = b.sharedElements[a.id],
		e = c.sharedElements[a.id];
	return d && e ? this.sharedElements = {
		from: d,
		to: e
	} : (Polymer.Base._warn(this.is + ":", "sharedElement with id", a.id, "not found in", d ? c : b), null)
};
Polymer({
	is: "ripple-animation",
	behaviors: [Polymer.NeonSharedElementAnimationBehavior],
	configure: function(a) {
		var b = this.findSharedElements(a);
		if (!b) return null;
		var c, d, e = b.to.getBoundingClientRect();
		if (a.gesture) c = a.gesture.x - (e.left + e.width / 2), d = a.gesture.y - (e.top + e.height / 2);
		else {
			var f = b.from.getBoundingClientRect();
			c = f.left + f.width / 2 - (e.left + e.width / 2);
			d = f.top + f.height / 2 - (e.top + e.height / 2)
		}
		f = "translate(" + c + "px," + d + "px)";
		c = Math.max(e.width + 2 * Math.abs(c), e.height + 2 * Math.abs(d));
		d = Math.sqrt(2 * c * c);
		c = d / e.width;
		e = d / e.height;
		e = "scale(" + c + "," + e + ")";
		this.setPrefixedProperty(b.to, "transformOrigin", "50% 50%");
		b.to.style.borderRadius = "50%";
		return this._effect = new KeyframeEffect(b.to, [{
			transform: f + " scale(0)"
		}, {
			transform: f + " " + e
		}], this.timingFromConfig(a))
	},
	complete: function() {
		this.sharedElements && (this.setPrefixedProperty(this.sharedElements.to, "transformOrigin", ""), this.sharedElements.to.style.borderRadius = "")
	}
});
U.NeonAnimation.Animations.ScaleDownAnimation = {};
var rc = function() {};
rc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
rc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
rc.prototype.complete = function() {};
Polymer({
	is: "scale-down-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin && this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin);
		var c = "scale(0, 0)";
		"x" === a.axis ? c = "scale(0, 1)" : "y" === a.axis && (c = "scale(1, 0)");
		return this._effect = new KeyframeEffect(b, [{
			transform: "scale(1,1)"
		}, {
			transform: c
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.ScaleUpAnimation = {};
var sc = function() {};
sc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
sc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
sc.prototype.complete = function() {};
Polymer({
	is: "scale-up-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin && this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin);
		var c = "scale(0)";
		"x" === a.axis ? c = "scale(0, 1)" : "y" === a.axis && (c = "scale(1, 0)");
		return this._effect = new KeyframeEffect(b, [{
			transform: c
		}, {
			transform: "scale(1, 1)"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideDownAnimation = {};
var tc = function() {};
tc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
tc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
tc.prototype.complete = function() {};
Polymer({
	is: "slide-down-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "50% 0");
		return this._effect = new KeyframeEffect(b, [{
			transform: "translateY(0%)"
		}, {
			transform: "translateY(100%)"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideFromBottomAnimation = {};
var Kc = function() {};
Kc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Kc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Kc.prototype.complete = function() {};
Polymer({
	is: "slide-from-bottom-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "50% 0");
		return this._effect = new KeyframeEffect(b, [{
			transform: "translateY(100%)"
		}, {
			transform: "translateY(0)"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideFromLeftAnimation = {};
var Lc = function() {};
Lc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Lc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Lc.prototype.complete = function() {};
Polymer({
	is: "slide-from-left-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "0 50%");
		return this._effect = new KeyframeEffect(b, [{
			transform: "translateX(-100%)"
		}, {
			transform: "none"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideFromRightAnimation = {};
var Mc = function() {};
Mc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Mc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Mc.prototype.complete = function() {};
Polymer({
	is: "slide-from-right-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "0 50%");
		return this._effect = new KeyframeEffect(b, [{
			transform: "translateX(100%)"
		}, {
			transform: "none"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideFromTopAnimation = {};
var Nc = function() {};
Nc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Nc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Nc.prototype.complete = function() {};
Polymer({
	is: "slide-from-top-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "50% 0");
		return this._effect = new KeyframeEffect(b, [{
			transform: "translateY(-100%)"
		}, {
			transform: "translateY(0%)"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideLeftAnimation = {};
var Oc = function() {};
Oc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Oc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Oc.prototype.complete = function() {};
Polymer({
	is: "slide-left-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "0 50%");
		return this._effect = new KeyframeEffect(b, [{
			transform: "none"
		}, {
			transform: "translateX(-100%)"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideRightAnimation = {};
var Pc = function() {};
Pc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Pc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Pc.prototype.complete = function() {};
Polymer({
	is: "slide-right-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "0 50%");
		return this._effect = new KeyframeEffect(b, [{
			transform: "none"
		}, {
			transform: "translateX(100%)"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.SlideUpAnimation = {};
var Qc = function() {};
Qc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Qc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Qc.prototype.complete = function() {};
Polymer({
	is: "slide-up-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node;
		a.transformOrigin ? this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin) : this.setPrefixedProperty(b, "transformOrigin", "50% 0");
		return this._effect = new KeyframeEffect(b, [{
			transform: "translate(0)"
		}, {
			transform: "translateY(-100%)"
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.Animations.TransformAnimation = {};
var Rc = function() {};
Rc.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Rc.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Rc.prototype.complete = function() {};
Polymer({
	is: "transform-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node,
			c = a.transformFrom || "none",
			d = a.transformTo || "none";
		a.transformOrigin && this.setPrefixedProperty(b, "transformOrigin", a.transformOrigin);
		return this._effect = new KeyframeEffect(b, [{
			transform: c
		}, {
			transform: d
		}], this.timingFromConfig(a))
	}
});
U.NeonAnimation.NeonAnimatableBehavior = {};
Polymer.NeonAnimatableBehavior = {
	properties: {
		animationConfig: {
			type: Object
		},
		entryAnimation: {
			observer: "_entryAnimationChanged",
			type: String
		},
		exitAnimation: {
			observer: "_exitAnimationChanged",
			type: String
		}
	},
	_entryAnimationChanged: function() {
		this.animationConfig = this.animationConfig || {};
		this.animationConfig.entry = "fade-in-animation" !== this.entryAnimation ? [{
			name: "opaque-animation",
			node: this
		}, {
			name: this.entryAnimation,
			node: this
		}] : [{
			name: this.entryAnimation,
			node: this
		}]
	},
	_exitAnimationChanged: function() {
		this.animationConfig =
			this.animationConfig || {};
		this.animationConfig.exit = [{
			name: this.exitAnimation,
			node: this
		}]
	},
	_copyProperties: function(a, b) {
		for (var c in b) a[c] = b[c]
	},
	_cloneConfig: function(a) {
		var b = {
			isClone: !0
		};
		this._copyProperties(b, a);
		return b
	},
	_getAnimationConfigRecursive: function(a, b, c) {
		if (this.animationConfig)
			if (this.animationConfig.value && "function" === typeof this.animationConfig.value) this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
			else {
				var d;
				d = a ? this.animationConfig[a] : this.animationConfig;
				Array.isArray(d) || (d = [d]);
				if (d)
					for (var e, f = 0; e = d[f]; f++)
						if (e.animatable) e.animatable._getAnimationConfigRecursive(e.type || a, b, c);
						else if (e.id) {
					var g = b[e.id];
					g ? (g.isClone || (b[e.id] = this._cloneConfig(g), g = b[e.id]), this._copyProperties(g, e)) : b[e.id] = e
				} else c.push(e)
			}
	},
	getAnimationConfig: function(a) {
		var b = {},
			c = [];
		this._getAnimationConfigRecursive(a, b, c);
		for (var d in b) c.push(b[d]);
		return c
	}
};
U.NeonAnimation.NeonAnimatable = {};
var Sc = function() {};
q = Sc.prototype;
q._entryAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.entry = "fade-in-animation" !== this.entryAnimation ? [{
		name: "opaque-animation",
		node: this
	}, {
		name: this.entryAnimation,
		node: this
	}] : [{
		name: this.entryAnimation,
		node: this
	}]
};
q._exitAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.exit = [{
		name: this.exitAnimation,
		node: this
	}]
};
q._copyProperties = function(a, b) {
	for (var c in b) a[c] = b[c]
};
q._cloneConfig = function(a) {
	var b = {
		isClone: !0
	};
	this._copyProperties(b, a);
	return b
};
q._getAnimationConfigRecursive = function(a, b, c) {
	if (this.animationConfig)
		if (this.animationConfig.value && "function" === typeof this.animationConfig.value) this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
		else {
			var d;
			d = a ? this.animationConfig[a] : this.animationConfig;
			Array.isArray(d) || (d = [d]);
			if (d)
				for (var e, f = 0; e = d[f]; f++)
					if (e.animatable) e.animatable._getAnimationConfigRecursive(e.type || a, b, c);
					else if (e.id) {
				var g =
					b[e.id];
				g ? (g.isClone || (b[e.id] = this._cloneConfig(g), g = b[e.id]), this._copyProperties(g, e)) : b[e.id] = e
			} else c.push(e)
		}
};
q.getAnimationConfig = function(a) {
	var b = {},
		c = [];
	this._getAnimationConfigRecursive(a, b, c);
	for (var d in b) c.push(b[d]);
	return c
};
q.notifyResize = function() {
	this.isAttached && (this._interestedResizables.forEach(function(a) {
		this.resizerShouldNotify(a) && this._notifyDescendant(a)
	}, this), this._fireResize())
};
q.assignParentResizable = function(a) {
	this._parentResizable = a
};
q.stopResizeNotificationsFor = function(a) {
	var b = this._interestedResizables.indexOf(a); - 1 < b && (this._interestedResizables.splice(b, 1), this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
};
q.resizerShouldNotify = function(a) {
	return !0
};
q._onDescendantIronResize = function(a) {
	this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
};
q._fireResize = function() {
	this.fire("iron-resize", null, {
		node: this,
		bubbles: !1
	})
};
q._onIronRequestResizeNotifications = function(a) {
	var b = a.path ? a.path[0] : a.target;
	b !== this && (-1 === this._interestedResizables.indexOf(b) && (this._interestedResizables.push(b), this.listen(b, "iron-resize", "_onDescendantIronResize")), b.assignParentResizable(this), this._notifyDescendant(b), a.stopPropagation())
};
q._parentResizableChanged = function(a) {
	a && window.removeEventListener("resize", this._boundNotifyResize)
};
q._notifyDescendant = function(a) {
	this.isAttached && (this._notifyingDescendant = !0, a.notifyResize(), this._notifyingDescendant = !1)
};
Polymer({
	is: "neon-animatable",
	behaviors: [Polymer.NeonAnimatableBehavior, Polymer.IronResizableBehavior]
});
U.NeonAnimation.NeonAnimationRunnerBehavior = {};
Polymer.NeonAnimationRunnerBehaviorImpl = {
	properties: {
		_player: {
			type: Object
		}
	},
	_configureAnimationEffects: function(a) {
		var b = [];
		if (0 < a.length)
			for (var c, d = 0; c = a[d]; d++) {
				var e = document.createElement(c.name);
				if (e.isNeonAnimation) {
					var f = e.configure(c);
					f && b.push({
						animation: e,
						config: c,
						effect: f
					})
				} else Polymer.Base._warn(this.is + ":", c.name, "not found!")
			}
		return b
	},
	_runAnimationEffects: function(a) {
		return document.timeline.play(new GroupEffect(a))
	},
	_completeAnimations: function(a) {
		for (var b, c = 0; b = a[c]; c++) b.animation.complete(b.config)
	},
	playAnimation: function(a, b) {
		if (a = this.getAnimationConfig(a)) {
			var c = this._configureAnimationEffects(a);
			a = c.map(function(a) {
				return a.effect
			});
			0 < a.length ? (this._player = this._runAnimationEffects(a), this._player.onfinish = function() {
				this._completeAnimations(c);
				this._player && (this._player.cancel(), this._player = null);
				this.fire("neon-animation-finish", b, {
					bubbles: !1
				})
			}.bind(this)) : this.fire("neon-animation-finish", b, {
				bubbles: !1
			})
		}
	},
	cancelAnimation: function() {
		this._player && this._player.cancel()
	}
};
Polymer.NeonAnimationRunnerBehavior = [Polymer.NeonAnimatableBehavior, Polymer.NeonAnimationRunnerBehaviorImpl];
U.IronSelector = {};
U.IronSelector.IronSelection = {};
Polymer.IronSelection = function(a) {
	this.selection = [];
	this.selectCallback = a
};
Polymer.IronSelection.prototype = {
	get: function() {
		return this.multi ? this.selection.slice() : this.selection[0]
	},
	clear: function(a) {
		this.selection.slice().forEach(function(b) {
			(!a || 0 > a.indexOf(b)) && this.setItemSelected(b, !1)
		}, this)
	},
	isSelected: function(a) {
		return 0 <= this.selection.indexOf(a)
	},
	setItemSelected: function(a, b) {
		if (null != a && b !== this.isSelected(a)) {
			if (b) this.selection.push(a);
			else {
				var c = this.selection.indexOf(a);
				0 <= c && this.selection.splice(c, 1)
			}
			this.selectCallback && this.selectCallback(a, b)
		}
	},
	select: function(a) {
		this.multi ?
			this.toggle(a) : this.get() !== a && (this.setItemSelected(this.get(), !1), this.setItemSelected(a, !0))
	},
	toggle: function(a) {
		this.setItemSelected(a, !this.isSelected(a))
	}
};
U.IronSelector.IronSelectable = {};
Polymer.IronSelectableBehavior = {
	properties: {
		attrForSelected: {
			type: String,
			value: null
		},
		selected: {
			type: String,
			notify: !0
		},
		selectedItem: {
			type: Object,
			readOnly: !0,
			notify: !0
		},
		activateEvent: {
			type: String,
			value: "tap",
			observer: "_activateEventChanged"
		},
		selectable: String,
		selectedClass: {
			type: String,
			value: "iron-selected"
		},
		selectedAttribute: {
			type: String,
			value: null
		},
		fallbackSelection: {
			type: String,
			value: null
		},
		items: {
			type: Array,
			readOnly: !0,
			notify: !0,
			value: function() {
				return []
			}
		},
		_excludedLocalNames: {
			type: Object,
			value: function() {
				return {
					template: 1
				}
			}
		}
	},
	observers: ["_updateAttrForSelected(attrForSelected)", "_updateSelected(selected)", "_checkFallback(fallbackSelection)"],
	created: function() {
		this._bindFilterItem = this._filterItem.bind(this);
		this._selection = new Polymer.IronSelection(this._applySelection.bind(this))
	},
	attached: function() {
		this._observer = this._observeItems(this);
		this._updateItems();
		this._shouldUpdateSelection || this._updateSelected();
		this._addListener(this.activateEvent)
	},
	detached: function() {
		this._observer && Polymer.dom(this).unobserveNodes(this._observer);
		this._removeListener(this.activateEvent)
	},
	indexOf: function(a) {
		return this.items.indexOf(a)
	},
	select: function(a) {
		this.selected = a
	},
	selectPrevious: function() {
		var a = this.items.length,
			a = (Number(this._valueToIndex(this.selected)) - 1 + a) % a;
		this.selected = this._indexToValue(a)
	},
	selectNext: function() {
		var a = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
		this.selected = this._indexToValue(a)
	},
	selectIndex: function(a) {
		this.select(this._indexToValue(a))
	},
	forceSynchronousItemUpdate: function() {
		this._updateItems()
	},
	get _shouldUpdateSelection() {
		return null != this.selected
	},
	_checkFallback: function() {
		this._shouldUpdateSelection && this._updateSelected()
	},
	_addListener: function(a) {
		this.listen(this, a, "_activateHandler")
	},
	_removeListener: function(a) {
		this.unlisten(this, a, "_activateHandler")
	},
	_activateEventChanged: function(a, b) {
		this._removeListener(b);
		this._addListener(a)
	},
	_updateItems: function() {
		var a = Polymer.dom(this).queryDistributedElements(this.selectable || "*"),
			a = Array.prototype.filter.call(a, this._bindFilterItem);
		this._setItems(a)
	},
	_updateAttrForSelected: function() {
		this._shouldUpdateSelection && (this.selected = this._indexToValue(this.indexOf(this.selectedItem)))
	},
	_updateSelected: function() {
		this._selectSelected(this.selected)
	},
	_selectSelected: function(a) {
		this._selection.select(this._valueToItem(this.selected));
		this.fallbackSelection && this.items.length && void 0 === this._selection.get() && (this.selected = this.fallbackSelection)
	},
	_filterItem: function(a) {
		return !this._excludedLocalNames[a.localName]
	},
	_valueToItem: function(a) {
		return null ==
			a ? null : this.items[this._valueToIndex(a)]
	},
	_valueToIndex: function(a) {
		if (this.attrForSelected)
			for (var b = 0, c; c = this.items[b]; b++) {
				if (this._valueForItem(c) == a) return b
			} else return Number(a)
	},
	_indexToValue: function(a) {
		if (this.attrForSelected) {
			if (a = this.items[a]) return this._valueForItem(a)
		} else return a
	},
	_valueForItem: function(a) {
		var b = a[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
		return void 0 != b ? b : a.getAttribute(this.attrForSelected)
	},
	_applySelection: function(a, b) {
		this.selectedClass && this.toggleClass(this.selectedClass,
			b, a);
		this.selectedAttribute && this.toggleAttribute(this.selectedAttribute, b, a);
		this._selectionChange();
		this.fire("iron-" + (b ? "select" : "deselect"), {
			item: a
		})
	},
	_selectionChange: function() {
		this._setSelectedItem(this._selection.get())
	},
	_observeItems: function(a) {
		return Polymer.dom(a).observeNodes(function(a) {
			this._updateItems();
			this._shouldUpdateSelection && this._updateSelected();
			this.fire("iron-items-changed", a, {
				bubbles: !1,
				cancelable: !1
			})
		})
	},
	_activateHandler: function(a) {
		a = a.target;
		for (var b = this.items; a &&
			a != this;) {
			var c = b.indexOf(a);
			if (0 <= c) {
				b = this._indexToValue(c);
				this._itemActivate(b, a);
				break
			}
			a = a.parentNode
		}
	},
	_itemActivate: function(a, b) {
		this.fire("iron-activate", {
			selected: a,
			item: b
		}, {
			cancelable: !0
		}).defaultPrevented || this.select(a)
	}
};
U.IronSelector.IronMultiSelectable = {};
Polymer.IronMultiSelectableBehaviorImpl = {
	properties: {
		multi: {
			type: Boolean,
			value: !1,
			observer: "multiChanged"
		},
		selectedValues: {
			type: Array,
			notify: !0
		},
		selectedItems: {
			type: Array,
			readOnly: !0,
			notify: !0
		}
	},
	observers: ["_updateSelected(selectedValues.splices)"],
	select: function(a) {
		this.multi ? this.selectedValues ? this._toggleSelected(a) : this.selectedValues = [a] : this.selected = a
	},
	multiChanged: function(a) {
		this._selection.multi = a
	},
	get _shouldUpdateSelection() {
		return null != this.selected || null != this.selectedValues && this.selectedValues.length
	},
	_updateAttrForSelected: function() {
		this.multi ? this._shouldUpdateSelection && (this.selectedValues = this.selectedItems.map(function(a) {
			return this._indexToValue(this.indexOf(a))
		}, this).filter(function(a) {
			return null != a
		}, this)) : Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this)
	},
	_updateSelected: function() {
		this.multi ? this._selectMulti(this.selectedValues) : this._selectSelected(this.selected)
	},
	_selectMulti: function(a) {
		if (a) {
			a = this._valuesToItems(a);
			this._selection.clear(a);
			for (var b = 0; b < a.length; b++) this._selection.setItemSelected(a[b], !0);
			this.fallbackSelection && this.items.length && !this._selection.get().length && (a = this._valueToItem(this.fallbackSelection)) && (this.selectedValues = [this.fallbackSelection])
		} else this._selection.clear()
	},
	_selectionChange: function() {
		var a = this._selection.get();
		this.multi ? this._setSelectedItems(a) : (this._setSelectedItems([a]), this._setSelectedItem(a))
	},
	_toggleSelected: function(a) {
		var b = this.selectedValues.indexOf(a),
			c = 0 > b;
		c ? this.push("selectedValues", a) : this.splice("selectedValues", b, 1)
	},
	_valuesToItems: function(a) {
		return null ==
			a ? null : a.map(function(a) {
				return this._valueToItem(a)
			}, this)
	}
};
Polymer.IronMultiSelectableBehavior = [Polymer.IronSelectableBehavior, Polymer.IronMultiSelectableBehaviorImpl];
U.IronSelector.IronSelector = {};
var Tc = function() {};
q = Tc.prototype;
q.indexOf = function(a) {
	return this.items.indexOf(a)
};
q.selectPrevious = function() {
	var a = this.items.length,
		a = (Number(this._valueToIndex(this.selected)) - 1 + a) % a;
	this.selected = this._indexToValue(a)
};
q.selectNext = function() {
	var a = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
	this.selected = this._indexToValue(a)
};
q.selectIndex = function(a) {
	this.select(this._indexToValue(a))
};
q.forceSynchronousItemUpdate = function() {
	this._updateItems()
};
q._checkFallback = function() {
	this._shouldUpdateSelection && this._updateSelected()
};
q._addListener = function(a) {
	this.listen(this, a, "_activateHandler")
};
q._removeListener = function(a) {
	this.unlisten(this, a, "_activateHandler")
};
q._activateEventChanged = function(a, b) {
	this._removeListener(b);
	this._addListener(a)
};
q._updateItems = function() {
	var a = Polymer.dom(this).queryDistributedElements(this.selectable || "*"),
		a = Array.prototype.filter.call(a, this._bindFilterItem);
	this._setItems(a)
};
q._selectSelected = function(a) {
	this._selection.select(this._valueToItem(this.selected));
	this.fallbackSelection && this.items.length && void 0 === this._selection.get() && (this.selected = this.fallbackSelection)
};
q._filterItem = function(a) {
	return !this._excludedLocalNames[a.localName]
};
q._valueToItem = function(a) {
	return null == a ? null : this.items[this._valueToIndex(a)]
};
q._valueToIndex = function(a) {
	if (this.attrForSelected)
		for (var b = 0, c; c = this.items[b]; b++) {
			if (this._valueForItem(c) == a) return b
		} else return Number(a)
};
q._indexToValue = function(a) {
	if (this.attrForSelected) {
		if (a = this.items[a]) return this._valueForItem(a)
	} else return a
};
q._valueForItem = function(a) {
	var b = a[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
	return void 0 != b ? b : a.getAttribute(this.attrForSelected)
};
q._applySelection = function(a, b) {
	this.selectedClass && this.toggleClass(this.selectedClass, b, a);
	this.selectedAttribute && this.toggleAttribute(this.selectedAttribute, b, a);
	this._selectionChange();
	this.fire("iron-" + (b ? "select" : "deselect"), {
		item: a
	})
};
q._observeItems = function(a) {
	return Polymer.dom(a).observeNodes(function(a) {
		this._updateItems();
		this._shouldUpdateSelection && this._updateSelected();
		this.fire("iron-items-changed", a, {
			bubbles: !1,
			cancelable: !1
		})
	})
};
q._activateHandler = function(a) {
	a = a.target;
	for (var b = this.items; a && a != this;) {
		var c = b.indexOf(a);
		if (0 <= c) {
			b = this._indexToValue(c);
			this._itemActivate(b, a);
			break
		}
		a = a.parentNode
	}
};
q._itemActivate = function(a, b) {
	this.fire("iron-activate", {
		selected: a,
		item: b
	}, {
		cancelable: !0
	}).defaultPrevented || this.select(a)
};
q.select = function(a) {
	this.multi ? this.selectedValues ? this._toggleSelected(a) : this.selectedValues = [a] : this.selected = a
};
q.multiChanged = function(a) {
	this._selection.multi = a
};
q._updateAttrForSelected = function() {
	this.multi ? this._shouldUpdateSelection && (this.selectedValues = this.selectedItems.map(function(a) {
		return this._indexToValue(this.indexOf(a))
	}, this).filter(function(a) {
		return null != a
	}, this)) : Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this)
};
q._updateSelected = function() {
	this.multi ? this._selectMulti(this.selectedValues) : this._selectSelected(this.selected)
};
q._selectMulti = function(a) {
	if (a) {
		a = this._valuesToItems(a);
		this._selection.clear(a);
		for (var b = 0; b < a.length; b++) this._selection.setItemSelected(a[b], !0);
		this.fallbackSelection && this.items.length && !this._selection.get().length && (a = this._valueToItem(this.fallbackSelection)) && (this.selectedValues = [this.fallbackSelection])
	} else this._selection.clear()
};
q._selectionChange = function() {
	var a = this._selection.get();
	this.multi ? this._setSelectedItems(a) : (this._setSelectedItems([a]), this._setSelectedItem(a))
};
q._toggleSelected = function(a) {
	var b = this.selectedValues.indexOf(a),
		c = 0 > b;
	c ? this.push("selectedValues", a) : this.splice("selectedValues", b, 1)
};
q._valuesToItems = function(a) {
	return null == a ? null : a.map(function(a) {
		return this._valueToItem(a)
	}, this)
};
q._setSelectedItem = function(a) {};
q._setItems = function(a) {};
q._setSelectedItems = function(a) {};
Polymer({
	is: "iron-selector",
	behaviors: [Polymer.IronMultiSelectableBehavior]
});
var Uc = function() {};
q = Uc.prototype;
q.notifyResize = function() {
	this.isAttached && (this._interestedResizables.forEach(function(a) {
		this.resizerShouldNotify(a) && this._notifyDescendant(a)
	}, this), this._fireResize())
};
q.assignParentResizable = function(a) {
	this._parentResizable = a
};
q.stopResizeNotificationsFor = function(a) {
	var b = this._interestedResizables.indexOf(a); - 1 < b && (this._interestedResizables.splice(b, 1), this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
};
q.resizerShouldNotify = function(a) {
	return !0
};
q._onDescendantIronResize = function(a) {
	this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
};
q._fireResize = function() {
	this.fire("iron-resize", null, {
		node: this,
		bubbles: !1
	})
};
q._onIronRequestResizeNotifications = function(a) {
	var b = a.path ? a.path[0] : a.target;
	b !== this && (-1 === this._interestedResizables.indexOf(b) && (this._interestedResizables.push(b), this.listen(b, "iron-resize", "_onDescendantIronResize")), b.assignParentResizable(this), this._notifyDescendant(b), a.stopPropagation())
};
q._parentResizableChanged = function(a) {
	a && window.removeEventListener("resize", this._boundNotifyResize)
};
q._notifyDescendant = function(a) {
	this.isAttached && (this._notifyingDescendant = !0, a.notifyResize(), this._notifyingDescendant = !1)
};
q.indexOf = function(a) {
	return this.items.indexOf(a)
};
q.select = function(a) {
	this.selected = a
};
q.selectPrevious = function() {
	var a = this.items.length,
		a = (Number(this._valueToIndex(this.selected)) - 1 + a) % a;
	this.selected = this._indexToValue(a)
};
q.selectNext = function() {
	var a = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
	this.selected = this._indexToValue(a)
};
q.selectIndex = function(a) {
	this.select(this._indexToValue(a))
};
q.forceSynchronousItemUpdate = function() {
	this._updateItems()
};
q._checkFallback = function() {
	this._shouldUpdateSelection && this._updateSelected()
};
q._addListener = function(a) {
	this.listen(this, a, "_activateHandler")
};
q._removeListener = function(a) {
	this.unlisten(this, a, "_activateHandler")
};
q._activateEventChanged = function(a, b) {
	this._removeListener(b);
	this._addListener(a)
};
q._updateItems = function() {
	var a = Polymer.dom(this).queryDistributedElements(this.selectable || "*"),
		a = Array.prototype.filter.call(a, this._bindFilterItem);
	this._setItems(a)
};
q._updateAttrForSelected = function() {
	this._shouldUpdateSelection && (this.selected = this._indexToValue(this.indexOf(this.selectedItem)))
};
q._updateSelected = function() {
	this._selectSelected(this.selected)
};
q._selectSelected = function(a) {
	this._selection.select(this._valueToItem(this.selected));
	this.fallbackSelection && this.items.length && void 0 === this._selection.get() && (this.selected = this.fallbackSelection)
};
q._filterItem = function(a) {
	return !this._excludedLocalNames[a.localName]
};
q._valueToItem = function(a) {
	return null == a ? null : this.items[this._valueToIndex(a)]
};
q._valueToIndex = function(a) {
	if (this.attrForSelected)
		for (var b = 0, c; c = this.items[b]; b++) {
			if (this._valueForItem(c) == a) return b
		} else return Number(a)
};
q._indexToValue = function(a) {
	if (this.attrForSelected) {
		if (a = this.items[a]) return this._valueForItem(a)
	} else return a
};
q._valueForItem = function(a) {
	var b = a[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
	return void 0 != b ? b : a.getAttribute(this.attrForSelected)
};
q._applySelection = function(a, b) {
	this.selectedClass && this.toggleClass(this.selectedClass, b, a);
	this.selectedAttribute && this.toggleAttribute(this.selectedAttribute, b, a);
	this._selectionChange();
	this.fire("iron-" + (b ? "select" : "deselect"), {
		item: a
	})
};
q._selectionChange = function() {
	this._setSelectedItem(this._selection.get())
};
q._observeItems = function(a) {
	return Polymer.dom(a).observeNodes(function(a) {
		this._updateItems();
		this._shouldUpdateSelection && this._updateSelected();
		this.fire("iron-items-changed", a, {
			bubbles: !1,
			cancelable: !1
		})
	})
};
q._activateHandler = function(a) {
	a = a.target;
	for (var b = this.items; a && a != this;) {
		var c = b.indexOf(a);
		if (0 <= c) {
			b = this._indexToValue(c);
			this._itemActivate(b, a);
			break
		}
		a = a.parentNode
	}
};
q._itemActivate = function(a, b) {
	this.fire("iron-activate", {
		selected: a,
		item: b
	}, {
		cancelable: !0
	}).defaultPrevented || this.select(a)
};
q._entryAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.entry = "fade-in-animation" !== this.entryAnimation ? [{
		name: "opaque-animation",
		node: this
	}, {
		name: this.entryAnimation,
		node: this
	}] : [{
		name: this.entryAnimation,
		node: this
	}]
};
q._exitAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.exit = [{
		name: this.exitAnimation,
		node: this
	}]
};
q._copyProperties = function(a, b) {
	for (var c in b) a[c] = b[c]
};
q._cloneConfig = function(a) {
	var b = {
		isClone: !0
	};
	this._copyProperties(b, a);
	return b
};
q._getAnimationConfigRecursive = function(a, b, c) {
	if (this.animationConfig)
		if (this.animationConfig.value && "function" === typeof this.animationConfig.value) this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
		else {
			var d;
			d = a ? this.animationConfig[a] : this.animationConfig;
			Array.isArray(d) || (d = [d]);
			if (d)
				for (var e, f = 0; e = d[f]; f++)
					if (e.animatable) e.animatable._getAnimationConfigRecursive(e.type || a, b, c);
					else if (e.id) {
				var g =
					b[e.id];
				g ? (g.isClone || (b[e.id] = this._cloneConfig(g), g = b[e.id]), this._copyProperties(g, e)) : b[e.id] = e
			} else c.push(e)
		}
};
q.getAnimationConfig = function(a) {
	var b = {},
		c = [];
	this._getAnimationConfigRecursive(a, b, c);
	for (var d in b) c.push(b[d]);
	return c
};
q._configureAnimationEffects = function(a) {
	var b = [];
	if (0 < a.length)
		for (var c, d = 0; c = a[d]; d++) {
			var e = document.createElement(c.name);
			if (e.isNeonAnimation) {
				var f = e.configure(c);
				f && b.push({
					animation: e,
					config: c,
					effect: f
				})
			} else Polymer.Base._warn(this.is + ":", c.name, "not found!")
		}
	return b
};
q._runAnimationEffects = function(a) {
	return document.timeline.play(new GroupEffect(a))
};
q._completeAnimations = function(a) {
	for (var b, c = 0; b = a[c]; c++) b.animation.complete(b.config)
};
q.playAnimation = function(a, b) {
	if (a = this.getAnimationConfig(a)) {
		var c = this._configureAnimationEffects(a);
		a = c.map(function(a) {
			return a.effect
		});
		0 < a.length ? (this._player = this._runAnimationEffects(a), this._player.onfinish = function() {
			this._completeAnimations(c);
			this._player && (this._player.cancel(), this._player = null);
			this.fire("neon-animation-finish", b, {
				bubbles: !1
			})
		}.bind(this)) : this.fire("neon-animation-finish", b, {
			bubbles: !1
		})
	}
};
q.cancelAnimation = function() {
	this._player && this._player.cancel()
};
q._setSelectedItem = function(a) {};
q._setItems = function(a) {};
U.NeonAnimation.NeonAnimatedPages = {};
(function() {
	Polymer({
		is: "neon-animated-pages",
		behaviors: [Polymer.IronResizableBehavior, Polymer.IronSelectableBehavior, Polymer.NeonAnimationRunnerBehavior],
		properties: {
			activateEvent: {
				type: String,
				value: ""
			},
			animateInitialSelection: {
				type: Boolean,
				value: !1
			}
		},
		listeners: {
			"iron-select": "_onIronSelect",
			"neon-animation-finish": "_onNeonAnimationFinish"
		},
		_onIronSelect: function(a) {
			var b = a.detail.item;
			0 > this.items.indexOf(b) || (a = this._valueToItem(this._prevSelected) || !1, this._prevSelected = this.selected, a || this.animateInitialSelection ?
				(this.animationConfig = [{
					name: "opaque-animation",
					node: b
				}], this.entryAnimation ? this.animationConfig.push({
					name: this.entryAnimation,
					node: b
				}) : b.getAnimationConfig && this.animationConfig.push({
					animatable: b,
					type: "entry"
				}), a && (a.classList.contains("neon-animating") && (this._squelchNextFinishEvent = !0, this.cancelAnimation(), this._completeSelectedChanged(), this._squelchNextFinishEvent = !1), this.exitAnimation ? this.animationConfig.push({
					name: this.exitAnimation,
					node: a
				}) : a.getAnimationConfig && this.animationConfig.push({
					animatable: a,
					type: "exit"
				}), a.classList.add("neon-animating")), b.classList.add("neon-animating"), 1 < this.animationConfig.length ? this.isAttached ? this.playAnimation(void 0, {
					fromPage: a,
					toPage: b
				}) : this.async(function() {
					this.playAnimation(void 0, {
						fromPage: null,
						toPage: b
					})
				}) : this._completeSelectedChanged(a, b)) : this._completeSelectedChanged())
		},
		_completeSelectedChanged: function(a, b) {
			b && b.classList.remove("neon-animating");
			a && a.classList.remove("neon-animating");
			if (!b || !a) {
				a = Polymer.dom(this.$.content).getDistributedNodes();
				for (var c = 0; b = a[c]; c++) b.classList && b.classList.remove("neon-animating")
			}
			this.async(this._notifyPageResize)
		},
		_onNeonAnimationFinish: function(a) {
			this._squelchNextFinishEvent ? this._squelchNextFinishEvent = !1 : this._completeSelectedChanged(a.detail.fromPage, a.detail.toPage)
		},
		_notifyPageResize: function() {
			var a = this.selectedItem || this._valueToItem(this.selected);
			this.resizerShouldNotify = function(b) {
				return b == a
			};
			this.notifyResize()
		}
	})
})();
U.NeonAnimation.NeonAnimations = {};
U.NeonAnimation.NeonSharedElementAnimatableBehavior = {};
Polymer.NeonSharedElementAnimatableBehaviorImpl = {
	properties: {
		sharedElements: {
			type: Object,
			value: {}
		}
	}
};
Polymer.NeonSharedElementAnimatableBehavior = [Polymer.NeonAnimatableBehavior, Polymer.NeonSharedElementAnimatableBehaviorImpl];
U.NeonAnimation.NeonAnimation = {};
U.IronOverlayBehavior = {};
U.IronOverlayBehavior.IronFocusablesHelper = {};
(function() {
	var a = Element.prototype,
		b = a.matches || a.matchesSelector || a.mozMatchesSelector || a.msMatchesSelector || a.oMatchesSelector || a.webkitMatchesSelector;
	Polymer.IronFocusablesHelper = {
		getTabbableNodes: function(a) {
			var b = [];
			return (a = this._collectTabbableNodes(a, b)) ? this._sortByTabIndex(b) : b
		},
		isFocusable: function(a) {
			return b.call(a, "input, select, textarea, button, object") ? b.call(a, ":not([disabled])") : b.call(a, "a[href], area[href], iframe, [tabindex], [contentEditable]")
		},
		isTabbable: function(a) {
			return this.isFocusable(a) &&
				b.call(a, ':not([tabindex="-1"])') && this._isVisible(a)
		},
		_normalizedTabIndex: function(a) {
			return this.isFocusable(a) ? (a = a.getAttribute("tabindex") || 0, Number(a)) : -1
		},
		_collectTabbableNodes: function(a, b) {
			if (a.nodeType !== Node.ELEMENT_NODE || !this._isVisible(a)) return !1;
			var c = a,
				d = this._normalizedTabIndex(c);
			a = 0 < d;
			0 <= d && b.push(c);
			c = "content" === c.localName ? Polymer.dom(c).getDistributedNodes() : Polymer.dom(c.root || c).children;
			for (d = 0; d < c.length; d++) {
				var g = this._collectTabbableNodes(c[d], b);
				a = a || g
			}
			return a
		},
		_isVisible: function(a) {
			var b =
				a.style;
			return "hidden" !== b.visibility && "none" !== b.display ? (b = window.getComputedStyle(a), "hidden" !== b.visibility && "none" !== b.display) : !1
		},
		_sortByTabIndex: function(a) {
			var b = a.length;
			if (2 > b) return a;
			var c = Math.ceil(b / 2),
				b = this._sortByTabIndex(a.slice(0, c));
			a = this._sortByTabIndex(a.slice(c));
			return this._mergeSortByTabIndex(b, a)
		},
		_mergeSortByTabIndex: function(a, b) {
			for (var c = []; 0 < a.length && 0 < b.length;) this._hasLowerTabOrder(a[0], b[0]) ? c.push(b.shift()) : c.push(a.shift());
			return c.concat(a, b)
		},
		_hasLowerTabOrder: function(a,
			b) {
			a = Math.max(a.tabIndex, 0);
			b = Math.max(b.tabIndex, 0);
			return 0 === a || 0 === b ? b > a : a > b
		}
	}
})();
var Vc = function() {};
U.IronOverlayBehavior.IronOverlayBackdrop = {};
(function() {
	Polymer({
		is: "iron-overlay-backdrop",
		properties: {
			opened: {
				reflectToAttribute: !0,
				type: Boolean,
				value: !1,
				observer: "_openedChanged"
			}
		},
		listeners: {
			transitionend: "_onTransitionend"
		},
		created: function() {
			this.__openedRaf = null
		},
		attached: function() {
			this.opened && this._openedChanged(this.opened)
		},
		prepare: function() {
			this.opened && !this.parentNode && Polymer.dom(document.body).appendChild(this)
		},
		open: function() {
			this.opened = !0
		},
		close: function() {
			this.opened = !1
		},
		complete: function() {
			this.opened || this.parentNode !==
				document.body || Polymer.dom(this.parentNode).removeChild(this)
		},
		_onTransitionend: function(a) {
			a && a.target === this && this.complete()
		},
		_openedChanged: function(a) {
			a ? this.prepare() : (a = window.getComputedStyle(this), "0s" !== a.transitionDuration && 0 != a.opacity || this.complete());
			this.isAttached && (this.__openedRaf && (window.cancelAnimationFrame(this.__openedRaf), this.__openedRaf = null), this.scrollTop = this.scrollTop, this.__openedRaf = window.requestAnimationFrame(function() {
				this.__openedRaf = null;
				this.toggleClass("opened",
					this.opened)
			}.bind(this)))
		}
	})
})();
U.IronOverlayBehavior.IronOverlayManager = {};
Polymer.IronOverlayManagerClass = function() {
	this._overlays = [];
	this._minimumZ = 101;
	this._backdropElement = null;
	Polymer.Gestures.add(document, "tap", this._onCaptureClick.bind(this));
	document.addEventListener("focus", this._onCaptureFocus.bind(this), !0);
	document.addEventListener("keydown", this._onCaptureKeyDown.bind(this), !0)
};
Polymer.IronOverlayManagerClass.prototype = {
	constructor: Polymer.IronOverlayManagerClass,
	get backdropElement() {
		this._backdropElement || (this._backdropElement = document.createElement("iron-overlay-backdrop"));
		return this._backdropElement
	},
	get deepActiveElement() {
		for (var a = document.activeElement || document.body; a.root && Polymer.dom(a.root).activeElement;) a = Polymer.dom(a.root).activeElement;
		return a
	},
	_bringOverlayAtIndexToFront: function(a) {
		var b = this._overlays[a];
		if (b) {
			var c = this._overlays.length - 1,
				d = this._overlays[c];
			d && this._shouldBeBehindOverlay(b, d) && c--;
			if (!(a >= c)) {
				d = Math.max(this.currentOverlayZ(), this._minimumZ);
				for (this._getZ(b) <= d && this._applyOverlayZ(b, d); a < c;) this._overlays[a] = this._overlays[a + 1], a++;
				this._overlays[c] = b
			}
		}
	},
	addOrRemoveOverlay: function(a) {
		a.opened ? this.addOverlay(a) : this.removeOverlay(a)
	},
	addOverlay: function(a) {
		var b = this._overlays.indexOf(a);
		if (0 <= b) this._bringOverlayAtIndexToFront(b);
		else {
			var b = this._overlays.length,
				c = this._overlays[b - 1],
				d = Math.max(this._getZ(c), this._minimumZ),
				e = this._getZ(a);
			c && this._shouldBeBehindOverlay(a, c) && (this._applyOverlayZ(c, d), b--, c = this._overlays[b - 1], d = Math.max(this._getZ(c), this._minimumZ));
			e <= d && this._applyOverlayZ(a, d);
			this._overlays.splice(b, 0, a)
		}
		this.trackBackdrop()
	},
	removeOverlay: function(a) {
		a = this._overlays.indexOf(a); - 1 !== a && (this._overlays.splice(a, 1), this.trackBackdrop())
	},
	currentOverlay: function() {
		var a = this._overlays.length - 1;
		return this._overlays[a]
	},
	currentOverlayZ: function() {
		return this._getZ(this.currentOverlay())
	},
	ensureMinimumZ: function(a) {
		this._minimumZ =
			Math.max(this._minimumZ, a)
	},
	focusOverlay: function() {
		var a = this.currentOverlay();
		a && a._applyFocus()
	},
	trackBackdrop: function() {
		var a = this._overlayWithBackdrop();
		if (a || this._backdropElement) this.backdropElement.style.zIndex = this._getZ(a) - 1, this.backdropElement.opened = !!a
	},
	getBackdrops: function() {
		for (var a = [], b = 0; b < this._overlays.length; b++) this._overlays[b].withBackdrop && a.push(this._overlays[b]);
		return a
	},
	backdropZ: function() {
		return this._getZ(this._overlayWithBackdrop()) - 1
	},
	_overlayWithBackdrop: function() {
		for (var a =
				0; a < this._overlays.length; a++)
			if (this._overlays[a].withBackdrop) return this._overlays[a]
	},
	_getZ: function(a) {
		var b = this._minimumZ;
		a && (a = Number(a.style.zIndex || window.getComputedStyle(a).zIndex), a === a && (b = a));
		return b
	},
	_setZ: function(a, b) {
		a.style.zIndex = b
	},
	_applyOverlayZ: function(a, b) {
		this._setZ(a, b + 2)
	},
	_overlayInPath: function(a) {
		a = a || [];
		for (var b = 0; b < a.length; b++)
			if (a[b]._manager === this) return a[b]
	},
	_onCaptureClick: function(a) {
		var b = this.currentOverlay();
		b && this._overlayInPath(Polymer.dom(a).path) !==
			b && b._onCaptureClick(a)
	},
	_onCaptureFocus: function(a) {
		var b = this.currentOverlay();
		b && b._onCaptureFocus(a)
	},
	_onCaptureKeyDown: function(a) {
		var b = this.currentOverlay();
		b && (Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(a, "esc") ? b._onCaptureEsc(a) : Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(a, "tab") && b._onCaptureTab(a))
	},
	_shouldBeBehindOverlay: function(a, b) {
		return !a.alwaysOnTop && b.alwaysOnTop
	}
};
Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass;
U.IronFitBehavior = {};
U.IronFitBehavior.IronFitBehavior = {};
Polymer.IronFitBehavior = {
	properties: {
		sizingTarget: {
			type: Object,
			value: function() {
				return this
			}
		},
		fitInto: {
			type: Object,
			value: window
		},
		noOverlap: {
			type: Boolean
		},
		positionTarget: {
			type: Element
		},
		horizontalAlign: {
			type: String
		},
		verticalAlign: {
			type: String
		},
		dynamicAlign: {
			type: Boolean
		},
		horizontalOffset: {
			type: Number,
			value: 0,
			notify: !0
		},
		verticalOffset: {
			type: Number,
			value: 0,
			notify: !0
		},
		autoFitOnAttach: {
			type: Boolean,
			value: !1
		},
		_fitInfo: {
			type: Object
		}
	},
	get _fitWidth() {
		var a;
		return a = this.fitInto === window ? this.fitInto.innerWidth :
			this.fitInto.getBoundingClientRect().width
	},
	get _fitHeight() {
		var a;
		return a = this.fitInto === window ? this.fitInto.innerHeight : this.fitInto.getBoundingClientRect().height
	},
	get _fitLeft() {
		var a;
		return a = this.fitInto === window ? 0 : this.fitInto.getBoundingClientRect().left
	},
	get _fitTop() {
		var a;
		return a = this.fitInto === window ? 0 : this.fitInto.getBoundingClientRect().top
	},
	get _defaultPositionTarget() {
		var a = Polymer.dom(this).parentNode;
		a && a.nodeType === Node.DOCUMENT_FRAGMENT_NODE && (a = a.host);
		return a
	},
	get _localeHorizontalAlign() {
		if (this._isRTL) {
			if ("right" ===
				this.horizontalAlign) return "left";
			if ("left" === this.horizontalAlign) return "right"
		}
		return this.horizontalAlign
	},
	attached: function() {
		this._isRTL = "rtl" == window.getComputedStyle(this).direction;
		this.positionTarget = this.positionTarget || this._defaultPositionTarget;
		this.autoFitOnAttach && ("none" === window.getComputedStyle(this).display ? setTimeout(function() {
			this.fit()
		}.bind(this)) : this.fit())
	},
	fit: function() {
		this.position();
		this.constrain();
		this.center()
	},
	_discoverInfo: function() {
		if (!this._fitInfo) {
			var a = window.getComputedStyle(this),
				b = window.getComputedStyle(this.sizingTarget);
			this._fitInfo = {
				inlineStyle: {
					top: this.style.top || "",
					left: this.style.left || "",
					position: this.style.position || ""
				},
				sizerInlineStyle: {
					maxWidth: this.sizingTarget.style.maxWidth || "",
					maxHeight: this.sizingTarget.style.maxHeight || "",
					boxSizing: this.sizingTarget.style.boxSizing || ""
				},
				positionedBy: {
					vertically: "auto" !== a.top ? "top" : "auto" !== a.bottom ? "bottom" : null,
					horizontally: "auto" !== a.left ? "left" : "auto" !== a.right ? "right" : null
				},
				sizedBy: {
					height: "none" !== b.maxHeight,
					width: "none" !==
						b.maxWidth,
					minWidth: parseInt(b.minWidth, 10) || 0,
					minHeight: parseInt(b.minHeight, 10) || 0
				},
				margin: {
					top: parseInt(a.marginTop, 10) || 0,
					right: parseInt(a.marginRight, 10) || 0,
					bottom: parseInt(a.marginBottom, 10) || 0,
					left: parseInt(a.marginLeft, 10) || 0
				}
			};
			this.verticalOffset && (this._fitInfo.margin.top = this._fitInfo.margin.bottom = this.verticalOffset, this._fitInfo.inlineStyle.marginTop = this.style.marginTop || "", this._fitInfo.inlineStyle.marginBottom = this.style.marginBottom || "", this.style.marginTop = this.style.marginBottom =
				this.verticalOffset + "px");
			this.horizontalOffset && (this._fitInfo.margin.left = this._fitInfo.margin.right = this.horizontalOffset, this._fitInfo.inlineStyle.marginLeft = this.style.marginLeft || "", this._fitInfo.inlineStyle.marginRight = this.style.marginRight || "", this.style.marginLeft = this.style.marginRight = this.horizontalOffset + "px")
		}
	},
	resetFit: function() {
		var a = this._fitInfo || {},
			b;
		for (b in a.sizerInlineStyle) this.sizingTarget.style[b] = a.sizerInlineStyle[b];
		for (b in a.inlineStyle) this.style[b] = a.inlineStyle[b];
		this._fitInfo = null
	},
	refit: function() {
		var a = this.sizingTarget.scrollLeft,
			b = this.sizingTarget.scrollTop;
		this.resetFit();
		this.fit();
		this.sizingTarget.scrollLeft = a;
		this.sizingTarget.scrollTop = b
	},
	position: function() {
		if (this.horizontalAlign || this.verticalAlign) {
			this._discoverInfo();
			this.style.position = "fixed";
			this.sizingTarget.style.boxSizing = "border-box";
			this.style.left = "0px";
			this.style.top = "0px";
			var a = this.getBoundingClientRect(),
				b = this.__getNormalizedRect(this.positionTarget),
				c = this.__getNormalizedRect(this.fitInto),
				d = this._fitInfo.margin,
				e = {
					width: a.width + d.left + d.right,
					height: a.height + d.top + d.bottom
				},
				e = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, e, b, c),
				b = e.left + d.left,
				e = e.top + d.top,
				f = Math.min(c.right - d.right, b + a.width),
				c = Math.min(c.bottom - d.bottom, e + a.height),
				g = this._fitInfo.sizedBy.minWidth,
				h = this._fitInfo.sizedBy.minHeight;
			b < d.left && (b = d.left, f - b < g && (b = f - g));
			e < d.top && (e = d.top, c - e < h && (e = c - h));
			this.sizingTarget.style.maxWidth = f - b + "px";
			this.sizingTarget.style.maxHeight = c - e + "px";
			this.style.left =
				b - a.left + "px";
			this.style.top = e - a.top + "px"
		}
	},
	constrain: function() {
		if (!this.horizontalAlign && !this.verticalAlign) {
			this._discoverInfo();
			var a = this._fitInfo;
			a.positionedBy.vertically || (this.style.position = "fixed", this.style.top = "0px");
			a.positionedBy.horizontally || (this.style.position = "fixed", this.style.left = "0px");
			this.sizingTarget.style.boxSizing = "border-box";
			var b = this.getBoundingClientRect();
			a.sizedBy.height || this.__sizeDimension(b, a.positionedBy.vertically, "top", "bottom", "Height");
			a.sizedBy.width ||
				this.__sizeDimension(b, a.positionedBy.horizontally, "left", "right", "Width")
		}
	},
	_sizeDimension: function(a, b, c, d, e) {
		this.__sizeDimension(a, b, c, d, e)
	},
	__sizeDimension: function(a, b, c, d, e) {
		var f = this._fitInfo,
			g = this.__getNormalizedRect(this.fitInto),
			g = "Width" === e ? g.width : g.height;
		a = (b = b === d) ? g - a[d] : a[c];
		c = f.margin[b ? c : d];
		d = "offset" + e;
		d = this[d] - this.sizingTarget[d];
		this.sizingTarget.style["max" + e] = g - c - a - d + "px"
	},
	center: function() {
		if (!this.horizontalAlign && !this.verticalAlign) {
			this._discoverInfo();
			var a = this._fitInfo.positionedBy;
			if (!a.vertically || !a.horizontally) {
				this.style.position = "fixed";
				a.vertically || (this.style.top = "0px");
				a.horizontally || (this.style.left = "0px");
				var b = this.getBoundingClientRect(),
					c = this.__getNormalizedRect(this.fitInto);
				if (!a.vertically) {
					var d = c.top - b.top + (c.height - b.height) / 2;
					this.style.top = d + "px"
				}
				a.horizontally || (a = c.left - b.left + (c.width - b.width) / 2, this.style.left = a + "px")
			}
		}
	},
	__getNormalizedRect: function(a) {
		return a === document.documentElement || a === window ? {
			top: 0,
			left: 0,
			width: window.innerWidth,
			height: window.innerHeight,
			right: window.innerWidth,
			bottom: window.innerHeight
		} : a.getBoundingClientRect()
	},
	__getCroppedArea: function(a, b, c) {
		var d = Math.min(0, a.top) + Math.min(0, c.bottom - (a.top + b.height));
		a = Math.min(0, a.left) + Math.min(0, c.right - (a.left + b.width));
		return Math.abs(d) * b.width + Math.abs(a) * b.height
	},
	__getPosition: function(a, b, c, d, e) {
		var f = [{
			verticalAlign: "top",
			horizontalAlign: "left",
			top: d.top,
			left: d.left
		}, {
			verticalAlign: "top",
			horizontalAlign: "right",
			top: d.top,
			left: d.right - c.width
		}, {
			verticalAlign: "bottom",
			horizontalAlign: "left",
			top: d.bottom - c.height,
			left: d.left
		}, {
			verticalAlign: "bottom",
			horizontalAlign: "right",
			top: d.bottom - c.height,
			left: d.right - c.width
		}];
		if (this.noOverlap) {
			for (var g = 0, h = f.length; g < h; g++) {
				var k = {},
					l;
				for (l in f[g]) k[l] = f[g][l];
				f.push(k)
			}
			f[0].top = f[1].top += d.height;
			f[2].top = f[3].top -= d.height;
			f[4].left = f[6].left += d.width;
			f[5].left = f[7].left -= d.width
		}
		b = "auto" === b ? null : b;
		a = "auto" === a ? null : a;
		for (var m, g = 0; g < f.length; g++) {
			d = f[g];
			if (!this.dynamicAlign && !this.noOverlap && d.verticalAlign === b && d.horizontalAlign === a) {
				m =
					d;
				break
			}
			h = (!b || d.verticalAlign === b) && (!a || d.horizontalAlign === a);
			if (this.dynamicAlign || h) {
				m = m || d;
				d.croppedArea = this.__getCroppedArea(d, c, e);
				k = d.croppedArea - m.croppedArea;
				if (0 > k || 0 === k && h) m = d;
				if (0 === m.croppedArea && h) break
			}
		}
		return m
	}
};
U.IronOverlayBehavior.IronOverlayBehavior = {};
(function() {
	Polymer.IronOverlayBehaviorImpl = {
		properties: {
			opened: {
				observer: "_openedChanged",
				type: Boolean,
				value: !1,
				notify: !0
			},
			canceled: {
				observer: "_canceledChanged",
				readOnly: !0,
				type: Boolean,
				value: !1
			},
			withBackdrop: {
				observer: "_withBackdropChanged",
				type: Boolean
			},
			noAutoFocus: {
				type: Boolean,
				value: !1
			},
			noCancelOnEscKey: {
				type: Boolean,
				value: !1
			},
			noCancelOnOutsideClick: {
				type: Boolean,
				value: !1
			},
			closingReason: {
				type: Object
			},
			restoreFocusOnClose: {
				type: Boolean,
				value: !1
			},
			alwaysOnTop: {
				type: Boolean
			},
			_manager: {
				type: Object,
				value: Polymer.IronOverlayManager
			},
			_focusedChild: {
				type: Object
			}
		},
		listeners: {
			"iron-resize": "_onIronResize"
		},
		get backdropElement() {
			return this._manager.backdropElement
		},
		get _focusNode() {
			return this._focusedChild || Polymer.dom(this).querySelector("[autofocus]") || this
		},
		get _focusableNodes() {
			return Polymer.IronFocusablesHelper.getTabbableNodes(this)
		},
		ready: function() {
			this.__shouldRemoveTabIndex = this.__isAnimating = !1;
			this.__restoreFocusNode = this.__raf = this.__firstFocusableNode = this.__lastFocusableNode = null;
			this._ensureSetup()
		},
		attached: function() {
			this.opened && this._openedChanged(this.opened);
			this._observer = Polymer.dom(this).observeNodes(this._onNodesChange)
		},
		detached: function() {
			Polymer.dom(this).unobserveNodes(this._observer);
			this._observer = null;
			this.__raf && (window.cancelAnimationFrame(this.__raf), this.__raf = null);
			this._manager.removeOverlay(this)
		},
		toggle: function() {
			this._setCanceled(!1);
			this.opened = !this.opened
		},
		open: function() {
			this._setCanceled(!1);
			this.opened = !0
		},
		close: function() {
			this._setCanceled(!1);
			this.opened = !1
		},
		cancel: function(a) {
			a = this.fire("iron-overlay-canceled", a, {
				cancelable: !0
			});
			a.defaultPrevented || (this._setCanceled(!0), this.opened = !1)
		},
		invalidateTabbables: function() {
			this.__firstFocusableNode = this.__lastFocusableNode = null
		},
		_ensureSetup: function() {
			this._overlaySetup || (this._overlaySetup = !0, this.style.outline = "none", this.style.display = "none")
		},
		_openedChanged: function(a) {
			a ? this.removeAttribute("aria-hidden") : this.setAttribute("aria-hidden", "true");
			this.isAttached && (this.__isAnimating = !0, this.__onNextAnimationFrame(this.__openedChanged))
		},
		_canceledChanged: function() {
			this.closingReason = this.closingReason || {};
			this.closingReason.canceled = this.canceled
		},
		_withBackdropChanged: function() {
			this.withBackdrop && !this.hasAttribute("tabindex") ? (this.setAttribute("tabindex", "-1"), this.__shouldRemoveTabIndex = !0) : this.__shouldRemoveTabIndex && (this.removeAttribute("tabindex"), this.__shouldRemoveTabIndex = !1);
			this.opened && this.isAttached && this._manager.trackBackdrop()
		},
		_prepareRenderOpened: function() {
			this.__restoreFocusNode =
				this._manager.deepActiveElement;
			this._preparePositioning();
			this.refit();
			this._finishPositioning();
			this.noAutoFocus && document.activeElement === this._focusNode && (this._focusNode.blur(), this.__restoreFocusNode.focus())
		},
		_renderOpened: function() {
			this._finishRenderOpened()
		},
		_renderClosed: function() {
			this._finishRenderClosed()
		},
		_finishRenderOpened: function() {
			this.notifyResize();
			this.__isAnimating = !1;
			this.fire("iron-overlay-opened")
		},
		_finishRenderClosed: function() {
			this.style.display = "none";
			this.style.zIndex =
				"";
			this.notifyResize();
			this.__isAnimating = !1;
			this.fire("iron-overlay-closed", this.closingReason)
		},
		_preparePositioning: function() {
			this.style.transition = this.style.webkitTransition = "none";
			this.style.transform = this.style.webkitTransform = "none";
			this.style.display = ""
		},
		_finishPositioning: function() {
			this.style.display = "none";
			this.scrollTop = this.scrollTop;
			this.style.transition = this.style.webkitTransition = "";
			this.style.transform = this.style.webkitTransform = "";
			this.style.display = "";
			this.scrollTop = this.scrollTop
		},
		_applyFocus: function() {
			if (this.opened) this.noAutoFocus || this._focusNode.focus();
			else {
				this._focusNode.blur();
				this._focusedChild = null;
				this.restoreFocusOnClose && this.__restoreFocusNode && this.__restoreFocusNode.focus();
				this.__restoreFocusNode = null;
				var a = this._manager.currentOverlay();
				a && this !== a && a._applyFocus()
			}
		},
		_onCaptureClick: function(a) {
			this.noCancelOnOutsideClick || this.cancel(a)
		},
		_onCaptureFocus: function(a) {
			if (this.withBackdrop) {
				var b = Polymer.dom(a).path; - 1 === b.indexOf(this) ? (a.stopPropagation(),
					this._applyFocus()) : this._focusedChild = b[0]
			}
		},
		_onCaptureEsc: function(a) {
			this.noCancelOnEscKey || this.cancel(a)
		},
		_onCaptureTab: function(a) {
			if (this.withBackdrop) {
				this.__ensureFirstLastFocusables();
				var b = a.shiftKey,
					c = b ? this.__firstFocusableNode : this.__lastFocusableNode,
					b = b ? this.__lastFocusableNode : this.__firstFocusableNode,
					d = !1;
				c === b ? d = !0 : (d = this._manager.deepActiveElement, d = d === c || d === this);
				d && (a.preventDefault(), this._focusedChild = b, this._applyFocus())
			}
		},
		_onIronResize: function() {
			this.opened && !this.__isAnimating &&
				this.__onNextAnimationFrame(this.refit)
		},
		_onNodesChange: function() {
			this.opened && !this.__isAnimating && (this.invalidateTabbables(), this.notifyResize())
		},
		__ensureFirstLastFocusables: function() {
			if (!this.__firstFocusableNode || !this.__lastFocusableNode) {
				var a = this._focusableNodes;
				this.__firstFocusableNode = a[0];
				this.__lastFocusableNode = a[a.length - 1]
			}
		},
		__openedChanged: function() {
			this.opened ? (this._prepareRenderOpened(), this._manager.addOverlay(this), this._applyFocus(), this._renderOpened()) : (this._manager.removeOverlay(this),
				this._applyFocus(), this._renderClosed())
		},
		__onNextAnimationFrame: function(a) {
			this.__raf && window.cancelAnimationFrame(this.__raf);
			var b = this;
			this.__raf = window.requestAnimationFrame(function d() {
				b.__raf = null;
				a.call(b)
			})
		}
	};
	Polymer.IronOverlayBehavior = [Polymer.IronFitBehavior, Polymer.IronResizableBehavior, Polymer.IronOverlayBehaviorImpl]
})();
U.PaperDialogBehavior = {};
U.PaperDialogBehavior.PaperDialogBehavior = {};
Polymer.PaperDialogBehaviorImpl = {
	hostAttributes: {
		role: "dialog",
		tabindex: "-1"
	},
	properties: {
		modal: {
			type: Boolean,
			value: !1
		}
	},
	observers: ["_modalChanged(modal, _readied)"],
	listeners: {
		tap: "_onDialogClick"
	},
	ready: function() {
		this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
		this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
		this.__prevWithBackdrop = this.withBackdrop
	},
	_modalChanged: function(a, b) {
		a ? this.setAttribute("aria-modal", "true") : this.setAttribute("aria-modal", "false");
		b && (a ? (this.__prevNoCancelOnOutsideClick =
			this.noCancelOnOutsideClick, this.__prevNoCancelOnEscKey = this.noCancelOnEscKey, this.__prevWithBackdrop = this.withBackdrop, this.withBackdrop = this.noCancelOnEscKey = this.noCancelOnOutsideClick = !0) : (this.noCancelOnOutsideClick = this.noCancelOnOutsideClick && this.__prevNoCancelOnOutsideClick, this.noCancelOnEscKey = this.noCancelOnEscKey && this.__prevNoCancelOnEscKey, this.withBackdrop = this.withBackdrop && this.__prevWithBackdrop))
	},
	_updateClosingReasonConfirmed: function(a) {
		this.closingReason = this.closingReason || {};
		this.closingReason.confirmed = a
	},
	_onDialogClick: function(a) {
		for (var b = Polymer.dom(a).path, c = 0; c < b.indexOf(this); c++) {
			var d = b[c];
			if (d.hasAttribute && (d.hasAttribute("dialog-dismiss") || d.hasAttribute("dialog-confirm"))) {
				this._updateClosingReasonConfirmed(d.hasAttribute("dialog-confirm"));
				this.close();
				a.stopPropagation();
				break
			}
		}
	}
};
Polymer.PaperDialogBehavior = [Polymer.IronOverlayBehavior, Polymer.PaperDialogBehaviorImpl];
U.PaperDialogBehavior.PaperDialogSharedStyles = {};
var Wc = function() {};
q = Wc.prototype;
q.fit = function() {
	this.position();
	this.constrain();
	this.center()
};
q._discoverInfo = function() {
	if (!this._fitInfo) {
		var a = window.getComputedStyle(this),
			b = window.getComputedStyle(this.sizingTarget);
		this._fitInfo = {
			inlineStyle: {
				top: this.style.top || "",
				left: this.style.left || "",
				position: this.style.position || ""
			},
			sizerInlineStyle: {
				maxWidth: this.sizingTarget.style.maxWidth || "",
				maxHeight: this.sizingTarget.style.maxHeight || "",
				boxSizing: this.sizingTarget.style.boxSizing || ""
			},
			positionedBy: {
				vertically: "auto" !== a.top ? "top" : "auto" !== a.bottom ? "bottom" : null,
				horizontally: "auto" !== a.left ?
					"left" : "auto" !== a.right ? "right" : null
			},
			sizedBy: {
				height: "none" !== b.maxHeight,
				width: "none" !== b.maxWidth,
				minWidth: parseInt(b.minWidth, 10) || 0,
				minHeight: parseInt(b.minHeight, 10) || 0
			},
			margin: {
				top: parseInt(a.marginTop, 10) || 0,
				right: parseInt(a.marginRight, 10) || 0,
				bottom: parseInt(a.marginBottom, 10) || 0,
				left: parseInt(a.marginLeft, 10) || 0
			}
		};
		this.verticalOffset && (this._fitInfo.margin.top = this._fitInfo.margin.bottom = this.verticalOffset, this._fitInfo.inlineStyle.marginTop = this.style.marginTop || "", this._fitInfo.inlineStyle.marginBottom =
			this.style.marginBottom || "", this.style.marginTop = this.style.marginBottom = this.verticalOffset + "px");
		this.horizontalOffset && (this._fitInfo.margin.left = this._fitInfo.margin.right = this.horizontalOffset, this._fitInfo.inlineStyle.marginLeft = this.style.marginLeft || "", this._fitInfo.inlineStyle.marginRight = this.style.marginRight || "", this.style.marginLeft = this.style.marginRight = this.horizontalOffset + "px")
	}
};
q.resetFit = function() {
	var a = this._fitInfo || {},
		b;
	for (b in a.sizerInlineStyle) this.sizingTarget.style[b] = a.sizerInlineStyle[b];
	for (b in a.inlineStyle) this.style[b] = a.inlineStyle[b];
	this._fitInfo = null
};
q.refit = function() {
	var a = this.sizingTarget.scrollLeft,
		b = this.sizingTarget.scrollTop;
	this.resetFit();
	this.fit();
	this.sizingTarget.scrollLeft = a;
	this.sizingTarget.scrollTop = b
};
q.position = function() {
	if (this.horizontalAlign || this.verticalAlign) {
		this._discoverInfo();
		this.style.position = "fixed";
		this.sizingTarget.style.boxSizing = "border-box";
		this.style.left = "0px";
		this.style.top = "0px";
		var a = this.getBoundingClientRect(),
			b = this.__getNormalizedRect(this.positionTarget),
			c = this.__getNormalizedRect(this.fitInto),
			d = this._fitInfo.margin,
			e = {
				width: a.width + d.left + d.right,
				height: a.height + d.top + d.bottom
			},
			e = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, e, b, c),
			b = e.left +
			d.left,
			e = e.top + d.top,
			f = Math.min(c.right - d.right, b + a.width),
			c = Math.min(c.bottom - d.bottom, e + a.height),
			g = this._fitInfo.sizedBy.minWidth,
			h = this._fitInfo.sizedBy.minHeight;
		b < d.left && (b = d.left, f - b < g && (b = f - g));
		e < d.top && (e = d.top, c - e < h && (e = c - h));
		this.sizingTarget.style.maxWidth = f - b + "px";
		this.sizingTarget.style.maxHeight = c - e + "px";
		this.style.left = b - a.left + "px";
		this.style.top = e - a.top + "px"
	}
};
q.constrain = function() {
	if (!this.horizontalAlign && !this.verticalAlign) {
		this._discoverInfo();
		var a = this._fitInfo;
		a.positionedBy.vertically || (this.style.position = "fixed", this.style.top = "0px");
		a.positionedBy.horizontally || (this.style.position = "fixed", this.style.left = "0px");
		this.sizingTarget.style.boxSizing = "border-box";
		var b = this.getBoundingClientRect();
		a.sizedBy.height || this.__sizeDimension(b, a.positionedBy.vertically, "top", "bottom", "Height");
		a.sizedBy.width || this.__sizeDimension(b, a.positionedBy.horizontally,
			"left", "right", "Width")
	}
};
q._sizeDimension = function(a, b, c, d, e) {
	this.__sizeDimension(a, b, c, d, e)
};
q.__sizeDimension = function(a, b, c, d, e) {
	var f = this._fitInfo,
		g = this.__getNormalizedRect(this.fitInto),
		g = "Width" === e ? g.width : g.height;
	a = (b = b === d) ? g - a[d] : a[c];
	c = f.margin[b ? c : d];
	d = "offset" + e;
	d = this[d] - this.sizingTarget[d];
	this.sizingTarget.style["max" + e] = g - c - a - d + "px"
};
q.center = function() {
	if (!this.horizontalAlign && !this.verticalAlign) {
		this._discoverInfo();
		var a = this._fitInfo.positionedBy;
		if (!a.vertically || !a.horizontally) {
			this.style.position = "fixed";
			a.vertically || (this.style.top = "0px");
			a.horizontally || (this.style.left = "0px");
			var b = this.getBoundingClientRect(),
				c = this.__getNormalizedRect(this.fitInto);
			if (!a.vertically) {
				var d = c.top - b.top + (c.height - b.height) / 2;
				this.style.top = d + "px"
			}
			a.horizontally || (a = c.left - b.left + (c.width - b.width) / 2, this.style.left = a + "px")
		}
	}
};
q.__getNormalizedRect = function(a) {
	return a === document.documentElement || a === window ? {
		top: 0,
		left: 0,
		width: window.innerWidth,
		height: window.innerHeight,
		right: window.innerWidth,
		bottom: window.innerHeight
	} : a.getBoundingClientRect()
};
q.__getCroppedArea = function(a, b, c) {
	var d = Math.min(0, a.top) + Math.min(0, c.bottom - (a.top + b.height));
	a = Math.min(0, a.left) + Math.min(0, c.right - (a.left + b.width));
	return Math.abs(d) * b.width + Math.abs(a) * b.height
};
q.__getPosition = function(a, b, c, d, e) {
	var f = [{
		verticalAlign: "top",
		horizontalAlign: "left",
		top: d.top,
		left: d.left
	}, {
		verticalAlign: "top",
		horizontalAlign: "right",
		top: d.top,
		left: d.right - c.width
	}, {
		verticalAlign: "bottom",
		horizontalAlign: "left",
		top: d.bottom - c.height,
		left: d.left
	}, {
		verticalAlign: "bottom",
		horizontalAlign: "right",
		top: d.bottom - c.height,
		left: d.right - c.width
	}];
	if (this.noOverlap) {
		for (var g = 0, h = f.length; g < h; g++) {
			var k = {},
				l;
			for (l in f[g]) k[l] = f[g][l];
			f.push(k)
		}
		f[0].top = f[1].top += d.height;
		f[2].top = f[3].top -=
			d.height;
		f[4].left = f[6].left += d.width;
		f[5].left = f[7].left -= d.width
	}
	b = "auto" === b ? null : b;
	a = "auto" === a ? null : a;
	for (var m, g = 0; g < f.length; g++) {
		d = f[g];
		if (!this.dynamicAlign && !this.noOverlap && d.verticalAlign === b && d.horizontalAlign === a) {
			m = d;
			break
		}
		h = (!b || d.verticalAlign === b) && (!a || d.horizontalAlign === a);
		if (this.dynamicAlign || h) {
			m = m || d;
			d.croppedArea = this.__getCroppedArea(d, c, e);
			k = d.croppedArea - m.croppedArea;
			if (0 > k || 0 === k && h) m = d;
			if (0 === m.croppedArea && h) break
		}
	}
	return m
};
q.notifyResize = function() {
	this.isAttached && (this._interestedResizables.forEach(function(a) {
		this.resizerShouldNotify(a) && this._notifyDescendant(a)
	}, this), this._fireResize())
};
q.assignParentResizable = function(a) {
	this._parentResizable = a
};
q.stopResizeNotificationsFor = function(a) {
	var b = this._interestedResizables.indexOf(a); - 1 < b && (this._interestedResizables.splice(b, 1), this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
};
q.resizerShouldNotify = function(a) {
	return !0
};
q._onDescendantIronResize = function(a) {
	this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
};
q._fireResize = function() {
	this.fire("iron-resize", null, {
		node: this,
		bubbles: !1
	})
};
q._onIronRequestResizeNotifications = function(a) {
	var b = a.path ? a.path[0] : a.target;
	b !== this && (-1 === this._interestedResizables.indexOf(b) && (this._interestedResizables.push(b), this.listen(b, "iron-resize", "_onDescendantIronResize")), b.assignParentResizable(this), this._notifyDescendant(b), a.stopPropagation())
};
q._parentResizableChanged = function(a) {
	a && window.removeEventListener("resize", this._boundNotifyResize)
};
q._notifyDescendant = function(a) {
	this.isAttached && (this._notifyingDescendant = !0, a.notifyResize(), this._notifyingDescendant = !1)
};
q.toggle = function() {};
q.open = function() {};
q.close = function() {};
q.cancel = function(a) {};
q.invalidateTabbables = function() {};
q._ensureSetup = function() {};
q._openedChanged = function(a) {};
q._canceledChanged = function() {};
q._withBackdropChanged = function() {};
q._prepareRenderOpened = function() {};
q._finishRenderOpened = function() {};
q._finishRenderClosed = function() {};
q._preparePositioning = function() {};
q._finishPositioning = function() {};
q._applyFocus = function() {};
q._onCaptureClick = function(a) {};
q._onCaptureFocus = function(a) {};
q._onCaptureEsc = function(a) {};
q._onCaptureTab = function(a) {};
q._onIronResize = function() {};
q._onNodesChange = function() {};
q.__ensureFirstLastFocusables = function() {};
q.__openedChanged = function() {};
q.__onNextAnimationFrame = function(a) {};
q._modalChanged = function(a, b) {
	a ? this.setAttribute("aria-modal", "true") : this.setAttribute("aria-modal", "false");
	b && (a ? (this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick, this.__prevNoCancelOnEscKey = this.noCancelOnEscKey, this.__prevWithBackdrop = this.withBackdrop, this.withBackdrop = this.noCancelOnEscKey = this.noCancelOnOutsideClick = !0) : (this.noCancelOnOutsideClick = this.noCancelOnOutsideClick && this.__prevNoCancelOnOutsideClick, this.noCancelOnEscKey = this.noCancelOnEscKey && this.__prevNoCancelOnEscKey,
		this.withBackdrop = this.withBackdrop && this.__prevWithBackdrop))
};
q._updateClosingReasonConfirmed = function(a) {
	this.closingReason = this.closingReason || {};
	this.closingReason.confirmed = a
};
q._onDialogClick = function(a) {
	for (var b = Polymer.dom(a).path, c = 0; c < b.indexOf(this); c++) {
		var d = b[c];
		if (d.hasAttribute && (d.hasAttribute("dialog-dismiss") || d.hasAttribute("dialog-confirm"))) {
			this._updateClosingReasonConfirmed(d.hasAttribute("dialog-confirm"));
			this.close();
			a.stopPropagation();
			break
		}
	}
};
q._entryAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.entry = "fade-in-animation" !== this.entryAnimation ? [{
		name: "opaque-animation",
		node: this
	}, {
		name: this.entryAnimation,
		node: this
	}] : [{
		name: this.entryAnimation,
		node: this
	}]
};
q._exitAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.exit = [{
		name: this.exitAnimation,
		node: this
	}]
};
q._copyProperties = function(a, b) {
	for (var c in b) a[c] = b[c]
};
q._cloneConfig = function(a) {
	var b = {
		isClone: !0
	};
	this._copyProperties(b, a);
	return b
};
q._getAnimationConfigRecursive = function(a, b, c) {
	if (this.animationConfig)
		if (this.animationConfig.value && "function" === typeof this.animationConfig.value) this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
		else {
			var d;
			d = a ? this.animationConfig[a] : this.animationConfig;
			Array.isArray(d) || (d = [d]);
			if (d)
				for (var e, f = 0; e = d[f]; f++)
					if (e.animatable) e.animatable._getAnimationConfigRecursive(e.type || a, b, c);
					else if (e.id) {
				var g =
					b[e.id];
				g ? (g.isClone || (b[e.id] = this._cloneConfig(g), g = b[e.id]), this._copyProperties(g, e)) : b[e.id] = e
			} else c.push(e)
		}
};
q.getAnimationConfig = function(a) {
	var b = {},
		c = [];
	this._getAnimationConfigRecursive(a, b, c);
	for (var d in b) c.push(b[d]);
	return c
};
q._configureAnimationEffects = function(a) {
	var b = [];
	if (0 < a.length)
		for (var c, d = 0; c = a[d]; d++) {
			var e = document.createElement(c.name);
			if (e.isNeonAnimation) {
				var f = e.configure(c);
				f && b.push({
					animation: e,
					config: c,
					effect: f
				})
			} else Polymer.Base._warn(this.is + ":", c.name, "not found!")
		}
	return b
};
q._runAnimationEffects = function(a) {
	return document.timeline.play(new GroupEffect(a))
};
q._completeAnimations = function(a) {
	for (var b, c = 0; b = a[c]; c++) b.animation.complete(b.config)
};
q.playAnimation = function(a, b) {
	if (a = this.getAnimationConfig(a)) {
		var c = this._configureAnimationEffects(a);
		a = c.map(function(a) {
			return a.effect
		});
		0 < a.length ? (this._player = this._runAnimationEffects(a), this._player.onfinish = function() {
			this._completeAnimations(c);
			this._player && (this._player.cancel(), this._player = null);
			this.fire("neon-animation-finish", b, {
				bubbles: !1
			})
		}.bind(this)) : this.fire("neon-animation-finish", b, {
			bubbles: !1
		})
	}
};
q.cancelAnimation = function() {
	this._player && this._player.cancel()
};
q._setCanceled = function(a) {};
U.PaperDialog = {};
U.PaperDialog.PaperDialog = {};
(function() {
	Polymer({
		is: "paper-dialog",
		behaviors: [Polymer.PaperDialogBehavior, Polymer.NeonAnimationRunnerBehavior],
		listeners: {
			"neon-animation-finish": "_onNeonAnimationFinish"
		},
		_renderOpened: function() {
			this.cancelAnimation();
			this.withBackdrop && this.backdropElement.open();
			this.playAnimation("entry")
		},
		_renderClosed: function() {
			this.cancelAnimation();
			this.withBackdrop && this.backdropElement.close();
			this.playAnimation("exit")
		},
		_onNeonAnimationFinish: function() {
			this.opened ? this._finishRenderOpened() : this._finishRenderClosed()
		}
	})
})();
U.PaperDialogScrollable = {};
U.PaperDialogScrollable.PaperDialogScrollable = {};
var Qd = function() {};
Polymer({
	is: "paper-dialog-scrollable",
	properties: {
		dialogElement: {
			type: Object
		}
	},
	listeners: {
		"scrollable.scroll": "_scroll"
	},
	get scrollTarget() {
		return this.$.scrollable
	},
	ready: function() {
		this._ensureTarget()
	},
	attached: function() {
		this.classList.add("no-padding");
		this._ensureTarget();
		requestAnimationFrame(this._scroll.bind(this))
	},
	_scroll: function() {
		this.toggleClass("is-scrolled", 0 < this.scrollTarget.scrollTop);
		this.toggleClass("can-scroll", this.scrollTarget.offsetHeight < this.scrollTarget.scrollHeight);
		this.toggleClass("scrolled-to-bottom", this.scrollTarget.scrollTop + this.scrollTarget.offsetHeight >= this.scrollTarget.scrollHeight)
	},
	_ensureTarget: function() {
		(this.dialogElement = this.dialogElement || Polymer.dom(this).parentNode) && this.dialogElement.behaviors && 0 <= this.dialogElement.behaviors.indexOf(Polymer.PaperDialogBehaviorImpl) ? (this.dialogElement.sizingTarget = this.scrollTarget, this.scrollTarget.classList.remove("fit")) : this.dialogElement && this.scrollTarget.classList.add("fit")
	}
});
U.PaperDropdownMenu = {};
U.PaperDropdownMenu.PaperDropdownMenuIcons = {};
U.PaperDropdownMenu.PaperDropdownMenuSharedStyles = {};
U.PaperInput = {};
U.PaperInput.PaperInputBehavior = {};
Polymer.PaperInputHelper = {};
Polymer.PaperInputHelper.NextLabelID = 1;
Polymer.PaperInputHelper.NextAddonID = 1;
Polymer.PaperInputBehaviorImpl = {
	properties: {
		label: {
			type: String
		},
		value: {
			notify: !0,
			type: String
		},
		disabled: {
			type: Boolean,
			value: !1
		},
		invalid: {
			type: Boolean,
			value: !1,
			notify: !0
		},
		preventInvalidInput: {
			type: Boolean
		},
		allowedPattern: {
			type: String
		},
		type: {
			type: String
		},
		list: {
			type: String
		},
		pattern: {
			type: String
		},
		required: {
			type: Boolean,
			value: !1
		},
		errorMessage: {
			type: String
		},
		charCounter: {
			type: Boolean,
			value: !1
		},
		noLabelFloat: {
			type: Boolean,
			value: !1
		},
		alwaysFloatLabel: {
			type: Boolean,
			value: !1
		},
		autoValidate: {
			type: Boolean,
			value: !1
		},
		validator: {
			type: String
		},
		autocomplete: {
			type: String,
			value: "off"
		},
		autofocus: {
			type: Boolean,
			observer: "_autofocusChanged"
		},
		inputmode: {
			type: String
		},
		minlength: {
			type: Number
		},
		maxlength: {
			type: Number
		},
		min: {
			type: String
		},
		max: {
			type: String
		},
		step: {
			type: String
		},
		name: {
			type: String
		},
		placeholder: {
			type: String,
			value: ""
		},
		readonly: {
			type: Boolean,
			value: !1
		},
		size: {
			type: Number
		},
		autocapitalize: {
			type: String,
			value: "none"
		},
		autocorrect: {
			type: String,
			value: "off"
		},
		autosave: {
			type: String
		},
		results: {
			type: Number
		},
		accept: {
			type: String
		},
		multiple: {
			type: Boolean
		},
		_ariaDescribedBy: {
			type: String,
			value: ""
		},
		_ariaLabelledBy: {
			type: String,
			value: ""
		}
	},
	listeners: {
		"addon-attached": "_onAddonAttached"
	},
	keyBindings: {
		"shift+tab:keydown": "_onShiftTabDown"
	},
	hostAttributes: {
		tabindex: 0
	},
	get inputElement() {
		return this.$.input
	},
	get _focusableElement() {
		return this.inputElement
	},
	registered: function() {
		this._typesThatHaveText = "date datetime datetime-local month time week file".split(" ")
	},
	attached: function() {
		this._updateAriaLabelledBy();
		this.inputElement && -1 !== this._typesThatHaveText.indexOf(this.inputElement.type) &&
			(this.alwaysFloatLabel = !0)
	},
	_appendStringWithSpace: function(a, b) {
		return a = a ? a + " " + b : b
	},
	_onAddonAttached: function(a) {
		a = a.path ? a.path[0] : a.target;
		if (a.id) this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, a.id);
		else {
			var b = "paper-input-add-on-" + Polymer.PaperInputHelper.NextAddonID++;
			a.id = b;
			this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, b)
		}
	},
	validate: function() {
		return this.inputElement.validate()
	},
	_focusBlurHandler: function(a) {
		Polymer.IronControlState._focusBlurHandler.call(this,
			a);
		this.focused && !this._shiftTabPressed && this._focusableElement.focus()
	},
	_onShiftTabDown: function(a) {
		var b = this.getAttribute("tabindex");
		this._shiftTabPressed = !0;
		this.setAttribute("tabindex", "-1");
		this.async(function() {
			this.setAttribute("tabindex", b);
			this._shiftTabPressed = !1
		}, 1)
	},
	_handleAutoValidate: function() {
		this.autoValidate && this.validate()
	},
	updateValueAndPreserveCaret: function(a) {
		try {
			var b = this.inputElement.selectionStart;
			this.value = a;
			this.inputElement.selectionStart = b;
			this.inputElement.selectionEnd =
				b
		} catch (c) {
			this.value = a
		}
	},
	_computeAlwaysFloatLabel: function(a, b) {
		return b || a
	},
	_updateAriaLabelledBy: function() {
		var a = Polymer.dom(this.root).querySelector("label");
		if (a) {
			var b;
			a.id ? b = a.id : (b = "paper-input-label-" + Polymer.PaperInputHelper.NextLabelID++, a.id = b);
			this._ariaLabelledBy = b
		} else this._ariaLabelledBy = ""
	},
	_onChange: function(a) {
		this.shadowRoot && this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	},
	_autofocusChanged: function() {
		if (this.autofocus && this._focusableElement) {
			var a =
				document.activeElement,
				b = a instanceof HTMLElement;
			(a = b && a !== document.body && a !== document.documentElement) || this._focusableElement.focus()
		}
	}
};
Polymer.PaperInputBehavior = [Polymer.IronControlState, Polymer.IronA11yKeysBehavior, Polymer.PaperInputBehaviorImpl];
U.PaperInput.PaperInputAddonBehavior = {};
Polymer.PaperInputAddonBehavior = {
	hostAttributes: {
		"add-on": ""
	},
	attached: function() {
		this.fire("addon-attached")
	},
	update: function(a) {}
};
U.PaperInput.PaperInputCharCounter = {};
var Rd = function() {};
Polymer({
	is: "paper-input-char-counter",
	behaviors: [Polymer.PaperInputAddonBehavior],
	properties: {
		_charCounterStr: {
			type: String,
			value: "0"
		}
	},
	update: function(a) {
		if (a.inputElement) {
			a.value = a.value || "";
			var b = a.value.toString().length.toString();
			a.inputElement.hasAttribute("maxlength") && (b += "/" + a.inputElement.getAttribute("maxlength"));
			this._charCounterStr = b
		}
	}
});
U.PaperInput.PaperInputContainer = {};
var Sd = function() {};
Sd.prototype._setFocused = function(a) {};
Polymer({
	is: "paper-input-container",
	properties: {
		noLabelFloat: {
			type: Boolean,
			value: !1
		},
		alwaysFloatLabel: {
			type: Boolean,
			value: !1
		},
		attrForValue: {
			type: String,
			value: "bind-value"
		},
		autoValidate: {
			type: Boolean,
			value: !1
		},
		invalid: {
			observer: "_invalidChanged",
			type: Boolean,
			value: !1
		},
		focused: {
			readOnly: !0,
			type: Boolean,
			value: !1,
			notify: !0
		},
		_addons: {
			type: Array
		},
		_inputHasContent: {
			type: Boolean,
			value: !1
		},
		_inputSelector: {
			type: String,
			value: "input,textarea,.paper-input-input"
		},
		_boundOnFocus: {
			type: Function,
			value: function() {
				return this._onFocus.bind(this)
			}
		},
		_boundOnBlur: {
			type: Function,
			value: function() {
				return this._onBlur.bind(this)
			}
		},
		_boundOnInput: {
			type: Function,
			value: function() {
				return this._onInput.bind(this)
			}
		},
		_boundValueChanged: {
			type: Function,
			value: function() {
				return this._onValueChanged.bind(this)
			}
		}
	},
	listeners: {
		"addon-attached": "_onAddonAttached",
		"iron-input-validate": "_onIronInputValidate"
	},
	get _valueChangedEvent() {
		return this.attrForValue + "-changed"
	},
	get _propertyForValue() {
		return Polymer.CaseMap.dashToCamelCase(this.attrForValue)
	},
	get _inputElement() {
		return Polymer.dom(this).querySelector(this._inputSelector)
	},
	get _inputElementValue() {
		return this._inputElement[this._propertyForValue] || this._inputElement.value
	},
	ready: function() {
		this._addons || (this._addons = []);
		this.addEventListener("focus", this._boundOnFocus, !0);
		this.addEventListener("blur", this._boundOnBlur, !0)
	},
	attached: function() {
		this.attrForValue ? this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged) : this.addEventListener("input", this._onInput);
		"" != this._inputElementValue ? this._handleValueAndAutoValidate(this._inputElement) :
			this._handleValue(this._inputElement)
	},
	_onAddonAttached: function(a) {
		this._addons || (this._addons = []);
		a = a.target; - 1 === this._addons.indexOf(a) && (this._addons.push(a), this.isAttached && this._handleValue(this._inputElement))
	},
	_onFocus: function() {
		this._setFocused(!0)
	},
	_onBlur: function() {
		this._setFocused(!1);
		this._handleValueAndAutoValidate(this._inputElement)
	},
	_onInput: function(a) {
		this._handleValueAndAutoValidate(a.target)
	},
	_onValueChanged: function(a) {
		this._handleValueAndAutoValidate(a.target)
	},
	_handleValue: function(a) {
		var b =
			this._inputElementValue;
		b || 0 === b || "number" === a.type && !a.checkValidity() ? this._inputHasContent = !0 : this._inputHasContent = !1;
		this.updateAddons({
			inputElement: a,
			value: b,
			invalid: this.invalid
		})
	},
	_handleValueAndAutoValidate: function(a) {
		if (this.autoValidate) {
			var b;
			b = a.validate ? a.validate(this._inputElementValue) : a.checkValidity();
			this.invalid = !b
		}
		this._handleValue(a)
	},
	_onIronInputValidate: function(a) {
		this.invalid = this._inputElement.invalid
	},
	_invalidChanged: function() {
		this._addons && this.updateAddons({
			invalid: this.invalid
		})
	},
	updateAddons: function(a) {
		for (var b, c = 0; b = this._addons[c]; c++) b.update(a)
	},
	_computeInputContentClass: function(a, b, c, d, e) {
		var f = "input-content";
		a ? e && (f += " label-is-hidden") : (a = this.querySelector("label"), b || e ? (f += " label-is-floating", this.$.labelAndInputContainer.style.position = "static", d ? f += " is-invalid" : c && (f += " label-is-highlighted")) : a && (this.$.labelAndInputContainer.style.position = "relative"));
		return f
	},
	_computeUnderlineClass: function(a, b) {
		var c = "underline";
		b ? c += " is-invalid" : a && (c += " is-highlighted");
		return c
	},
	_computeAddOnContentClass: function(a, b) {
		var c = "add-on-content";
		b ? c += " is-invalid" : a && (c += " is-highlighted");
		return c
	}
});
U.PaperInput.PaperInputError = {};
var Td = function() {};
Td.prototype._setInvalid = function(a) {};
Polymer({
	is: "paper-input-error",
	behaviors: [Polymer.PaperInputAddonBehavior],
	properties: {
		invalid: {
			readOnly: !0,
			reflectToAttribute: !0,
			type: Boolean
		}
	},
	update: function(a) {
		this._setInvalid(a.invalid)
	}
});
U.IronA11yAnnouncer = {};
U.IronA11yAnnouncer.IronA11yAnnouncer = {};
(function() {
	Polymer.IronA11yAnnouncer = function() {};
	Polymer.IronA11yAnnouncer = Polymer({
		is: "iron-a11y-announcer",
		properties: {
			mode: {
				type: String,
				value: "polite"
			},
			_text: {
				type: String,
				value: ""
			}
		},
		created: function() {
			Polymer.IronA11yAnnouncer.instance || (Polymer.IronA11yAnnouncer.instance = this);
			document.body.addEventListener("iron-announce", this._onIronAnnounce.bind(this))
		},
		announce: function(a) {
			this._text = "";
			this.async(function() {
				this._text = a
			}, 100)
		},
		_onIronAnnounce: function(a) {
			a.detail && a.detail.text && this.announce(a.detail.text)
		}
	});
	Polymer.IronA11yAnnouncer.instance = null;
	Polymer.IronA11yAnnouncer.requestAvailability = function() {
		Polymer.IronA11yAnnouncer.instance || (Polymer.IronA11yAnnouncer.instance = document.createElement("iron-a11y-announcer"));
		document.body.appendChild(Polymer.IronA11yAnnouncer.instance)
	}
})();
U.IronInput = {};
U.IronInput.IronInput = {};
var Ud = function() {};
Ud.prototype._invalidChanged = function() {
	this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")
};
Ud.prototype.hasValidator = function() {
	return null != this._validator
};
Ud.prototype._getValidity = function(a) {
	return this.hasValidator() ? this._validator.validate(a) : !0
};
Ud.prototype.__computeValidator = function() {
	return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator)
};
Polymer({
	is: "iron-input",
	extends: "input",
	behaviors: [Polymer.IronValidatableBehavior],
	properties: {
		bindValue: {
			observer: "_bindValueChanged",
			type: String
		},
		preventInvalidInput: {
			type: Boolean
		},
		allowedPattern: {
			type: String,
			observer: "_allowedPatternChanged"
		},
		_previousValidInput: {
			type: String,
			value: ""
		},
		_patternAlreadyChecked: {
			type: Boolean,
			value: !1
		}
	},
	listeners: {
		input: "_onInput",
		keypress: "_onKeypress"
	},
	registered: function() {
		this._canDispatchEventOnDisabled() || (this._origDispatchEvent = this.dispatchEvent, this.dispatchEvent =
			this._dispatchEventFirefoxIE)
	},
	created: function() {
		Polymer.IronA11yAnnouncer.requestAvailability()
	},
	_canDispatchEventOnDisabled: function() {
		var a = document.createElement("input"),
			b = !1;
		a.disabled = !0;
		a.addEventListener("feature-check-dispatch-event", function() {
			b = !0
		});
		try {
			a.dispatchEvent(new Event("feature-check-dispatch-event"))
		} catch (c) {}
		return b
	},
	_dispatchEventFirefoxIE: function() {
		var a = this.disabled;
		this.disabled = !1;
		this._origDispatchEvent.apply(this, arguments);
		this.disabled = a
	},
	get _patternRegExp() {
		var a;
		if (this.allowedPattern) a = new RegExp(this.allowedPattern);
		else switch (this.type) {
			case "number":
				a = /[0-9.,e-]/
		}
		return a
	},
	ready: function() {
		this.bindValue = this.value
	},
	_bindValueChanged: function() {
		this.value !== this.bindValue && (this.value = this.bindValue || 0 === this.bindValue || !1 === this.bindValue ? this.bindValue : "");
		this.fire("bind-value-changed", {
			value: this.bindValue
		})
	},
	_allowedPatternChanged: function() {
		this.preventInvalidInput = this.allowedPattern ? !0 : !1
	},
	_onInput: function() {
		if (this.preventInvalidInput && !this._patternAlreadyChecked) {
			var a =
				this._checkPatternValidity();
			a || (this._announceInvalidCharacter("Invalid string of characters not entered."), this.value = this._previousValidInput)
		}
		this._previousValidInput = this.bindValue = this.value;
		this._patternAlreadyChecked = !1
	},
	_isPrintable: function(a) {
		var b = 8 == a.keyCode || 9 == a.keyCode || 13 == a.keyCode || 27 == a.keyCode,
			c = 19 == a.keyCode || 20 == a.keyCode || 45 == a.keyCode || 46 == a.keyCode || 144 == a.keyCode || 145 == a.keyCode || 32 < a.keyCode && 41 > a.keyCode || 111 < a.keyCode && 124 > a.keyCode;
		return !b && !(0 == a.charCode && c)
	},
	_onKeypress: function(a) {
		if (this.preventInvalidInput ||
			"number" === this.type) {
			var b = this._patternRegExp;
			if (b && !(a.metaKey || a.ctrlKey || a.altKey)) {
				this._patternAlreadyChecked = !0;
				var c = String.fromCharCode(a.charCode);
				this._isPrintable(a) && !b.test(c) && (a.preventDefault(), this._announceInvalidCharacter("Invalid character " + c + " not entered."))
			}
		}
	},
	_checkPatternValidity: function() {
		var a = this._patternRegExp;
		if (!a) return !0;
		for (var b = 0; b < this.value.length; b++)
			if (!a.test(this.value[b])) return !1;
		return !0
	},
	validate: function() {
		var a = this.checkValidity();
		a && (this.required &&
			"" === this.value ? a = !1 : this.hasValidator() && (a = Polymer.IronValidatableBehavior.validate.call(this, this.value)));
		this.invalid = !a;
		this.fire("iron-input-validate");
		return a
	},
	_announceInvalidCharacter: function(a) {
		this.fire("iron-announce", {
			text: a
		})
	}
});
U.PaperInput.PaperInput = {};
var Vd = function() {};
q = Vd.prototype;
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q.registered = function() {
	this._typesThatHaveText = "date datetime datetime-local month time week file".split(" ")
};
q._appendStringWithSpace = function(a, b) {
	return a = a ? a + " " + b : b
};
q._onAddonAttached = function(a) {
	a = a.path ? a.path[0] : a.target;
	if (a.id) this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, a.id);
	else {
		var b = "paper-input-add-on-" + Polymer.PaperInputHelper.NextAddonID++;
		a.id = b;
		this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, b)
	}
};
q.validate = function() {
	return this.inputElement.validate()
};
q._focusBlurHandler = function(a) {
	Polymer.IronControlState._focusBlurHandler.call(this, a);
	this.focused && !this._shiftTabPressed && this._focusableElement.focus()
};
q._onShiftTabDown = function(a) {
	var b = this.getAttribute("tabindex");
	this._shiftTabPressed = !0;
	this.setAttribute("tabindex", "-1");
	this.async(function() {
		this.setAttribute("tabindex", b);
		this._shiftTabPressed = !1
	}, 1)
};
q._handleAutoValidate = function() {
	this.autoValidate && this.validate()
};
q.updateValueAndPreserveCaret = function(a) {
	try {
		var b = this.inputElement.selectionStart;
		this.value = a;
		this.inputElement.selectionStart = b;
		this.inputElement.selectionEnd = b
	} catch (c) {
		this.value = a
	}
};
q._computeAlwaysFloatLabel = function(a, b) {
	return b || a
};
q._updateAriaLabelledBy = function() {
	var a = Polymer.dom(this.root).querySelector("label");
	if (a) {
		var b;
		a.id ? b = a.id : (b = "paper-input-label-" + Polymer.PaperInputHelper.NextLabelID++, a.id = b);
		this._ariaLabelledBy = b
	} else this._ariaLabelledBy = ""
};
q._onChange = function(a) {
	this.shadowRoot && this.fire(a.type, {
		sourceEvent: a
	}, {
		node: this,
		bubbles: a.bubbles,
		cancelable: a.cancelable
	})
};
q._autofocusChanged = function() {
	if (this.autofocus && this._focusableElement) {
		var a = document.activeElement,
			b = a instanceof HTMLElement;
		(a = b && a !== document.body && a !== document.documentElement) || this._focusableElement.focus()
	}
};
q._setFocused = function(a) {};
Polymer({
	is: "paper-input",
	behaviors: [Polymer.IronFormElementBehavior, Polymer.PaperInputBehavior]
});
U.IronAutogrowTextarea = {};
U.IronAutogrowTextarea.IronAutogrowTextarea = {};
var Wd = function() {};
q = Wd.prototype;
q.registered = function() {
	Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({
		type: "validator"
	})
};
q._invalidChanged = function() {
	this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")
};
q.hasValidator = function() {
	return null != this._validator
};
q._getValidity = function(a) {
	return this.hasValidator() ? this._validator.validate(a) : !0
};
q.__computeValidator = function() {
	return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator)
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._setFocused = function(a) {};
Polymer({
	is: "iron-autogrow-textarea",
	behaviors: [Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior, Polymer.IronControlState],
	properties: {
		bindValue: {
			observer: "_bindValueChanged",
			type: String
		},
		rows: {
			type: Number,
			value: 1,
			observer: "_updateCached"
		},
		maxRows: {
			type: Number,
			value: 0,
			observer: "_updateCached"
		},
		autocomplete: {
			type: String,
			value: "off"
		},
		autofocus: {
			type: Boolean,
			value: !1
		},
		inputmode: {
			type: String
		},
		placeholder: {
			type: String
		},
		readonly: {
			type: String
		},
		required: {
			type: Boolean
		},
		maxlength: {
			type: Number
		}
	},
	listeners: {
		input: "_onInput"
	},
	observers: ["_onValueChanged(value)"],
	get textarea() {
		return this.$.textarea
	},
	get selectionStart() {
		return this.$.textarea.selectionStart
	},
	get selectionEnd() {
		return this.$.textarea.selectionEnd
	},
	set selectionStart(a) {
		this.$.textarea.selectionStart = a
	},
	set selectionEnd(a) {
		this.$.textarea.selectionEnd = a
	},
	validate: function() {
		if (!this.required && "" == this.value) return this.invalid = !1, !0;
		var a;
		this.hasValidator() ? a = Polymer.IronValidatableBehavior.validate.call(this, this.value) : (a =
			this.$.textarea.validity.valid, this.invalid = !a);
		this.fire("iron-input-validate");
		return a
	},
	_bindValueChanged: function() {
		var a = this.textarea;
		a && (a.value !== this.bindValue && (a.value = this.bindValue || 0 === this.bindValue ? this.bindValue : ""), this.value = this.bindValue, this.$.mirror.innerHTML = this._valueForMirror(), this.fire("bind-value-changed", {
			value: this.bindValue
		}))
	},
	_onInput: function(a) {
		this.bindValue = a.path ? a.path[0].value : a.target.value
	},
	_constrain: function(a) {
		var b;
		a = a || [""];
		for (b = 0 < this.maxRows && a.length >
			this.maxRows ? a.slice(0, this.maxRows) : a.slice(0); 0 < this.rows && b.length < this.rows;) b.push("");
		return b.join("<br/>") + "&#160;"
	},
	_valueForMirror: function() {
		var a = this.textarea;
		if (a) return this.tokens = a && a.value ? a.value.replace(/&/gm, "&amp;").replace(/"/gm, "&quot;").replace(/'/gm, "&#39;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").split("\n") : [""], this._constrain(this.tokens)
	},
	_updateCached: function() {
		this.$.mirror.innerHTML = this._constrain(this.tokens)
	},
	_onValueChanged: function() {
		this.bindValue = this.value
	}
});
U.PaperInput.PaperTextarea = {};
var Xd = function() {};
q = Xd.prototype;
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q.registered = function() {
	this._typesThatHaveText = "date datetime datetime-local month time week file".split(" ")
};
q._appendStringWithSpace = function(a, b) {
	return a = a ? a + " " + b : b
};
q._onAddonAttached = function(a) {
	a = a.path ? a.path[0] : a.target;
	if (a.id) this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, a.id);
	else {
		var b = "paper-input-add-on-" + Polymer.PaperInputHelper.NextAddonID++;
		a.id = b;
		this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, b)
	}
};
q.validate = function() {
	return this.inputElement.validate()
};
q._focusBlurHandler = function(a) {
	Polymer.IronControlState._focusBlurHandler.call(this, a);
	this.focused && !this._shiftTabPressed && this._focusableElement.focus()
};
q._onShiftTabDown = function(a) {
	var b = this.getAttribute("tabindex");
	this._shiftTabPressed = !0;
	this.setAttribute("tabindex", "-1");
	this.async(function() {
		this.setAttribute("tabindex", b);
		this._shiftTabPressed = !1
	}, 1)
};
q._handleAutoValidate = function() {
	this.autoValidate && this.validate()
};
q.updateValueAndPreserveCaret = function(a) {
	try {
		var b = this.inputElement.selectionStart;
		this.value = a;
		this.inputElement.selectionStart = b;
		this.inputElement.selectionEnd = b
	} catch (c) {
		this.value = a
	}
};
q._computeAlwaysFloatLabel = function(a, b) {
	return b || a
};
q._updateAriaLabelledBy = function() {
	var a = Polymer.dom(this.root).querySelector("label");
	if (a) {
		var b;
		a.id ? b = a.id : (b = "paper-input-label-" + Polymer.PaperInputHelper.NextLabelID++, a.id = b);
		this._ariaLabelledBy = b
	} else this._ariaLabelledBy = ""
};
q._onChange = function(a) {
	this.shadowRoot && this.fire(a.type, {
		sourceEvent: a
	}, {
		node: this,
		bubbles: a.bubbles,
		cancelable: a.cancelable
	})
};
q._autofocusChanged = function() {
	if (this.autofocus && this._focusableElement) {
		var a = document.activeElement,
			b = a instanceof HTMLElement;
		(a = b && a !== document.body && a !== document.documentElement) || this._focusableElement.focus()
	}
};
q._setFocused = function(a) {};
Polymer({
	is: "paper-textarea",
	behaviors: [Polymer.PaperInputBehavior, Polymer.IronFormElementBehavior],
	properties: {
		_ariaLabelledBy: {
			observer: "_ariaLabelledByChanged",
			type: String
		},
		_ariaDescribedBy: {
			observer: "_ariaDescribedByChanged",
			type: String
		},
		rows: {
			type: Number,
			value: 1
		},
		maxRows: {
			type: Number,
			value: 0
		}
	},
	_ariaLabelledByChanged: function(a) {
		this.$.input.textarea.setAttribute("aria-labelledby", a)
	},
	_ariaDescribedByChanged: function(a) {
		this.$.input.textarea.setAttribute("aria-describedby", a)
	},
	get _focusableElement() {
		return this.$.input.textarea
	}
});
U.PaperInput.AllImports = {};
U.PaperMenuButton = {};
U.PaperMenuButton.PaperMenuButtonAnimations = {};
var Yd = function() {};
Yd.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Yd.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Yd.prototype.complete = function() {};
Polymer({
	is: "paper-menu-grow-height-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node,
			c = b.getBoundingClientRect(),
			c = c.height;
		return this._effect = new KeyframeEffect(b, [{
			height: c / 2 + "px"
		}, {
			height: c + "px"
		}], this.timingFromConfig(a))
	}
});
var Zd = function() {};
Zd.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
Zd.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
Zd.prototype.complete = function() {};
Polymer({
	is: "paper-menu-grow-width-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node,
			c = b.getBoundingClientRect(),
			c = c.width;
		return this._effect = new KeyframeEffect(b, [{
			width: c / 2 + "px"
		}, {
			width: c + "px"
		}], this.timingFromConfig(a))
	}
});
var $d = function() {};
$d.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
$d.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
$d.prototype.complete = function() {};
Polymer({
	is: "paper-menu-shrink-width-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node,
			c = b.getBoundingClientRect(),
			c = c.width;
		return this._effect = new KeyframeEffect(b, [{
			width: c + "px"
		}, {
			width: c - c / 20 + "px"
		}], this.timingFromConfig(a))
	}
});
var ae = function() {};
ae.prototype.timingFromConfig = function(a) {
	if (a.timing)
		for (var b in a.timing) this.animationTiming[b] = a.timing[b];
	return this.animationTiming
};
ae.prototype.setPrefixedProperty = function(a, b, c) {
	for (var d = {
			transform: ["webkitTransform"],
			transformOrigin: ["mozTransformOrigin", "webkitTransformOrigin"]
		}, d = d[b], e, f = 0; e = d[f]; f++) a.style[e] = c;
	a.style[b] = c
};
ae.prototype.complete = function() {};
Polymer({
	is: "paper-menu-shrink-height-animation",
	behaviors: [Polymer.NeonAnimationBehavior],
	configure: function(a) {
		var b = a.node,
			c = b.getBoundingClientRect(),
			d = c.height,
			c = c.top;
		this.setPrefixedProperty(b, "transformOrigin", "0 0");
		return this._effect = new KeyframeEffect(b, [{
			height: d + "px",
			transform: "translateY(0)"
		}, {
			height: d / 2 + "px",
			transform: "translateY(-20px)"
		}], this.timingFromConfig(a))
	}
});
U.IronDropdown = {};
U.IronDropdown.IronDropdownScrollManager = {};
(function() {
	Polymer.IronDropdownScrollManager = {get currentLockingElement() {
			return this._lockingElements[this._lockingElements.length - 1]
		},
		elementIsScrollLocked: function(a) {
			var b = this.currentLockingElement;
			if (void 0 === b) return !1;
			if (this._hasCachedLockedElement(a)) return !0;
			if (this._hasCachedUnlockedElement(a)) return !1;
			(b = !!b && b !== a && !this._composedTreeContains(b, a)) ? this._lockedElementCache.push(a): this._unlockedElementCache.push(a);
			return b
		},
		pushScrollLock: function(a) {
			0 <= this._lockingElements.indexOf(a) ||
				(0 === this._lockingElements.length && this._lockScrollInteractions(), this._lockingElements.push(a), this._lockedElementCache = [], this._unlockedElementCache = [])
		},
		removeScrollLock: function(a) {
			a = this._lockingElements.indexOf(a); - 1 !== a && (this._lockingElements.splice(a, 1), this._lockedElementCache = [], this._unlockedElementCache = [], 0 === this._lockingElements.length && this._unlockScrollInteractions())
		},
		_lockingElements: [],
		_lockedElementCache: null,
		_unlockedElementCache: null,
		_originalBodyStyles: {},
		_isScrollingKeypress: function(a) {
			return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(a,
				"pageup pagedown home end up left down right")
		},
		_hasCachedLockedElement: function(a) {
			return -1 < this._lockedElementCache.indexOf(a)
		},
		_hasCachedUnlockedElement: function(a) {
			return -1 < this._unlockedElementCache.indexOf(a)
		},
		_composedTreeContains: function(a, b) {
			var c, d, e;
			if (a.contains(b)) return !0;
			a = Polymer.dom(a).querySelectorAll("content");
			for (d = 0; d < a.length; ++d)
				for (c = Polymer.dom(a[d]).getDistributedNodes(), e = 0; e < c.length; ++e)
					if (this._composedTreeContains(c[e], b)) return !0;
			return !1
		},
		_scrollInteractionHandler: function(a) {
			var b =
				Polymer.dom(a).rootTarget;
			Polymer.IronDropdownScrollManager.elementIsScrollLocked(b) && ("keydown" !== a.type || Polymer.IronDropdownScrollManager._isScrollingKeypress(a)) && a.preventDefault()
		},
		_lockScrollInteractions: function() {
			this._originalBodyStyles.overflow = document.body.style.overflow;
			this._originalBodyStyles.overflowX = document.body.style.overflowX;
			this._originalBodyStyles.overflowY = document.body.style.overflowY;
			document.body.style.overflow = "hidden";
			document.body.style.overflowX = "hidden";
			document.body.style.overflowY =
				"hidden";
			document.addEventListener("wheel", this._scrollInteractionHandler, !0);
			document.addEventListener("mousewheel", this._scrollInteractionHandler, !0);
			document.addEventListener("DOMMouseScroll", this._scrollInteractionHandler, !0);
			document.addEventListener("touchmove", this._scrollInteractionHandler, !0);
			document.addEventListener("keydown", this._scrollInteractionHandler, !0)
		},
		_unlockScrollInteractions: function() {
			document.body.style.overflow = this._originalBodyStyles.overflow;
			document.body.style.overflowX =
				this._originalBodyStyles.overflowX;
			document.body.style.overflowY = this._originalBodyStyles.overflowY;
			document.removeEventListener("wheel", this._scrollInteractionHandler, !0);
			document.removeEventListener("mousewheel", this._scrollInteractionHandler, !0);
			document.removeEventListener("DOMMouseScroll", this._scrollInteractionHandler, !0);
			document.removeEventListener("touchmove", this._scrollInteractionHandler, !0);
			document.removeEventListener("keydown", this._scrollInteractionHandler, !0)
		}
	}
})();
var be = function() {};
q = be.prototype;
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q.fit = function() {
	this.position();
	this.constrain();
	this.center()
};
q._discoverInfo = function() {
	if (!this._fitInfo) {
		var a = window.getComputedStyle(this),
			b = window.getComputedStyle(this.sizingTarget);
		this._fitInfo = {
			inlineStyle: {
				top: this.style.top || "",
				left: this.style.left || "",
				position: this.style.position || ""
			},
			sizerInlineStyle: {
				maxWidth: this.sizingTarget.style.maxWidth || "",
				maxHeight: this.sizingTarget.style.maxHeight || "",
				boxSizing: this.sizingTarget.style.boxSizing || ""
			},
			positionedBy: {
				vertically: "auto" !== a.top ? "top" : "auto" !== a.bottom ? "bottom" : null,
				horizontally: "auto" !== a.left ?
					"left" : "auto" !== a.right ? "right" : null
			},
			sizedBy: {
				height: "none" !== b.maxHeight,
				width: "none" !== b.maxWidth,
				minWidth: parseInt(b.minWidth, 10) || 0,
				minHeight: parseInt(b.minHeight, 10) || 0
			},
			margin: {
				top: parseInt(a.marginTop, 10) || 0,
				right: parseInt(a.marginRight, 10) || 0,
				bottom: parseInt(a.marginBottom, 10) || 0,
				left: parseInt(a.marginLeft, 10) || 0
			}
		};
		this.verticalOffset && (this._fitInfo.margin.top = this._fitInfo.margin.bottom = this.verticalOffset, this._fitInfo.inlineStyle.marginTop = this.style.marginTop || "", this._fitInfo.inlineStyle.marginBottom =
			this.style.marginBottom || "", this.style.marginTop = this.style.marginBottom = this.verticalOffset + "px");
		this.horizontalOffset && (this._fitInfo.margin.left = this._fitInfo.margin.right = this.horizontalOffset, this._fitInfo.inlineStyle.marginLeft = this.style.marginLeft || "", this._fitInfo.inlineStyle.marginRight = this.style.marginRight || "", this.style.marginLeft = this.style.marginRight = this.horizontalOffset + "px")
	}
};
q.resetFit = function() {
	var a = this._fitInfo || {},
		b;
	for (b in a.sizerInlineStyle) this.sizingTarget.style[b] = a.sizerInlineStyle[b];
	for (b in a.inlineStyle) this.style[b] = a.inlineStyle[b];
	this._fitInfo = null
};
q.position = function() {
	if (this.horizontalAlign || this.verticalAlign) {
		this._discoverInfo();
		this.style.position = "fixed";
		this.sizingTarget.style.boxSizing = "border-box";
		this.style.left = "0px";
		this.style.top = "0px";
		var a = this.getBoundingClientRect(),
			b = this.__getNormalizedRect(this.positionTarget),
			c = this.__getNormalizedRect(this.fitInto),
			d = this._fitInfo.margin,
			e = {
				width: a.width + d.left + d.right,
				height: a.height + d.top + d.bottom
			},
			e = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, e, b, c),
			b = e.left +
			d.left,
			e = e.top + d.top,
			f = Math.min(c.right - d.right, b + a.width),
			c = Math.min(c.bottom - d.bottom, e + a.height),
			g = this._fitInfo.sizedBy.minWidth,
			h = this._fitInfo.sizedBy.minHeight;
		b < d.left && (b = d.left, f - b < g && (b = f - g));
		e < d.top && (e = d.top, c - e < h && (e = c - h));
		this.sizingTarget.style.maxWidth = f - b + "px";
		this.sizingTarget.style.maxHeight = c - e + "px";
		this.style.left = b - a.left + "px";
		this.style.top = e - a.top + "px"
	}
};
q.constrain = function() {
	if (!this.horizontalAlign && !this.verticalAlign) {
		this._discoverInfo();
		var a = this._fitInfo;
		a.positionedBy.vertically || (this.style.position = "fixed", this.style.top = "0px");
		a.positionedBy.horizontally || (this.style.position = "fixed", this.style.left = "0px");
		this.sizingTarget.style.boxSizing = "border-box";
		var b = this.getBoundingClientRect();
		a.sizedBy.height || this.__sizeDimension(b, a.positionedBy.vertically, "top", "bottom", "Height");
		a.sizedBy.width || this.__sizeDimension(b, a.positionedBy.horizontally,
			"left", "right", "Width")
	}
};
q._sizeDimension = function(a, b, c, d, e) {
	this.__sizeDimension(a, b, c, d, e)
};
q.__sizeDimension = function(a, b, c, d, e) {
	var f = this._fitInfo,
		g = this.__getNormalizedRect(this.fitInto),
		g = "Width" === e ? g.width : g.height;
	a = (b = b === d) ? g - a[d] : a[c];
	c = f.margin[b ? c : d];
	d = "offset" + e;
	d = this[d] - this.sizingTarget[d];
	this.sizingTarget.style["max" + e] = g - c - a - d + "px"
};
q.center = function() {
	if (!this.horizontalAlign && !this.verticalAlign) {
		this._discoverInfo();
		var a = this._fitInfo.positionedBy;
		if (!a.vertically || !a.horizontally) {
			this.style.position = "fixed";
			a.vertically || (this.style.top = "0px");
			a.horizontally || (this.style.left = "0px");
			var b = this.getBoundingClientRect(),
				c = this.__getNormalizedRect(this.fitInto);
			if (!a.vertically) {
				var d = c.top - b.top + (c.height - b.height) / 2;
				this.style.top = d + "px"
			}
			a.horizontally || (a = c.left - b.left + (c.width - b.width) / 2, this.style.left = a + "px")
		}
	}
};
q.__getNormalizedRect = function(a) {
	return a === document.documentElement || a === window ? {
		top: 0,
		left: 0,
		width: window.innerWidth,
		height: window.innerHeight,
		right: window.innerWidth,
		bottom: window.innerHeight
	} : a.getBoundingClientRect()
};
q.__getCroppedArea = function(a, b, c) {
	var d = Math.min(0, a.top) + Math.min(0, c.bottom - (a.top + b.height));
	a = Math.min(0, a.left) + Math.min(0, c.right - (a.left + b.width));
	return Math.abs(d) * b.width + Math.abs(a) * b.height
};
q.__getPosition = function(a, b, c, d, e) {
	var f = [{
		verticalAlign: "top",
		horizontalAlign: "left",
		top: d.top,
		left: d.left
	}, {
		verticalAlign: "top",
		horizontalAlign: "right",
		top: d.top,
		left: d.right - c.width
	}, {
		verticalAlign: "bottom",
		horizontalAlign: "left",
		top: d.bottom - c.height,
		left: d.left
	}, {
		verticalAlign: "bottom",
		horizontalAlign: "right",
		top: d.bottom - c.height,
		left: d.right - c.width
	}];
	if (this.noOverlap) {
		for (var g = 0, h = f.length; g < h; g++) {
			var k = {},
				l;
			for (l in f[g]) k[l] = f[g][l];
			f.push(k)
		}
		f[0].top = f[1].top += d.height;
		f[2].top = f[3].top -=
			d.height;
		f[4].left = f[6].left += d.width;
		f[5].left = f[7].left -= d.width
	}
	b = "auto" === b ? null : b;
	a = "auto" === a ? null : a;
	for (var m, g = 0; g < f.length; g++) {
		d = f[g];
		if (!this.dynamicAlign && !this.noOverlap && d.verticalAlign === b && d.horizontalAlign === a) {
			m = d;
			break
		}
		h = (!b || d.verticalAlign === b) && (!a || d.horizontalAlign === a);
		if (this.dynamicAlign || h) {
			m = m || d;
			d.croppedArea = this.__getCroppedArea(d, c, e);
			k = d.croppedArea - m.croppedArea;
			if (0 > k || 0 === k && h) m = d;
			if (0 === m.croppedArea && h) break
		}
	}
	return m
};
q.notifyResize = function() {
	this.isAttached && (this._interestedResizables.forEach(function(a) {
		this.resizerShouldNotify(a) && this._notifyDescendant(a)
	}, this), this._fireResize())
};
q.assignParentResizable = function(a) {
	this._parentResizable = a
};
q.stopResizeNotificationsFor = function(a) {
	var b = this._interestedResizables.indexOf(a); - 1 < b && (this._interestedResizables.splice(b, 1), this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
};
q.resizerShouldNotify = function(a) {
	return !0
};
q._onDescendantIronResize = function(a) {
	this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
};
q._fireResize = function() {
	this.fire("iron-resize", null, {
		node: this,
		bubbles: !1
	})
};
q._onIronRequestResizeNotifications = function(a) {
	var b = a.path ? a.path[0] : a.target;
	b !== this && (-1 === this._interestedResizables.indexOf(b) && (this._interestedResizables.push(b), this.listen(b, "iron-resize", "_onDescendantIronResize")), b.assignParentResizable(this), this._notifyDescendant(b), a.stopPropagation())
};
q._parentResizableChanged = function(a) {
	a && window.removeEventListener("resize", this._boundNotifyResize)
};
q._notifyDescendant = function(a) {
	this.isAttached && (this._notifyingDescendant = !0, a.notifyResize(), this._notifyingDescendant = !1)
};
q.toggle = function() {};
q.open = function() {};
q.close = function() {};
q.cancel = function(a) {};
q.invalidateTabbables = function() {};
q._ensureSetup = function() {};
q._canceledChanged = function() {};
q._withBackdropChanged = function() {};
q._prepareRenderOpened = function() {};
q._finishRenderOpened = function() {};
q._finishRenderClosed = function() {};
q._preparePositioning = function() {};
q._finishPositioning = function() {};
q._onCaptureClick = function(a) {};
q._onCaptureFocus = function(a) {};
q._onCaptureEsc = function(a) {};
q._onCaptureTab = function(a) {};
q._onIronResize = function() {};
q._onNodesChange = function() {};
q.__ensureFirstLastFocusables = function() {};
q.__openedChanged = function() {};
q.__onNextAnimationFrame = function(a) {};
q._entryAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.entry = "fade-in-animation" !== this.entryAnimation ? [{
		name: "opaque-animation",
		node: this
	}, {
		name: this.entryAnimation,
		node: this
	}] : [{
		name: this.entryAnimation,
		node: this
	}]
};
q._exitAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.exit = [{
		name: this.exitAnimation,
		node: this
	}]
};
q._copyProperties = function(a, b) {
	for (var c in b) a[c] = b[c]
};
q._cloneConfig = function(a) {
	var b = {
		isClone: !0
	};
	this._copyProperties(b, a);
	return b
};
q._getAnimationConfigRecursive = function(a, b, c) {
	if (this.animationConfig)
		if (this.animationConfig.value && "function" === typeof this.animationConfig.value) this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
		else {
			var d;
			d = a ? this.animationConfig[a] : this.animationConfig;
			Array.isArray(d) || (d = [d]);
			if (d)
				for (var e, f = 0; e = d[f]; f++)
					if (e.animatable) e.animatable._getAnimationConfigRecursive(e.type || a, b, c);
					else if (e.id) {
				var g =
					b[e.id];
				g ? (g.isClone || (b[e.id] = this._cloneConfig(g), g = b[e.id]), this._copyProperties(g, e)) : b[e.id] = e
			} else c.push(e)
		}
};
q.getAnimationConfig = function(a) {
	var b = {},
		c = [];
	this._getAnimationConfigRecursive(a, b, c);
	for (var d in b) c.push(b[d]);
	return c
};
q._configureAnimationEffects = function(a) {
	var b = [];
	if (0 < a.length)
		for (var c, d = 0; c = a[d]; d++) {
			var e = document.createElement(c.name);
			if (e.isNeonAnimation) {
				var f = e.configure(c);
				f && b.push({
					animation: e,
					config: c,
					effect: f
				})
			} else Polymer.Base._warn(this.is + ":", c.name, "not found!")
		}
	return b
};
q._runAnimationEffects = function(a) {
	return document.timeline.play(new GroupEffect(a))
};
q._completeAnimations = function(a) {
	for (var b, c = 0; b = a[c]; c++) b.animation.complete(b.config)
};
q.playAnimation = function(a, b) {
	if (a = this.getAnimationConfig(a)) {
		var c = this._configureAnimationEffects(a);
		a = c.map(function(a) {
			return a.effect
		});
		0 < a.length ? (this._player = this._runAnimationEffects(a), this._player.onfinish = function() {
			this._completeAnimations(c);
			this._player && (this._player.cancel(), this._player = null);
			this.fire("neon-animation-finish", b, {
				bubbles: !1
			})
		}.bind(this)) : this.fire("neon-animation-finish", b, {
			bubbles: !1
		})
	}
};
q.cancelAnimation = function() {
	this._player && this._player.cancel()
};
q._setFocused = function(a) {};
q._setCanceled = function(a) {};
U.IronDropdown.IronDropdown = {};
(function() {
	Polymer({
		is: "iron-dropdown",
		behaviors: [Polymer.IronControlState, Polymer.IronA11yKeysBehavior, Polymer.IronOverlayBehavior, Polymer.NeonAnimationRunnerBehavior],
		properties: {
			horizontalAlign: {
				type: String,
				value: "left",
				reflectToAttribute: !0
			},
			verticalAlign: {
				type: String,
				value: "top",
				reflectToAttribute: !0
			},
			openAnimationConfig: {
				type: Object
			},
			closeAnimationConfig: {
				type: Object
			},
			focusTarget: {
				type: Object
			},
			noAnimations: {
				type: Boolean,
				value: !1
			},
			allowOutsideScroll: {
				type: Boolean,
				value: !1
			}
		},
		listeners: {
			"neon-animation-finish": "_onNeonAnimationFinish"
		},
		observers: ["_updateOverlayPosition(positionTarget, verticalAlign, horizontalAlign, verticalOffset, horizontalOffset)"],
		get containedElement() {
			return Polymer.dom(this.$.content).getDistributedNodes()[0]
		},
		get _focusTarget() {
			return this.focusTarget || this.containedElement
		},
		_openedChanged: function() {
			this.opened && this.disabled ? this.cancel() : (this.cancelAnimation(), this.sizingTarget = this.containedElement || this.sizingTarget, this._updateAnimationConfig(), this.opened && !this.allowOutsideScroll ? Polymer.IronDropdownScrollManager.pushScrollLock(this) :
				Polymer.IronDropdownScrollManager.removeScrollLock(this), Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments))
		},
		_renderOpened: function() {
			!this.noAnimations && this.animationConfig && this.animationConfig.open ? (this.withBackdrop && this.backdropElement.open(), this.$.contentWrapper.classList.add("animating"), this.playAnimation("open")) : Polymer.IronOverlayBehaviorImpl._renderOpened.apply(this, arguments)
		},
		_renderClosed: function() {
			!this.noAnimations && this.animationConfig && this.animationConfig.close ?
				(this.withBackdrop && this.backdropElement.close(), this.$.contentWrapper.classList.add("animating"), this.playAnimation("close")) : Polymer.IronOverlayBehaviorImpl._renderClosed.apply(this, arguments)
		},
		_onNeonAnimationFinish: function() {
			this.$.contentWrapper.classList.remove("animating");
			this.opened ? Polymer.IronOverlayBehaviorImpl._finishRenderOpened.apply(this) : Polymer.IronOverlayBehaviorImpl._finishRenderClosed.apply(this)
		},
		_updateAnimationConfig: function() {
			var a = {},
				b = [];
			this.openAnimationConfig && (a.open = [{
				name: "opaque-animation"
			}].concat(this.openAnimationConfig), b = b.concat(a.open));
			this.closeAnimationConfig && (a.close = this.closeAnimationConfig, b = b.concat(a.close));
			b.forEach(function(a) {
				a.node = this.containedElement
			}, this);
			this.animationConfig = a
		},
		_updateOverlayPosition: function() {
			this.isAttached && this.notifyResize()
		},
		refit: function() {
			if (this.opened) {
				var a = this.containedElement,
					b, c;
				a && (b = a.scrollTop, c = a.scrollLeft);
				Polymer.IronFitBehavior.refit.apply(this, arguments);
				a && (a.scrollTop = b, a.scrollLeft = c)
			}
		},
		_applyFocus: function() {
			var a = this.focusTarget || this.containedElement;
			a && this.opened && !this.noAutoFocus ? a.focus() : Polymer.IronOverlayBehaviorImpl._applyFocus.apply(this, arguments)
		}
	})
})();
var ce = function() {};
q = ce.prototype;
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._setFocused = function(a) {};
U.PaperMenuButton.PaperMenuButton = {};
(function() {
	var a = {
		ANIMATION_CUBIC_BEZIER: "cubic-bezier(.3,.95,.5,1)",
		MAX_ANIMATION_TIME_MS: 400
	};
	ce = Polymer({
		is: "paper-menu-button",
		behaviors: [Polymer.IronA11yKeysBehavior, Polymer.IronControlState],
		properties: {
			opened: {
				type: Boolean,
				value: !1,
				notify: !0,
				observer: "_openedChanged"
			},
			horizontalAlign: {
				type: String,
				value: "left",
				reflectToAttribute: !0
			},
			verticalAlign: {
				type: String,
				value: "top",
				reflectToAttribute: !0
			},
			dynamicAlign: {
				type: Boolean
			},
			horizontalOffset: {
				type: Number,
				value: 0,
				notify: !0
			},
			verticalOffset: {
				type: Number,
				value: 0,
				notify: !0
			},
			noOverlap: {
				type: Boolean
			},
			noAnimations: {
				type: Boolean,
				value: !1
			},
			ignoreSelect: {
				type: Boolean,
				value: !1
			},
			closeOnActivate: {
				type: Boolean,
				value: !1
			},
			openAnimationConfig: {
				type: Object,
				value: function() {
					return [{
						name: "fade-in-animation",
						timing: {
							delay: 100,
							duration: 200
						}
					}, {
						name: "paper-menu-grow-width-animation",
						timing: {
							delay: 100,
							duration: 150,
							easing: a.ANIMATION_CUBIC_BEZIER
						}
					}, {
						name: "paper-menu-grow-height-animation",
						timing: {
							delay: 100,
							duration: 275,
							easing: a.ANIMATION_CUBIC_BEZIER
						}
					}]
				}
			},
			closeAnimationConfig: {
				type: Object,
				value: function() {
					return [{
						name: "fade-out-animation",
						timing: {
							duration: 150
						}
					}, {
						name: "paper-menu-shrink-width-animation",
						timing: {
							delay: 100,
							duration: 50,
							easing: a.ANIMATION_CUBIC_BEZIER
						}
					}, {
						name: "paper-menu-shrink-height-animation",
						timing: {
							duration: 200,
							easing: "ease-in"
						}
					}]
				}
			},
			allowOutsideScroll: {
				type: Boolean,
				value: !1
			},
			restoreFocusOnClose: {
				type: Boolean,
				value: !0
			},
			_dropdownContent: {
				type: Object
			}
		},
		hostAttributes: {
			role: "group",
			"aria-haspopup": "true"
		},
		listeners: {
			"iron-activate": "_onIronActivate",
			"iron-select": "_onIronSelect"
		},
		get contentElement() {
			return Polymer.dom(this.$.content).getDistributedNodes()[0]
		},
		toggle: function() {
			this.opened ? this.close() : this.open()
		},
		open: function() {
			this.disabled || this.$.dropdown.open()
		},
		close: function() {
			this.$.dropdown.close()
		},
		_onIronSelect: function(a) {
			this.ignoreSelect || this.close()
		},
		_onIronActivate: function(a) {
			this.closeOnActivate && this.close()
		},
		_openedChanged: function(a, c) {
			a ? (this._dropdownContent = this.contentElement, this.fire("paper-dropdown-open")) : null != c && this.fire("paper-dropdown-close")
		},
		_disabledChanged: function(a) {
			Polymer.IronControlState._disabledChanged.apply(this, arguments);
			a && this.opened && this.close()
		},
		__onIronOverlayCanceled: function(a) {
			var b = a.detail,
				d = Polymer.dom(b).rootTarget,
				d = this.$.trigger,
				b = Polymer.dom(b).path; - 1 < b.indexOf(d) && a.preventDefault()
		}
	});
	Object.keys(a).forEach(function(b) {
		ce[b] = a[b]
	});
	Polymer.PaperMenuButton = ce
})();
var de = function() {};
q = de.prototype;
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._downHandler = function(a) {
	this._setPointerDown(!0);
	this._setPressed(!0);
	this._setReceivedFocusFromKeyboard(!1)
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q.registered = function() {
	Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({
		type: "validator"
	})
};
q._invalidChanged = function() {
	this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")
};
q.hasValidator = function() {
	return null != this._validator
};
q.validate = function(a) {
	this.invalid = !this._getValidity(a);
	return !this.invalid
};
q.__computeValidator = function() {
	return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator)
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
q._setSelectedItemLabel = function(a) {};
q._setSelectedItem = function(a) {};
q._setValue = function(a) {};
U.PaperDropdownMenu.PaperDropdownMenu = {};
(function() {
	Polymer({
		is: "paper-dropdown-menu",
		behaviors: [Polymer.IronButtonState, Polymer.IronControlState, Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior],
		properties: {
			selectedItemLabel: {
				type: String,
				notify: !0,
				readOnly: !0
			},
			selectedItem: {
				type: Object,
				notify: !0,
				readOnly: !0
			},
			value: {
				type: String,
				notify: !0,
				readOnly: !0
			},
			label: {
				type: String
			},
			placeholder: {
				type: String
			},
			errorMessage: {
				type: String
			},
			opened: {
				type: Boolean,
				notify: !0,
				value: !1,
				observer: "_openedChanged"
			},
			allowOutsideScroll: {
				type: Boolean,
				value: !1
			},
			noLabelFloat: {
				type: Boolean,
				value: !1,
				reflectToAttribute: !0
			},
			alwaysFloatLabel: {
				type: Boolean,
				value: !1
			},
			noAnimations: {
				type: Boolean,
				value: !1
			},
			horizontalAlign: {
				type: String,
				value: "right"
			},
			verticalAlign: {
				type: String,
				value: "top"
			},
			dynamicAlign: {
				type: Boolean
			}
		},
		listeners: {
			tap: "_onTap"
		},
		keyBindings: {
			"up down": "open",
			esc: "close"
		},
		hostAttributes: {
			role: "combobox",
			"aria-autocomplete": "none",
			"aria-haspopup": "true"
		},
		observers: ["_selectedItemChanged(selectedItem)"],
		attached: function() {
			var a = this.contentElement;
			a && a.selectedItem && this._setSelectedItem(a.selectedItem)
		},
		get contentElement() {
			return Polymer.dom(this.$.content).getDistributedNodes()[0]
		},
		open: function() {
			this.$.menuButton.open()
		},
		close: function() {
			this.$.menuButton.close()
		},
		_onIronSelect: function(a) {
			this._setSelectedItem(a.detail.item)
		},
		_onIronDeselect: function(a) {
			this._setSelectedItem(null)
		},
		_onTap: function(a) {
			Polymer.Gestures.findOriginalTarget(a) === this && this.open()
		},
		_selectedItemChanged: function(a) {
			var b = "",
				b = a ? a.label || a.getAttribute("label") ||
				a.textContent.trim() : "";
			this._setValue(b);
			this._setSelectedItemLabel(b)
		},
		_computeMenuVerticalOffset: function(a) {
			return a ? -4 : 8
		},
		_getValidity: function(a) {
			return this.disabled || !this.required || this.required && !!this.value
		},
		_openedChanged: function() {
			var a = this.opened ? "true" : "false",
				b = this.contentElement;
			b && b.setAttribute("aria-expanded", a)
		}
	})
})();
var ee = function() {};
q = ee.prototype;
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._buttonStateChanged = function() {
	this.focused && this.ensureRipple()
};
q._downHandler = function(a) {
	Polymer.IronButtonStateImpl._downHandler.call(this, a);
	this.pressed && this.ensureRipple(a)
};
q.ensureRipple = function(a) {
	if (!this.hasRipple()) {
		this._ripple = this._createRipple();
		this._ripple.noink = this.noink;
		var b = this._rippleContainer || this.root;
		b && Polymer.dom(b).appendChild(this._ripple);
		if (a) {
			var b = Polymer.dom(this._rippleContainer || this),
				c = Polymer.dom(a).rootTarget;
			b.deepContains(c) && this._ripple.uiDownAction(a)
		}
	}
};
q.getRipple = function() {
	this.ensureRipple();
	return this._ripple
};
q.hasRipple = function() {
	return !!this._ripple
};
q._createRipple = function() {
	return document.createElement("paper-ripple")
};
q._noinkChanged = function(a) {
	this.hasRipple() && (this._ripple.noink = a)
};
q.registered = function() {
	Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({
		type: "validator"
	})
};
q._invalidChanged = function() {
	this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")
};
q.hasValidator = function() {
	return null != this._validator
};
q.validate = function(a) {
	this.invalid = !this._getValidity(a);
	return !this.invalid
};
q.__computeValidator = function() {
	return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator)
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
q._setSelectedItemLabel = function(a) {};
q._setSelectedItem = function(a) {};
q._setValue = function(a) {};
q._setHasContent = function(a) {};
U.PaperDropdownMenu.PaperDropdownMenuLight = {};
(function() {
	Polymer({
		is: "paper-dropdown-menu-light",
		behaviors: [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperRippleBehavior, Polymer.IronFormElementBehavior, Polymer.IronValidatableBehavior],
		properties: {
			selectedItemLabel: {
				type: String,
				notify: !0,
				readOnly: !0
			},
			selectedItem: {
				type: Object,
				notify: !0,
				readOnly: !0
			},
			value: {
				type: String,
				notify: !0,
				readOnly: !0,
				observer: "_valueChanged"
			},
			label: {
				type: String
			},
			placeholder: {
				type: String
			},
			opened: {
				type: Boolean,
				notify: !0,
				value: !1,
				observer: "_openedChanged"
			},
			allowOutsideScroll: {
				type: Boolean,
				value: !1
			},
			noLabelFloat: {
				type: Boolean,
				value: !1,
				reflectToAttribute: !0
			},
			alwaysFloatLabel: {
				type: Boolean,
				value: !1
			},
			noAnimations: {
				type: Boolean,
				value: !1
			},
			horizontalAlign: {
				type: String,
				value: "right"
			},
			verticalAlign: {
				type: String,
				value: "top"
			},
			hasContent: {
				type: Boolean,
				readOnly: !0
			}
		},
		listeners: {
			tap: "_onTap"
		},
		keyBindings: {
			"up down": "open",
			esc: "close"
		},
		hostAttributes: {
			tabindex: 0,
			role: "combobox",
			"aria-autocomplete": "none",
			"aria-haspopup": "true"
		},
		observers: ["_selectedItemChanged(selectedItem)"],
		attached: function() {
			var a =
				this.contentElement;
			a && a.selectedItem && this._setSelectedItem(a.selectedItem)
		},
		get contentElement() {
			return Polymer.dom(this.$.content).getDistributedNodes()[0]
		},
		open: function() {
			this.$.menuButton.open()
		},
		close: function() {
			this.$.menuButton.close()
		},
		_onIronSelect: function(a) {
			this._setSelectedItem(a.detail.item)
		},
		_onIronDeselect: function(a) {
			this._setSelectedItem(null)
		},
		_onTap: function(a) {
			Polymer.Gestures.findOriginalTarget(a) === this && this.open()
		},
		_selectedItemChanged: function(a) {
			var b = "",
				b = a ? a.label ||
				a.getAttribute("label") || a.textContent.trim() : "";
			this._setValue(b);
			this._setSelectedItemLabel(b)
		},
		_computeMenuVerticalOffset: function(a) {
			return a ? -4 : 8
		},
		_getValidity: function(a) {
			return this.disabled || !this.required || this.required && !!this.value
		},
		_openedChanged: function() {
			var a = this.opened ? "true" : "false",
				b = this.contentElement;
			b && b.setAttribute("aria-expanded", a)
		},
		_computeLabelClass: function(a, b, c) {
			var d = "";
			if (!0 === a) return c ? "label-is-hidden" : "";
			if (c || !0 === b) d += " label-is-floating";
			return d
		},
		_valueChanged: function() {
			this.$.input &&
				this.$.input.textContent !== this.value && (this.$.input.textContent = this.value);
			this._setHasContent(!!this.value)
		}
	})
})();
U.PaperIconButton = {};
U.PaperIconButton.PaperIconButton = {};
var fe = function() {};
q = fe.prototype;
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._buttonStateChanged = function() {
	this.focused && this.ensureRipple()
};
q._downHandler = function(a) {
	Polymer.IronButtonStateImpl._downHandler.call(this, a);
	this.pressed && this.ensureRipple(a)
};
q.ensureRipple = function(a) {
	if (!this.hasRipple()) {
		this._ripple = this._createRipple();
		this._ripple.noink = this.noink;
		var b = this._rippleContainer || this.root;
		b && Polymer.dom(b).appendChild(this._ripple);
		if (a) {
			var b = Polymer.dom(this._rippleContainer || this),
				c = Polymer.dom(a).rootTarget;
			b.deepContains(c) && this._ripple.uiDownAction(a)
		}
	}
};
q.getRipple = function() {
	this.ensureRipple();
	return this._ripple
};
q.hasRipple = function() {
	return !!this._ripple
};
q._noinkChanged = function(a) {
	this.hasRipple() && (this._ripple.noink = a)
};
q._focusedChanged = function(a) {
	a && this.ensureRipple();
	this.hasRipple() && (this._ripple.holdDown = a)
};
q._createRipple = function() {
	var a = Polymer.PaperRippleBehavior._createRipple();
	a.id = "ink";
	a.setAttribute("center", "");
	a.classList.add("circle");
	return a
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
Polymer({
	is: "paper-icon-button",
	hostAttributes: {
		role: "button",
		tabindex: "0"
	},
	behaviors: [Polymer.PaperInkyFocusBehavior],
	properties: {
		src: {
			type: String
		},
		icon: {
			type: String
		},
		alt: {
			type: String,
			observer: "_altChanged"
		}
	},
	_altChanged: function(a, b) {
		var c = this.getAttribute("aria-label");
		c && b != c || this.setAttribute("aria-label", a)
	}
});
U.PaperIconButton.PaperIconButtonLight = {};
var ge = function() {};
q = ge.prototype;
q._buttonStateChanged = function() {
	this.focused && this.ensureRipple()
};
q._downHandler = function(a) {
	Polymer.IronButtonStateImpl._downHandler.call(this, a);
	this.pressed && this.ensureRipple(a)
};
q.getRipple = function() {
	this.ensureRipple();
	return this._ripple
};
q.hasRipple = function() {
	return !!this._ripple
};
q._createRipple = function() {
	return document.createElement("paper-ripple")
};
q._noinkChanged = function(a) {
	this.hasRipple() && (this._ripple.noink = a)
};
Polymer({
	is: "paper-icon-button-light",
	extends: "button",
	behaviors: [Polymer.PaperRippleBehavior],
	listeners: {
		down: "_rippleDown",
		up: "_rippleUp",
		focus: "_rippleDown",
		blur: "_rippleUp"
	},
	_rippleDown: function() {
		this.getRipple().downAction()
	},
	_rippleUp: function() {
		this.getRipple().upAction()
	},
	ensureRipple: function(a) {
		var b = this._ripple;
		Polymer.PaperRippleBehavior.ensureRipple.apply(this, arguments);
		this._ripple && this._ripple !== b && (this._ripple.center = !0, this._ripple.classList.add("circle"))
	}
});
U.PaperItem = {};
U.PaperItem.PaperItemBehavior = {};
Polymer.PaperItemBehaviorImpl = {
	hostAttributes: {
		role: "option",
		tabindex: "0"
	}
};
Polymer.PaperItemBehavior = [Polymer.IronButtonState, Polymer.IronControlState, Polymer.PaperItemBehaviorImpl];
U.PaperItem.PaperItemSharedStyles = {};
U.PaperItem.PaperIconItem = {};
var he = function() {};
q = he.prototype;
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._downHandler = function(a) {
	this._setPointerDown(!0);
	this._setPressed(!0);
	this._setReceivedFocusFromKeyboard(!1)
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
Polymer({
	is: "paper-icon-item",
	behaviors: [Polymer.PaperItemBehavior]
});
U.PaperItem.PaperItemBody = {};
var ie = function() {};
Polymer({
	is: "paper-item-body"
});
U.PaperItem.PaperItem = {};
var je = function() {};
q = je.prototype;
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._downHandler = function(a) {
	this._setPointerDown(!0);
	this._setPressed(!0);
	this._setReceivedFocusFromKeyboard(!1)
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
Polymer({
	is: "paper-item",
	behaviors: [Polymer.PaperItemBehavior]
});
U.PaperItem.AllImports = {};
U.IronMenuBehavior = {};
U.IronMenuBehavior.IronMenuBehavior = {};
Polymer.IronMenuBehaviorImpl = {
	properties: {
		focusedItem: {
			observer: "_focusedItemChanged",
			readOnly: !0,
			type: Object
		},
		attrForItemTitle: {
			type: String
		}
	},
	hostAttributes: {
		role: "menu",
		tabindex: "0"
	},
	observers: ["_updateMultiselectable(multi)"],
	listeners: {
		focus: "_onFocus",
		keydown: "_onKeydown",
		"iron-items-changed": "_onIronItemsChanged"
	},
	keyBindings: {
		up: "_onUpKey",
		down: "_onDownKey",
		esc: "_onEscKey",
		"shift+tab:keydown": "_onShiftTabDown"
	},
	attached: function() {
		this._resetTabindices()
	},
	select: function(a) {
		this._defaultFocusAsync &&
			(this.cancelAsync(this._defaultFocusAsync), this._defaultFocusAsync = null);
		var b = this._valueToItem(a);
		b && b.hasAttribute("disabled") || (this._setFocusedItem(b), Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments))
	},
	_resetTabindices: function() {
		var a = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
		this.items.forEach(function(b) {
			b.setAttribute("tabindex", b === a ? "0" : "-1")
		}, this)
	},
	_updateMultiselectable: function(a) {
		a ? this.setAttribute("aria-multiselectable", "true") : this.removeAttribute("aria-multiselectable")
	},
	_focusWithKeyboardEvent: function(a) {
		for (var b = 0, c; c = this.items[b]; b++) {
			var d = this.attrForItemTitle || "textContent",
				d = c[d] || c.getAttribute(d);
			if (!c.hasAttribute("disabled") && d && d.trim().charAt(0).toLowerCase() === String.fromCharCode(a.keyCode).toLowerCase()) {
				this._setFocusedItem(c);
				break
			}
		}
	},
	_focusPrevious: function() {
		for (var a = this.items.length, b = Number(this.indexOf(this.focusedItem)), c = 1; c < a + 1; c++) {
			var d = this.items[(b - c + a) % a];
			if (!d.hasAttribute("disabled")) {
				var e = Polymer.dom(d).getOwnerRoot() || document;
				this._setFocusedItem(d);
				if (Polymer.dom(e).activeElement == d) break
			}
		}
	},
	_focusNext: function() {
		for (var a = this.items.length, b = Number(this.indexOf(this.focusedItem)), c = 1; c < a + 1; c++) {
			var d = this.items[(b + c) % a];
			if (!d.hasAttribute("disabled")) {
				var e = Polymer.dom(d).getOwnerRoot() || document;
				this._setFocusedItem(d);
				if (Polymer.dom(e).activeElement == d) break
			}
		}
	},
	_applySelection: function(a, b) {
		b ? a.setAttribute("aria-selected", "true") : a.removeAttribute("aria-selected");
		Polymer.IronSelectableBehavior._applySelection.apply(this,
			arguments)
	},
	_focusedItemChanged: function(a, b) {
		b && b.setAttribute("tabindex", "-1");
		a && (a.setAttribute("tabindex", "0"), a.focus())
	},
	_onIronItemsChanged: function(a) {
		a.detail.addedNodes.length && this._resetTabindices()
	},
	_onShiftTabDown: function(a) {
		var b = this.getAttribute("tabindex");
		Polymer.IronMenuBehaviorImpl._shiftTabPressed = !0;
		this._setFocusedItem(null);
		this.setAttribute("tabindex", "-1");
		this.async(function() {
			this.setAttribute("tabindex", b);
			Polymer.IronMenuBehaviorImpl._shiftTabPressed = !1
		}, 1)
	},
	_onFocus: function(a) {
		!Polymer.IronMenuBehaviorImpl._shiftTabPressed &&
			(a = Polymer.dom(a).rootTarget, a === this || "undefined" === typeof a.tabIndex || this.isLightDescendant(a)) && (this._defaultFocusAsync = this.async(function() {
				var a = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
				this._setFocusedItem(null);
				a ? this._setFocusedItem(a) : this.items[0] && this._focusNext()
			}))
	},
	_onUpKey: function(a) {
		this._focusPrevious();
		a.detail.keyboardEvent.preventDefault()
	},
	_onDownKey: function(a) {
		this._focusNext();
		a.detail.keyboardEvent.preventDefault()
	},
	_onEscKey: function(a) {
		this.focusedItem.blur()
	},
	_onKeydown: function(a) {
		this.keyboardEventMatchesKeys(a, "up down esc") || this._focusWithKeyboardEvent(a);
		a.stopPropagation()
	},
	_activateHandler: function(a) {
		Polymer.IronSelectableBehavior._activateHandler.call(this, a);
		a.stopPropagation()
	}
};
Polymer.IronMenuBehaviorImpl._shiftTabPressed = !1;
Polymer.IronMenuBehavior = [Polymer.IronMultiSelectableBehavior, Polymer.IronA11yKeysBehavior, Polymer.IronMenuBehaviorImpl];
U.IronMenuBehavior.IronMenubarBehavior = {};
Polymer.IronMenubarBehaviorImpl = {
	hostAttributes: {
		role: "menubar"
	},
	keyBindings: {
		left: "_onLeftKey",
		right: "_onRightKey"
	},
	_onUpKey: function(a) {
		this.focusedItem.click();
		a.detail.keyboardEvent.preventDefault()
	},
	_onDownKey: function(a) {
		this.focusedItem.click();
		a.detail.keyboardEvent.preventDefault()
	},
	get _isRTL() {
		return "rtl" === window.getComputedStyle(this).direction
	},
	_onLeftKey: function(a) {
		this._isRTL ? this._focusNext() : this._focusPrevious();
		a.detail.keyboardEvent.preventDefault()
	},
	_onRightKey: function(a) {
		this._isRTL ?
			this._focusPrevious() : this._focusNext();
		a.detail.keyboardEvent.preventDefault()
	},
	_onKeydown: function(a) {
		this.keyboardEventMatchesKeys(a, "up down left right esc") || this._focusWithKeyboardEvent(a)
	}
};
Polymer.IronMenubarBehavior = [Polymer.IronMenuBehavior, Polymer.IronMenubarBehaviorImpl];
var ke = function() {};
q = ke.prototype;
q.indexOf = function(a) {
	return this.items.indexOf(a)
};
q.selectPrevious = function() {
	var a = this.items.length,
		a = (Number(this._valueToIndex(this.selected)) - 1 + a) % a;
	this.selected = this._indexToValue(a)
};
q.selectNext = function() {
	var a = (Number(this._valueToIndex(this.selected)) + 1) % this.items.length;
	this.selected = this._indexToValue(a)
};
q.selectIndex = function(a) {
	this.select(this._indexToValue(a))
};
q.forceSynchronousItemUpdate = function() {
	this._updateItems()
};
q._checkFallback = function() {
	this._shouldUpdateSelection && this._updateSelected()
};
q._addListener = function(a) {
	this.listen(this, a, "_activateHandler")
};
q._removeListener = function(a) {
	this.unlisten(this, a, "_activateHandler")
};
q._activateEventChanged = function(a, b) {
	this._removeListener(b);
	this._addListener(a)
};
q._updateItems = function() {
	var a = Polymer.dom(this).queryDistributedElements(this.selectable || "*"),
		a = Array.prototype.filter.call(a, this._bindFilterItem);
	this._setItems(a)
};
q._selectSelected = function(a) {
	this._selection.select(this._valueToItem(this.selected));
	this.fallbackSelection && this.items.length && void 0 === this._selection.get() && (this.selected = this.fallbackSelection)
};
q._filterItem = function(a) {
	return !this._excludedLocalNames[a.localName]
};
q._valueToItem = function(a) {
	return null == a ? null : this.items[this._valueToIndex(a)]
};
q._valueToIndex = function(a) {
	if (this.attrForSelected)
		for (var b = 0, c; c = this.items[b]; b++) {
			if (this._valueForItem(c) == a) return b
		} else return Number(a)
};
q._indexToValue = function(a) {
	if (this.attrForSelected) {
		if (a = this.items[a]) return this._valueForItem(a)
	} else return a
};
q._valueForItem = function(a) {
	var b = a[Polymer.CaseMap.dashToCamelCase(this.attrForSelected)];
	return void 0 != b ? b : a.getAttribute(this.attrForSelected)
};
q._observeItems = function(a) {
	return Polymer.dom(a).observeNodes(function(a) {
		this._updateItems();
		this._shouldUpdateSelection && this._updateSelected();
		this.fire("iron-items-changed", a, {
			bubbles: !1,
			cancelable: !1
		})
	})
};
q._itemActivate = function(a, b) {
	this.fire("iron-activate", {
		selected: a,
		item: b
	}, {
		cancelable: !0
	}).defaultPrevented || this.select(a)
};
q.multiChanged = function(a) {
	this._selection.multi = a
};
q._updateAttrForSelected = function() {
	this.multi ? this._shouldUpdateSelection && (this.selectedValues = this.selectedItems.map(function(a) {
		return this._indexToValue(this.indexOf(a))
	}, this).filter(function(a) {
		return null != a
	}, this)) : Polymer.IronSelectableBehavior._updateAttrForSelected.apply(this)
};
q._updateSelected = function() {
	this.multi ? this._selectMulti(this.selectedValues) : this._selectSelected(this.selected)
};
q._selectMulti = function(a) {
	if (a) {
		a = this._valuesToItems(a);
		this._selection.clear(a);
		for (var b = 0; b < a.length; b++) this._selection.setItemSelected(a[b], !0);
		this.fallbackSelection && this.items.length && !this._selection.get().length && (a = this._valueToItem(this.fallbackSelection)) && (this.selectedValues = [this.fallbackSelection])
	} else this._selection.clear()
};
q._selectionChange = function() {
	var a = this._selection.get();
	this.multi ? this._setSelectedItems(a) : (this._setSelectedItems([a]), this._setSelectedItem(a))
};
q._toggleSelected = function(a) {
	var b = this.selectedValues.indexOf(a),
		c = 0 > b;
	c ? this.push("selectedValues", a) : this.splice("selectedValues", b, 1)
};
q._valuesToItems = function(a) {
	return null == a ? null : a.map(function(a) {
		return this._valueToItem(a)
	}, this)
};
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q.select = function(a) {
	this._defaultFocusAsync && (this.cancelAsync(this._defaultFocusAsync), this._defaultFocusAsync = null);
	var b = this._valueToItem(a);
	b && b.hasAttribute("disabled") || (this._setFocusedItem(b), Polymer.IronMultiSelectableBehaviorImpl.select.apply(this, arguments))
};
q._resetTabindices = function() {
	var a = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
	this.items.forEach(function(b) {
		b.setAttribute("tabindex", b === a ? "0" : "-1")
	}, this)
};
q._updateMultiselectable = function(a) {
	a ? this.setAttribute("aria-multiselectable", "true") : this.removeAttribute("aria-multiselectable")
};
q._focusWithKeyboardEvent = function(a) {
	for (var b = 0, c; c = this.items[b]; b++) {
		var d = this.attrForItemTitle || "textContent",
			d = c[d] || c.getAttribute(d);
		if (!c.hasAttribute("disabled") && d && d.trim().charAt(0).toLowerCase() === String.fromCharCode(a.keyCode).toLowerCase()) {
			this._setFocusedItem(c);
			break
		}
	}
};
q._focusPrevious = function() {
	for (var a = this.items.length, b = Number(this.indexOf(this.focusedItem)), c = 1; c < a + 1; c++) {
		var d = this.items[(b - c + a) % a];
		if (!d.hasAttribute("disabled")) {
			var e = Polymer.dom(d).getOwnerRoot() || document;
			this._setFocusedItem(d);
			if (Polymer.dom(e).activeElement == d) break
		}
	}
};
q._focusNext = function() {
	for (var a = this.items.length, b = Number(this.indexOf(this.focusedItem)), c = 1; c < a + 1; c++) {
		var d = this.items[(b + c) % a];
		if (!d.hasAttribute("disabled")) {
			var e = Polymer.dom(d).getOwnerRoot() || document;
			this._setFocusedItem(d);
			if (Polymer.dom(e).activeElement == d) break
		}
	}
};
q._applySelection = function(a, b) {
	b ? a.setAttribute("aria-selected", "true") : a.removeAttribute("aria-selected");
	Polymer.IronSelectableBehavior._applySelection.apply(this, arguments)
};
q._focusedItemChanged = function(a, b) {
	b && b.setAttribute("tabindex", "-1");
	a && (a.setAttribute("tabindex", "0"), a.focus())
};
q._onIronItemsChanged = function(a) {
	a.detail.addedNodes.length && this._resetTabindices()
};
q._onShiftTabDown = function(a) {
	var b = this.getAttribute("tabindex");
	Polymer.IronMenuBehaviorImpl._shiftTabPressed = !0;
	this._setFocusedItem(null);
	this.setAttribute("tabindex", "-1");
	this.async(function() {
		this.setAttribute("tabindex", b);
		Polymer.IronMenuBehaviorImpl._shiftTabPressed = !1
	}, 1)
};
q._onFocus = function(a) {
	!Polymer.IronMenuBehaviorImpl._shiftTabPressed && (a = Polymer.dom(a).rootTarget, a === this || "undefined" === typeof a.tabIndex || this.isLightDescendant(a)) && (this._defaultFocusAsync = this.async(function() {
		var a = this.multi ? this.selectedItems && this.selectedItems[0] : this.selectedItem;
		this._setFocusedItem(null);
		a ? this._setFocusedItem(a) : this.items[0] && this._focusNext()
	}))
};
q._onUpKey = function(a) {
	this._focusPrevious();
	a.detail.keyboardEvent.preventDefault()
};
q._onDownKey = function(a) {
	this._focusNext();
	a.detail.keyboardEvent.preventDefault()
};
q._onEscKey = function(a) {
	this.focusedItem.blur()
};
q._onKeydown = function(a) {
	this.keyboardEventMatchesKeys(a, "up down esc") || this._focusWithKeyboardEvent(a);
	a.stopPropagation()
};
q._activateHandler = function(a) {
	Polymer.IronSelectableBehavior._activateHandler.call(this, a);
	a.stopPropagation()
};
q._setSelectedItem = function(a) {};
q._setItems = function(a) {};
q._setSelectedItems = function(a) {};
q._setFocusedItem = function(a) {};
U.PaperListbox = {};
U.PaperListbox.PaperListbox = {};
(function() {
	Polymer({
		is: "paper-listbox",
		behaviors: [Polymer.IronMenuBehavior],
		hostAttributes: {
			role: "listbox"
		}
	})
})();
U.IronRangeBehavior = {};
U.IronRangeBehavior.IronRangeBehavior = {};
Polymer.IronRangeBehavior = {
	properties: {
		value: {
			type: Number,
			value: 0,
			notify: !0,
			reflectToAttribute: !0
		},
		min: {
			type: Number,
			value: 0,
			notify: !0
		},
		max: {
			type: Number,
			value: 100,
			notify: !0
		},
		step: {
			type: Number,
			value: 1,
			notify: !0
		},
		ratio: {
			type: Number,
			value: 0,
			readOnly: !0,
			notify: !0
		}
	},
	observers: ["_update(value, min, max, step)"],
	_calcRatio: function(a) {
		return (this._clampValue(a) - this.min) / (this.max - this.min)
	},
	_clampValue: function(a) {
		return Math.min(this.max, Math.max(this.min, this._calcStep(a)))
	},
	_calcStep: function(a) {
		a = parseFloat(a);
		return this.step ? (Math.round((a + this.min) / this.step) - this.min / this.step) / (1 / this.step) : a
	},
	_validateValue: function() {
		var a = this._clampValue(this.value);
		this.value = this.oldValue = isNaN(a) ? this.oldValue : a;
		return this.value !== a
	},
	_update: function() {
		this._validateValue();
		this._setRatio(100 * this._calcRatio(this.value))
	}
};
U.PaperProgress = {};
U.PaperProgress.PaperProgress = {};
var le = function() {};
q = le.prototype;
q._calcRatio = function(a) {
	return (this._clampValue(a) - this.min) / (this.max - this.min)
};
q._clampValue = function(a) {
	return Math.min(this.max, Math.max(this.min, this._calcStep(a)))
};
q._calcStep = function(a) {
	a = parseFloat(a);
	return this.step ? (Math.round((a + this.min) / this.step) - this.min / this.step) / (1 / this.step) : a
};
q._validateValue = function() {
	var a = this._clampValue(this.value);
	this.value = this.oldValue = isNaN(a) ? this.oldValue : a;
	return this.value !== a
};
q._update = function() {
	this._validateValue();
	this._setRatio(100 * this._calcRatio(this.value))
};
q._setRatio = function(a) {};
q._setSecondaryRatio = function(a) {};
Polymer({
	is: "paper-progress",
	behaviors: [Polymer.IronRangeBehavior],
	properties: {
		secondaryProgress: {
			type: Number,
			value: 0
		},
		secondaryRatio: {
			type: Number,
			value: 0,
			readOnly: !0
		},
		indeterminate: {
			type: Boolean,
			value: !1,
			observer: "_toggleIndeterminate"
		},
		disabled: {
			type: Boolean,
			value: !1,
			reflectToAttribute: !0,
			observer: "_disabledChanged"
		}
	},
	observers: ["_progressChanged(secondaryProgress, value, min, max)"],
	hostAttributes: {
		role: "progressbar"
	},
	_toggleIndeterminate: function(a) {
		this.toggleClass("indeterminate", a, this.$.primaryProgress)
	},
	_transformProgress: function(a, b) {
		b = "scaleX(" + b / 100 + ")";
		a.style.transform = a.style.webkitTransform = b
	},
	_mainRatioChanged: function(a) {
		this._transformProgress(this.$.primaryProgress, a)
	},
	_progressChanged: function(a, b, c, d) {
		a = this._clampValue(a);
		b = this._clampValue(b);
		var e = 100 * this._calcRatio(a),
			f = 100 * this._calcRatio(b);
		this._setSecondaryRatio(e);
		this._transformProgress(this.$.secondaryProgress, e);
		this._transformProgress(this.$.primaryProgress, f);
		this.secondaryProgress = a;
		this.setAttribute("aria-valuenow",
			b);
		this.setAttribute("aria-valuemin", c);
		this.setAttribute("aria-valuemax", d)
	},
	_disabledChanged: function(a) {
		this.setAttribute("aria-disabled", a ? "true" : "false")
	},
	_hideSecondaryProgress: function(a) {
		return 0 === a
	}
});
U.PaperSlider = {};
U.PaperSlider.PaperSlider = {};
var me = function() {};
q = me.prototype;
q.registered = function() {};
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._buttonStateChanged = function() {
	this.focused && this.ensureRipple()
};
q._downHandler = function(a) {
	Polymer.IronButtonStateImpl._downHandler.call(this, a);
	this.pressed && this.ensureRipple(a)
};
q.ensureRipple = function(a) {
	if (!this.hasRipple()) {
		this._ripple = this._createRipple();
		this._ripple.noink = this.noink;
		var b = this._rippleContainer || this.root;
		b && Polymer.dom(b).appendChild(this._ripple);
		if (a) {
			var b = Polymer.dom(this._rippleContainer || this),
				c = Polymer.dom(a).rootTarget;
			b.deepContains(c) && this._ripple.uiDownAction(a)
		}
	}
};
q.getRipple = function() {
	this.ensureRipple();
	return this._ripple
};
q.hasRipple = function() {
	return !!this._ripple
};
q._noinkChanged = function(a) {
	this.hasRipple() && (this._ripple.noink = a)
};
q._calcRatio = function(a) {
	return (this._clampValue(a) - this.min) / (this.max - this.min)
};
q._clampValue = function(a) {
	return Math.min(this.max, Math.max(this.min, this._calcStep(a)))
};
q._calcStep = function(a) {
	a = parseFloat(a);
	return this.step ? (Math.round((a + this.min) / this.step) - this.min / this.step) / (1 / this.step) : a
};
q._validateValue = function() {
	var a = this._clampValue(this.value);
	this.value = this.oldValue = isNaN(a) ? this.oldValue : a;
	return this.value !== a
};
q._update = function() {
	this._validateValue();
	this._setRatio(100 * this._calcRatio(this.value))
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
q._setRatio = function(a) {};
q._setImmediateValue = function(a) {};
q._setExpand = function(a) {};
q._setDragging = function(a) {};
q._setTransiting = function(a) {};
q._setMarkers = function(a) {};
Polymer({
	is: "paper-slider",
	behaviors: [Polymer.IronA11yKeysBehavior, Polymer.IronFormElementBehavior, Polymer.PaperInkyFocusBehavior, Polymer.IronRangeBehavior],
	properties: {
		snaps: {
			type: Boolean,
			value: !1,
			notify: !0
		},
		pin: {
			type: Boolean,
			value: !1,
			notify: !0
		},
		secondaryProgress: {
			type: Number,
			value: 0,
			notify: !0,
			observer: "_secondaryProgressChanged"
		},
		editable: {
			type: Boolean,
			value: !1
		},
		immediateValue: {
			type: Number,
			value: 0,
			readOnly: !0,
			notify: !0
		},
		maxMarkers: {
			type: Number,
			value: 0,
			notify: !0,
			observer: "_maxMarkersChanged"
		},
		expand: {
			type: Boolean,
			value: !1,
			readOnly: !0
		},
		dragging: {
			type: Boolean,
			value: !1,
			readOnly: !0
		},
		transiting: {
			type: Boolean,
			value: !1,
			readOnly: !0
		},
		markers: {
			type: Array,
			readOnly: !0,
			value: []
		}
	},
	observers: ["_updateKnob(value, min, max, snaps, step)", "_valueChanged(value)", "_immediateValueChanged(immediateValue)"],
	hostAttributes: {
		role: "slider",
		tabindex: 0
	},
	keyBindings: {
		"left down pagedown home": "_decrementKey",
		"right up pageup end": "_incrementKey"
	},
	ready: function() {
		this.async(function() {
			this._updateKnob(this.value)
		}, 1)
	},
	increment: function() {
		this.value =
			this._clampValue(this.value + this.step)
	},
	decrement: function() {
		this.value = this._clampValue(this.value - this.step)
	},
	_updateKnob: function(a, b, c, d, e) {
		this.setAttribute("aria-valuemin", b);
		this.setAttribute("aria-valuemax", c);
		this.setAttribute("aria-valuenow", a);
		this._positionKnob(this._calcRatio(a))
	},
	_valueChanged: function() {
		this.fire("value-change")
	},
	_immediateValueChanged: function() {
		this.dragging ? this.fire("immediate-value-change") : this.value = this.immediateValue
	},
	_secondaryProgressChanged: function() {
		this.secondaryProgress =
			this._clampValue(this.secondaryProgress)
	},
	_expandKnob: function() {
		this._setExpand(!0)
	},
	_resetKnob: function() {
		this.cancelDebouncer("expandKnob");
		this._setExpand(!1)
	},
	_positionKnob: function(a) {
		this._setImmediateValue(this._calcStep(this._calcKnobPosition(a)));
		this._setRatio(this._calcRatio(this.immediateValue));
		this.$.sliderKnob.style.left = 100 * this.ratio + "%";
		this.dragging && (this._knobstartx = this.ratio * this._w, this.translate3d(0, 0, 0, this.$.sliderKnob))
	},
	_calcKnobPosition: function(a) {
		return (this.max - this.min) *
			a + this.min
	},
	_onTrack: function(a) {
		a.stopPropagation();
		switch (a.detail.state) {
			case "start":
				this._trackStart(a);
				break;
			case "track":
				this._trackX(a);
				break;
			case "end":
				this._trackEnd()
		}
	},
	_trackStart: function(a) {
		this._w = this.$.sliderBar.offsetWidth;
		this._knobstartx = this._startx = this._x = this.ratio * this._w;
		this._minx = -this._startx;
		this._maxx = this._w - this._startx;
		this.$.sliderKnob.classList.add("dragging");
		this._setDragging(!0)
	},
	_trackX: function(a) {
		this.dragging || this._trackStart(a);
		a = Math.min(this._maxx, Math.max(this._minx,
			a.detail.dx));
		this._x = this._startx + a;
		a = this._calcStep(this._calcKnobPosition(this._x / this._w));
		this._setImmediateValue(a);
		a = this._calcRatio(this.immediateValue) * this._w - this._knobstartx;
		this.translate3d(a + "px", 0, 0, this.$.sliderKnob)
	},
	_trackEnd: function() {
		var a = this.$.sliderKnob.style;
		this.$.sliderKnob.classList.remove("dragging");
		this._setDragging(!1);
		this._resetKnob();
		this.value = this.immediateValue;
		a.transform = a.webkitTransform = "";
		this.fire("change")
	},
	_knobdown: function(a) {
		this._expandKnob();
		a.preventDefault();
		this.focus()
	},
	_bardown: function(a) {
		this._w = this.$.sliderBar.offsetWidth;
		var b = this.$.sliderBar.getBoundingClientRect(),
			b = (a.detail.x - b.left) / this._w,
			c = this.ratio;
		this._setTransiting(!0);
		this._positionKnob(b);
		this.debounce("expandKnob", this._expandKnob, 60);
		c === this.ratio && this._setTransiting(!1);
		this.async(function() {
			this.fire("change")
		});
		a.preventDefault();
		this.focus()
	},
	_knobTransitionEnd: function(a) {
		a.target === this.$.sliderKnob && this._setTransiting(!1)
	},
	_maxMarkersChanged: function(a) {
		this.snaps ||
			this._setMarkers([]);
		var b = Math.round((this.max - this.min) / this.step);
		b > a && (b = a);
		this._setMarkers(Array(b))
	},
	_mergeClasses: function(a) {
		return Object.keys(a).filter(function(b) {
			return a[b]
		}).join(" ")
	},
	_getClassNames: function() {
		return this._mergeClasses({
			disabled: this.disabled,
			pin: this.pin,
			snaps: this.snaps,
			ring: this.immediateValue <= this.min,
			expand: this.expand,
			dragging: this.dragging,
			transiting: this.transiting,
			editable: this.editable
		})
	},
	_incrementKey: function(a) {
		this.disabled || ("end" === a.detail.key ? this.value =
			this.max : this.increment(), this.fire("change"))
	},
	_decrementKey: function(a) {
		this.disabled || ("home" === a.detail.key ? this.value = this.min : this.decrement(), this.fire("change"))
	},
	_changeValue: function(a) {
		this.value = a.target.value;
		this.fire("change")
	},
	_inputKeyDown: function(a) {
		a.stopPropagation()
	},
	_createRipple: function() {
		this._rippleContainer = this.$.sliderKnob;
		return Polymer.PaperInkyFocusBehaviorImpl._createRipple.call(this)
	},
	_focusedChanged: function(a) {
		a && this.ensureRipple();
		this.hasRipple() && (this._ripple.style.display =
			a ? "" : "none", this._ripple.holdDown = a)
	}
});
U.PaperSpinner = {};
U.PaperSpinner.PaperSpinnerBehavior = {};
Polymer.PaperSpinnerBehavior = {
	listeners: {
		animationend: "__reset",
		webkitAnimationEnd: "__reset"
	},
	properties: {
		active: {
			type: Boolean,
			value: !1,
			reflectToAttribute: !0,
			observer: "__activeChanged"
		},
		alt: {
			type: String,
			value: "loading",
			observer: "__altChanged"
		},
		__coolingDown: {
			type: Boolean,
			value: !1
		}
	},
	__computeContainerClasses: function(a, b) {
		return [a || b ? "active" : "", b ? "cooldown" : ""].join(" ")
	},
	__activeChanged: function(a, b) {
		this.__setAriaHidden(!a);
		this.__coolingDown = !a && b
	},
	__altChanged: function(a) {
		a === this.getPropertyInfo("alt").value ?
			this.alt = this.getAttribute("aria-label") || a : (this.__setAriaHidden("" === a), this.setAttribute("aria-label", a))
	},
	__setAriaHidden: function(a) {
		a ? this.setAttribute("aria-hidden", "true") : this.removeAttribute("aria-hidden")
	},
	__reset: function() {
		this.__coolingDown = this.active = !1
	}
};
U.PaperSpinner.PaperSpinnerStyles = {};
U.PaperSpinner.PaperSpinner = {};
var ne = function() {};
q = ne.prototype;
q.__computeContainerClasses = function(a, b) {
	return [a || b ? "active" : "", b ? "cooldown" : ""].join(" ")
};
q.__activeChanged = function(a, b) {
	this.__setAriaHidden(!a);
	this.__coolingDown = !a && b
};
q.__altChanged = function(a) {
	a === this.getPropertyInfo("alt").value ? this.alt = this.getAttribute("aria-label") || a : (this.__setAriaHidden("" === a), this.setAttribute("aria-label", a))
};
q.__setAriaHidden = function(a) {
	a ? this.setAttribute("aria-hidden", "true") : this.removeAttribute("aria-hidden")
};
q.__reset = function() {
	this.__coolingDown = this.active = !1
};
Polymer({
	is: "paper-spinner",
	behaviors: [Polymer.PaperSpinnerBehavior]
});
U.PaperSpinner.PaperSpinnerLite = {};
var oe = function() {};
q = oe.prototype;
q.__computeContainerClasses = function(a, b) {
	return [a || b ? "active" : "", b ? "cooldown" : ""].join(" ")
};
q.__activeChanged = function(a, b) {
	this.__setAriaHidden(!a);
	this.__coolingDown = !a && b
};
q.__altChanged = function(a) {
	a === this.getPropertyInfo("alt").value ? this.alt = this.getAttribute("aria-label") || a : (this.__setAriaHidden("" === a), this.setAttribute("aria-label", a))
};
q.__setAriaHidden = function(a) {
	a ? this.setAttribute("aria-hidden", "true") : this.removeAttribute("aria-hidden")
};
q.__reset = function() {
	this.__coolingDown = this.active = !1
};
Polymer({
	is: "paper-spinner-lite",
	behaviors: [Polymer.PaperSpinnerBehavior]
});
var pe = function() {};
q = pe.prototype;
q.fit = function() {
	this.position();
	this.constrain();
	this.center()
};
q._discoverInfo = function() {
	if (!this._fitInfo) {
		var a = window.getComputedStyle(this),
			b = window.getComputedStyle(this.sizingTarget);
		this._fitInfo = {
			inlineStyle: {
				top: this.style.top || "",
				left: this.style.left || "",
				position: this.style.position || ""
			},
			sizerInlineStyle: {
				maxWidth: this.sizingTarget.style.maxWidth || "",
				maxHeight: this.sizingTarget.style.maxHeight || "",
				boxSizing: this.sizingTarget.style.boxSizing || ""
			},
			positionedBy: {
				vertically: "auto" !== a.top ? "top" : "auto" !== a.bottom ? "bottom" : null,
				horizontally: "auto" !== a.left ?
					"left" : "auto" !== a.right ? "right" : null
			},
			sizedBy: {
				height: "none" !== b.maxHeight,
				width: "none" !== b.maxWidth,
				minWidth: parseInt(b.minWidth, 10) || 0,
				minHeight: parseInt(b.minHeight, 10) || 0
			},
			margin: {
				top: parseInt(a.marginTop, 10) || 0,
				right: parseInt(a.marginRight, 10) || 0,
				bottom: parseInt(a.marginBottom, 10) || 0,
				left: parseInt(a.marginLeft, 10) || 0
			}
		};
		this.verticalOffset && (this._fitInfo.margin.top = this._fitInfo.margin.bottom = this.verticalOffset, this._fitInfo.inlineStyle.marginTop = this.style.marginTop || "", this._fitInfo.inlineStyle.marginBottom =
			this.style.marginBottom || "", this.style.marginTop = this.style.marginBottom = this.verticalOffset + "px");
		this.horizontalOffset && (this._fitInfo.margin.left = this._fitInfo.margin.right = this.horizontalOffset, this._fitInfo.inlineStyle.marginLeft = this.style.marginLeft || "", this._fitInfo.inlineStyle.marginRight = this.style.marginRight || "", this.style.marginLeft = this.style.marginRight = this.horizontalOffset + "px")
	}
};
q.resetFit = function() {
	var a = this._fitInfo || {},
		b;
	for (b in a.sizerInlineStyle) this.sizingTarget.style[b] = a.sizerInlineStyle[b];
	for (b in a.inlineStyle) this.style[b] = a.inlineStyle[b];
	this._fitInfo = null
};
q.refit = function() {
	var a = this.sizingTarget.scrollLeft,
		b = this.sizingTarget.scrollTop;
	this.resetFit();
	this.fit();
	this.sizingTarget.scrollLeft = a;
	this.sizingTarget.scrollTop = b
};
q.position = function() {
	if (this.horizontalAlign || this.verticalAlign) {
		this._discoverInfo();
		this.style.position = "fixed";
		this.sizingTarget.style.boxSizing = "border-box";
		this.style.left = "0px";
		this.style.top = "0px";
		var a = this.getBoundingClientRect(),
			b = this.__getNormalizedRect(this.positionTarget),
			c = this.__getNormalizedRect(this.fitInto),
			d = this._fitInfo.margin,
			e = {
				width: a.width + d.left + d.right,
				height: a.height + d.top + d.bottom
			},
			e = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, e, b, c),
			b = e.left +
			d.left,
			e = e.top + d.top,
			f = Math.min(c.right - d.right, b + a.width),
			c = Math.min(c.bottom - d.bottom, e + a.height),
			g = this._fitInfo.sizedBy.minWidth,
			h = this._fitInfo.sizedBy.minHeight;
		b < d.left && (b = d.left, f - b < g && (b = f - g));
		e < d.top && (e = d.top, c - e < h && (e = c - h));
		this.sizingTarget.style.maxWidth = f - b + "px";
		this.sizingTarget.style.maxHeight = c - e + "px";
		this.style.left = b - a.left + "px";
		this.style.top = e - a.top + "px"
	}
};
q.constrain = function() {
	if (!this.horizontalAlign && !this.verticalAlign) {
		this._discoverInfo();
		var a = this._fitInfo;
		a.positionedBy.vertically || (this.style.position = "fixed", this.style.top = "0px");
		a.positionedBy.horizontally || (this.style.position = "fixed", this.style.left = "0px");
		this.sizingTarget.style.boxSizing = "border-box";
		var b = this.getBoundingClientRect();
		a.sizedBy.height || this.__sizeDimension(b, a.positionedBy.vertically, "top", "bottom", "Height");
		a.sizedBy.width || this.__sizeDimension(b, a.positionedBy.horizontally,
			"left", "right", "Width")
	}
};
q._sizeDimension = function(a, b, c, d, e) {
	this.__sizeDimension(a, b, c, d, e)
};
q.__sizeDimension = function(a, b, c, d, e) {
	var f = this._fitInfo,
		g = this.__getNormalizedRect(this.fitInto),
		g = "Width" === e ? g.width : g.height;
	a = (b = b === d) ? g - a[d] : a[c];
	c = f.margin[b ? c : d];
	d = "offset" + e;
	d = this[d] - this.sizingTarget[d];
	this.sizingTarget.style["max" + e] = g - c - a - d + "px"
};
q.center = function() {
	if (!this.horizontalAlign && !this.verticalAlign) {
		this._discoverInfo();
		var a = this._fitInfo.positionedBy;
		if (!a.vertically || !a.horizontally) {
			this.style.position = "fixed";
			a.vertically || (this.style.top = "0px");
			a.horizontally || (this.style.left = "0px");
			var b = this.getBoundingClientRect(),
				c = this.__getNormalizedRect(this.fitInto);
			if (!a.vertically) {
				var d = c.top - b.top + (c.height - b.height) / 2;
				this.style.top = d + "px"
			}
			a.horizontally || (a = c.left - b.left + (c.width - b.width) / 2, this.style.left = a + "px")
		}
	}
};
q.__getNormalizedRect = function(a) {
	return a === document.documentElement || a === window ? {
		top: 0,
		left: 0,
		width: window.innerWidth,
		height: window.innerHeight,
		right: window.innerWidth,
		bottom: window.innerHeight
	} : a.getBoundingClientRect()
};
q.__getCroppedArea = function(a, b, c) {
	var d = Math.min(0, a.top) + Math.min(0, c.bottom - (a.top + b.height));
	a = Math.min(0, a.left) + Math.min(0, c.right - (a.left + b.width));
	return Math.abs(d) * b.width + Math.abs(a) * b.height
};
q.__getPosition = function(a, b, c, d, e) {
	var f = [{
		verticalAlign: "top",
		horizontalAlign: "left",
		top: d.top,
		left: d.left
	}, {
		verticalAlign: "top",
		horizontalAlign: "right",
		top: d.top,
		left: d.right - c.width
	}, {
		verticalAlign: "bottom",
		horizontalAlign: "left",
		top: d.bottom - c.height,
		left: d.left
	}, {
		verticalAlign: "bottom",
		horizontalAlign: "right",
		top: d.bottom - c.height,
		left: d.right - c.width
	}];
	if (this.noOverlap) {
		for (var g = 0, h = f.length; g < h; g++) {
			var k = {},
				l;
			for (l in f[g]) k[l] = f[g][l];
			f.push(k)
		}
		f[0].top = f[1].top += d.height;
		f[2].top = f[3].top -=
			d.height;
		f[4].left = f[6].left += d.width;
		f[5].left = f[7].left -= d.width
	}
	b = "auto" === b ? null : b;
	a = "auto" === a ? null : a;
	for (var m, g = 0; g < f.length; g++) {
		d = f[g];
		if (!this.dynamicAlign && !this.noOverlap && d.verticalAlign === b && d.horizontalAlign === a) {
			m = d;
			break
		}
		h = (!b || d.verticalAlign === b) && (!a || d.horizontalAlign === a);
		if (this.dynamicAlign || h) {
			m = m || d;
			d.croppedArea = this.__getCroppedArea(d, c, e);
			k = d.croppedArea - m.croppedArea;
			if (0 > k || 0 === k && h) m = d;
			if (0 === m.croppedArea && h) break
		}
	}
	return m
};
q.notifyResize = function() {
	this.isAttached && (this._interestedResizables.forEach(function(a) {
		this.resizerShouldNotify(a) && this._notifyDescendant(a)
	}, this), this._fireResize())
};
q.assignParentResizable = function(a) {
	this._parentResizable = a
};
q.stopResizeNotificationsFor = function(a) {
	var b = this._interestedResizables.indexOf(a); - 1 < b && (this._interestedResizables.splice(b, 1), this.unlisten(a, "iron-resize", "_onDescendantIronResize"))
};
q.resizerShouldNotify = function(a) {
	return !0
};
q._onDescendantIronResize = function(a) {
	this._notifyingDescendant ? a.stopPropagation() : Polymer.Settings.useShadow || this._fireResize()
};
q._fireResize = function() {
	this.fire("iron-resize", null, {
		node: this,
		bubbles: !1
	})
};
q._onIronRequestResizeNotifications = function(a) {
	var b = a.path ? a.path[0] : a.target;
	b !== this && (-1 === this._interestedResizables.indexOf(b) && (this._interestedResizables.push(b), this.listen(b, "iron-resize", "_onDescendantIronResize")), b.assignParentResizable(this), this._notifyDescendant(b), a.stopPropagation())
};
q._parentResizableChanged = function(a) {
	a && window.removeEventListener("resize", this._boundNotifyResize)
};
q._notifyDescendant = function(a) {
	this.isAttached && (this._notifyingDescendant = !0, a.notifyResize(), this._notifyingDescendant = !1)
};
q.toggle = function() {};
q.open = function() {};
q.close = function() {};
q.cancel = function(a) {};
q.invalidateTabbables = function() {};
q._ensureSetup = function() {};
q._canceledChanged = function() {};
q._withBackdropChanged = function() {};
q._prepareRenderOpened = function() {};
q._finishRenderOpened = function() {};
q._finishRenderClosed = function() {};
q._preparePositioning = function() {};
q._finishPositioning = function() {};
q._applyFocus = function() {};
q._onCaptureClick = function(a) {};
q._onCaptureFocus = function(a) {};
q._onCaptureEsc = function(a) {};
q._onCaptureTab = function(a) {};
q._onIronResize = function() {};
q._onNodesChange = function() {};
q.__ensureFirstLastFocusables = function() {};
q.__openedChanged = function() {};
q.__onNextAnimationFrame = function(a) {};
q._setCanceled = function(a) {};
U.PaperToast = {};
U.PaperToast.PaperToast = {};
(function() {
	var a = null;
	Polymer({
		is: "paper-toast",
		behaviors: [Polymer.IronOverlayBehavior],
		properties: {
			fitInto: {
				type: Object,
				value: window,
				observer: "_onFitIntoChanged"
			},
			horizontalAlign: {
				type: String,
				value: "left"
			},
			verticalAlign: {
				type: String,
				value: "bottom"
			},
			duration: {
				type: Number,
				value: 3E3
			},
			text: {
				type: String,
				value: ""
			},
			noCancelOnOutsideClick: {
				type: Boolean,
				value: !0
			},
			noAutoFocus: {
				type: Boolean,
				value: !0
			}
		},
		listeners: {
			transitionend: "__onTransitionEnd"
		},
		get visible() {
			Polymer.Base._warn("`visible` is deprecated, use `opened` instead");
			return this.opened
		},
		get _canAutoClose() {
			return 0 < this.duration && Infinity !== this.duration
		},
		created: function() {
			this._autoClose = null;
			Polymer.IronA11yAnnouncer.requestAvailability()
		},
		show: function(a) {
			"string" == typeof a && (a = {
				text: a
			});
			for (var b in a) 0 === b.indexOf("_") ? Polymer.Base._warn('The property "' + b + '" is private and was not set.') : b in this ? this[b] = a[b] : Polymer.Base._warn('The property "' + b + '" is not valid.');
			this.open()
		},
		hide: function() {
			this.close()
		},
		__onTransitionEnd: function(a) {
			a && a.target === this && "opacity" === a.propertyName &&
				(this.opened ? this._finishRenderOpened() : this._finishRenderClosed())
		},
		_openedChanged: function() {
			null !== this._autoClose && (this.cancelAsync(this._autoClose), this._autoClose = null);
			this.opened ? (a && a !== this && a.close(), a = this, this.fire("iron-announce", {
				text: this.text
			}), this._canAutoClose && (this._autoClose = this.async(this.close, this.duration))) : a === this && (a = null);
			Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments)
		},
		_renderOpened: function() {
			this.classList.add("paper-toast-open")
		},
		_renderClosed: function() {
			this.classList.remove("paper-toast-open")
		},
		_onFitIntoChanged: function(a) {
			this.positionTarget = a
		}
	})
})();
U.PaperToggleButton = {};
U.PaperToggleButton.PaperToggleButton = {};
var qe = function() {};
q = qe.prototype;
q.addOwnKeyBinding = function(a, b) {};
q.removeOwnKeyBindings = function() {};
q.keyboardEventMatchesKeys = function(a, b) {};
q._collectKeyBindings = function() {};
q._prepKeyBindings = function() {};
q._addKeyBinding = function(a, b) {};
q._resetKeyEventListeners = function() {};
q._listenKeyEventListeners = function() {};
q._unlistenKeyEventListeners = function() {};
q._onKeyBindingEvent = function(a, b) {};
q._triggerKeyHandler = function(a, b, c) {};
q._tapHandler = function() {
	this.toggles ? this._userActivate(!this.active) : this.active = !1
};
q._detectKeyboardFocus = function(a) {
	this._setReceivedFocusFromKeyboard(!this.pointerDown && a)
};
q._userActivate = function(a) {
	this.active !== a && (this.active = a, this.fire("change"))
};
q._upHandler = function() {
	this._setPointerDown(!1);
	this._setPressed(!1)
};
q._spaceKeyDownHandler = function(a) {
	a = a.detail.keyboardEvent;
	var b = Polymer.dom(a).localTarget;
	this.isLightDescendant(b) || (a.preventDefault(), a.stopImmediatePropagation(), this._setPressed(!0))
};
q._spaceKeyUpHandler = function(a) {
	a = a.detail.keyboardEvent;
	a = Polymer.dom(a).localTarget;
	this.isLightDescendant(a) || (this.pressed && this._asyncClick(), this._setPressed(!1))
};
q._asyncClick = function() {
	this.async(function() {
		this.click()
	}, 1)
};
q._pressedChanged = function(a) {
	this._changedButtonState()
};
q._ariaActiveAttributeChanged = function(a, b) {
	b && b != a && this.hasAttribute(b) && this.removeAttribute(b)
};
q._activeChanged = function(a, b) {
	this.toggles ? this.setAttribute(this.ariaActiveAttribute, a ? "true" : "false") : this.removeAttribute(this.ariaActiveAttribute);
	this._changedButtonState()
};
q._controlStateChanged = function() {
	this.disabled ? this._setPressed(!1) : this._changedButtonState()
};
q._changedButtonState = function() {
	this._buttonStateChanged && this._buttonStateChanged()
};
q._focusBlurHandler = function(a) {
	if (a.target === this) this._setFocused("focus" === a.type);
	else if (!this.shadowRoot) {
		var b = Polymer.dom(a).localTarget;
		this.isLightDescendant(b) || this.fire(a.type, {
			sourceEvent: a
		}, {
			node: this,
			bubbles: a.bubbles,
			cancelable: a.cancelable
		})
	}
};
q._disabledChanged = function(a, b) {
	this.setAttribute("aria-disabled", a ? "true" : "false");
	this.style.pointerEvents = a ? "none" : "";
	a ? (this._oldTabIndex = this.tabIndex, this._setFocused(!1), this.tabIndex = -1, this.blur()) : void 0 !== this._oldTabIndex && (this.tabIndex = this._oldTabIndex)
};
q._changedControlState = function() {
	this._controlStateChanged && this._controlStateChanged()
};
q._downHandler = function(a) {
	Polymer.IronButtonStateImpl._downHandler.call(this, a);
	this.pressed && this.ensureRipple(a)
};
q.ensureRipple = function(a) {
	if (!this.hasRipple()) {
		this._ripple = this._createRipple();
		this._ripple.noink = this.noink;
		var b = this._rippleContainer || this.root;
		b && Polymer.dom(b).appendChild(this._ripple);
		if (a) {
			var b = Polymer.dom(this._rippleContainer || this),
				c = Polymer.dom(a).rootTarget;
			b.deepContains(c) && this._ripple.uiDownAction(a)
		}
	}
};
q.getRipple = function() {
	this.ensureRipple();
	return this._ripple
};
q.hasRipple = function() {
	return !!this._ripple
};
q._noinkChanged = function(a) {
	this.hasRipple() && (this._ripple.noink = a)
};
q._focusedChanged = function(a) {
	a && this.ensureRipple();
	this.hasRipple() && (this._ripple.holdDown = a)
};
q.registered = function() {
	Polymer.IronValidatableBehaviorMeta = new Polymer.IronMeta({
		type: "validator"
	})
};
q._invalidChanged = function() {
	this.invalid ? this.setAttribute("aria-invalid", "true") : this.removeAttribute("aria-invalid")
};
q.hasValidator = function() {
	return null != this._validator
};
q.validate = function(a) {
	this.invalid = !this._getValidity(a);
	return !this.invalid
};
q.__computeValidator = function() {
	return Polymer.IronValidatableBehaviorMeta && Polymer.IronValidatableBehaviorMeta.byKey(this.validator)
};
q._getValidity = function(a) {
	return this.disabled || !this.required || this.required && this.checked
};
q._requiredChanged = function() {
	this.required ? this.setAttribute("aria-required", "true") : this.removeAttribute("aria-required")
};
q._valueChanged = function() {
	if (void 0 === this.value || null === this.value) this.value = "on"
};
q._checkedChanged = function() {
	Polymer.IronCheckedElementBehaviorImpl._checkedChanged.call(this);
	this.hasRipple() && (this.checked ? this._ripple.setAttribute("checked", "") : this._ripple.removeAttribute("checked"))
};
q._buttonStateChanged = function() {
	Polymer.PaperRippleBehavior._buttonStateChanged.call(this);
	!this.disabled && this.isAttached && (this.checked = this.active)
};
q._setPressed = function(a) {};
q._setPointerDown = function(a) {};
q._setReceivedFocusFromKeyboard = function(a) {};
q._setFocused = function(a) {};
Polymer({
	is: "paper-toggle-button",
	behaviors: [Polymer.PaperCheckedElementBehavior],
	hostAttributes: {
		role: "button",
		"aria-pressed": "false",
		tabindex: 0
	},
	properties: {},
	listeners: {
		track: "_ontrack"
	},
	attached: function() {
		Polymer.RenderStatus.afterNextRender(this, function() {
			this.setScrollDirection("y")
		})
	},
	_ontrack: function(a) {
		a = a.detail;
		"start" === a.state ? this._trackStart(a) : "track" === a.state ? this._trackMove(a) : "end" === a.state && this._trackEnd(a)
	},
	_trackStart: function(a) {
		this._width = this.$.toggleBar.offsetWidth /
			2;
		this._trackChecked = this.checked;
		this.$.toggleButton.classList.add("dragging")
	},
	_trackMove: function(a) {
		a = a.dx;
		this._x = Math.min(this._width, Math.max(0, this._trackChecked ? this._width + a : a));
		this.translate3d(this._x + "px", 0, 0, this.$.toggleButton);
		this._userActivate(this._x > this._width / 2)
	},
	_trackEnd: function(a) {
		this.$.toggleButton.classList.remove("dragging");
		this.transform("", this.$.toggleButton)
	},
	_createRipple: function() {
		this._rippleContainer = this.$.toggleButton;
		var a = Polymer.PaperRippleBehavior._createRipple();
		a.id = "ink";
		a.setAttribute("recenters", "");
		a.classList.add("circle", "toggle-ink");
		return a
	}
});
U.PaperTooltip = {};
U.PaperTooltip.PaperTooltip = {};
var re = function() {};
q = re.prototype;
q._entryAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.entry = "fade-in-animation" !== this.entryAnimation ? [{
		name: "opaque-animation",
		node: this
	}, {
		name: this.entryAnimation,
		node: this
	}] : [{
		name: this.entryAnimation,
		node: this
	}]
};
q._exitAnimationChanged = function() {
	this.animationConfig = this.animationConfig || {};
	this.animationConfig.exit = [{
		name: this.exitAnimation,
		node: this
	}]
};
q._copyProperties = function(a, b) {
	for (var c in b) a[c] = b[c]
};
q._cloneConfig = function(a) {
	var b = {
		isClone: !0
	};
	this._copyProperties(b, a);
	return b
};
q._getAnimationConfigRecursive = function(a, b, c) {
	if (this.animationConfig)
		if (this.animationConfig.value && "function" === typeof this.animationConfig.value) this._warn(this._logf("playAnimation", "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
		else {
			var d;
			d = a ? this.animationConfig[a] : this.animationConfig;
			Array.isArray(d) || (d = [d]);
			if (d)
				for (var e, f = 0; e = d[f]; f++)
					if (e.animatable) e.animatable._getAnimationConfigRecursive(e.type || a, b, c);
					else if (e.id) {
				var g =
					b[e.id];
				g ? (g.isClone || (b[e.id] = this._cloneConfig(g), g = b[e.id]), this._copyProperties(g, e)) : b[e.id] = e
			} else c.push(e)
		}
};
q.getAnimationConfig = function(a) {
	var b = {},
		c = [];
	this._getAnimationConfigRecursive(a, b, c);
	for (var d in b) c.push(b[d]);
	return c
};
q._configureAnimationEffects = function(a) {
	var b = [];
	if (0 < a.length)
		for (var c, d = 0; c = a[d]; d++) {
			var e = document.createElement(c.name);
			if (e.isNeonAnimation) {
				var f = e.configure(c);
				f && b.push({
					animation: e,
					config: c,
					effect: f
				})
			} else Polymer.Base._warn(this.is + ":", c.name, "not found!")
		}
	return b
};
q._runAnimationEffects = function(a) {
	return document.timeline.play(new GroupEffect(a))
};
q._completeAnimations = function(a) {
	for (var b, c = 0; b = a[c]; c++) b.animation.complete(b.config)
};
q.playAnimation = function(a, b) {
	if (a = this.getAnimationConfig(a)) {
		var c = this._configureAnimationEffects(a);
		a = c.map(function(a) {
			return a.effect
		});
		0 < a.length ? (this._player = this._runAnimationEffects(a), this._player.onfinish = function() {
			this._completeAnimations(c);
			this._player && (this._player.cancel(), this._player = null);
			this.fire("neon-animation-finish", b, {
				bubbles: !1
			})
		}.bind(this)) : this.fire("neon-animation-finish", b, {
			bubbles: !1
		})
	}
};
q.cancelAnimation = function() {
	this._player && this._player.cancel()
};
Polymer({
	is: "paper-tooltip",
	hostAttributes: {
		role: "tooltip",
		tabindex: -1
	},
	behaviors: [Polymer.NeonAnimationRunnerBehavior],
	properties: {
		for: {
			type: String,
			observer: "_forChanged"
		},
		manualMode: {
			type: Boolean,
			value: !1
		},
		position: {
			type: String,
			value: "bottom"
		},
		fitToVisibleBounds: {
			type: Boolean,
			value: !1
		},
		offset: {
			type: Number,
			value: 14
		},
		marginTop: {
			type: Number,
			value: 14
		},
		animationDelay: {
			type: Number,
			value: 500
		},
		animationConfig: {
			type: Object,
			value: function() {
				return {
					entry: [{
						name: "fade-in-animation",
						node: this,
						timing: {
							delay: 0
						}
					}],
					exit: [{
						name: "fade-out-animation",
						node: this
					}]
				}
			}
		},
		_showing: {
			type: Boolean,
			value: !1
		}
	},
	listeners: {
		"neon-animation-finish": "_onAnimationFinish",
		mouseenter: "hide"
	},
	get target() {
		var a = Polymer.dom(this).parentNode,
			b = Polymer.dom(this).getOwnerRoot();
		return a = this.for ? Polymer.dom(b).querySelector("#" + this.for) : a.nodeType == Node.DOCUMENT_FRAGMENT_NODE ? b.host : a
	},
	attached: function() {
		this._target = this.target;
		this.manualMode || (this.listen(this._target, "mouseenter", "show"), this.listen(this._target, "focus", "show"),
			this.listen(this._target, "mouseleave", "hide"), this.listen(this._target, "blur", "hide"), this.listen(this._target, "tap", "hide"))
	},
	detached: function() {
		this._target && !this.manualMode && (this.unlisten(this._target, "mouseenter", "show"), this.unlisten(this._target, "focus", "show"), this.unlisten(this._target, "mouseleave", "hide"), this.unlisten(this._target, "blur", "hide"), this.unlisten(this._target, "tap", "hide"))
	},
	show: function() {
		this._showing || "" === Polymer.dom(this).textContent.trim() || (this.cancelAnimation(),
			this._showing = !0, this.toggleClass("hidden", !1, this.$.tooltip), this.updatePosition(), this.animationConfig.entry[0].timing.delay = this.animationDelay, this._animationPlaying = !0, this.playAnimation("entry"))
	},
	hide: function() {
		this._showing && (this._animationPlaying ? (this.cancelAnimation(), this._showing = !1, this._onAnimationFinish()) : (this._showing = !1, this._animationPlaying = !0, this.playAnimation("exit")))
	},
	_forChanged: function() {
		this._target = this.target
	},
	updatePosition: function() {
		if (this._target && this.offsetParent) {
			var a =
				this.offset;
			14 != this.marginTop && 14 == this.offset && (a = this.marginTop);
			var b = this.offsetParent.getBoundingClientRect(),
				c = this._target.getBoundingClientRect(),
				d = this.getBoundingClientRect(),
				e = (c.width - d.width) / 2,
				f = (c.height - d.height) / 2,
				g = c.left - b.left,
				b = c.top - b.top,
				h, k;
			switch (this.position) {
				case "top":
					h = g + e;
					k = b - d.height - a;
					break;
				case "bottom":
					h = g + e;
					k = b + c.height + a;
					break;
				case "left":
					h = g - d.width - a;
					k = b + f;
					break;
				case "right":
					h = g + c.width + a, k = b + f
			}
			this.fitToVisibleBounds ? (h + d.width > window.innerWidth ? (this.style.right =
				"0px", this.style.left = "auto") : (this.style.left = Math.max(0, h) + "px", this.style.right = "auto"), k + d.height > window.innerHeight ? (this.style.bottom = "0px", this.style.top = "auto") : (this.style.top = Math.max(0, k) + "px", this.style.bottom = "auto")) : (this.style.left = h + "px", this.style.top = k + "px")
		}
	},
	_onAnimationFinish: function() {
		this._animationPlaying = !1;
		this._showing || this.toggleClass("hidden", !0, this.$.tooltip)
	}
});
/*


 Copyright (c) 2010-2016, Michael Bostock
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

 * Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

 * The name Michael Bostock may not be used to endorse or promote products
   derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 ARE DISCLAIMED. IN NO EVENT SHALL MICHAEL BOSTOCK BE LIABLE FOR ANY DIRECT,
 INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
d3 = function() {
	function a(a) {
		return a && (a.ownerDocument && a.ownerDocument.defaultView || a.document && a || a.defaultView)
	}

	function b(a, b) {
		return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN
	}

	function c(a) {
		return null === a ? NaN : +a
	}

	function d(a) {
		return !isNaN(a)
	}

	function e(a) {
		return {
			left: function(b, c, d, e) {
				3 > arguments.length && (d = 0);
				4 > arguments.length && (e = b.length);
				for (; d < e;) {
					var f = d + e >>> 1;
					0 > a(b[f], c) ? d = f + 1 : e = f
				}
				return d
			},
			right: function(b, c, d, e) {
				3 > arguments.length && (d = 0);
				4 > arguments.length && (e = b.length);
				for (; d < e;) {
					var f = d + e >>> 1;
					0 < a(b[f],
						c) ? e = f : d = f + 1
				}
				return d
			}
		}
	}

	function f(a) {
		return a.length
	}

	function g(a, b) {
		for (var c in b) Object.defineProperty(a.prototype, c, {
			value: b[c],
			enumerable: !1
		})
	}

	function h() {
		this._ = Object.create(null)
	}

	function k(a) {
		return "__proto__" === (a += "") || "\x00" === a[0] ? "\x00" + a : a
	}

	function l(a) {
		return "\x00" === (a += "")[0] ? a.slice(1) : a
	}

	function m(a) {
		return k(a) in this._
	}

	function n(a) {
		return (a = k(a)) in this._ && delete this._[a]
	}

	function r() {
		var a = [],
			b;
		for (b in this._) a.push(l(b));
		return a
	}

	function t() {
		var a = 0,
			b;
		for (b in this._) ++a;
		return a
	}

	function u() {
		for (var a in this._) return !1;
		return !0
	}

	function w() {
		this._ = Object.create(null)
	}

	function v(a) {
		return a
	}

	function x(a, b, c) {
		return function() {
			var d = c.apply(b, arguments);
			return d === b ? a : d
		}
	}

	function y(a, b) {
		if (b in a) return b;
		b = b.charAt(0).toUpperCase() + b.slice(1);
		for (var c = 0, d = qg.length; c < d; ++c) {
			var e = qg[c] + b;
			if (e in a) return e
		}
	}

	function D() {}

	function z() {}

	function G(a) {
		function b() {
			for (var b = c, d = -1, e = b.length, f; ++d < e;)(f = b[d].on) && f.apply(this, arguments);
			return a
		}
		var c = [],
			d = new h;
		b.on =
			function(b, e) {
				var f = d.get(b),
					C;
				if (2 > arguments.length) return f && f.on;
				f && (f.on = null, c = c.slice(0, C = c.indexOf(f)).concat(c.slice(C + 1)), d.remove(b));
				e && c.push(d.set(b, {
					on: e
				}));
				return a
			};
		return b
	}

	function A() {
		B.event.preventDefault()
	}

	function H() {
		for (var a = B.event, b; b = a.sourceEvent;) a = b;
		return a
	}

	function O(a) {
		for (var b = new z, c = 0, d = arguments.length; ++c < d;) b[arguments[c]] = G(b);
		b.of = function(c, d) {
			return function(e) {
				try {
					var f = e.sourceEvent = B.event;
					e.target = a;
					B.event = e;
					b[e.type].apply(c, d)
				} finally {
					B.event = f
				}
			}
		};
		return b
	}

	function M(a) {
		Xc(a, qa);
		return a
	}

	function J(a) {
		return "function" === typeof a ? a : function() {
			return Be(a, this)
		}
	}

	function P(a) {
		return "function" === typeof a ? a : function() {
			return Ce(a, this)
		}
	}

	function L(a, b) {
		function c() {
			this.removeAttribute(a)
		}

		function d() {
			this.removeAttributeNS(a.space, a.local)
		}

		function e() {
			this.setAttribute(a, b)
		}

		function f() {
			this.setAttributeNS(a.space, a.local, b)
		}

		function C() {
			var c = b.apply(this, arguments);
			null == c ? this.removeAttribute(a) : this.setAttribute(a, c)
		}

		function g() {
			var c = b.apply(this,
				arguments);
			null == c ? this.removeAttributeNS(a.space, a.local) : this.setAttributeNS(a.space, a.local, c)
		}
		a = B.ns.qualify(a);
		return null == b ? a.local ? d : c : "function" === typeof b ? a.local ? g : C : a.local ? f : e
	}

	function Q(a) {
		return new RegExp("(?:^|\\s+)" + B.requote(a) + "(?:\\s+|$)", "g")
	}

	function S(a, b) {
		function c() {
			for (var c = -1; ++c < e;) a[c](this, b)
		}

		function d() {
			for (var c = -1, d = b.apply(this, arguments); ++c < e;) a[c](this, d)
		}
		a = (a + "").trim().split(/^|\s+/).map(K);
		var e = a.length;
		return "function" === typeof b ? d : c
	}

	function K(a) {
		var b =
			Q(a);
		return function(c, d) {
			if (e = c.classList) return d ? e.add(a) : e.remove(a);
			var e = c.getAttribute("class") || "";
			d ? (b.lastIndex = 0, b.test(e) || c.setAttribute("class", (e + " " + a).trim().replace(/\s+/g, " "))) : c.setAttribute("class", e.replace(b, " ").trim().replace(/\s+/g, " "))
		}
	}

	function X(a, b, c) {
		function d() {
			this.style.removeProperty(a)
		}

		function e() {
			this.style.setProperty(a, b, c)
		}

		function f() {
			var d = b.apply(this, arguments);
			null == d ? this.style.removeProperty(a) : this.style.setProperty(a, d, c)
		}
		return null == b ? d : "function" ===
			typeof b ? f : e
	}

	function ba(a, b) {
		function c() {
			delete this[a]
		}

		function d() {
			this[a] = b
		}

		function e() {
			var c = b.apply(this, arguments);
			null == c ? delete this[a] : this[a] = c
		}
		return null == b ? c : "function" === typeof b ? e : d
	}

	function ca(a) {
		function b() {
			var b = this.ownerDocument,
				c = this.namespaceURI;
			return c && c !== b.documentElement.namespaceURI ? b.createElementNS(c, a) : b.createElement(a)
		}

		function c() {
			return this.ownerDocument.createElementNS(a.space, a.local)
		}
		return "function" === typeof a ? a : (a = B.ns.qualify(a)).local ? c : b
	}

	function ia() {
		var a =
			this.parentNode;
		a && a.removeChild(this)
	}

	function Y(a) {
		return function() {
			return Yc(this, a)
		}
	}

	function ha(a) {
		arguments.length || (a = b);
		return function(b, c) {
			return b && c ? a(b.__data__, c.__data__) : !b - !c
		}
	}

	function Z(a, b) {
		for (var c = 0, d = a.length; c < d; c++)
			for (var e = a[c], f = 0, g = e.length, C; f < g; f++)(C = e[f]) && b(C, f, c);
		return a
	}

	function aa(a) {
		Xc(a, sb);
		return a
	}

	function I(a) {
		var b, c;
		return function(d, e, f) {
			d = a[f].update;
			var g = d.length;
			f != c && (c = f, b = 0);
			for (e >= b && (b = e + 1); !(e = d[b]) && ++b < g;);
			return e
		}
	}

	function ma(a, b, c) {
		function d() {
			var b =
				this[g];
			b && (this.removeEventListener(a, b, b.$), delete this[g])
		}

		function e() {
			var e = h(b, lb(arguments));
			d.call(this);
			this.addEventListener(a, this[g] = e, e.$ = c);
			e._ = b
		}

		function f() {
			var b = new RegExp("^__on([^.]+)" + B.requote(a) + "$"),
				c, d;
			for (d in this)
				if (c = d.match(b)) {
					var e = this[d];
					this.removeEventListener(c[1], e, e.$);
					delete this[d]
				}
		}
		var g = "__on" + a,
			C = a.indexOf("."),
			h = ka;
		0 < C && (a = a.slice(0, C));
		var k = Ee.get(a);
		k && (a = k, h = oa);
		return C ? b ? e : d : b ? D : f
	}

	function ka(a, b) {
		return function(c) {
			var d = B.event;
			B.event = c;
			b[0] = this.__data__;
			try {
				a.apply(this, b)
			} finally {
				B.event = d
			}
		}
	}

	function oa(a, b) {
		var c = ka(a, b);
		return function(a) {
			var b = this,
				d = a.relatedTarget;
			d && (d === b || d.compareDocumentPosition(b) & 8) || c.call(b, a)
		}
	}

	function Fa(b) {
		var c = ".dragsuppress-" + ++Jj,
			d = "click" + c,
			e = B.select(a(b)).on("touchmove" + c, A).on("dragstart" + c, A).on("selectstart" + c, A);
		null == Mb && (Mb = "onselectstart" in b ? !1 : y(b.style, "userSelect"));
		if (Mb) {
			var f = (b && (b.ownerDocument || b.document || b).documentElement).style,
				g = f[Mb];
			f[Mb] = "none"
		}
		return function(a) {
			e.on(c, null);
			Mb &&
				(f[Mb] = g);
			if (a) {
				var b = function() {
					e.on(d, null)
				};
				e.on(d, function() {
					A();
					b()
				}, !0);
				setTimeout(b, 0)
			}
		}
	}

	function Pa(b, c) {
		c.changedTouches && (c = c.changedTouches[0]);
		var d = b.ownerSVGElement || b;
		if (d.createSVGPoint) {
			var e = d.createSVGPoint();
			if (0 > Fe && (d = a(b), d.scrollX || d.scrollY)) {
				var d = B.select("body").append("svg").style({
						position: "absolute",
						top: 0,
						left: 0,
						margin: 0,
						padding: 0,
						border: "none"
					}, "important"),
					f = d[0][0].getScreenCTM();
				Fe = !(f.f || f.e);
				d.remove()
			}
			Fe ? (e.x = c.pageX, e.y = c.pageY) : (e.x = c.clientX, e.y = c.clientY);
			e = e.matrixTransform(b.getScreenCTM().inverse());
			return [e.x, e.y]
		}
		e = b.getBoundingClientRect();
		return [c.clientX - e.left - b.clientLeft, c.clientY - e.top - b.clientTop]
	}

	function Xa() {
		return B.event.changedTouches[0].identifier
	}

	function Ba(a, b, c) {
		return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])
	}

	function Qa(a) {
		return 1 < a ? 0 : -1 > a ? da : Math.acos(a)
	}

	function Ja(a) {
		return 1 < a ? Da : -1 > a ? -Da : Math.asin(a)
	}

	function Ua(a) {
		return ((a = Math.exp(a)) + 1 / a) / 2
	}

	function ac(a) {
		return (a = Math.sin(a / 2)) * a
	}

	function Za() {}

	function Ya(a,
		b, c) {
		return this instanceof Ya ? void(this.h = +a, this.s = +b, this.l = +c) : 2 > arguments.length ? a instanceof Ya ? new Ya(a.h, a.s, a.l) : tb("" + a, Nb, Ya) : new Ya(a, b, c)
	}

	function La(a, b, c) {
		function d(a) {
			360 < a ? a -= 360 : 0 > a && (a += 360);
			return 60 > a ? e + (f - e) * a / 60 : 180 > a ? f : 240 > a ? e + (f - e) * (240 - a) / 60 : e
		}
		var e, f;
		a = isNaN(a) ? 0 : 0 > (a %= 360) ? a + 360 : a;
		b = isNaN(b) ? 0 : 0 > b ? 0 : 1 < b ? 1 : b;
		c = 0 > c ? 0 : 1 < c ? 1 : c;
		f = .5 >= c ? c * (1 + b) : c + b - c * b;
		e = 2 * c - f;
		return new Ca(Math.round(255 * d(a + 120)), Math.round(255 * d(a)), Math.round(255 * d(a - 120)))
	}

	function Ia(a, b, c) {
		return this instanceof
		Ia ? void(this.h = +a, this.c = +b, this.l = +c) : 2 > arguments.length ? a instanceof Ia ? new Ia(a.h, a.c, a.l) : a instanceof Ra ? bc(a.l, a.a, a.b) : bc((a = Ka((a = B.rgb(a)).r, a.g, a.b)).l, a.a, a.b) : new Ia(a, b, c)
	}

	function ub(a, b, c) {
		isNaN(a) && (a = 0);
		isNaN(b) && (b = 0);
		return new Ra(c, Math.cos(a *= ea) * b, Math.sin(a) * b)
	}

	function Ra(a, b, c) {
		return this instanceof Ra ? void(this.l = +a, this.a = +b, this.b = +c) : 2 > arguments.length ? a instanceof Ra ? new Ra(a.l, a.a, a.b) : a instanceof Ia ? ub(a.h, a.c, a.l) : Ka((a = Ca(a)).r, a.g, a.b) : new Ra(a, b, c)
	}

	function Sa(a,
		b, c) {
		a = (a + 16) / 116;
		b = a + b / 500;
		c = a - c / 200;
		b = cc(b) * rg;
		a = cc(a) * sg;
		c = cc(c) * tg;
		return new Ca(dc(3.2404542 * b - 1.5371385 * a - .4985314 * c), dc(-.969266 * b + 1.8760108 * a + .041556 * c), dc(.0556434 * b - .2040259 * a + 1.0572252 * c))
	}

	function bc(a, b, c) {
		return 0 < a ? new Ia(Math.atan2(c, b) * ya, Math.sqrt(b * b + c * c), a) : new Ia(NaN, NaN, a)
	}

	function cc(a) {
		return .206893034 < a ? a * a * a : (a - 4 / 29) / 7.787037
	}

	function vb(a) {
		return .008856 < a ? Math.pow(a, 1 / 3) : 7.787037 * a + 4 / 29
	}

	function dc(a) {
		return Math.round(255 * (.00304 >= a ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - .055))
	}

	function Ca(a, b, c) {
		return this instanceof Ca ? void(this.r = ~~a, this.g = ~~b, this.b = ~~c) : 2 > arguments.length ? a instanceof Ca ? new Ca(a.r, a.g, a.b) : tb("" + a, Ca, La) : new Ca(a, b, c)
	}

	function wb(a) {
		return new Ca(a >> 16, a >> 8 & 255, a & 255) + ""
	}

	function mb(a) {
		return 16 > a ? "0" + Math.max(0, a).toString(16) : Math.min(255, a).toString(16)
	}

	function tb(a, b, c) {
		var d = 0,
			e = 0,
			f = 0,
			g, C;
		if (g = /([a-z]+)\((.*)\)/.exec(a = a.toLowerCase())) switch (C = g[2].split(","), g[1]) {
			case "hsl":
				return c(parseFloat(C[0]), parseFloat(C[1]) / 100, parseFloat(C[2]) /
					100);
			case "rgb":
				return b(nb(C[0]), nb(C[1]), nb(C[2]))
		}
		if (c = Zc.get(a)) return b(c.r, c.g, c.b);
		null == a || "#" !== a.charAt(0) || isNaN(c = parseInt(a.slice(1), 16)) || (4 === a.length ? (d = (c & 3840) >> 4, d |= d >> 4, e = c & 240, e |= e >> 4, f = c & 15, f |= f << 4) : 7 === a.length && (d = (c & 16711680) >> 16, e = (c & 65280) >> 8, f = c & 255));
		return b(d, e, f)
	}

	function Nb(a, b, c) {
		var d = Math.min(a /= 255, b /= 255, c /= 255),
			e = Math.max(a, b, c),
			f = e - d,
			g = (e + d) / 2;
		f ? (d = .5 > g ? f / (e + d) : f / (2 - e - d), a = a == e ? (b - c) / f + (b < c ? 6 : 0) : b == e ? (c - a) / f + 2 : (a - b) / f + 4, a *= 60) : (a = NaN, d = 0 < g && 1 > g ? 0 : a);
		return new Ya(a,
			d, g)
	}

	function Ka(a, b, c) {
		a = la(a);
		b = la(b);
		c = la(c);
		var d = vb((.4124564 * a + .3575761 * b + .1804375 * c) / rg),
			e = vb((.2126729 * a + .7151522 * b + .072175 * c) / sg);
		a = vb((.0193339 * a + .119192 * b + .9503041 * c) / tg);
		return Ra(116 * e - 16, 500 * (d - e), 200 * (e - a))
	}

	function la(a) {
		return .04045 >= (a /= 255) ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4)
	}

	function nb(a) {
		var b = parseFloat(a);
		return "%" === a.charAt(a.length - 1) ? Math.round(2.55 * b) : b
	}

	function pa(a) {
		return "function" === typeof a ? a : function() {
			return a
		}
	}

	function E(a) {
		return function(b, c, d) {
			2 === arguments.length &&
				"function" === typeof c && (d = c, c = null);
			return Ob(b, c, a, d)
		}
	}

	function Ob(a, b, c, d) {
		function e() {
			var a = h.status,
				b, d;
			if (d = !a) d = (d = h.responseType) && "text" !== d ? h.response : h.responseText;
			if (d || 200 <= a && 300 > a || 304 === a) {
				try {
					b = c.call(f, h)
				} catch (Ij) {
					g.error.call(f, Ij);
					return
				}
				g.load.call(f, b)
			} else g.error.call(f, h)
		}
		var f = {},
			g = B.dispatch("beforesend", "progress", "load", "error"),
			C = {},
			h = new XMLHttpRequest,
			k = null;
		!this.XDomainRequest || "withCredentials" in h || !/^(http(s)?:)?\/\//.test(a) || (h = new XDomainRequest);
		"onload" in
		h ? h.onload = h.onerror = e : h.onreadystatechange = function() {
			3 < h.readyState && e()
		};
		h.onprogress = function(a) {
			var b = B.event;
			B.event = a;
			try {
				g.progress.call(f, h)
			} finally {
				B.event = b
			}
		};
		f.header = function(a, b) {
			a = (a + "").toLowerCase();
			if (2 > arguments.length) return C[a];
			null == b ? delete C[a] : C[a] = b + "";
			return f
		};
		f.mimeType = function(a) {
			if (!arguments.length) return b;
			b = null == a ? null : a + "";
			return f
		};
		f.responseType = function(a) {
			if (!arguments.length) return k;
			k = a;
			return f
		};
		f.response = function(a) {
			c = a;
			return f
		};
		["get", "post"].forEach(function(a) {
			f[a] =
				function() {
					return f.send.apply(f, [a].concat(lb(arguments)))
				}
		});
		f.send = function(c, d, e) {
			2 === arguments.length && "function" === typeof d && (e = d, d = null);
			h.open(c, a, !0);
			null == b || "accept" in C || (C.accept = b + ",*/*");
			if (h.setRequestHeader)
				for (var R in C) h.setRequestHeader(R, C[R]);
			null != b && h.overrideMimeType && h.overrideMimeType(b);
			null != k && (h.responseType = k);
			if (null != e) f.on("error", e).on("load", function(a) {
				e(null, a)
			});
			g.beforesend.call(f, h);
			h.send(null == d ? null : d);
			return f
		};
		f.abort = function() {
			h.abort();
			return f
		};
		B.rebind(f, g, "on");
		return null == d ? f : f.get($c(d))
	}

	function $c(a) {
		return 1 === a.length ? function(b, c) {
			a(null == b ? c : null)
		} : a
	}

	function ua(a, b, c) {
		var d = arguments.length;
		2 > d && (b = 0);
		3 > d && (c = Date.now());
		d = c + b;
		d = {
			c: a,
			t: d,
			n: null
		};
		ad ? ad.n = d : bd = d;
		ad = d;
		cd || (dd = clearTimeout(dd), cd = 1, ug($a));
		return d
	}

	function $a() {
		var a = W(),
			a = ra() - a;
		24 < a ? (isFinite(a) && (clearTimeout(dd), dd = setTimeout($a, a)), cd = 0) : (cd = 1, ug($a))
	}

	function W() {
		for (var a = Date.now(), b = bd; b;) a >= b.t && b.c(a - b.t) && (b.c = null), b = b.n;
		return a
	}

	function ra() {
		for (var a,
				b = bd, c = Infinity; b;) b.c ? (b.t < c && (c = b.t), b = (a = b).n) : b = a ? a.n = b.n : bd = b.n;
		ad = a;
		return c
	}

	function xb(a, b) {
		return b - (a ? Math.ceil(Math.log(a) / Math.LN10) : 1)
	}

	function Pb(a, b) {
		var c = Math.pow(10, 3 * fa(8 - b));
		return {
			scale: 8 < b ? function(a) {
				return a / c
			} : function(a) {
				return a * c
			},
			symbol: a
		}
	}

	function ec(a) {
		var b = a.decimal,
			c = a.thousands,
			d = a.grouping,
			e = a.currency,
			f = d && c ? function(a, b) {
				for (var e = a.length, f = [], g = 0, C = d[0], h = 0; 0 < e && 0 < C;) {
					h + C + 1 > b && (C = Math.max(1, b - h));
					f.push(a.substring(e -= C, e + C));
					if ((h += C + 1) > b) break;
					C = d[g = (g + 1) %
						d.length]
				}
				return f.reverse().join(c)
			} : v;
		return function(a) {
			a = vg.exec(a);
			var c = a[1] || " ",
				d = a[2] || ">",
				g = a[3] || "-",
				C = a[4] || "",
				h = a[5],
				k = +a[6],
				R = a[7],
				l = a[8],
				m = a[9],
				ja = 1,
				n = "",
				r = "",
				Aa = !1,
				u = !0;
			l && (l = +l.substring(1));
			if (h || "0" === c && "=" === d) h = c = "0", d = "=";
			switch (m) {
				case "n":
					R = !0;
					m = "g";
					break;
				case "%":
					ja = 100;
					r = "%";
					m = "f";
					break;
				case "p":
					ja = 100;
					r = "%";
					m = "r";
					break;
				case "b":
				case "o":
				case "x":
				case "X":
					"#" === C && (n = "0" + m.toLowerCase());
				case "c":
					u = !1;
				case "d":
					Aa = !0;
					l = 0;
					break;
				case "s":
					ja = -1, m = "r"
			}
			"$" === C && (n = e[0], r = e[1]);
			"r" != m || l || (m = "g");
			if (null != l)
				if ("g" == m) l = Math.max(1, Math.min(21, l));
				else if ("e" == m || "f" == m) l = Math.max(0, Math.min(20, l));
			var m = Kj.get(m) || Ge,
				va = h && R;
			return function(a) {
				var e = r;
				if (Aa && a % 1) return "";
				var C = 0 > a || 0 === a && 0 > 1 / a ? (a = -a, "-") : "-" === g ? "" : g;
				0 > ja ? (e = B.formatPrefix(a, l), a = e.scale(a), e = e.symbol + r) : a *= ja;
				a = m(a, l);
				var sa = a.lastIndexOf("."),
					t;
				0 > sa ? (sa = u ? a.lastIndexOf("e") : -1, 0 > sa ? (t = a, a = "") : (t = a.substring(0, sa), a = a.substring(sa))) : (t = a.substring(0, sa), a = b + a.substring(sa + 1));
				!h && R && (t = f(t, Infinity));
				var sa = n.length + t.length + a.length + (va ? 0 : C.length),
					ta = sa < k ? Array(sa = k - sa + 1).join(c) : "";
				va && (t = f(ta + t, ta.length ? k - a.length : Infinity));
				C += n;
				a = t + a;
				return ("<" === d ? C + a + ta : ">" === d ? ta + C + a : "^" === d ? ta.substring(0, sa >>= 1) + C + a + ta.substring(sa) : C + (va ? a : ta + a)) + e
			}
		}
	}

	function Ge(a) {
		return a + ""
	}

	function hb() {
		this._ = new Date(1 < arguments.length ? Date.UTC.apply(this, arguments) : arguments[0])
	}

	function ob(a, b, c) {
		function d(b) {
			var c = a(b),
				d = f(c, 1);
			return b - c < d - b ? c : d
		}

		function e(c) {
			b(c = a(new Ma(c - 1)), 1);
			return c
		}

		function f(a,
			c) {
			b(a = new Ma(+a), c);
			return a
		}

		function g(a, d, f) {
			a = e(a);
			var g = [];
			if (1 < f)
				for (; a < d;) c(a) % f || g.push(new Date(+a)), b(a, 1);
			else
				for (; a < d;) g.push(new Date(+a)), b(a, 1);
			return g
		}

		function C(a, b, c) {
			try {
				Ma = hb;
				var d = new hb;
				d._ = a;
				return g(d, b, c)
			} finally {
				Ma = Date
			}
		}
		a.floor = a;
		a.round = d;
		a.ceil = e;
		a.offset = f;
		a.range = g;
		var h = a.utc = fc(a);
		h.floor = h;
		h.round = fc(d);
		h.ceil = fc(e);
		h.offset = fc(f);
		h.range = C;
		return a
	}

	function fc(a) {
		return function(b, c) {
			try {
				Ma = hb;
				var d = new hb;
				d._ = b;
				return a(d, c)._
			} finally {
				Ma = Date
			}
		}
	}

	function He(a) {
		function b(a) {
			function b(b) {
				for (var c = [], e = -1, f = 0, g, C; ++e < d;)
					if (37 === a.charCodeAt(e)) {
						c.push(a.slice(f, e));
						null != (g = wg[f = a.charAt(++e)]) && (f = a.charAt(++e));
						if (C = P[f]) f = C(b, null == g ? "e" === f ? " " : "0" : g);
						c.push(f);
						f = e + 1
					}
				c.push(a.slice(f, e));
				return c.join("")
			}
			var d = a.length;
			b.parse = function(b) {
				var d = {
						y: 1900,
						m: 0,
						d: 1,
						H: 0,
						M: 0,
						S: 0,
						L: 0,
						Z: null
					},
					e = c(d, a, b, 0);
				if (e != b.length) return null;
				"p" in d && (d.H = d.H % 12 + 12 * d.p);
				b = null != d.Z && Ma !== hb;
				e = new(b ? hb : Ma);
				"j" in d ? e.setFullYear(d.y, 0, d.j) : "W" in d || "U" in d ? ("w" in d || (d.w = "W" in d ? 1 : 0), e.setFullYear(d.y, 0,
					1), e.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + 7 * d.W - (e.getDay() + 5) % 7 : d.w + 7 * d.U - (e.getDay() + 6) % 7)) : e.setFullYear(d.y, d.m, d.d);
				e.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
				return b ? e._ : e
			};
			b.toString = function() {
				return a
			};
			return b
		}

		function c(a, b, c, d) {
			for (var e, f = 0, g = b.length, C = c.length; f < g;) {
				if (d >= C) return -1;
				e = b.charCodeAt(f++);
				if (37 === e) {
					if (e = b.charAt(f++), e = I[e in wg ? b.charAt(f++) : e], !e || 0 > (d = e(a, c, d))) return -1
				} else if (e != c.charCodeAt(d++)) return -1
			}
			return d
		}

		function d(a, b, c) {
			A.lastIndex = 0;
			return (b = A.exec(b.slice(c))) ?
				(a.w = D.get(b[0].toLowerCase()), c + b[0].length) : -1
		}

		function e(a, b, c) {
			z.lastIndex = 0;
			return (b = z.exec(b.slice(c))) ? (a.w = J.get(b[0].toLowerCase()), c + b[0].length) : -1
		}

		function f(a, b, c) {
			H.lastIndex = 0;
			return (b = H.exec(b.slice(c))) ? (a.m = E.get(b[0].toLowerCase()), c + b[0].length) : -1
		}

		function g(a, b, c) {
			K.lastIndex = 0;
			return (b = K.exec(b.slice(c))) ? (a.m = G.get(b[0].toLowerCase()), c + b[0].length) : -1
		}

		function C(a, b, d) {
			return c(a, P.c.toString(), b, d)
		}

		function h(a, b, d) {
			return c(a, P.x.toString(), b, d)
		}

		function k(a, b, d) {
			return c(a,
				P.X.toString(), b, d)
		}

		function l(a, b, c) {
			b = y.get(b.slice(c, c += 2).toLowerCase());
			return null == b ? -1 : (a.p = b, c)
		}
		var m = a.dateTime,
			n = a.date,
			r = a.time,
			u = a.periods,
			t = a.days,
			v = a.shortDays,
			w = a.months,
			x = a.shortMonths;
		b.utc = function(a) {
			function c(a) {
				try {
					Ma = hb;
					var b = new Ma;
					b._ = a;
					return d(b)
				} finally {
					Ma = Date
				}
			}
			var d = b(a);
			c.parse = function(a) {
				try {
					Ma = hb;
					var b = d.parse(a);
					return b && b._
				} finally {
					Ma = Date
				}
			};
			c.toString = d.toString;
			return c
		};
		b.multi = b.utc.multi = Lj;
		var y = B.map(),
			z = Na(t),
			J = uc(t),
			A = Na(v),
			D = uc(v),
			K = Na(w),
			G = uc(w),
			H =
			Na(x),
			E = uc(x);
		u.forEach(function(a, b) {
			y.set(a.toLowerCase(), b)
		});
		var P = {
				a: function(a) {
					return v[a.getDay()]
				},
				A: function(a) {
					return t[a.getDay()]
				},
				b: function(a) {
					return x[a.getMonth()]
				},
				B: function(a) {
					return w[a.getMonth()]
				},
				c: b(m),
				d: function(a, b) {
					return na(a.getDate(), b, 2)
				},
				e: function(a, b) {
					return na(a.getDate(), b, 2)
				},
				H: function(a, b) {
					return na(a.getHours(), b, 2)
				},
				I: function(a, b) {
					return na(a.getHours() % 12 || 12, b, 2)
				},
				j: function(a, b) {
					return na(1 + V.dayOfYear(a), b, 3)
				},
				L: function(a, b) {
					return na(a.getMilliseconds(),
						b, 3)
				},
				m: function(a, b) {
					return na(a.getMonth() + 1, b, 2)
				},
				M: function(a, b) {
					return na(a.getMinutes(), b, 2)
				},
				p: function(a) {
					return u[+(12 <= a.getHours())]
				},
				S: function(a, b) {
					return na(a.getSeconds(), b, 2)
				},
				U: function(a, b) {
					return na(V.sundayOfYear(a), b, 2)
				},
				w: function(a) {
					return a.getDay()
				},
				W: function(a, b) {
					return na(V.mondayOfYear(a), b, 2)
				},
				x: b(n),
				X: b(r),
				y: function(a, b) {
					return na(a.getFullYear() % 100, b, 2)
				},
				Y: function(a, b) {
					return na(a.getFullYear() % 1E4, b, 4)
				},
				Z: Mj,
				"%": function() {
					return "%"
				}
			},
			I = {
				a: d,
				A: e,
				b: f,
				B: g,
				c: C,
				d: xg,
				e: xg,
				H: yg,
				I: yg,
				j: Nj,
				L: Oj,
				m: Pj,
				M: Qj,
				p: l,
				S: Rj,
				U: Sj,
				w: Tj,
				W: Uj,
				x: h,
				X: k,
				y: Vj,
				Y: Wj,
				Z: Xj,
				"%": Yj
			};
		return b
	}

	function na(a, b, c) {
		var d = 0 > a ? "-" : "";
		a = (d ? -a : a) + "";
		var e = a.length;
		return d + (e < c ? Array(c - e + 1).join(b) + a : a)
	}

	function Na(a) {
		return new RegExp("^(?:" + a.map(B.requote).join("|") + ")", "i")
	}

	function uc(a) {
		for (var b = new h, c = -1, d = a.length; ++c < d;) b.set(a[c].toLowerCase(), c);
		return b
	}

	function Tj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c, c + 1))) ? (a.w = +b[0], c + b[0].length) : -1
	}

	function Sj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c))) ? (a.U = +b[0], c + b[0].length) : -1
	}

	function Uj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c))) ? (a.W = +b[0], c + b[0].length) : -1
	}

	function Wj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c, c + 4))) ? (a.y = +b[0], c + b[0].length) : -1
	}

	function Vj(a, b, c) {
		Ea.lastIndex = 0;
		if (b = Ea.exec(b.slice(c, c + 2))) {
			var d;
			d = +b[0];
			d += 68 < d ? 1900 : 2E3;
			a = (a.y = d, c + b[0].length)
		} else a = -1;
		return a
	}

	function Xj(a, b, c) {
		return /^[+-]\d{4}$/.test(b = b.slice(c, c + 5)) ? (a.Z = -b, c + 5) : -1
	}

	function Pj(a, b, c) {
		Ea.lastIndex = 0;
		return (b =
			Ea.exec(b.slice(c, c + 2))) ? (a.m = b[0] - 1, c + b[0].length) : -1
	}

	function xg(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c, c + 2))) ? (a.d = +b[0], c + b[0].length) : -1
	}

	function Nj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c, c + 3))) ? (a.j = +b[0], c + b[0].length) : -1
	}

	function yg(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c, c + 2))) ? (a.H = +b[0], c + b[0].length) : -1
	}

	function Qj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c, c + 2))) ? (a.M = +b[0], c + b[0].length) : -1
	}

	function Rj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c,
			c + 2))) ? (a.S = +b[0], c + b[0].length) : -1
	}

	function Oj(a, b, c) {
		Ea.lastIndex = 0;
		return (b = Ea.exec(b.slice(c, c + 3))) ? (a.L = +b[0], c + b[0].length) : -1
	}

	function Mj(a) {
		var b = a.getTimezoneOffset();
		a = 0 < b ? "-" : "+";
		var c = fa(b) / 60 | 0,
			b = fa(b) % 60;
		return a + na(c, "0", 2) + na(b, "0", 2)
	}

	function Yj(a, b, c) {
		zg.lastIndex = 0;
		return (a = zg.exec(b.slice(c, c + 1))) ? c + a[0].length : -1
	}

	function Lj(a) {
		for (var b = a.length, c = -1; ++c < b;) a[c][0] = this(a[c][0]);
		return function(b) {
			for (var c = 0, d = a[c]; !d[1](b);) d = a[++c];
			return d[0](b)
		}
	}

	function Ie() {}

	function Ag(a,
		b, c) {
		var d = c.s = a + b,
			e = d - a,
			d = d - e;
		c.t = a - d + (b - e)
	}

	function ed(a, b) {
		if (a && Bg.hasOwnProperty(a.type)) Bg[a.type](a, b)
	}

	function Je(a, b, c) {
		var d = -1;
		c = a.length - c;
		var e;
		for (b.lineStart(); ++d < c;) e = a[d], b.point(e[0], e[1], e[2]);
		b.lineEnd()
	}

	function Cg(a, b) {
		var c = -1,
			d = a.length;
		for (b.polygonStart(); ++c < d;) Je(a[c], b, 1);
		b.polygonEnd()
	}

	function Zj() {
		function a(a, b) {
			a *= ea;
			b = b * ea / 2 + da / 4;
			var c = a - d,
				g = 0 <= c ? 1 : -1,
				C = g * c,
				c = Math.cos(b);
			b = Math.sin(b);
			var h = f * b,
				k = e * c + h * Math.cos(C),
				g = h * g * Math.sin(C);
			Qb.add(Math.atan2(g, k));
			d = a;
			e =
				c;
			f = b
		}
		var b, c, d, e, f;
		ab.point = function(g, C) {
			ab.point = a;
			d = (b = g) * ea;
			e = Math.cos(C = (c = C) * ea / 2 + da / 4);
			f = Math.sin(C)
		};
		ab.lineEnd = function() {
			a(b, c)
		}
	}

	function Rb(a) {
		var b = a[0];
		a = a[1];
		var c = Math.cos(a);
		return [c * Math.cos(b), c * Math.sin(b), Math.sin(a)]
	}

	function fd(a, b) {
		return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
	}

	function gc(a, b) {
		return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]]
	}

	function Ke(a, b) {
		a[0] += b[0];
		a[1] += b[1];
		a[2] += b[2]
	}

	function gd(a, b) {
		return [a[0] * b, a[1] * b, a[2] * b]
	}

	function hd(a) {
		var b = Math.sqrt(a[0] *
			a[0] + a[1] * a[1] + a[2] * a[2]);
		a[0] /= b;
		a[1] /= b;
		a[2] /= b
	}

	function id(a) {
		return [Math.atan2(a[1], a[0]), Ja(a[2])]
	}

	function jd(a, b) {
		return 1E-6 > fa(a[0] - b[0]) && 1E-6 > fa(a[1] - b[1])
	}

	function Le(a, b) {
		a *= ea;
		var c = Math.cos(b *= ea);
		vc(c * Math.cos(a), c * Math.sin(a), Math.sin(b))
	}

	function vc(a, b, c) {
		++wc;
		Sb += (a - Sb) / wc;
		Tb += (b - Tb) / wc;
		yb += (c - yb) / wc
	}

	function Dg() {
		function a(a, e) {
			a *= ea;
			var f = Math.cos(e *= ea),
				g = f * Math.cos(a);
			a = f * Math.sin(a);
			e = Math.sin(e);
			var h = Math.atan2(Math.sqrt((h = c * e - d * a) * h + (h = d * g - b * e) * h + (h = b * a - c * g) * h), b * g + c *
				a + d * e);
			kd += h;
			Cb += h * (b + (b = g));
			Db += h * (c + (c = a));
			pb += h * (d + (d = e));
			vc(b, c, d)
		}
		var b, c, d;
		ib.point = function(e, f) {
			e *= ea;
			var g = Math.cos(f *= ea);
			b = g * Math.cos(e);
			c = g * Math.sin(e);
			d = Math.sin(f);
			ib.point = a;
			vc(b, c, d)
		}
	}

	function Eg() {
		ib.point = Le
	}

	function ak() {
		function a(a, b) {
			a *= ea;
			var c = Math.cos(b *= ea),
				g = c * Math.cos(a);
			a = c * Math.sin(a);
			b = Math.sin(b);
			var c = e * b - f * a,
				h = f * g - d * b,
				C = d * a - e * g,
				k = Math.sqrt(c * c + h * h + C * C),
				l = d * g + e * a + f * b,
				R = k && -Qa(l) / k,
				k = Math.atan2(k, l);
			hc += R * c;
			ic += R * h;
			Eb += R * C;
			kd += k;
			Cb += k * (d + (d = g));
			Db += k * (e + (e = a));
			pb +=
				k * (f + (f = b));
			vc(d, e, f)
		}
		var b, c, d, e, f;
		ib.point = function(g, h) {
			b = g;
			c = h;
			ib.point = a;
			g *= ea;
			var C = Math.cos(h *= ea);
			d = C * Math.cos(g);
			e = C * Math.sin(g);
			f = Math.sin(h);
			vc(d, e, f)
		};
		ib.lineEnd = function() {
			a(b, c);
			ib.lineEnd = Eg;
			ib.point = Le
		}
	}

	function Fg(a, b) {
		function c(c, d) {
			return c = a(c, d), b(c[0], c[1])
		}
		a.invert && b.invert && (c.invert = function(c, d) {
			return c = b.invert(c, d), c && a.invert(c[0], c[1])
		});
		return c
	}

	function xc() {
		return !0
	}

	function Gg(a, b, c, d, e) {
		var f = [],
			g = [];
		a.forEach(function(a) {
			if (!(0 >= (b = a.length - 1))) {
				var b, c = a[0],
					d = a[b];
				if (jd(c, d)) {
					e.lineStart();
					for (d = 0; d < b; ++d) e.point((c = a[d])[0], c[1]);
					e.lineEnd()
				} else b = new ld(c, a, null, !0), c = new ld(c, null, b, !1), b.o = c, f.push(b), g.push(c), b = new ld(d, a, null, !1), c = new ld(d, null, b, !0), b.o = c, f.push(b), g.push(c)
			}
		});
		g.sort(b);
		Hg(f);
		Hg(g);
		if (f.length) {
			a = 0;
			b = c;
			for (c = g.length; a < c; ++a) g[a].e = b = !b;
			b = f[0];
			for (var h, C;;) {
				for (var k = b, l = !0; k.v;)
					if ((k = k.n) === b) return;
				h = k.z;
				e.lineStart();
				do {
					k.v = k.o.v = !0;
					if (k.e) {
						if (l)
							for (a = 0, c = h.length; a < c; ++a) e.point((C = h[a])[0], C[1]);
						else d(k.x, k.n.x, 1, e);
						k = k.n
					} else {
						if (l)
							for (h = k.p.z, a = h.length - 1; 0 <= a; --a) e.point((C = h[a])[0], C[1]);
						else d(k.x, k.p.x, -1, e);
						k = k.p
					}
					k = k.o;
					h = k.z;
					l = !l
				} while (!k.v);
				e.lineEnd()
			}
		}
	}

	function Hg(a) {
		if (b = a.length) {
			for (var b, c = 0, d = a[0], e; ++c < b;) d.n = e = a[c], e.p = d, d = e;
			d.n = e = a[0];
			e.p = d
		}
	}

	function ld(a, b, c, d) {
		this.x = a;
		this.z = b;
		this.o = c;
		this.e = d;
		this.v = !1;
		this.n = this.p = null
	}

	function Ig(a, b, c, d) {
		return function(e, f) {
			function g(b, c) {
				var d = e(b, c);
				a(b = d[0], c = d[1]) && f.point(b, c)
			}

			function h(a, b) {
				a = e(a, b);
				n.point(a[0], a[1])
			}

			function C() {
				r.point = h;
				n.lineStart()
			}

			function k() {
				r.point = g;
				n.lineEnd()
			}

			function l(a, b) {
				v.push([a, b]);
				a = e(a, b);
				t.point(a[0], a[1])
			}

			function R() {
				t.lineStart();
				v = []
			}

			function m() {
				l(v[0][0], v[0][1]);
				t.lineEnd();
				var a = t.clean(),
					b = u.buffer(),
					c = b.length;
				v.pop();
				sa.push(v);
				v = null;
				if (c)
					if (a & 1) {
						var a = b[0],
							c = a.length - 1,
							b = -1,
							d;
						if (0 < c) {
							va || (f.polygonStart(), va = !0);
							for (f.lineStart(); ++b < c;) f.point((d = a[b])[0], d[1]);
							f.lineEnd()
						}
					} else 1 < c && a & 2 && b.push(b.pop().concat(b.shift())), Aa.push(b.filter(bk))
			}
			var n = b(f),
				ja = e.invert(d[0], d[1]),
				r = {
					point: g,
					lineStart: C,
					lineEnd: k,
					polygonStart: function() {
						r.point = l;
						r.lineStart = R;
						r.lineEnd = m;
						Aa = [];
						sa = []
					},
					polygonEnd: function() {
						r.point = g;
						r.lineStart = C;
						r.lineEnd = k;
						Aa = B.merge(Aa);
						var a, b = ja;
						a = sa;
						var d = b[0],
							e = b[1],
							h = [Math.sin(d), -Math.cos(d), 0],
							l = 0,
							R = 0;
						Qb.reset();
						for (var m = 0, n = a.length; m < n; ++m) {
							var u = a[m],
								t = u.length;
							if (t)
								for (var ta = u[0], v = ta[0], b = ta[1] / 2 + da / 4, Oa = Math.sin(b), w = Math.cos(b), db = 1;;) {
									db === t && (db = 0);
									var b = u[db],
										$b = b[0],
										x = b[1] / 2 + da / 4,
										y = Math.sin(x),
										x = Math.cos(x),
										Wa = $b - v,
										z = 0 <= Wa ? 1 : -1,
										De = z * Wa,
										J = De > da,
										Oa = Oa * y;
									Qb.add(Math.atan2(Oa * z * Math.sin(De), w * x + Oa * Math.cos(De)));
									l += J ? Wa + z * bb : Wa;
									J ^ v >= d ^ $b >= d && (ta = gc(Rb(ta), Rb(b)), hd(ta), v = gc(h, ta), hd(v), v = (J ^ 0 <= Wa ? -1 : 1) * Ja(v[2]), e > v || e === v && (ta[0] || ta[1])) && (R += J ^ 0 <= Wa ? 1 : -1);
									if (!db++) break;
									v = $b;
									Oa = y;
									w = x;
									ta = b
								}
						}
						a = (-1E-6 > l || 1E-6 > l && 0 > Qb) ^ R & 1;
						Aa.length ? (va || (f.polygonStart(), va = !0), Gg(Aa, ck, a, c, f)) : a && (va || (f.polygonStart(), va = !0), f.lineStart(), c(null, null, 1, f), f.lineEnd());
						va && (f.polygonEnd(), va = !1);
						Aa = sa = null
					},
					sphere: function() {
						f.polygonStart();
						f.lineStart();
						c(null, null, 1, f);
						f.lineEnd();
						f.polygonEnd()
					}
				},
				Aa, u = Jg(),
				t = b(u),
				va = !1,
				sa, v;
			return r
		}
	}

	function bk(a) {
		return 1 < a.length
	}

	function Jg() {
		var a = [],
			b;
		return {
			lineStart: function() {
				a.push(b = [])
			},
			point: function(a, c) {
				b.push([a, c])
			},
			lineEnd: D,
			buffer: function() {
				var c = a;
				a = [];
				b = null;
				return c
			},
			rejoin: function() {
				1 < a.length && a.push(a.pop().concat(a.shift()))
			}
		}
	}

	function ck(a, b) {
		return (0 > (a = a.x)[0] ? a[1] - Da - 1E-6 : Da - a[1]) - (0 > (b = b.x)[0] ? b[1] - Da - 1E-6 : Da - b[1])
	}

	function dk(a) {
		var b = NaN,
			c = NaN,
			d = NaN,
			e;
		return {
			lineStart: function() {
				a.lineStart();
				e = 1
			},
			point: function(f, g) {
				var h = 0 < f ? da : -da,
					C = fa(f - b);
				if (1E-6 > fa(C - da)) a.point(b, c = 0 < (c + g) / 2 ? Da : -Da), a.point(d, c), a.lineEnd(), a.lineStart(), a.point(h, c), a.point(f, c), e = 0;
				else if (d !== h && C >= da) {
					1E-6 > fa(b - d) && (b -= 1E-6 * d);
					1E-6 > fa(f - h) && (f -= 1E-6 * h);
					var C = b,
						k = c,
						l = f,
						R = g,
						m, n, ja = Math.sin(C - l);
					c = 1E-6 < fa(ja) ? Math.atan((Math.sin(k) * (n = Math.cos(R)) * Math.sin(l) - Math.sin(R) * (m = Math.cos(k)) * Math.sin(C)) / (m * n * ja)) : (k + R) / 2;
					a.point(d, c);
					a.lineEnd();
					a.lineStart();
					a.point(h, c);
					e = 0
				}
				a.point(b = f, c = g);
				d = h
			},
			lineEnd: function() {
				a.lineEnd();
				b = c = NaN
			},
			clean: function() {
				return 2 - e
			}
		}
	}

	function ek(a, b, c, d) {
		null == a ? (c *= Da, d.point(-da, c), d.point(0, c), d.point(da, c), d.point(da, 0), d.point(da, -c), d.point(0, -c), d.point(-da, -c), d.point(-da, 0), d.point(-da, c)) : 1E-6 < fa(a[0] - b[0]) ? (a = a[0] < b[0] ? da : -da, c = c * a / 2, d.point(-a, c), d.point(0, c), d.point(a, c)) : d.point(b[0], b[1])
	}

	function fk(a) {
		function b(a, b) {
			return Math.cos(a) * Math.cos(b) > f
		}

		function c(a) {
			var c, f, C, k, l;
			return {
				lineStart: function() {
					k = C = !1;
					l = 1
				},
				point: function(R, m) {
					var n = [R, m],
						r = b(R, m);
					m = g ? r ? 0 : e(R, m) :
						r ? e(R + (0 > R ? da : -da), m) : 0;
					!c && (k = C = r) && a.lineStart();
					r !== C && (R = d(c, n), jd(c, R) || jd(n, R)) && (n[0] += 1E-6, n[1] += 1E-6, r = b(n[0], n[1]));
					if (r !== C) l = 0, r ? (a.lineStart(), R = d(n, c), a.point(R[0], R[1])) : (R = d(c, n), a.point(R[0], R[1]), a.lineEnd()), c = R;
					else if (h && c && g ^ r) {
						var ja;
						m & f || !(ja = d(n, c, !0)) || (l = 0, g ? (a.lineStart(), a.point(ja[0][0], ja[0][1]), a.point(ja[1][0], ja[1][1]), a.lineEnd()) : (a.point(ja[1][0], ja[1][1]), a.lineEnd(), a.lineStart(), a.point(ja[0][0], ja[0][1])))
					}!r || c && jd(c, n) || a.point(n[0], n[1]);
					c = n;
					C = r;
					f = m
				},
				lineEnd: function() {
					C &&
						a.lineEnd();
					c = null
				},
				clean: function() {
					return l | (k && C) << 1
				}
			}
		}

		function d(a, b, c) {
			var d = Rb(a),
				e = Rb(b),
				g = [1, 0, 0],
				d = gc(d, e),
				e = fd(d, d),
				h = d[0],
				C = e - h * h;
			if (!C) return !c && a;
			e = f * e / C;
			C = -f * h / C;
			h = gc(g, d);
			g = gd(g, e);
			d = gd(d, C);
			Ke(g, d);
			d = h;
			e = fd(g, d);
			h = fd(d, d);
			C = e * e - h * (fd(g, g) - 1);
			if (!(0 > C)) {
				var k = Math.sqrt(C),
					C = gd(d, (-e - k) / h);
				Ke(C, g);
				C = id(C);
				if (!c) return C;
				c = a[0];
				var l = b[0];
				a = a[1];
				b = b[1];
				var R;
				l < c && (R = c, c = l, l = R);
				var m = l - c,
					n = 1E-6 > fa(m - da),
					r = n || 1E-6 > m;
				!n && b < a && (R = a, a = b, b = R);
				if (r ? n ? 0 < a + b ^ C[1] < (1E-6 > fa(C[0] - c) ? a : b) : a <= C[1] &&
					C[1] <= b : m > da ^ (c <= C[0] && C[0] <= l)) return b = gd(d, (-e + k) / h), Ke(b, g), [C, id(b)]
			}
		}

		function e(b, c) {
			var d = g ? a : da - a,
				e = 0;
			b < -d ? e |= 1 : b > d && (e |= 2);
			c < -d ? e |= 4 : c > d && (e |= 8);
			return e
		}
		var f = Math.cos(a),
			g = 0 < f,
			h = 1E-6 < fa(f),
			C = Me(a, 6 * ea);
		return Ig(b, c, C, g ? [0, -a] : [-da, a - da])
	}

	function Kg(a, b, c, d) {
		return function(e) {
			var f = e.a,
				g = e.b,
				h = f.x,
				f = f.y,
				C = g.x,
				k = g.y,
				g = 0,
				l = 1,
				C = C - h,
				k = k - f,
				R;
			R = a - h;
			if (C || !(0 < R)) {
				R /= C;
				if (0 > C) {
					if (R < g) return;
					R < l && (l = R)
				} else if (0 < C) {
					if (R > l) return;
					R > g && (g = R)
				}
				R = c - h;
				if (C || !(0 > R)) {
					R /= C;
					if (0 > C) {
						if (R > l) return;
						R > g && (g =
							R)
					} else if (0 < C) {
						if (R < g) return;
						R < l && (l = R)
					}
					R = b - f;
					if (k || !(0 < R)) {
						R /= k;
						if (0 > k) {
							if (R < g) return;
							R < l && (l = R)
						} else if (0 < k) {
							if (R > l) return;
							R > g && (g = R)
						}
						R = d - f;
						if (k || !(0 > R)) {
							R /= k;
							if (0 > k) {
								if (R > l) return;
								R > g && (g = R)
							} else if (0 < k) {
								if (R < g) return;
								R < l && (l = R)
							}
							0 < g && (e.a = {
								x: h + g * C,
								y: f + g * k
							});
							1 > l && (e.b = {
								x: h + l * C,
								y: f + l * k
							});
							return e
						}
					}
				}
			}
		}
	}

	function Lg(a, b, c, d) {
		function e(d, e) {
			return 1E-6 > fa(d[0] - a) ? 0 < e ? 0 : 3 : 1E-6 > fa(d[0] - c) ? 0 < e ? 2 : 1 : 1E-6 > fa(d[1] - b) ? 0 < e ? 1 : 0 : 0 < e ? 3 : 2
		}

		function f(a, b) {
			return g(a.x, b.x)
		}

		function g(a, b) {
			var c = e(a, 1),
				d = e(b, 1);
			return c !== d ? c - d : 0 === c ? b[1] - a[1] : 1 === c ? a[0] - b[0] : 2 === c ? a[1] - b[1] : b[0] - a[0]
		}
		return function(h) {
			function C(f, h, C, k) {
				var l = 0,
					R = 0;
				if (null == f || (l = e(f, C)) !== (R = e(h, C)) || 0 > g(f, h) ^ 0 < C) {
					do k.point(0 === l || 3 === l ? a : c, 1 < l ? d : b); while ((l = (l + C + 4) % 4) !== R)
				} else k.point(h[0], h[1])
			}

			function k(e, f) {
				a <= e && e <= c && b <= f && f <= d && h.point(e, f)
			}

			function l() {
				va.point = m;
				t && t.push(Aa = []);
				y = !0;
				x = !1;
				w = Oa = NaN
			}

			function R() {
				u && (m(sa, v), ta && x && r.rejoin(), u.push(r.buffer()));
				va.point = k;
				x && h.lineEnd()
			}

			function m(e, f) {
				e = Math.max(-1E9, Math.min(1E9,
					e));
				f = Math.max(-1E9, Math.min(1E9, f));
				var g = a <= e && e <= c && b <= f && f <= d;
				t && Aa.push([e, f]);
				if (y) sa = e, v = f, ta = g, y = !1, g && (h.lineStart(), h.point(e, f));
				else if (g && x) h.point(e, f);
				else {
					var C = {
						a: {
							x: w,
							y: Oa
						},
						b: {
							x: e,
							y: f
						}
					};
					ja(C) ? (x || (h.lineStart(), h.point(C.a.x, C.a.y)), h.point(C.b.x, C.b.y), g || h.lineEnd(), z = !1) : g && (h.lineStart(), h.point(e, f), z = !1)
				}
				w = e;
				Oa = f;
				x = g
			}
			var n = h,
				r = Jg(),
				ja = Kg(a, b, c, d),
				u, t, Aa, va = {
					point: k,
					lineStart: l,
					lineEnd: R,
					polygonStart: function() {
						h = r;
						u = [];
						t = [];
						z = !0
					},
					polygonEnd: function() {
						h = n;
						u = B.merge(u);
						var b;
						b = [a, d];
						for (var c = 0, e = t.length, g = b[1], k = 0; k < e; ++k)
							for (var l = 1, R = t[k], m = R.length, r = R[0], ja; l < m; ++l) ja = R[l], r[1] <= g ? ja[1] > g && 0 < Ba(r, ja, b) && ++c : ja[1] <= g && 0 > Ba(r, ja, b) && --c, r = ja;
						b = 0 !== c;
						c = z && b;
						e = u.length;
						if (c || e) h.polygonStart(), c && (h.lineStart(), C(null, null, 1, h), h.lineEnd()), e && Gg(u, f, b, C, h), h.polygonEnd();
						u = t = Aa = null
					}
				},
				sa, v, ta, w, Oa, x, y, z;
			return va
		}
	}

	function Ne(a) {
		var b = 0,
			c = da / 3,
			d = Oe(a);
		a = d(b, c);
		a.parallels = function(a) {
			return arguments.length ? d(b = a[0] * da / 180, c = a[1] * da / 180) : [b / da * 180, c / da * 180]
		};
		return a
	}

	function Mg(a, b) {
		function c(a, b) {
			b = Math.sqrt(e - 2 * d * Math.sin(b)) / d;
			return [b * Math.sin(a *= d), f - b * Math.cos(a)]
		}
		a = Math.sin(a);
		var d = (a + Math.sin(b)) / 2,
			e = 1 + a * (2 * d - a),
			f = Math.sqrt(e) / d;
		c.invert = function(a, b) {
			b = f - b;
			return [Math.atan2(a, b) / d, Ja((e - (a * a + b * b) * d * d) / (2 * d))]
		};
		return c
	}

	function gk() {
		function a(a, b) {
			Pe += e * a - d * b;
			d = a;
			e = b
		}
		var b, c, d, e;
		Fb.point = function(f, g) {
			Fb.point = a;
			b = d = f;
			c = e = g
		};
		Fb.lineEnd = function() {
			a(b, c)
		}
	}

	function hk(a, b) {
		a < md && (md = a);
		a > nd && (nd = a);
		b < od && (od = b);
		b > pd && (pd = b)
	}

	function ik() {
		function a(a,
			b) {
			g.push("M", a, ",", b, f)
		}

		function b(a, b) {
			g.push("M", a, ",", b);
			h.point = c
		}

		function c(a, b) {
			g.push("L", a, ",", b)
		}

		function d() {
			h.point = a
		}

		function e() {
			g.push("Z")
		}
		var f = Ng(4.5),
			g = [],
			h = {
				point: a,
				lineStart: function() {
					h.point = b
				},
				lineEnd: d,
				polygonStart: function() {
					h.lineEnd = e
				},
				polygonEnd: function() {
					h.lineEnd = d;
					h.point = a
				},
				pointRadius: function(a) {
					f = Ng(a);
					return h
				},
				result: function() {
					if (g.length) {
						var a = g.join("");
						g = [];
						return a
					}
				}
			};
		return h
	}

	function Ng(a) {
		return "m0," + a + "a" + a + "," + a + " 0 1,1 0," + -2 * a + "a" + a + "," + a + " 0 1,1 0," +
			2 * a + "z"
	}

	function Ub(a, b) {
		Sb += a;
		Tb += b;
		++yb
	}

	function Og() {
		function a(a, d) {
			var e = a - b,
				f = d - c,
				e = Math.sqrt(e * e + f * f);
			Cb += e * (b + a) / 2;
			Db += e * (c + d) / 2;
			pb += e;
			Ub(b = a, c = d)
		}
		var b, c;
		jb.point = function(d, e) {
			jb.point = a;
			Ub(b = d, c = e)
		}
	}

	function Pg() {
		jb.point = Ub
	}

	function jk() {
		function a(a, b) {
			var c = a - d,
				f = b - e,
				c = Math.sqrt(c * c + f * f);
			Cb += c * (d + a) / 2;
			Db += c * (e + b) / 2;
			pb += c;
			c = e * a - d * b;
			hc += c * (d + a);
			ic += c * (e + b);
			Eb += 3 * c;
			Ub(d = a, e = b)
		}
		var b, c, d, e;
		jb.point = function(f, g) {
			jb.point = a;
			Ub(b = d = f, c = e = g)
		};
		jb.lineEnd = function() {
			a(b, c)
		}
	}

	function kk(a) {
		function b(b,
			c) {
			a.moveTo(b + g, c);
			a.arc(b, c, g, 0, bb)
		}

		function c(b, c) {
			a.moveTo(b, c);
			h.point = d
		}

		function d(b, c) {
			a.lineTo(b, c)
		}

		function e() {
			h.point = b
		}

		function f() {
			a.closePath()
		}
		var g = 4.5,
			h = {
				point: b,
				lineStart: function() {
					h.point = c
				},
				lineEnd: e,
				polygonStart: function() {
					h.lineEnd = f
				},
				polygonEnd: function() {
					h.lineEnd = e;
					h.point = b
				},
				pointRadius: function(a) {
					g = a;
					return h
				},
				result: D
			};
		return h
	}

	function Qg(a) {
		function b(a) {
			return (h ? d : c)(a)
		}

		function c(b) {
			return Rg(b, function(c, d) {
				c = a(c, d);
				b.point(c[0], c[1])
			})
		}

		function d(b) {
			function c(c,
				d) {
				c = a(c, d);
				b.point(c[0], c[1])
			}

			function d() {
				va = NaN;
				x.point = f;
				b.lineStart()
			}

			function f(c, d) {
				var f = Rb([c, d]);
				d = a(c, d);
				e(va, sa, Aa, v, ta, w, va = d[0], sa = d[1], Aa = c, v = f[0], ta = f[1], w = f[2], h, b);
				b.point(va, sa)
			}

			function g() {
				x.point = c;
				b.lineEnd()
			}

			function C() {
				d();
				x.point = k;
				x.lineEnd = l
			}

			function k(a, b) {
				f(R = a, m = b);
				n = va;
				r = sa;
				ja = v;
				u = ta;
				t = w;
				x.point = f
			}

			function l() {
				e(va, sa, Aa, v, ta, w, n, r, R, ja, u, t, h, b);
				x.lineEnd = g;
				g()
			}
			var R, m, n, r, ja, u, t, Aa, va, sa, v, ta, w, x = {
				point: c,
				lineStart: d,
				lineEnd: g,
				polygonStart: function() {
					b.polygonStart();
					x.lineStart = C
				},
				polygonEnd: function() {
					b.polygonEnd();
					x.lineStart = d
				}
			};
			return x
		}

		function e(b, c, d, h, C, k, l, R, m, n, r, ja, u, t) {
			var Aa = l - b,
				va = R - c,
				sa = Aa * Aa + va * va;
			if (sa > 4 * f && u--) {
				var v = h + n,
					ta = C + r,
					w = k + ja,
					x = Math.sqrt(v * v + ta * ta + w * w),
					Oa = Math.asin(w /= x),
					y = 1E-6 > fa(fa(w) - 1) || 1E-6 > fa(d - m) ? (d + m) / 2 : Math.atan2(ta, v),
					db = a(y, Oa),
					Oa = db[0],
					db = db[1],
					$b = Oa - b,
					z = db - c,
					Wa = va * $b - Aa * z;
				if (Wa * Wa / sa > f || .3 < fa((Aa * $b + va * z) / sa - .5) || h * n + C * r + k * ja < g) e(b, c, d, h, C, k, Oa, db, y, v /= x, ta /= x, w, u, t), t.point(Oa, db), e(Oa, db, y, v, ta, w, l, R, m, n, r, ja, u, t)
			}
		}
		var f = .5,
			g = Math.cos(30 * ea),
			h = 16;
		b.precision = function(a) {
			if (!arguments.length) return Math.sqrt(f);
			h = 0 < (f = a * a) && 16;
			return b
		};
		return b
	}

	function lk(a) {
		var b = Qg(function(b, c) {
			return a([b * ya, c * ya])
		});
		return function(a) {
			return Sg(b(a))
		}
	}

	function Tg(a) {
		this.stream = a
	}

	function Rg(a, b) {
		return {
			point: b,
			sphere: function() {
				a.sphere()
			},
			lineStart: function() {
				a.lineStart()
			},
			lineEnd: function() {
				a.lineEnd()
			},
			polygonStart: function() {
				a.polygonStart()
			},
			polygonEnd: function() {
				a.polygonEnd()
			}
		}
	}

	function Gb(a) {
		return Oe(function() {
			return a
		})()
	}

	function Oe(a) {
		function b(a) {
			a = h(a[0] * ea, a[1] * ea);
			return [a[0] * k + x, y - a[1] * k]
		}

		function c(a) {
			return (a = h.invert((a[0] - x) / k, (y - a[1]) / k)) && [a[0] * ya, a[1] * ya]
		}

		function d() {
			h = Fg(g = Qe(u, t, w), f);
			var a = f(n, r);
			x = l - a[0] * k;
			y = m + a[1] * k;
			return e()
		}

		function e() {
			K && (K.valid = !1, K = null);
			return b
		}
		var f, g, h, C = Qg(function(a, b) {
				a = f(a, b);
				return [a[0] * k + x, y - a[1] * k]
			}),
			k = 150,
			l = 480,
			m = 250,
			n = 0,
			r = 0,
			u = 0,
			t = 0,
			w = 0,
			x, y, z = Ug,
			J = v,
			A = null,
			D = null,
			K;
		b.stream = function(a) {
			K && (K.valid = !1);
			K = Sg(z(g, C(J(a))));
			K.valid = !0;
			return K
		};
		b.clipAngle = function(a) {
			if (!arguments.length) return A;
			z = null == a ? (A = a, Ug) : fk((A = +a) * ea);
			return e()
		};
		b.clipExtent = function(a) {
			if (!arguments.length) return D;
			J = (D = a) ? Lg(a[0][0], a[0][1], a[1][0], a[1][1]) : v;
			return e()
		};
		b.scale = function(a) {
			if (!arguments.length) return k;
			k = +a;
			return d()
		};
		b.translate = function(a) {
			if (!arguments.length) return [l, m];
			l = +a[0];
			m = +a[1];
			return d()
		};
		b.center = function(a) {
			if (!arguments.length) return [n * ya, r * ya];
			n = a[0] % 360 * ea;
			r = a[1] % 360 * ea;
			return d()
		};
		b.rotate = function(a) {
			if (!arguments.length) return [u * ya, t * ya, w * ya];
			u = a[0] % 360 * ea;
			t = a[1] % 360 * ea;
			w = 2 < a.length ? a[2] % 360 * ea : 0;
			return d()
		};
		B.rebind(b, C, "precision");
		return function() {
			f = a.apply(this, arguments);
			b.invert = f.invert && c;
			return d()
		}
	}

	function Sg(a) {
		return Rg(a, function(b, c) {
			a.point(b * ea, c * ea)
		})
	}

	function yc(a, b) {
		return [a, b]
	}

	function Vg(a, b) {
		return [a > da ? a - bb : a < -da ? a + bb : a, b]
	}

	function Qe(a, b, c) {
		return a ? b || c ? Fg(Wg(a), Xg(b, c)) : Wg(a) : b || c ? Xg(b, c) : Vg
	}

	function Yg(a) {
		return function(b, c) {
			return b += a, [b > da ? b - bb : b < -da ? b + bb : b, c]
		}
	}

	function Wg(a) {
		var b = Yg(a);
		b.invert = Yg(-a);
		return b
	}

	function Xg(a, b) {
		function c(a,
			b) {
			var c = Math.cos(b),
				h = Math.cos(a) * c;
			a = Math.sin(a) * c;
			b = Math.sin(b);
			c = b * d + h * e;
			return [Math.atan2(a * f - c * g, h * d - b * e), Ja(c * f + a * g)]
		}
		var d = Math.cos(a),
			e = Math.sin(a),
			f = Math.cos(b),
			g = Math.sin(b);
		c.invert = function(a, b) {
			var c = Math.cos(b),
				h = Math.cos(a) * c;
			a = Math.sin(a) * c;
			b = Math.sin(b);
			c = b * f - a * g;
			return [Math.atan2(a * f + b * g, h * d + c * e), Ja(c * d - h * e)]
		};
		return c
	}

	function Me(a, b) {
		var c = Math.cos(a),
			d = Math.sin(a);
		return function(e, f, g, h) {
			var C = g * b;
			if (null != e) {
				if (e = Zg(c, e), f = Zg(c, f), 0 < g ? e < f : e > f) e += g * bb
			} else e = a + g * bb, f = a - .5 * C;
			for (var k; 0 < g ? e > f : e < f; e -= C) h.point((k = id([c, -d * Math.cos(e), -d * Math.sin(e)]))[0], k[1])
		}
	}

	function Zg(a, b) {
		b = Rb(b);
		b[0] -= a;
		hd(b);
		a = Qa(-b[1]);
		return ((0 > -b[2] ? -a : a) + 2 * Math.PI - 1E-6) % (2 * Math.PI)
	}

	function $g(a, b, c) {
		var d = B.range(a, b - 1E-6, c).concat(b);
		return function(a) {
			return d.map(function(b) {
				return [a, b]
			})
		}
	}

	function ah(a, b, c) {
		var d = B.range(a, b - 1E-6, c).concat(b);
		return function(a) {
			return d.map(function(b) {
				return [b, a]
			})
		}
	}

	function Re(a) {
		return a.source
	}

	function Se(a) {
		return a.target
	}

	function mk(a, b, c, d) {
		var e =
			Math.cos(b),
			f = Math.sin(b),
			g = Math.cos(d),
			h = Math.sin(d),
			C = e * Math.cos(a),
			k = e * Math.sin(a),
			l = g * Math.cos(c),
			R = g * Math.sin(c),
			m = 2 * Math.asin(Math.sqrt(ac(d - b) + e * g * ac(c - a))),
			n = 1 / Math.sin(m);
		c = m ? function(a) {
			var b = Math.sin(a *= m) * n,
				c = Math.sin(m - a) * n;
			a = c * C + b * l;
			var d = c * k + b * R,
				b = c * f + b * h;
			return [Math.atan2(d, a) * ya, Math.atan2(b, Math.sqrt(a * a + d * d)) * ya]
		} : function() {
			return [a * ya, b * ya]
		};
		c.distance = m;
		return c
	}

	function nk() {
		function a(a, e) {
			var f = Math.sin(e *= ea);
			e = Math.cos(e);
			var g = fa((a *= ea) - b),
				h = Math.cos(g);
			Te += Math.atan2(Math.sqrt((g =
				e * Math.sin(g)) * g + (g = d * f - c * e * h) * g), c * f + d * e * h);
			b = a;
			c = f;
			d = e
		}
		var b, c, d;
		jc.point = function(e, f) {
			b = e * ea;
			c = Math.sin(f *= ea);
			d = Math.cos(f);
			jc.point = a
		};
		jc.lineEnd = function() {
			jc.point = jc.lineEnd = D
		}
	}

	function zc(a, b) {
		function c(b, c) {
			var d = Math.cos(b),
				e = Math.cos(c),
				d = a(d * e);
			return [d * e * Math.sin(b), d * Math.sin(c)]
		}
		c.invert = function(a, c) {
			var d = Math.sqrt(a * a + c * c),
				e = b(d),
				f = Math.sin(e),
				e = Math.cos(e);
			return [Math.atan2(a * f, d * e), Math.asin(d && c * f / d)]
		};
		return c
	}

	function bh(a, b) {
		function c(a, b) {
			0 < f ? b < -Da + 1E-6 && (b = -Da + 1E-6) :
				b > Da - 1E-6 && (b = Da - 1E-6);
			b = f / Math.pow(Math.tan(da / 4 + b / 2), e);
			return [b * Math.sin(e * a), f - b * Math.cos(e * a)]
		}
		var d = Math.cos(a),
			e = a === b ? Math.sin(a) : Math.log(d / Math.cos(b)) / Math.log(Math.tan(da / 4 + b / 2) / Math.tan(da / 4 + a / 2)),
			f = d * Math.pow(Math.tan(da / 4 + a / 2), e) / e;
		if (!e) return qd;
		c.invert = function(a, b) {
			b = f - b;
			var c = (0 < e ? 1 : 0 > e ? -1 : 0) * Math.sqrt(a * a + b * b);
			return [Math.atan2(a, b) / e, 2 * Math.atan(Math.pow(f / c, 1 / e)) - Da]
		};
		return c
	}

	function ch(a, b) {
		function c(a, b) {
			b = f - b;
			return [b * Math.sin(e * a), f - b * Math.cos(e * a)]
		}
		var d = Math.cos(a),
			e = a === b ? Math.sin(a) : (d - Math.cos(b)) / (b - a),
			f = d / e + a;
		if (1E-6 > fa(e)) return yc;
		c.invert = function(a, b) {
			b = f - b;
			return [Math.atan2(a, b) / e, f - (0 < e ? 1 : 0 > e ? -1 : 0) * Math.sqrt(a * a + b * b)]
		};
		return c
	}

	function qd(a, b) {
		return [a, Math.log(Math.tan(da / 4 + b / 2))]
	}

	function dh(a) {
		var b = Gb(a),
			c = b.scale,
			d = b.translate,
			e = b.clipExtent,
			f;
		b.scale = function() {
			var a = c.apply(b, arguments);
			return a === b ? f ? b.clipExtent(null) : b : a
		};
		b.translate = function() {
			var a = d.apply(b, arguments);
			return a === b ? f ? b.clipExtent(null) : b : a
		};
		b.clipExtent = function(a) {
			var g =
				e.apply(b, arguments);
			if (g === b) {
				if (f = null == a) {
					var h = da * c(),
						C = d();
					e([
						[C[0] - h, C[1] - h],
						[C[0] + h, C[1] + h]
					])
				}
			} else f && (g = null);
			return g
		};
		return b.clipExtent(null)
	}

	function Ue(a, b) {
		return [Math.log(Math.tan(da / 4 + b / 2)), -a]
	}

	function kc(a) {
		return a[0]
	}

	function Ac(a) {
		return a[1]
	}

	function eh(a) {
		for (var b = a.length, c = [0, 1], d = 2, e = 2; e < b; e++) {
			for (; 1 < d && 0 >= Ba(a[c[d - 2]], a[c[d - 1]], a[e]);) --d;
			c[d++] = e
		}
		return c.slice(0, d)
	}

	function ok(a, b) {
		return a[0] - b[0] || a[1] - b[1]
	}

	function Ve(a, b, c) {
		return (c[0] - b[0]) * (a[1] - b[1]) < (c[1] -
			b[1]) * (a[0] - b[0])
	}

	function We(a, b, c, d) {
		var e = a[0],
			f = c[0],
			g = b[0] - e,
			h = d[0] - f;
		a = a[1];
		c = c[1];
		b = b[1] - a;
		d = d[1] - c;
		f = (h * (a - c) - d * (e - f)) / (d * g - h * b);
		return [e + f * g, a + f * b]
	}

	function fh(a) {
		var b = a[0];
		a = a[a.length - 1];
		return !(b[0] - a[0] || b[1] - a[1])
	}

	function pk() {
		rd(this);
		this.edge = this.site = this.circle = null
	}

	function gh(a) {
		var b = hh.pop() || new pk;
		b.site = a;
		return b
	}

	function Xe(a) {
		lc(a);
		mc.remove(a);
		hh.push(a);
		rd(a)
	}

	function ih(a, b) {
		var c = a.site,
			d = c.x,
			e = c.y,
			f = e - b;
		if (!f) return d;
		a = a.P;
		if (!a) return -Infinity;
		c = a.site;
		a = c.x;
		c = c.y;
		b = c - b;
		if (!b) return a;
		var g = a - d,
			h = 1 / f - 1 / b,
			C = g / b;
		return h ? (-C + Math.sqrt(C * C - 2 * h * (g * g / (-2 * b) - c + b / 2 + e - f / 2))) / h + d : (d + a) / 2
	}

	function jh(a) {
		this.site = a;
		this.edges = []
	}

	function kh(a, b) {
		return b.angle - a.angle
	}

	function qk() {
		rd(this);
		this.x = this.y = this.arc = this.site = this.cy = null
	}

	function nc(a) {
		var b = a.P,
			c = a.N;
		if (b && c) {
			var d = b.site,
				b = a.site,
				e = c.site;
			if (d !== e) {
				var c = b.x,
					f = b.y,
					g = d.x - c,
					h = d.y - f,
					d = e.x - c,
					e = e.y - f,
					C = 2 * (g * e - h * d);
				if (!(-1E-12 <= C)) {
					var k = g * g + h * h,
						l = d * d + e * e,
						h = (e * k - h * l) / C,
						g = (g * l - d * k) / C,
						e = g + f,
						f = lh.pop() ||
						new qk;
					f.arc = a;
					f.site = b;
					f.x = h + c;
					f.y = e + Math.sqrt(h * h + g * g);
					f.cy = e;
					a.circle = f;
					a = null;
					for (b = Bc._; b;)
						if (f.y < b.y || f.y === b.y && f.x <= b.x)
							if (b.L) b = b.L;
							else {
								a = b.P;
								break
							}
					else if (b.R) b = b.R;
					else {
						a = b;
						break
					}
					Bc.insert(a, f);
					a || (Ye = f)
				}
			}
		}
	}

	function lc(a) {
		var b = a.circle;
		b && (b.P || (Ye = b.N), Bc.remove(b), lh.push(b), rd(b), a.circle = null)
	}

	function rk(a, b) {
		var c = a.b;
		if (c) return !0;
		var d = a.a,
			c = b[0][0],
			e = b[1][0],
			f = b[0][1];
		b = b[1][1];
		var g = a.l,
			h = a.r,
			C = g.x,
			g = g.y,
			k = h.x,
			h = h.y,
			l = (C + k) / 2,
			m = (g + h) / 2,
			R;
		if (h === g) {
			if (l < c || l >= e) return;
			if (C > k) {
				if (!d) d = {
					x: l,
					y: f
				};
				else if (d.y >= b) return;
				c = {
					x: l,
					y: b
				}
			} else {
				if (!d) d = {
					x: l,
					y: b
				};
				else if (d.y < f) return;
				c = {
					x: l,
					y: f
				}
			}
		} else if (R = (C - k) / (h - g), l = m - R * l, -1 > R || 1 < R)
			if (C > k) {
				if (!d) d = {
					x: (f - l) / R,
					y: f
				};
				else if (d.y >= b) return;
				c = {
					x: (b - l) / R,
					y: b
				}
			} else {
				if (!d) d = {
					x: (b - l) / R,
					y: b
				};
				else if (d.y < f) return;
				c = {
					x: (f - l) / R,
					y: f
				}
			}
		else if (g < h) {
			if (!d) d = {
				x: c,
				y: R * c + l
			};
			else if (d.x >= e) return;
			c = {
				x: e,
				y: R * e + l
			}
		} else {
			if (!d) d = {
				x: e,
				y: R * e + l
			};
			else if (d.x < c) return;
			c = {
				x: c,
				y: R * c + l
			}
		}
		a.a = d;
		a.b = c;
		return !0
	}

	function mh(a, b) {
		this.l = a;
		this.r = b;
		this.a = this.b = null
	}

	function Cc(a,
		b, c, d) {
		var e = new mh(a, b);
		oc.push(e);
		c && sd(e, a, b, c);
		d && sd(e, b, a, d);
		Vb[a.i].edges.push(new td(e, a, b));
		Vb[b.i].edges.push(new td(e, b, a));
		return e
	}

	function sk(a, b, c) {
		a = new mh(a, null);
		a.a = b;
		a.b = c;
		oc.push(a);
		return a
	}

	function sd(a, b, c, d) {
		a.a || a.b ? a.l === c ? a.b = d : a.a = d : (a.a = d, a.l = b, a.r = c)
	}

	function td(a, b, c) {
		var d = a.a,
			e = a.b;
		this.edge = a;
		this.site = b;
		this.angle = c ? Math.atan2(c.y - b.y, c.x - b.x) : a.l === b ? Math.atan2(e.x - d.x, d.y - e.y) : Math.atan2(d.x - e.x, e.y - d.y)
	}

	function Ze() {
		this._ = null
	}

	function rd(a) {
		a.U = a.C = a.L = a.R =
			a.P = a.N = null
	}

	function Dc(a, b) {
		var c = b;
		b = b.R;
		var d = c.U;
		d ? d.L === c ? d.L = b : d.R = b : a._ = b;
		b.U = d;
		c.U = b;
		c.R = b.L;
		c.R && (c.R.U = c);
		b.L = c
	}

	function Ec(a, b) {
		var c = b;
		b = b.L;
		var d = c.U;
		d ? d.L === c ? d.L = b : d.R = b : a._ = b;
		b.U = d;
		c.U = b;
		c.L = b.R;
		c.L && (c.L.U = c);
		b.R = c
	}

	function nh(a) {
		for (; a.L;) a = a.L;
		return a
	}

	function $e(a, b) {
		var c = a.sort(tk).pop(),
			d, e, f;
		oc = [];
		Vb = Array(a.length);
		mc = new Ze;
		for (Bc = new Ze;;)
			if (f = Ye, c && (!f || c.y < f.y || c.y === f.y && c.x < f.x)) {
				if (c.x !== d || c.y !== e) {
					Vb[c.i] = new jh(c);
					var g = void 0,
						h = void 0;
					e = d = void 0;
					f = c;
					for (var C =
							f.x, k = f.y, l = mc._; l;)
						if (h = ih(l, k) - C, 1E-6 < h) l = l.L;
						else {
							var m = l,
								g = k,
								n = m.N;
							n ? g = ih(n, g) : (m = m.site, g = m.y === g ? m.x : Infinity);
							g = C - g;
							if (1E-6 < g) {
								if (!l.R) {
									e = l;
									break
								}
								l = l.R
							} else {
								-1E-6 < h ? (e = l.P, d = l) : -1E-6 < g ? (e = l, d = l.N) : e = d = l;
								break
							}
						}
					h = gh(f);
					mc.insert(e, h);
					if (e || d)
						if (e === d) lc(e), d = gh(e.site), mc.insert(h, d), h.edge = d.edge = Cc(e.site, h.site), nc(e), nc(d);
						else if (d) {
						lc(e);
						lc(d);
						var C = e.site,
							l = C.x,
							g = C.y,
							m = f.x - l,
							n = f.y - g,
							k = d.site,
							R = k.x - l,
							r = k.y - g,
							u = 2 * (m * r - n * R),
							t = m * m + n * n,
							v = R * R + r * r,
							l = {
								x: (r * t - n * v) / u + l,
								y: (m * v - R * t) / u + g
							};
						sd(d.edge,
							C, k, l);
						h.edge = Cc(C, f, null, l);
						d.edge = Cc(f, k, null, l);
						nc(e);
						nc(d)
					} else h.edge = Cc(e.site, h.site);
					d = c.x;
					e = c.y
				}
				c = a.pop()
			} else if (f) {
			C = void 0;
			k = f.arc;
			f = k.circle;
			C = f.x;
			l = f.cy;
			f = {
				x: C,
				y: l
			};
			m = k.P;
			g = k.N;
			h = [k];
			Xe(k);
			for (k = m; k.circle && 1E-6 > fa(C - k.circle.x) && 1E-6 > fa(l - k.circle.cy);) m = k.P, h.unshift(k), Xe(k), k = m;
			h.unshift(k);
			lc(k);
			for (m = g; m.circle && 1E-6 > fa(C - m.circle.x) && 1E-6 > fa(l - m.circle.cy);) g = m.N, h.push(m), Xe(m), m = g;
			h.push(m);
			lc(m);
			l = h.length;
			for (C = 1; C < l; ++C) m = h[C], k = h[C - 1], sd(m.edge, k.site, m.site, f);
			k = h[0];
			m =
				h[l - 1];
			m.edge = Cc(k.site, m.site, null, f);
			nc(k);
			nc(m)
		} else break;
		if (b) {
			a = b;
			c = oc;
			d = Kg(a[0][0], a[0][1], a[1][0], a[1][1]);
			for (e = c.length; e--;)
				if (f = c[e], !rk(f, a) || !d(f) || 1E-6 > fa(f.a.x - f.b.x) && 1E-6 > fa(f.a.y - f.b.y)) f.a = f.b = null, c.splice(e, 1);
			a = void 0;
			a = b[0][0];
			c = b[1][0];
			d = b[0][1];
			b = b[1][1];
			C = Vb;
			for (k = C.length; k--;)
				if ((l = C[k]) && l.prepare())
					for (m = l.edges, n = m.length, g = 0; g < n;)
						if (R = m[g].end(), f = R.x, h = R.y, r = m[++g % n].start(), e = r.x, r = r.y, 1E-6 < fa(f - e) || 1E-6 < fa(h - r)) m.splice(g, 0, new td(sk(l.site, R, 1E-6 > fa(f - a) && 1E-6 <
							b - h ? {
								x: a,
								y: 1E-6 > fa(e - a) ? r : b
							} : 1E-6 > fa(h - b) && 1E-6 < c - f ? {
								x: 1E-6 > fa(r - b) ? e : c,
								y: b
							} : 1E-6 > fa(f - c) && 1E-6 < h - d ? {
								x: c,
								y: 1E-6 > fa(e - c) ? r : d
							} : 1E-6 > fa(h - d) && 1E-6 < f - a ? {
								x: 1E-6 > fa(r - d) ? e : a,
								y: d
							} : null), l.site, null)), ++n;
			b = void 0
		}
		b = {
			cells: Vb,
			edges: oc
		};
		mc = Bc = oc = Vb = null;
		return b
	}

	function tk(a, b) {
		return b.y - a.y || b.x - a.x
	}

	function uk(a) {
		return a.x
	}

	function vk(a) {
		return a.y
	}

	function oh() {
		return {
			leaf: !0,
			nodes: [],
			point: null,
			x: null,
			y: null
		}
	}

	function Fc(a, b, c, d, e, f) {
		if (!a(b, c, d, e, f)) {
			var g = .5 * (c + e),
				h = .5 * (d + f);
			b = b.nodes;
			b[0] && Fc(a,
				b[0], c, d, g, h);
			b[1] && Fc(a, b[1], g, d, e, h);
			b[2] && Fc(a, b[2], c, h, g, f);
			b[3] && Fc(a, b[3], g, h, e, f)
		}
	}

	function wk(a, b, c, d, e, f, g) {
		var h = Infinity,
			C;
		(function Wa(a, k, l, m, n) {
			if (!(k > f || l > g || m < d || n < e)) {
				if (R = a.point) {
					var R, r = b - a.x,
						u = c - a.y,
						r = r * r + u * u;
					r < h && (r = Math.sqrt(h = r), d = b - r, e = c - r, f = b + r, g = c + r, C = R)
				}
				R = a.nodes;
				r = .5 * (k + m);
				u = .5 * (l + n);
				a = b >= r;
				for (var t = c >= u, t = t << 1 | a, ja = t + 4; t < ja; ++t)
					if (a = R[t & 3]) switch (t & 3) {
						case 0:
							Wa(a, k, l, r, u);
							break;
						case 1:
							Wa(a, r, l, m, u);
							break;
						case 2:
							Wa(a, k, u, r, n);
							break;
						case 3:
							Wa(a, r, u, m, n)
					}
			}
		})(a, d, e, f, g);
		return C
	}

	function af(a, b) {
		a = B.rgb(a);
		b = B.rgb(b);
		var c = a.r,
			d = a.g,
			e = a.b,
			f = b.r - c,
			g = b.g - d,
			h = b.b - e;
		return function(a) {
			return "#" + mb(Math.round(c + f * a)) + mb(Math.round(d + g * a)) + mb(Math.round(e + h * a))
		}
	}

	function ph(a, b) {
		var c = {},
			d = {},
			e;
		for (e in a) e in b ? c[e] = Wb(a[e], b[e]) : d[e] = a[e];
		for (e in b) e in a || (d[e] = b[e]);
		return function(a) {
			for (e in c) d[e] = c[e](a);
			return d
		}
	}

	function zb(a, b) {
		a = +a;
		b = +b;
		return function(c) {
			return a * (1 - c) + b * c
		}
	}

	function qh(a, b) {
		var c = bf.lastIndex = cf.lastIndex = 0,
			d, e, f, g = -1,
			h = [],
			C = [];
		a += "";
		for (b +=
			"";
			(d = bf.exec(a)) && (e = cf.exec(b));)(f = e.index) > c && (f = b.slice(c, f), h[g] ? h[g] += f : h[++g] = f), (d = d[0]) === (e = e[0]) ? h[g] ? h[g] += e : h[++g] = e : (h[++g] = null, C.push({
			i: g,
			x: zb(d, e)
		})), c = cf.lastIndex;
		c < b.length && (f = b.slice(c), h[g] ? h[g] += f : h[++g] = f);
		return 2 > h.length ? C[0] ? (b = C[0].x, function(a) {
			return b(a) + ""
		}) : function() {
			return b
		} : (b = C.length, function(a) {
			for (var c = 0, d; c < b; ++c) h[(d = C[c]).i] = d.x(a);
			return h.join("")
		})
	}

	function Wb(a, b) {
		for (var c = B.interpolators.length, d; 0 <= --c && !(d = B.interpolators[c](a, b)););
		return d
	}

	function ud(a, b) {
		var c = [],
			d = [],
			e = a.length,
			f = b.length,
			g = Math.min(a.length, b.length),
			h;
		for (h = 0; h < g; ++h) c.push(Wb(a[h], b[h]));
		for (; h < e; ++h) d[h] = a[h];
		for (; h < f; ++h) d[h] = b[h];
		return function(a) {
			for (h = 0; h < g; ++h) d[h] = c[h](a);
			return d
		}
	}

	function xk(a) {
		return function(b) {
			return 0 >= b ? 0 : 1 <= b ? 1 : a(b)
		}
	}

	function rh(a) {
		return function(b) {
			return 1 - a(1 - b)
		}
	}

	function sh(a) {
		return function(b) {
			return .5 * (.5 > b ? a(2 * b) : 2 - a(2 - 2 * b))
		}
	}

	function yk(a) {
		return a * a
	}

	function zk(a) {
		return a * a * a
	}

	function Ak(a) {
		if (0 >= a) return 0;
		if (1 <= a) return 1;
		var b = a * a,
			c = b * a;
		return 4 * (.5 > a ? c : 3 * (a - b) + c - .75)
	}

	function Bk(a) {
		return function(b) {
			return Math.pow(b, a)
		}
	}

	function Ck(a) {
		return 1 - Math.cos(a * Da)
	}

	function Dk(a) {
		return Math.pow(2, 10 * (a - 1))
	}

	function Ek(a) {
		return 1 - Math.sqrt(1 - a * a)
	}

	function Fk(a, b) {
		var c;
		2 > arguments.length && (b = .45);
		arguments.length ? c = b / bb * Math.asin(1 / a) : (a = 1, c = b / 4);
		return function(d) {
			return 1 + a * Math.pow(2, -10 * d) * Math.sin((d - c) * bb / b)
		}
	}

	function Gk(a) {
		a || (a = 1.70158);
		return function(b) {
			return b * b * ((a + 1) * b - a)
		}
	}

	function Hk(a) {
		return a < 1 / 2.75 ?
			7.5625 * a * a : a < 2 / 2.75 ? 7.5625 * (a -= 1.5 / 2.75) * a + .75 : a < 2.5 / 2.75 ? 7.5625 * (a -= 2.25 / 2.75) * a + .9375 : 7.5625 * (a -= 2.625 / 2.75) * a + .984375
	}

	function Ik(a, b) {
		a = B.hcl(a);
		b = B.hcl(b);
		var c = a.h,
			d = a.c,
			e = a.l,
			f = b.h - c,
			g = b.c - d,
			h = b.l - e;
		isNaN(g) && (g = 0, d = isNaN(d) ? b.c : d);
		isNaN(f) ? (f = 0, c = isNaN(c) ? b.h : c) : 180 < f ? f -= 360 : -180 > f && (f += 360);
		return function(a) {
			return ub(c + f * a, d + g * a, e + h * a) + ""
		}
	}

	function Jk(a, b) {
		a = B.hsl(a);
		b = B.hsl(b);
		var c = a.h,
			d = a.s,
			e = a.l,
			f = b.h - c,
			g = b.s - d,
			h = b.l - e;
		isNaN(g) && (g = 0, d = isNaN(d) ? b.s : d);
		isNaN(f) ? (f = 0, c = isNaN(c) ? b.h : c) :
			180 < f ? f -= 360 : -180 > f && (f += 360);
		return function(a) {
			return La(c + f * a, d + g * a, e + h * a) + ""
		}
	}

	function Kk(a, b) {
		a = B.lab(a);
		b = B.lab(b);
		var c = a.l,
			d = a.a,
			e = a.b,
			f = b.l - c,
			g = b.a - d,
			h = b.b - e;
		return function(a) {
			return Sa(c + f * a, d + g * a, e + h * a) + ""
		}
	}

	function th(a, b) {
		b -= a;
		return function(c) {
			return Math.round(a + b * c)
		}
	}

	function uh(a) {
		var b = [a.a, a.b],
			c = [a.c, a.d],
			d = vh(b),
			e = b[0] * c[0] + b[1] * c[1],
			f;
		f = c;
		var g = b,
			h = -e;
		f[0] += h * g[0];
		f[1] += h * g[1];
		f = vh(f) || 0;
		b[0] * c[1] < c[0] * b[1] && (b[0] *= -1, b[1] *= -1, d *= -1, e *= -1);
		this.rotate = (d ? Math.atan2(b[1], b[0]) :
			Math.atan2(-c[0], c[1])) * ya;
		this.translate = [a.e, a.f];
		this.scale = [d, f];
		this.skew = f ? Math.atan2(e, f) * ya : 0
	}

	function vh(a) {
		var b = Math.sqrt(a[0] * a[0] + a[1] * a[1]);
		b && (a[0] /= b, a[1] /= b);
		return b
	}

	function pc(a) {
		return a.length ? a.pop() + "," : ""
	}

	function Lk(a, b, c, d) {
		a[0] !== b[0] || a[1] !== b[1] ? (c = c.push("translate(", null, ",", null, ")"), d.push({
			i: c - 4,
			x: zb(a[0], b[0])
		}, {
			i: c - 2,
			x: zb(a[1], b[1])
		})) : (b[0] || b[1]) && c.push("translate(" + b + ")")
	}

	function Mk(a, b, c, d) {
		a !== b ? (180 < a - b ? b += 360 : 180 < b - a && (a += 360), d.push({
			i: c.push(pc(c) + "rotate(",
				null, ")") - 2,
			x: zb(a, b)
		})) : b && c.push(pc(c) + "rotate(" + b + ")")
	}

	function Nk(a, b, c, d) {
		a !== b ? d.push({
			i: c.push(pc(c) + "skewX(", null, ")") - 2,
			x: zb(a, b)
		}) : b && c.push(pc(c) + "skewX(" + b + ")")
	}

	function Ok(a, b, c, d) {
		a[0] !== b[0] || a[1] !== b[1] ? (c = c.push(pc(c) + "scale(", null, ",", null, ")"), d.push({
			i: c - 4,
			x: zb(a[0], b[0])
		}, {
			i: c - 2,
			x: zb(a[1], b[1])
		})) : 1 === b[0] && 1 === b[1] || c.push(pc(c) + "scale(" + b + ")")
	}

	function wh(a, b) {
		var c = [],
			d = [];
		a = B.transform(a);
		b = B.transform(b);
		Lk(a.translate, b.translate, c, d);
		Mk(a.rotate, b.rotate, c, d);
		Nk(a.skew,
			b.skew, c, d);
		Ok(a.scale, b.scale, c, d);
		a = b = null;
		return function(a) {
			for (var b = -1, e = d.length, f; ++b < e;) c[(f = d[b]).i] = f.x(a);
			return c.join("")
		}
	}

	function Pk(a, b) {
		b = (b -= a = +a) || 1 / b;
		return function(c) {
			return (c - a) / b
		}
	}

	function Qk(a, b) {
		b = (b -= a = +a) || 1 / b;
		return function(c) {
			return Math.max(0, Math.min(1, (c - a) / b))
		}
	}

	function Rk(a) {
		var b = a.source;
		a = a.target;
		var c;
		var d = a;
		if (b === d) c = b;
		else {
			c = xh(b);
			for (var d = xh(d), e = c.pop(), f = d.pop(), g = null; e === f;) g = e, e = c.pop(), f = d.pop();
			c = g
		}
		for (d = [b]; b !== c;) b = b.parent, d.push(b);
		for (b =
			d.length; a !== c;) d.splice(b, 0, a), a = a.parent;
		return d
	}

	function xh(a) {
		for (var b = [], c = a.parent; null != c;) b.push(a), a = c, c = c.parent;
		b.push(a);
		return b
	}

	function Sk(a) {
		a.fixed |= 2
	}

	function Tk(a) {
		a.fixed &= -7
	}

	function Uk(a) {
		a.fixed |= 4;
		a.px = a.x;
		a.py = a.y
	}

	function Vk(a) {
		a.fixed &= -5
	}

	function yh(a, b, c) {
		var d = 0,
			e = 0;
		a.charge = 0;
		if (!a.leaf)
			for (var f = a.nodes, g = f.length, h = -1, k; ++h < g;) k = f[h], null != k && (yh(k, b, c), a.charge += k.charge, d += k.charge * k.cx, e += k.charge * k.cy);
		a.point && (a.leaf || (a.point.x += Math.random() - .5, a.point.y +=
			Math.random() - .5), b *= c[a.point.index], a.charge += a.pointCharge = b, d += b * a.point.x, e += b * a.point.y);
		a.cx = d / a.charge;
		a.cy = e / a.charge
	}

	function Gc(a, b) {
		B.rebind(a, b, "sort", "children", "value");
		a.nodes = a;
		a.links = Wk;
		return a
	}

	function Hc(a, b) {
		for (var c = [a]; null != (a = c.pop());)
			if (b(a), (e = a.children) && (d = e.length))
				for (var d, e; 0 <= --d;) c.push(e[d])
	}

	function qb(a, b) {
		for (var c = [a], d = []; null != (a = c.pop());)
			if (d.push(a), (f = a.children) && (e = f.length)) {
				a = -1;
				for (var e, f; ++a < e;) c.push(f[a])
			}
		for (; null != (a = d.pop());) b(a)
	}

	function Xk(a) {
		return a.children
	}

	function Yk(a) {
		return a.value
	}

	function Zk(a, b) {
		return b.value - a.value
	}

	function Wk(a) {
		return B.merge(a.map(function(a) {
			return (a.children || []).map(function(b) {
				return {
					source: a,
					target: b
				}
			})
		}))
	}

	function $k(a) {
		return a.x
	}

	function al(a) {
		return a.y
	}

	function bl(a, b, c) {
		a.y0 = b;
		a.y = c
	}

	function df(a) {
		return B.range(a.length)
	}

	function ef(a) {
		var b = -1;
		a = a[0].length;
		for (var c = []; ++b < a;) c[b] = 0;
		return c
	}

	function cl(a) {
		for (var b = 1, c = 0, d = a[0][1], e, f = a.length; b < f; ++b)(e = a[b][1]) > d && (c = b, d = e);
		return c
	}

	function dl(a) {
		return a.reduce(el,
			0)
	}

	function el(a, b) {
		return a + b[1]
	}

	function fl(a, b) {
		return zh(a, Math.ceil(Math.log(b.length) / Math.LN2 + 1))
	}

	function zh(a, b) {
		var c = -1,
			d = +a[0];
		a = (a[1] - d) / b;
		for (var e = []; ++c <= b;) e[c] = a * c + d;
		return e
	}

	function gl(a) {
		return [B.min(a), B.max(a)]
	}

	function hl(a, b) {
		return a.value - b.value
	}

	function ff(a, b) {
		var c = a._pack_next;
		a._pack_next = b;
		b._pack_prev = a;
		b._pack_next = c;
		c._pack_prev = b
	}

	function Ah(a, b) {
		a._pack_next = b;
		b._pack_prev = a
	}

	function Bh(a, b) {
		var c = b.x - a.x,
			d = b.y - a.y;
		a = a.r + b.r;
		return .999 * a * a > c * c + d * d
	}

	function Ch(a) {
		function b(a) {
			d =
				Math.min(a.x - a.r, d);
			e = Math.max(a.x + a.r, e);
			f = Math.min(a.y - a.r, f);
			g = Math.max(a.y + a.r, g)
		}
		if ((c = a.children) && (r = c.length)) {
			var c, d = Infinity,
				e = -Infinity,
				f = Infinity,
				g = -Infinity,
				h, k, C, l, m, n, r;
			c.forEach(il);
			h = c[0];
			h.x = -h.r;
			h.y = 0;
			b(h);
			if (1 < r && (k = c[1], k.x = k.r, k.y = 0, b(k), 2 < r))
				for (C = c[2], Dh(h, k, C), b(C), ff(h, C), h._pack_prev = C, ff(C, k), k = h._pack_next, l = 3; l < r; l++) {
					Dh(h, k, C = c[l]);
					var u = 0,
						t = 1,
						v = 1;
					for (m = k._pack_next; m !== k; m = m._pack_next, t++)
						if (Bh(m, C)) {
							u = 1;
							break
						}
					if (1 == u)
						for (n = h._pack_prev; n !== m._pack_prev && !Bh(n, C); n =
							n._pack_prev, v++);
					u ? (t < v || t == v && k.r < h.r ? Ah(h, k = m) : Ah(h = n, k), l--) : (ff(h, C), k = C, b(C))
				}
			h = (d + e) / 2;
			k = (f + g) / 2;
			for (l = m = 0; l < r; l++) C = c[l], C.x -= h, C.y -= k, m = Math.max(m, C.r + Math.sqrt(C.x * C.x + C.y * C.y));
			a.r = m;
			c.forEach(jl)
		}
	}

	function il(a) {
		a._pack_next = a._pack_prev = a
	}

	function jl(a) {
		delete a._pack_next;
		delete a._pack_prev
	}

	function Eh(a, b, c, d) {
		var e = a.children;
		a.x = b += d * a.x;
		a.y = c += d * a.y;
		a.r *= d;
		if (e) {
			a = -1;
			for (var f = e.length; ++a < f;) Eh(e[a], b, c, d)
		}
	}

	function Dh(a, b, c) {
		var d = a.r + c.r,
			e = b.x - a.x,
			f = b.y - a.y;
		if (d && (e || f)) {
			var g =
				b.r + c.r,
				h = e * e + f * f,
				g = g * g,
				d = d * d;
			b = .5 + (d - g) / (2 * h);
			g = Math.sqrt(Math.max(0, 2 * g * (d + h) - (d -= h) * d - g * g)) / (2 * h);
			c.x = a.x + b * e + g * f;
			c.y = a.y + b * f - g * e
		} else c.x = a.x + d, c.y = a.y
	}

	function Fh(a, b) {
		return a.parent == b.parent ? 1 : 2
	}

	function gf(a) {
		var b = a.children;
		return b.length ? b[0] : a.t
	}

	function hf(a) {
		var b = a.children,
			c;
		return (c = b.length) ? b[c - 1] : a.t
	}

	function kl(a) {
		return 1 + B.max(a, function(a) {
			return a.y
		})
	}

	function ll(a) {
		return a.reduce(function(a, b) {
			return a + b.x
		}, 0) / a.length
	}

	function Gh(a) {
		var b = a.children;
		return b && b.length ?
			Gh(b[0]) : a
	}

	function Hh(a) {
		var b = a.children,
			c;
		return b && (c = b.length) ? Hh(b[c - 1]) : a
	}

	function jf(a) {
		return {
			x: a.x,
			y: a.y,
			dx: a.dx,
			dy: a.dy
		}
	}

	function Ih(a, b) {
		var c = a.x + b[3],
			d = a.y + b[0],
			e = a.dx - b[1] - b[3];
		a = a.dy - b[0] - b[2];
		0 > e && (c += e / 2, e = 0);
		0 > a && (d += a / 2, a = 0);
		return {
			x: c,
			y: d,
			dx: e,
			dy: a
		}
	}

	function qc(a) {
		var b = a[0];
		a = a[a.length - 1];
		return b < a ? [b, a] : [a, b]
	}

	function vd(a) {
		return a.rangeExtent ? a.rangeExtent() : qc(a.range())
	}

	function ml(a, b, c, d) {
		var e = c(a[0], a[1]),
			f = d(b[0], b[1]);
		return function(a) {
			return f(e(a))
		}
	}

	function wd(a,
		b) {
		var c = 0,
			d = a.length - 1,
			e = a[c],
			f = a[d],
			g;
		f < e && (g = c, c = d, d = g, g = e, e = f, f = g);
		a[c] = b.floor(e);
		a[d] = b.ceil(f);
		return a
	}

	function Jh(a) {
		return a ? {
			floor: function(b) {
				return Math.floor(b / a) * a
			},
			ceil: function(b) {
				return Math.ceil(b / a) * a
			}
		} : nl
	}

	function ol(a, b, c, d) {
		var e = [],
			f = [],
			g = 0,
			h = Math.min(a.length, b.length) - 1;
		a[h] < a[0] && (a = a.slice().reverse(), b = b.slice().reverse());
		for (; ++g <= h;) e.push(c(a[g - 1], a[g])), f.push(d(b[g - 1], b[g]));
		return function(b) {
			var c = B.bisect(a, b, 1, h) - 1;
			return f[c](e[c](b))
		}
	}

	function Kh(a, b, c, d) {
		function e() {
			var e =
				2 < Math.min(a.length, b.length) ? ol : ml,
				k = d ? Qk : Pk;
			g = e(a, b, k, c);
			h = e(b, a, k, Wb);
			return f
		}

		function f(a) {
			return g(a)
		}
		var g, h;
		f.invert = function(a) {
			return h(a)
		};
		f.domain = function(b) {
			if (!arguments.length) return a;
			a = b.map(Number);
			return e()
		};
		f.range = function(a) {
			if (!arguments.length) return b;
			b = a;
			return e()
		};
		f.rangeRound = function(a) {
			return f.range(a).interpolate(th)
		};
		f.clamp = function(a) {
			if (!arguments.length) return d;
			d = a;
			return e()
		};
		f.interpolate = function(a) {
			if (!arguments.length) return c;
			c = a;
			return e()
		};
		f.ticks =
			function(b) {
				return B.range.apply(B, Hb(a, b))
			};
		f.tickFormat = function(b, c) {
			return kf(a, b, c)
		};
		f.nice = function(b) {
			Lh(a, b);
			return e()
		};
		f.copy = function() {
			return Kh(a, b, c, d)
		};
		return e()
	}

	function lf(a, b) {
		return B.rebind(a, b, "range", "rangeRound", "interpolate", "clamp")
	}

	function Lh(a, b) {
		wd(a, Jh(Hb(a, b)[2]));
		wd(a, Jh(Hb(a, b)[2]));
		return a
	}

	function Hb(a, b) {
		null == b && (b = 10);
		a = qc(a);
		var c = a[1] - a[0],
			d = Math.pow(10, Math.floor(Math.log(c / b) / Math.LN10));
		b = b / c * d;
		.15 >= b ? d *= 10 : .35 >= b ? d *= 5 : .75 >= b && (d *= 2);
		a[0] = Math.ceil(a[0] /
			d) * d;
		a[1] = Math.floor(a[1] / d) * d + .5 * d;
		a[2] = d;
		return a
	}

	function kf(a, b, c) {
		a = Hb(a, b);
		if (c) {
			b = vg.exec(c);
			b.shift();
			if ("s" === b[8]) {
				var d = B.formatPrefix(Math.max(fa(a[0]), fa(a[1])));
				b[7] || (b[7] = "." + xd(d.scale(a[2])));
				b[8] = "f";
				c = B.format(b.join(""));
				return function(a) {
					return c(d.scale(a)) + d.symbol
				}
			}
			b[7] || (b[7] = "." + pl(b[8], a));
			c = b.join("")
		} else c = ",." + xd(a[2]) + "f";
		return B.format(c)
	}

	function xd(a) {
		return -Math.floor(Math.log(a) / Math.LN10 + .01)
	}

	function pl(a, b) {
		var c = xd(b[2]);
		return a in ql ? Math.abs(c - xd(Math.max(fa(b[0]),
			fa(b[1])))) + +("e" !== a) : c - 2 * ("%" === a)
	}

	function Mh(a, b, c, d) {
		function e(a) {
			return (c ? Math.log(0 > a ? 0 : a) : -Math.log(0 < a ? 0 : -a)) / Math.log(b)
		}

		function f(a) {
			return c ? Math.pow(b, a) : -Math.pow(b, -a)
		}

		function g(b) {
			return a(e(b))
		}
		g.invert = function(b) {
			return f(a.invert(b))
		};
		g.domain = function(b) {
			if (!arguments.length) return d;
			c = 0 <= b[0];
			a.domain((d = b.map(Number)).map(e));
			return g
		};
		g.base = function(c) {
			if (!arguments.length) return b;
			b = +c;
			a.domain(d.map(e));
			return g
		};
		g.nice = function() {
			var b = wd(d.map(e), c ? Math : rl);
			a.domain(b);
			d = b.map(f);
			return g
		};
		g.ticks = function() {
			var a = qc(d),
				g = [],
				h = a[0],
				a = a[1],
				k = Math.floor(e(h)),
				l = Math.ceil(e(a)),
				C = b % 1 ? 2 : b;
			if (isFinite(l - k)) {
				if (c) {
					for (; k < l; k++)
						for (var m = 1; m < C; m++) g.push(f(k) * m);
					g.push(f(k))
				} else
					for (g.push(f(k)); k++ < l;)
						for (m = C - 1; 0 < m; m--) g.push(f(k) * m);
				for (k = 0; g[k] < h; k++);
				for (l = g.length; g[l - 1] > a; l--);
				g = g.slice(k, l)
			}
			return g
		};
		g.tickFormat = function(a, c) {
			if (!arguments.length) return Nh;
			2 > arguments.length ? c = Nh : "function" !== typeof c && (c = B.format(c));
			var d = Math.max(1, b * a / g.ticks().length);
			return function(a) {
				var g =
					a / f(Math.round(e(a)));
				g * b < b - .5 && (g *= b);
				return g <= d ? c(a) : ""
			}
		};
		g.copy = function() {
			return Mh(a.copy(), b, c, d)
		};
		return lf(g, a)
	}

	function Oh(a, b, c) {
		function d(b) {
			return a(e(b))
		}
		var e = yd(b),
			f = yd(1 / b);
		d.invert = function(b) {
			return f(a.invert(b))
		};
		d.domain = function(b) {
			if (!arguments.length) return c;
			a.domain((c = b.map(Number)).map(e));
			return d
		};
		d.ticks = function(a) {
			return B.range.apply(B, Hb(c, a))
		};
		d.tickFormat = function(a, b) {
			return kf(c, a, b)
		};
		d.nice = function(a) {
			return d.domain(Lh(c, a))
		};
		d.exponent = function(g) {
			if (!arguments.length) return b;
			e = yd(b = g);
			f = yd(1 / b);
			a.domain(c.map(e));
			return d
		};
		d.copy = function() {
			return Oh(a.copy(), b, c)
		};
		return lf(d, a)
	}

	function yd(a) {
		return function(b) {
			return 0 > b ? -Math.pow(-b, a) : Math.pow(b, a)
		}
	}

	function Ph(a, b) {
		function c(c) {
			return f[((e.get(c) || ("range" === b.t ? e.set(c, a.push(c)) : NaN)) - 1) % f.length]
		}

		function d(b, c) {
			return B.range(a.length).map(function(a) {
				return b + c * a
			})
		}
		var e, f, g;
		c.domain = function(d) {
			if (!arguments.length) return a;
			a = [];
			e = new h;
			for (var f = -1, g = d.length, k; ++f < g;) e.has(k = d[f]) || e.set(k, a.push(k));
			return c[b.t].apply(c, b.a)
		};
		c.range = function(a) {
			if (!arguments.length) return f;
			f = a;
			g = 0;
			b = {
				t: "range",
				a: arguments
			};
			return c
		};
		c.rangePoints = function(e, h) {
			2 > arguments.length && (h = 0);
			var k = e[0],
				l = e[1],
				l = 2 > a.length ? (k = (k + l) / 2, 0) : (l - k) / (a.length - 1 + h);
			f = d(k + l * h / 2, l);
			g = 0;
			b = {
				t: "rangePoints",
				a: arguments
			};
			return c
		};
		c.rangeRoundPoints = function(e, h) {
			2 > arguments.length && (h = 0);
			var k = e[0],
				l = e[1],
				C = 2 > a.length ? (k = l = Math.round((k + l) / 2), 0) : (l - k) / (a.length - 1 + h) | 0;
			f = d(k + Math.round(C * h / 2 + (l - k - (a.length - 1 + h) * C) / 2), C);
			g = 0;
			b = {
				t: "rangeRoundPoints",
				a: arguments
			};
			return c
		};
		c.rangeBands = function(e, h, k) {
			2 > arguments.length && (h = 0);
			3 > arguments.length && (k = h);
			var l = e[1] < e[0],
				C = e[l - 0],
				m = e[1 - l],
				m = (m - C) / (a.length - h + 2 * k);
			f = d(C + m * k, m);
			l && f.reverse();
			g = m * (1 - h);
			b = {
				t: "rangeBands",
				a: arguments
			};
			return c
		};
		c.rangeRoundBands = function(e, h, k) {
			2 > arguments.length && (h = 0);
			3 > arguments.length && (k = h);
			var l = e[1] < e[0],
				C = e[l - 0],
				m = e[1 - l],
				n = Math.floor((m - C) / (a.length - h + 2 * k));
			f = d(C + Math.round((m - C - (a.length - h) * n) / 2), n);
			l && f.reverse();
			g = Math.round(n * (1 - h));
			b = {
				t: "rangeRoundBands",
				a: arguments
			};
			return c
		};
		c.rangeBand = function() {
			return g
		};
		c.rangeExtent = function() {
			return qc(b.a[0])
		};
		c.copy = function() {
			return Ph(a, b)
		};
		return c.domain(a)
	}

	function Qh(a, e) {
		function f() {
			var b = 0,
				c = e.length;
			for (h = []; ++b < c;) h[b - 1] = B.quantile(a, b / c);
			return g
		}

		function g(a) {
			if (!isNaN(a = +a)) return e[B.bisect(h, a)]
		}
		var h;
		g.domain = function(e) {
			if (!arguments.length) return a;
			a = e.map(c).filter(d).sort(b);
			return f()
		};
		g.range = function(a) {
			if (!arguments.length) return e;
			e = a;
			return f()
		};
		g.quantiles =
			function() {
				return h
			};
		g.invertExtent = function(b) {
			b = e.indexOf(b);
			return 0 > b ? [NaN, NaN] : [0 < b ? h[b - 1] : a[0], b < h.length ? h[b] : a[a.length - 1]]
		};
		g.copy = function() {
			return Qh(a, e)
		};
		return f()
	}

	function Rh(a, b, c) {
		function d(b) {
			return c[Math.max(0, Math.min(g, Math.floor(f * (b - a))))]
		}

		function e() {
			f = c.length / (b - a);
			g = c.length - 1;
			return d
		}
		var f, g;
		d.domain = function(c) {
			if (!arguments.length) return [a, b];
			a = +c[0];
			b = +c[c.length - 1];
			return e()
		};
		d.range = function(a) {
			if (!arguments.length) return c;
			c = a;
			return e()
		};
		d.invertExtent = function(b) {
			b =
				c.indexOf(b);
			b = 0 > b ? NaN : b / f + a;
			return [b, b + 1 / f]
		};
		d.copy = function() {
			return Rh(a, b, c)
		};
		return e()
	}

	function Sh(a, b) {
		function c(c) {
			if (c <= c) return b[B.bisect(a, c)]
		}
		c.domain = function(b) {
			if (!arguments.length) return a;
			a = b;
			return c
		};
		c.range = function(a) {
			if (!arguments.length) return b;
			b = a;
			return c
		};
		c.invertExtent = function(c) {
			c = b.indexOf(c);
			return [a[c - 1], a[c]]
		};
		c.copy = function() {
			return Sh(a, b)
		};
		return c
	}

	function Th(a) {
		function b(a) {
			return +a
		}
		b.invert = b;
		b.domain = b.range = function(c) {
			if (!arguments.length) return a;
			a =
				c.map(b);
			return b
		};
		b.ticks = function(b) {
			return B.range.apply(B, Hb(a, b))
		};
		b.tickFormat = function(b, c) {
			return kf(a, b, c)
		};
		b.copy = function() {
			return Th(a)
		};
		return b
	}

	function sl() {
		return 0
	}

	function tl(a) {
		return a.innerRadius
	}

	function ul(a) {
		return a.outerRadius
	}

	function Uh(a) {
		return a.startAngle
	}

	function Vh(a) {
		return a.endAngle
	}

	function vl(a) {
		return a && a.padAngle
	}

	function zd(a, b, c, d) {
		return 0 < (a - c) * b - (b - d) * a ? 0 : 1
	}

	function Ad(a, b, c, d, e) {
		var f = a[0] - b[0],
			g = a[1] - b[1];
		e = (e ? d : -d) / Math.sqrt(f * f + g * g);
		var g = e * g,
			f = -e *
			f,
			h = a[0] + g,
			k = a[1] + f,
			l = b[0] + g,
			C = b[1] + f;
		a = (h + l) / 2;
		b = (k + C) / 2;
		e = l - h;
		var m = C - k,
			n = e * e + m * m;
		d = c - d;
		var C = h * C - l * k,
			r = (0 > m ? -1 : 1) * Math.sqrt(Math.max(0, d * d * n - C * C)),
			h = (C * m - e * r) / n,
			k = (-C * e - m * r) / n,
			l = (C * m + e * r) / n;
		e = (-C * e + m * r) / n;
		m = h - a;
		n = k - b;
		a = l - a;
		b = e - b;
		m * m + n * n > a * a + b * b && (h = l, k = e);
		return [
			[h - g, k - f],
			[h * c / d, k * c / d]
		]
	}

	function Wh(a) {
		function b(b) {
			function g() {
				k.push("M", f(a(l), h))
			}
			for (var k = [], l = [], C = -1, m = b.length, n, r = pa(c), u = pa(d); ++C < m;) e.call(this, n = b[C], C) ? l.push([+r.call(this, n, C), +u.call(this, n, C)]) : l.length && (g(), l = []);
			l.length && g();
			return k.length ? k.join("") : null
		}
		var c = kc,
			d = Ac,
			e = xc,
			f = kb,
			g = f.key,
			h = .7;
		b.x = function(a) {
			if (!arguments.length) return c;
			c = a;
			return b
		};
		b.y = function(a) {
			if (!arguments.length) return d;
			d = a;
			return b
		};
		b.defined = function(a) {
			if (!arguments.length) return e;
			e = a;
			return b
		};
		b.interpolate = function(a) {
			if (!arguments.length) return g;
			g = "function" === typeof a ? f = a : (f = mf.get(a) || kb).key;
			return b
		};
		b.tension = function(a) {
			if (!arguments.length) return h;
			h = a;
			return b
		};
		return b
	}

	function kb(a) {
		return 1 < a.length ? a.join("L") :
			a + "Z"
	}

	function Xh(a) {
		return a.join("L") + "Z"
	}

	function wl(a) {
		for (var b = 0, c = a.length, d = a[0], e = [d[0], ",", d[1]]; ++b < c;) e.push("H", (d[0] + (d = a[b])[0]) / 2, "V", d[1]);
		1 < c && e.push("H", d[0]);
		return e.join("")
	}

	function nf(a) {
		for (var b = 0, c = a.length, d = a[0], e = [d[0], ",", d[1]]; ++b < c;) e.push("V", (d = a[b])[1], "H", d[0]);
		return e.join("")
	}

	function of(a) {
		for (var b = 0, c = a.length, d = a[0], e = [d[0], ",", d[1]]; ++b < c;) e.push("H", (d = a[b])[0], "V", d[1]);
		return e.join("")
	}

	function xl(a, b) {
		return 4 > a.length ? kb(a) : a[1] + Bd(a.slice(1, -1),
			pf(a, b))
	}

	function yl(a, b) {
		return 3 > a.length ? Xh(a) : a[0] + Bd((a.push(a[0]), a), pf([a[a.length - 2]].concat(a, [a[1]]), b))
	}

	function zl(a, b) {
		return 3 > a.length ? kb(a) : a[0] + Bd(a, pf(a, b))
	}

	function Bd(a, b) {
		if (1 > b.length || a.length != b.length && a.length != b.length + 2) return kb(a);
		var c = a.length != b.length,
			d = "",
			e = a[0],
			f = a[1],
			g = b[0],
			h = g,
			k = 1;
		c && (d += "Q" + (f[0] - 2 * g[0] / 3) + "," + (f[1] - 2 * g[1] / 3) + "," + f[0] + "," + f[1], e = a[1], k = 2);
		if (1 < b.length)
			for (h = b[1], f = a[k], k++, d += "C" + (e[0] + g[0]) + "," + (e[1] + g[1]) + "," + (f[0] - h[0]) + "," + (f[1] - h[1]) + "," +
				f[0] + "," + f[1], e = 2; e < b.length; e++, k++) f = a[k], h = b[e], d += "S" + (f[0] - h[0]) + "," + (f[1] - h[1]) + "," + f[0] + "," + f[1];
		c && (a = a[k], d += "Q" + (f[0] + 2 * h[0] / 3) + "," + (f[1] + 2 * h[1] / 3) + "," + a[0] + "," + a[1]);
		return d
	}

	function pf(a, b) {
		var c = [];
		b = (1 - b) / 2;
		for (var d, e = a[0], f = a[1], g = 1, h = a.length; ++g < h;) d = e, e = f, f = a[g], c.push([b * (f[0] - d[0]), b * (f[1] - d[1])]);
		return c
	}

	function Yh(a) {
		if (3 > a.length) return kb(a);
		var b = 1,
			c = a.length,
			d = a[0],
			e = d[0],
			f = d[1],
			g = [e, e, e, (d = a[1])[0]],
			h = [f, f, f, d[1]],
			e = [e, ",", f, "L", eb(Ib, g), ",", eb(Ib, h)];
		for (a.push(a[c -
				1]); ++b <= c;) d = a[b], g.shift(), g.push(d[0]), h.shift(), h.push(d[1]), qf(e, g, h);
		a.pop();
		e.push("L", d);
		return e.join("")
	}

	function Al(a) {
		if (4 > a.length) return kb(a);
		for (var b = [], c = -1, d = a.length, e, f = [0], g = [0]; 3 > ++c;) e = a[c], f.push(e[0]), g.push(e[1]);
		b.push(eb(Ib, f) + "," + eb(Ib, g));
		for (--c; ++c < d;) e = a[c], f.shift(), f.push(e[0]), g.shift(), g.push(e[1]), qf(b, f, g);
		return b.join("")
	}

	function Bl(a) {
		for (var b, c = -1, d = a.length, e = d + 4, f, g = [], h = []; 4 > ++c;) f = a[c % d], g.push(f[0]), h.push(f[1]);
		b = [eb(Ib, g), ",", eb(Ib, h)];
		for (--c; ++c <
			e;) f = a[c % d], g.shift(), g.push(f[0]), h.shift(), h.push(f[1]), qf(b, g, h);
		return b.join("")
	}

	function Cl(a, b) {
		var c = a.length - 1;
		if (c)
			for (var d = a[0][0], e = a[0][1], f = a[c][0] - d, g = a[c][1] - e, h = -1, k, l; ++h <= c;) k = a[h], l = h / c, k[0] = b * k[0] + (1 - b) * (d + l * f), k[1] = b * k[1] + (1 - b) * (e + l * g);
		return Yh(a)
	}

	function eb(a, b) {
		return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
	}

	function qf(a, b, c) {
		a.push("C", eb(Zh, b), ",", eb(Zh, c), ",", eb($h, b), ",", eb($h, c), ",", eb(Ib, b), ",", eb(Ib, c))
	}

	function rf(a, b) {
		return (b[1] - a[1]) / (b[0] - a[0])
	}

	function Dl(a) {
		if (3 >
			a.length) a = kb(a);
		else {
			var b = a[0],
				c;
			c = a;
			var d = [],
				e, f, g, h, k;
			e = c;
			f = 0;
			g = e.length - 1;
			h = [];
			k = e[0];
			for (var l = e[1], C = h[0] = rf(k, l); ++f < g;) h[f] = (C + (C = rf(k = l, l = e[f + 1]))) / 2;
			h[f] = C;
			k = h;
			l = -1;
			for (C = c.length - 1; ++l < C;) e = rf(c[l], c[l + 1]), 1E-6 > fa(e) ? k[l] = k[l + 1] = 0 : (f = k[l] / e, g = k[l + 1] / e, h = f * f + g * g, 9 < h && (h = 3 * e / Math.sqrt(h), k[l] = h * f, k[l + 1] = h * g));
			for (l = -1; ++l <= C;) h = (c[Math.min(C, l + 1)][0] - c[Math.max(0, l - 1)][0]) / (6 * (1 + k[l] * k[l])), d.push([h || 0, k[l] * h || 0]);
			c = d;
			a = b + Bd(a, c)
		}
		return a
	}

	function ai(a) {
		for (var b, c = -1, d = a.length, e, f; ++c <
			d;) b = a[c], e = b[0], f = b[1] - Da, b[0] = e * Math.cos(f), b[1] = e * Math.sin(f);
		return a
	}

	function bi(a) {
		function b(b) {
			function k() {
				n.push("M", h(a(u), m), C, l(a(r.reverse()), m), "Z")
			}
			for (var n = [], r = [], u = [], t = -1, R = b.length, v, w = pa(c), x = pa(e), ja = c === d ? function() {
					return Aa
				} : pa(d), y = e === f ? function() {
					return z
				} : pa(f), Aa, z; ++t < R;) g.call(this, v = b[t], t) ? (r.push([Aa = +w.call(this, v, t), z = +x.call(this, v, t)]), u.push([+ja.call(this, v, t), +y.call(this, v, t)])) : r.length && (k(), r = [], u = []);
			r.length && k();
			return n.length ? n.join("") : null
		}
		var c =
			kc,
			d = kc,
			e = 0,
			f = Ac,
			g = xc,
			h = kb,
			k = h.key,
			l = h,
			C = "L",
			m = .7;
		b.x = function(a) {
			if (!arguments.length) return d;
			c = d = a;
			return b
		};
		b.x0 = function(a) {
			if (!arguments.length) return c;
			c = a;
			return b
		};
		b.x1 = function(a) {
			if (!arguments.length) return d;
			d = a;
			return b
		};
		b.y = function(a) {
			if (!arguments.length) return f;
			e = f = a;
			return b
		};
		b.y0 = function(a) {
			if (!arguments.length) return e;
			e = a;
			return b
		};
		b.y1 = function(a) {
			if (!arguments.length) return f;
			f = a;
			return b
		};
		b.defined = function(a) {
			if (!arguments.length) return g;
			g = a;
			return b
		};
		b.interpolate = function(a) {
			if (!arguments.length) return k;
			k = "function" === typeof a ? h = a : (h = mf.get(a) || kb).key;
			l = h.reverse || h;
			C = h.closed ? "M" : "L";
			return b
		};
		b.tension = function(a) {
			if (!arguments.length) return m;
			m = a;
			return b
		};
		return b
	}

	function El(a) {
		return a.radius
	}

	function ci(a) {
		return [a.x, a.y]
	}

	function Fl(a) {
		return function() {
			var b = a.apply(this, arguments),
				c = b[0],
				b = b[1] - Da;
			return [c * Math.cos(b), c * Math.sin(b)]
		}
	}

	function Gl() {
		return 64
	}

	function Hl() {
		return "circle"
	}

	function di(a) {
		a = Math.sqrt(a / da);
		return "M0," + a + "A" + a + "," + a + " 0 1,1 0," + -a + "A" + a + "," + a + " 0 1,1 0," + a +
			"Z"
	}

	function ei(a) {
		return function() {
			var b, c, d;
			(b = this[a]) && (d = b[c = b.active]) && (d.timer.c = null, d.timer.t = NaN, --b.count ? delete b[c] : delete this[a], b.active += .5, d.event && d.event.interrupt.call(this, this.__data__, d.index))
		}
	}

	function Ic(a, b, c) {
		Xc(a, Ha);
		a.namespace = b;
		a.id = c;
		return a
	}

	function sf(a, b, c, d) {
		var e = a.id,
			f = a.namespace;
		return Z(a, "function" === typeof c ? function(a, g, h) {
			a[f][e].tween.set(b, d(c.call(a, a.__data__, g, h)))
		} : (c = d(c), function(a) {
			a[f][e].tween.set(b, c)
		}))
	}

	function Il(a) {
		null == a && (a = "");
		return function() {
			this.textContent = a
		}
	}

	function tf(a) {
		return null == a ? "__transition__" : "__transition_" + a + "__"
	}

	function Cd(a, b, c, d, e) {
		function f(a) {
			var b = C.delay;
			n.t = b + m;
			if (b <= a) return g(a - b);
			n.c = g
		}

		function g(c) {
			var e = l.active,
				f = l[e];
			f && (f.timer.c = null, f.timer.t = NaN, --l.count, delete l[e], f.event && f.event.interrupt.call(a, a.__data__, f.index));
			for (var g in l) + g < d && (e = l[g], e.timer.c = null, e.timer.t = NaN, --l.count, delete l[g]);
			n.c = k;
			ua(function() {
				n.c && k(c || 1) && (n.c = null, n.t = NaN);
				return 1
			}, 0, m);
			l.active = d;
			C.event && C.event.start.call(a, a.__data__, b);
			t = [];
			C.tween.forEach(function(c, d) {
				(d = d.call(a, a.__data__, b)) && t.push(d)
			});
			u = C.ease;
			r = C.duration
		}

		function k(e) {
			e /= r;
			for (var f = u(e), g = t.length; 0 < g;) t[--g].call(a, f);
			if (1 <= e) return C.event && C.event.end.call(a, a.__data__, b), --l.count ? delete l[d] : delete a[c], 1
		}
		var l = a[c] || (a[c] = {
				active: 0,
				count: 0
			}),
			C = l[d],
			m, n, r, u, t;
		C || (m = e.time, n = ua(f, 0, m), C = l[d] = {
			tween: new h,
			time: m,
			timer: n,
			delay: e.delay,
			duration: e.duration,
			ease: e.ease,
			index: b
		}, e = null, ++l.count)
	}

	function Jl(a,
		b, c) {
		a.attr("transform", function(a) {
			var d = b(a);
			return "translate(" + (isFinite(d) ? d : c(a)) + ",0)"
		})
	}

	function Kl(a, b, c) {
		a.attr("transform", function(a) {
			var d = b(a);
			return "translate(0," + (isFinite(d) ? d : c(a)) + ")"
		})
	}

	function uf(a) {
		return a.toISOString()
	}

	function vf(a, b, c) {
		function d(b) {
			return a(b)
		}

		function e(a, c) {
			var d = a[1] - a[0],
				d = d / c,
				e = B.bisect(Dd, d);
			return e == Dd.length ? [b.year, Hb(a.map(function(a) {
				return a / 31536E6
			}), c)[2]] : e ? b[d / Dd[e - 1] < Dd[e] / d ? e - 1 : e] : [Ll, Hb(a, c)[2]]
		}
		d.invert = function(b) {
			return Xb(a.invert(b))
		};
		d.domain = function(b) {
			if (!arguments.length) return a.domain().map(Xb);
			a.domain(b);
			return d
		};
		d.nice = function(a, b) {
			function c(c) {
				return !isNaN(c) && !a.range(c, Xb(+c + 1), b).length
			}
			var f = d.domain(),
				g = qc(f);
			if (g = null == a ? e(g, 10) : "number" === typeof a && e(g, a)) a = g[0], b = g[1];
			return d.domain(wd(f, 1 < b ? {
				floor: function(b) {
					for (; c(b = a.floor(b));) b = Xb(b - 1);
					return b
				},
				ceil: function(b) {
					for (; c(b = a.ceil(b));) b = Xb(+b + 1);
					return b
				}
			} : a))
		};
		d.ticks = function(a, b) {
			var c = qc(d.domain()),
				f = null == a ? e(c, 10) : "number" === typeof a ? e(c, a) : !a.range && [{
					range: a
				}, b];
			f && (a = f[0], b = f[1]);
			return a.range(c[0], Xb(+c[1] + 1), 1 > b ? 1 : b)
		};
		d.tickFormat = function() {
			return c
		};
		d.copy = function() {
			return vf(a.copy(), b, c)
		};
		return lf(d, a)
	}

	function Xb(a) {
		return new Date(a)
	}

	function Ml(a) {
		return JSON.parse(a.responseText)
	}

	function Nl(a) {
		var b = Ta.createRange();
		b.selectNode(Ta.body);
		return b.createContextualFragment(a.responseText)
	}
	var B = {
			version: "3.5.15"
		},
		fi = [].slice,
		lb = function(a) {
			return fi.call(a)
		},
		Ta = this.document;
	if (Ta) try {
		lb(Ta.documentElement.childNodes)[0].nodeType
	} catch (C) {
		lb =
			function(a) {
				for (var b = a.length, c = Array(b); b--;) c[b] = a[b];
				return c
			}
	}
	Date.now || (Date.now = function() {
		return +new Date
	});
	if (Ta) try {
		Ta.createElement("DIV").style.setProperty("opacity", 0, "")
	} catch (C) {
		var Ed = this.Element.prototype,
			Ol = Ed.setAttribute,
			Pl = Ed.setAttributeNS,
			gi = this.CSSStyleDeclaration.prototype,
			Ql = gi.setProperty;
		Ed.setAttribute = function(a, b) {
			Ol.call(this, a, b + "")
		};
		Ed.setAttributeNS = function(a, b, c) {
			Pl.call(this, a, b, c + "")
		};
		gi.setProperty = function(a, b, c) {
			Ql.call(this, a, b + "", c)
		}
	}
	B.ascending = b;
	B.descending =
		function(a, b) {
			return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN
		};
	B.min = function(a, b) {
		var c = -1,
			d = a.length,
			e, f;
		if (1 === arguments.length) {
			for (; ++c < d;)
				if (null != (f = a[c]) && f >= f) {
					e = f;
					break
				}
			for (; ++c < d;) null != (f = a[c]) && e > f && (e = f)
		} else {
			for (; ++c < d;)
				if (null != (f = b.call(a, a[c], c)) && f >= f) {
					e = f;
					break
				}
			for (; ++c < d;) null != (f = b.call(a, a[c], c)) && e > f && (e = f)
		}
		return e
	};
	B.max = function(a, b) {
		var c = -1,
			d = a.length,
			e, f;
		if (1 === arguments.length) {
			for (; ++c < d;)
				if (null != (f = a[c]) && f >= f) {
					e = f;
					break
				}
			for (; ++c < d;) null != (f = a[c]) && f > e && (e = f)
		} else {
			for (; ++c < d;)
				if (null !=
					(f = b.call(a, a[c], c)) && f >= f) {
					e = f;
					break
				}
			for (; ++c < d;) null != (f = b.call(a, a[c], c)) && f > e && (e = f)
		}
		return e
	};
	B.extent = function(a, b) {
		var c = -1,
			d = a.length,
			e, f, g;
		if (1 === arguments.length) {
			for (; ++c < d;)
				if (null != (f = a[c]) && f >= f) {
					e = g = f;
					break
				}
			for (; ++c < d;) null != (f = a[c]) && (e > f && (e = f), g < f && (g = f))
		} else {
			for (; ++c < d;)
				if (null != (f = b.call(a, a[c], c)) && f >= f) {
					e = g = f;
					break
				}
			for (; ++c < d;) null != (f = b.call(a, a[c], c)) && (e > f && (e = f), g < f && (g = f))
		}
		return [e, g]
	};
	B.sum = function(a, b) {
		var c = 0,
			d = a.length,
			e, f = -1;
		if (1 === arguments.length)
			for (; ++f < d;) isNaN(e = +a[f]) || (c += e);
		else
			for (; ++f < d;) isNaN(e = +b.call(a, a[f], f)) || (c += e);
		return c
	};
	B.mean = function(a, b) {
		var d = 0,
			e = a.length,
			f, g = -1,
			h = e;
		if (1 === arguments.length)
			for (; ++g < e;) isNaN(f = c(a[g])) ? --h : d += f;
		else
			for (; ++g < e;) isNaN(f = c(b.call(a, a[g], g))) ? --h : d += f;
		if (h) return d / h
	};
	B.quantile = function(a, b) {
		var c = (a.length - 1) * b + 1;
		b = Math.floor(c);
		var d = +a[b - 1];
		return (c -= b) ? d + c * (a[b] - d) : d
	};
	B.median = function(a, d) {
		var e = [],
			f = a.length,
			g, h = -1;
		if (1 === arguments.length)
			for (; ++h < f;) isNaN(g = c(a[h])) || e.push(g);
		else
			for (; ++h < f;) isNaN(g =
				c(d.call(a, a[h], h))) || e.push(g);
		if (e.length) return B.quantile(e.sort(b), .5)
	};
	B.variance = function(a, b) {
		var d = a.length,
			e = 0,
			f, g, h = 0,
			k = -1,
			l = 0;
		if (1 === arguments.length)
			for (; ++k < d;) isNaN(f = c(a[k])) || (g = f - e, e += g / ++l, h += g * (f - e));
		else
			for (; ++k < d;) isNaN(f = c(b.call(a, a[k], k))) || (g = f - e, e += g / ++l, h += g * (f - e));
		if (1 < l) return h / (l - 1)
	};
	B.deviation = function() {
		var a = B.variance.apply(this, arguments);
		return a ? Math.sqrt(a) : a
	};
	var hi = e(b);
	B.bisectLeft = hi.left;
	B.bisect = B.bisectRight = hi.right;
	B.bisector = function(a) {
		return e(1 ===
			a.length ? function(c, d) {
				return b(a(c), d)
			} : a)
	};
	B.shuffle = function(a, b, c) {
		3 > (d = arguments.length) && (c = a.length, 2 > d && (b = 0));
		for (var d = c - b, e, f; d;) f = Math.random() * d-- | 0, e = a[d + b], a[d + b] = a[f + b], a[f + b] = e;
		return a
	};
	B.permute = function(a, b) {
		for (var c = b.length, d = Array(c); c--;) d[c] = a[b[c]];
		return d
	};
	B.pairs = function(a) {
		for (var b = 0, c = a.length - 1, d, e = a[0], f = Array(0 > c ? 0 : c); b < c;) f[b] = [d = e, e = a[++b]];
		return f
	};
	B.transpose = function(a) {
		if (!(g = a.length)) return [];
		for (var b = -1, c = B.min(a, f), d = Array(c); ++b < c;)
			for (var e = -1, g,
					h = d[b] = Array(g); ++e < g;) h[e] = a[e][b];
		return d
	};
	B.zip = function() {
		return B.transpose(arguments)
	};
	B.keys = function(a) {
		var b = [],
			c;
		for (c in a) b.push(c);
		return b
	};
	B.values = function(a) {
		var b = [],
			c;
		for (c in a) b.push(a[c]);
		return b
	};
	B.entries = function(a) {
		var b = [],
			c;
		for (c in a) b.push({
			key: c,
			value: a[c]
		});
		return b
	};
	B.merge = function(a) {
		var b = a.length,
			c;
		c = -1;
		for (var d = 0, e, f; ++c < b;) d += a[c].length;
		for (e = Array(d); 0 <= --b;)
			for (f = a[b], c = f.length; 0 <= --c;) e[--d] = f[c];
		return e
	};
	var fa = Math.abs;
	B.range = function(a, b, c) {
		3 > arguments.length &&
			(c = 1, 2 > arguments.length && (b = a, a = 0));
		if (Infinity === (b - a) / c) throw Error("infinite range");
		var d = [],
			e;
		e = fa(c);
		for (var f = 1; e * f % 1;) f *= 10;
		e = f;
		var f = -1,
			g;
		a *= e;
		b *= e;
		c *= e;
		if (0 > c)
			for (;
				(g = a + c * ++f) > b;) d.push(g / e);
		else
			for (;
				(g = a + c * ++f) < b;) d.push(g / e);
		return d
	};
	B.map = function(a, b) {
		var c = new h;
		if (a instanceof h) a.forEach(function(a, b) {
			c.set(a, b)
		});
		else if (Array.isArray(a)) {
			var d = -1,
				e = a.length,
				f;
			if (1 === arguments.length)
				for (; ++d < e;) c.set(d, a[d]);
			else
				for (; ++d < e;) c.set(b.call(a, f = a[d], d), f)
		} else
			for (d in a) c.set(d,
				a[d]);
		return c
	};
	g(h, {
		has: m,
		get: function(a) {
			return this._[k(a)]
		},
		set: function(a, b) {
			return this._[k(a)] = b
		},
		remove: n,
		keys: r,
		values: function() {
			var a = [],
				b;
			for (b in this._) a.push(this._[b]);
			return a
		},
		entries: function() {
			var a = [],
				b;
			for (b in this._) a.push({
				key: l(b),
				value: this._[b]
			});
			return a
		},
		size: t,
		empty: u,
		forEach: function(a) {
			for (var b in this._) a.call(this, l(b), this._[b])
		}
	});
	B.nest = function() {
		function a(b, e, k) {
			if (k >= d.length) return g ? g.call(c, e) : f ? e.sort(f) : e;
			for (var l = -1, m = e.length, C = d[k++], n, r, u = new h,
					t; ++l < m;)(t = u.get(n = C(r = e[l]))) ? t.push(r) : u.set(n, [r]);
			b ? (r = b(), e = function(c, d) {
				r.set(c, a(b, d, k))
			}) : (r = {}, e = function(c, d) {
				r[c] = a(b, d, k)
			});
			u.forEach(e);
			return r
		}

		function b(a, c) {
			if (c >= d.length) return a;
			var f = [],
				g = e[c++];
			a.forEach(function(a, d) {
				f.push({
					key: a,
					values: b(d, c)
				})
			});
			return g ? f.sort(function(a, b) {
				return g(a.key, b.key)
			}) : f
		}
		var c = {},
			d = [],
			e = [],
			f, g;
		c.map = function(b, c) {
			return a(c, b, 0)
		};
		c.entries = function(c) {
			return b(a(B.map, c, 0), 0)
		};
		c.key = function(a) {
			d.push(a);
			return c
		};
		c.sortKeys = function(a) {
			e[d.length -
				1] = a;
			return c
		};
		c.sortValues = function(a) {
			f = a;
			return c
		};
		c.rollup = function(a) {
			g = a;
			return c
		};
		return c
	};
	B.set = function(a) {
		var b = new w;
		if (a)
			for (var c = 0, d = a.length; c < d; ++c) b.add(a[c]);
		return b
	};
	g(w, {
		has: m,
		add: function(a) {
			this._[k(a += "")] = !0;
			return a
		},
		remove: n,
		values: r,
		size: t,
		empty: u,
		forEach: function(a) {
			for (var b in this._) a.call(this, l(b))
		}
	});
	B.behavior = {};
	B.rebind = function(a, b) {
		for (var c = 1, d = arguments.length, e; ++c < d;) a[e = arguments[c]] = x(a, b, b[e]);
		return a
	};
	var qg = "webkit ms moz Moz o O".split(" ");
	B.dispatch =
		function() {
			for (var a = new z, b = -1, c = arguments.length; ++b < c;) a[arguments[b]] = G(a);
			return a
		};
	z.prototype.on = function(a, b) {
		var c = a.indexOf("."),
			d = "";
		0 <= c && (d = a.slice(c + 1), a = a.slice(0, c));
		if (a) return 2 > arguments.length ? this[a].on(d) : this[a].on(d, b);
		if (2 === arguments.length) {
			if (null == b)
				for (a in this)
					if (this.hasOwnProperty(a)) this[a].on(d, null);
			return this
		}
	};
	B.event = null;
	B.requote = function(a) {
		return a.replace(Rl, "\\$&")
	};
	var Rl = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g,
		Xc = {}.__proto__ ? function(a, b) {
			a.__proto__ = b
		} :
		function(a, b) {
			for (var c in b) a[c] = b[c]
		},
		Be = function(a, b) {
			return b.querySelector(a)
		},
		Ce = function(a, b) {
			return b.querySelectorAll(a)
		},
		Yc = function(a, b) {
			var c = a.matches || a[y(a, "matchesSelector")];
			Yc = function(a, b) {
				return c.call(a, b)
			};
			return Yc(a, b)
		};
	"function" === typeof Sizzle && (Be = function(a, b) {
		return Sizzle(a, b)[0] || null
	}, Ce = Sizzle, Yc = Sizzle.matchesSelector);
	B.selection = function() {
		return B.select(Ta.documentElement)
	};
	var qa = B.selection.prototype = [];
	qa.select = function(a) {
		var b = [],
			c, d, e, f;
		a = J(a);
		for (var g = -1, h = this.length; ++g < h;) {
			b.push(c = []);
			c.parentNode = (e = this[g]).parentNode;
			for (var k = -1, l = e.length; ++k < l;)(f = e[k]) ? (c.push(d = a.call(f, f.__data__, k, g)), d && "__data__" in f && (d.__data__ = f.__data__)) : c.push(null)
		}
		return M(b)
	};
	qa.selectAll = function(a) {
		var b = [],
			c, d;
		a = P(a);
		for (var e = -1, f = this.length; ++e < f;)
			for (var g = this[e], h = -1, k = g.length; ++h < k;)
				if (d = g[h]) b.push(c = lb(a.call(d, d.__data__, h, e))), c.parentNode = d;
		return M(b)
	};
	var wf = {
		svg: "http://www.w3.org/2000/svg",
		xhtml: "http://www.w3.org/1999/xhtml",
		xlink: "http://www.w3.org/1999/xlink",
		xml: "http://www.w3.org/XML/1998/namespace",
		xmlns: "http://www.w3.org/2000/xmlns/"
	};
	B.ns = {
		prefix: wf,
		qualify: function(a) {
			var b = a.indexOf(":"),
				c = a;
			0 <= b && "xmlns" !== (c = a.slice(0, b)) && (a = a.slice(b + 1));
			return wf.hasOwnProperty(c) ? {
				space: wf[c],
				local: a
			} : a
		}
	};
	qa.attr = function(a, b) {
		if (2 > arguments.length) {
			if ("string" === typeof a) {
				var c = this.node();
				a = B.ns.qualify(a);
				return a.local ? c.getAttributeNS(a.space, a.local) : c.getAttribute(a)
			}
			for (b in a) this.each(L(b, a[b]));
			return this
		}
		return this.each(L(a, b))
	};
	qa.classed =
		function(a, b) {
			if (2 > arguments.length) {
				if ("string" === typeof a) {
					var c = this.node(),
						d = (a = (a + "").trim().split(/^|\s+/)).length,
						e = -1;
					if (b = c.classList)
						for (; ++e < d;) {
							if (!b.contains(a[e])) return !1
						} else
							for (b = c.getAttribute("class"); ++e < d;)
								if (!Q(a[e]).test(b)) return !1;
					return !0
				}
				for (b in a) this.each(S(b, a[b]));
				return this
			}
			return this.each(S(a, b))
		};
	qa.style = function(b, c, d) {
		var e = arguments.length;
		if (3 > e) {
			if ("string" !== typeof b) {
				2 > e && (c = "");
				for (d in b) this.each(X(d, b[d], c));
				return this
			}
			if (2 > e) return e = this.node(),
				a(e).getComputedStyle(e, null).getPropertyValue(b);
			d = ""
		}
		return this.each(X(b, c, d))
	};
	qa.property = function(a, b) {
		if (2 > arguments.length) {
			if ("string" === typeof a) return this.node()[a];
			for (b in a) this.each(ba(b, a[b]));
			return this
		}
		return this.each(ba(a, b))
	};
	qa.text = function(a) {
		return arguments.length ? this.each("function" === typeof a ? function() {
			var b = a.apply(this, arguments);
			this.textContent = null == b ? "" : b
		} : null == a ? function() {
			this.textContent = ""
		} : function() {
			this.textContent = a
		}) : this.node().textContent
	};
	qa.html =
		function(a) {
			return arguments.length ? this.each("function" === typeof a ? function() {
				var b = a.apply(this, arguments);
				this.innerHTML = null == b ? "" : b
			} : null == a ? function() {
				this.innerHTML = ""
			} : function() {
				this.innerHTML = a
			}) : this.node().innerHTML
		};
	qa.append = function(a) {
		a = ca(a);
		return this.select(function() {
			return this.appendChild(a.apply(this, arguments))
		})
	};
	qa.insert = function(a, b) {
		a = ca(a);
		b = J(b);
		return this.select(function() {
			return this.insertBefore(a.apply(this, arguments), b.apply(this, arguments) || null)
		})
	};
	qa.remove =
		function() {
			return this.each(ia)
		};
	qa.data = function(a, b) {
		function c(a, c) {
			var d, e = a.length,
				f = c.length,
				g = Math.min(e, f),
				n = Array(f),
				C = Array(f),
				r = Array(e),
				u, t;
			if (b) {
				var g = new h,
					v = Array(e),
					w;
				for (d = -1; ++d < e;)
					if (u = a[d]) g.has(w = b.call(u, u.__data__, d)) ? r[d] = u : g.set(w, u), v[d] = w;
				for (d = -1; ++d < f;)(u = g.get(w = b.call(c, t = c[d], d))) ? !0 !== u && (n[d] = u, u.__data__ = t) : C[d] = {
					__data__: t
				}, g.set(w, !0);
				for (d = -1; ++d < e;) d in v && !0 !== g.get(v[d]) && (r[d] = a[d])
			} else {
				for (d = -1; ++d < g;) u = a[d], t = c[d], u ? (u.__data__ = t, n[d] = u) : C[d] = {
					__data__: t
				};
				for (; d < f; ++d) C[d] = {
					__data__: c[d]
				};
				for (; d < e; ++d) r[d] = a[d]
			}
			C.update = n;
			C.parentNode = n.parentNode = r.parentNode = a.parentNode;
			k.push(C);
			l.push(n);
			m.push(r)
		}
		var d = -1,
			e = this.length,
			f, g;
		if (!arguments.length) {
			for (a = Array(e = (f = this[0]).length); ++d < e;)
				if (g = f[d]) a[d] = g.__data__;
			return a
		}
		var k = aa([]),
			l = M([]),
			m = M([]);
		if ("function" === typeof a)
			for (; ++d < e;) c(f = this[d], a.call(f, f.parentNode.__data__, d));
		else
			for (; ++d < e;) c(f = this[d], a);
		l.enter = function() {
			return k
		};
		l.exit = function() {
			return m
		};
		return l
	};
	qa.datum = function(a) {
		return arguments.length ?
			this.property("__data__", a) : this.property("__data__")
	};
	qa.filter = function(a) {
		var b = [],
			c, d, e;
		"function" !== typeof a && (a = Y(a));
		for (var f = 0, g = this.length; f < g; f++) {
			b.push(c = []);
			c.parentNode = (d = this[f]).parentNode;
			for (var h = 0, k = d.length; h < k; h++)(e = d[h]) && a.call(e, e.__data__, h, f) && c.push(e)
		}
		return M(b)
	};
	qa.order = function() {
		for (var a = -1, b = this.length; ++a < b;)
			for (var c = this[a], d = c.length - 1, e = c[d], f; 0 <= --d;)
				if (f = c[d]) e && e !== f.nextSibling && e.parentNode.insertBefore(f, e), e = f;
		return this
	};
	qa.sort = function(a) {
		a =
			ha.apply(this, arguments);
		for (var b = -1, c = this.length; ++b < c;) this[b].sort(a);
		return this.order()
	};
	qa.each = function(a) {
		return Z(this, function(b, c, d) {
			a.call(b, b.__data__, c, d)
		})
	};
	qa.call = function(a) {
		var b = lb(arguments);
		a.apply(b[0] = this, b);
		return this
	};
	qa.empty = function() {
		return !this.node()
	};
	qa.node = function() {
		for (var a = 0, b = this.length; a < b; a++)
			for (var c = this[a], d = 0, e = c.length; d < e; d++) {
				var f = c[d];
				if (f) return f
			}
		return null
	};
	qa.size = function() {
		var a = 0;
		Z(this, function() {
			++a
		});
		return a
	};
	var sb = [];
	B.selection.enter =
		aa;
	B.selection.enter.prototype = sb;
	sb.append = qa.append;
	sb.empty = qa.empty;
	sb.node = qa.node;
	sb.call = qa.call;
	sb.size = qa.size;
	sb.select = function(a) {
		for (var b = [], c, d, e, f, g, h = -1, k = this.length; ++h < k;) {
			e = (f = this[h]).update;
			b.push(c = []);
			c.parentNode = f.parentNode;
			for (var l = -1, m = f.length; ++l < m;)(g = f[l]) ? (c.push(e[l] = d = a.call(f.parentNode, g.__data__, l, h)), d.__data__ = g.__data__) : c.push(null)
		}
		return M(b)
	};
	sb.insert = function(a, b) {
		2 > arguments.length && (b = I(this));
		return qa.insert.call(this, a, b)
	};
	B.select = function(a) {
		var b;
		"string" === typeof a ? (b = [Be(a, Ta)], b.parentNode = Ta.documentElement) : (b = [a], b.parentNode = a && (a.ownerDocument || a.document || a).documentElement);
		return M([b])
	};
	B.selectAll = function(a) {
		"string" === typeof a ? (a = lb(Ce(a, Ta)), a.parentNode = Ta.documentElement) : (a = lb(a), a.parentNode = null);
		return M([a])
	};
	qa.on = function(a, b, c) {
		var d = arguments.length;
		if (3 > d) {
			if ("string" !== typeof a) {
				2 > d && (b = !1);
				for (c in a) this.each(ma(c, a[c], b));
				return this
			}
			if (2 > d) return (d = this.node()["__on" + a]) && d._;
			c = !1
		}
		return this.each(ma(a, b, c))
	};
	var Ee = B.map({
		mouseenter: "mouseover",
		mouseleave: "mouseout"
	});
	Ta && Ee.forEach(function(a) {
		"on" + a in Ta && Ee.remove(a)
	});
	var Mb, Jj = 0;
	B.mouse = function(a) {
		return Pa(a, H())
	};
	var Fe = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
	B.touch = function(a, b, c) {
		3 > arguments.length && (c = b, b = H().changedTouches);
		if (b)
			for (var d = 0, e = b.length, f; d < e; ++d)
				if ((f = b[d]).identifier === c) return Pa(a, f)
	};
	B.behavior.drag = function() {
		function b() {
			this.on("mousedown.drag", f).on("touchstart.drag", g)
		}

		function c(a, b, c, f, g) {
			return function() {
				function h() {
					var a =
						b(n, u),
						c, d;
					a && (c = a[0] - y[0], d = a[1] - y[1], C |= c | d, y = a, r({
						type: "drag",
						x: a[0] + v[0],
						y: a[1] + v[1],
						dx: c,
						dy: d
					}))
				}

				function k() {
					b(n, u) && (w.on(f + t, null).on(g + t, null), x(C), r({
						type: "dragend"
					}))
				}
				var l = this,
					m = B.event.target.correspondingElement || B.event.target,
					n = l.parentNode,
					r = d.of(l, arguments),
					C = 0,
					u = a(),
					t = ".drag" + (null == u ? "" : "-" + u),
					v, w = B.select(c(m)).on(f + t, h).on(g + t, k),
					x = Fa(m),
					y = b(n, u);
				e ? (v = e.apply(l, arguments), v = [v.x - y[0], v.y - y[1]]) : v = [0, 0];
				r({
					type: "dragstart"
				})
			}
		}
		var d = O(b, "drag", "dragstart", "dragend"),
			e = null,
			f =
			c(D, B.mouse, a, "mousemove", "mouseup"),
			g = c(Xa, B.touch, v, "touchmove", "touchend");
		b.origin = function(a) {
			if (!arguments.length) return e;
			e = a;
			return b
		};
		return B.rebind(b, d, "on")
	};
	B.touches = function(a, b) {
		2 > arguments.length && (b = H().touches);
		return b ? lb(b).map(function(b) {
			var c = Pa(a, b);
			c.identifier = b.identifier;
			return c
		}) : []
	};
	var da = Math.PI,
		bb = 2 * da,
		Sl = bb - 1E-6,
		Da = da / 2,
		ea = da / 180,
		ya = 180 / da,
		Jc = Math.SQRT2;
	B.interpolateZoom = function(a, b) {
		var c = a[0],
			d = a[1],
			e = a[2];
		a = b[0];
		var f = b[1];
		b = b[2];
		var g = a - c,
			h = f - d,
			f = g * g + h * h,
			k;
		if (1E-12 > f) k = Math.log(b / e) / Jc, b = function(a) {
			return [c + a * g, d + a * h, e * Math.exp(Jc * a * k)]
		};
		else {
			var l = Math.sqrt(f);
			a = (b * b - e * e + 4 * f) / (4 * e * l);
			b = (b * b - e * e - 4 * f) / (4 * b * l);
			var m = Math.log(Math.sqrt(a * a + 1) - a);
			b = Math.log(Math.sqrt(b * b + 1) - b);
			k = (b - m) / Jc;
			b = function(a) {
				a *= k;
				var b = Ua(m),
					f = e / (2 * l),
					n, r = Jc * a + m;
				n = ((r = Math.exp(2 * r)) - 1) / (r + 1);
				n *= b;
				var C = m,
					r = ((C = Math.exp(C)) - 1 / C) / 2,
					f = f * (n - r);
				return [c + f * g, d + f * h, e * b / Ua(Jc * a + m)]
			}
		}
		b.duration = 1E3 * k;
		return b
	};
	B.behavior.zoom = function() {
		function b(a) {
			a.on("mousedown.zoom", m).on(xf + ".zoom",
				r).on("dblclick.zoom", u).on("touchstart.zoom", n)
		}

		function c(a) {
			return [(a[0] - t.x) / t.k, (a[1] - t.y) / t.k]
		}

		function d(a) {
			t.k = Math.max(z[0], Math.min(z[1], a))
		}

		function e(a, b) {
			b = [b[0] * t.k + t.x, b[1] * t.k + t.y];
			t.x += a[0] - b[0];
			t.y += a[1] - b[1]
		}

		function f(a, c, f, g) {
			a.__chart__ = {
				x: t.x,
				y: t.y,
				k: t.k
			};
			d(Math.pow(2, g));
			e(w = c, f);
			a = B.select(a);
			0 < J && (a = a.transition().duration(J));
			a.call(b.event)
		}

		function g() {
			H && H.domain(G.range().map(function(a) {
				return (a - t.x) / t.k
			}).map(G.invert));
			E && E.domain(P.range().map(function(a) {
				return (a -
					t.y) / t.k
			}).map(P.invert))
		}

		function h(a) {
			D++ || a({
				type: "zoomstart"
			})
		}

		function k(a) {
			g();
			a({
				type: "zoom",
				scale: t.k,
				translate: [t.x, t.y]
			})
		}

		function l(a) {
			--D || (a({
				type: "zoomend"
			}), w = null)
		}

		function m() {
			function b() {
				m = 1;
				e(B.mouse(f), r);
				k(g)
			}

			function d() {
				n.on("mousemove.zoom", null).on("mouseup.zoom", null);
				C(m);
				l(g)
			}
			var f = this,
				g = Na.of(f, arguments),
				m = 0,
				n = B.select(a(f)).on("mousemove.zoom", b).on("mouseup.zoom", d),
				r = c(B.mouse(f)),
				C = Fa(f);
			Fd.call(f);
			h(g)
		}

		function n() {
			function a() {
				var a = B.touches(C);
				x = t.k;
				a.forEach(function(a) {
					a.identifier in
						v && (v[a.identifier] = c(a))
				});
				return a
			}

			function b() {
				var b = B.event.target;
				B.select(b).on(R, g).on(z, r);
				J.push(b);
				for (var b = B.event.changedTouches, c = 0, d = b.length; c < d; ++c) v[b[c].identifier] = null;
				c = a();
				d = Date.now();
				1 === c.length ? (500 > d - na && (b = c[0], f(C, b, v[b.identifier], Math.floor(Math.log(t.k) / Math.LN2) + 1), A()), na = d) : 1 < c.length && (b = c[0], d = c[1], c = b[0] - d[0], b = b[1] - d[1], w = c * c + b * b)
			}

			function g() {
				var a = B.touches(C),
					b, c, f, g;
				Fd.call(C);
				for (var h = 0, l = a.length; h < l; ++h, g = null)
					if (f = a[h], g = v[f.identifier]) {
						if (c) break;
						b = f;
						c = g
					}
				if (g) {
					var m = (m = f[0] - b[0]) * m + (m = f[1] - b[1]) * m,
						a = w && Math.sqrt(m / w);
					b = [(b[0] + f[0]) / 2, (b[1] + f[1]) / 2];
					c = [(c[0] + g[0]) / 2, (c[1] + g[1]) / 2];
					d(a * x)
				}
				na = null;
				e(b, c);
				k(u)
			}

			function r() {
				if (B.event.touches.length) {
					for (var b = B.event.changedTouches, c = 0, d = b.length; c < d; ++c) delete v[b[c].identifier];
					for (var e in v) return void a()
				}
				B.selectAll(J).on(y, null);
				D.on("mousedown.zoom", m).on("touchstart.zoom", n);
				ja();
				l(u)
			}
			var C = this,
				u = Na.of(C, arguments),
				v = {},
				w = 0,
				x, y = ".zoom-" + B.event.changedTouches[0].identifier,
				R = "touchmove" +
				y,
				z = "touchend" + y,
				J = [],
				D = B.select(C),
				ja = Fa(C);
			b();
			h(u);
			D.on("mousedown.zoom", null).on("touchstart.zoom", b)
		}

		function r() {
			var a = Na.of(this, arguments);
			K ? clearTimeout(K) : (Fd.call(this), v = c(w = x || B.mouse(this)), h(a));
			K = setTimeout(function() {
				K = null;
				l(a)
			}, 50);
			A();
			d(Math.pow(2, .002 * Gd()) * t.k);
			e(w, v);
			k(a)
		}

		function u() {
			var a = B.mouse(this),
				b = Math.log(t.k) / Math.LN2;
			f(this, a, c(a), B.event.shiftKey ? Math.ceil(b) - 1 : Math.floor(b) + 1)
		}
		var t = {
				x: 0,
				y: 0,
				k: 1
			},
			v, w, x, y = [960, 500],
			z = ii,
			J = 250,
			D = 0,
			K, na, Na = O(b, "zoomstart", "zoom",
				"zoomend"),
			G, H, P, E;
		xf || (xf = "onwheel" in Ta ? (Gd = function() {
			return -B.event.deltaY * (B.event.deltaMode ? 120 : 1)
		}, "wheel") : "onmousewheel" in Ta ? (Gd = function() {
			return B.event.wheelDelta
		}, "mousewheel") : (Gd = function() {
			return -B.event.detail
		}, "MozMousePixelScroll"));
		b.event = function(a) {
			a.each(function() {
				var a = Na.of(this, arguments),
					b = t;
				Yb ? B.select(this).transition().each("start.zoom", function() {
					t = this.__chart__ || {
						x: 0,
						y: 0,
						k: 1
					};
					h(a)
				}).tween("zoom:zoom", function() {
					var c = y[0],
						d = y[1],
						e = w ? w[0] : c / 2,
						f = w ? w[1] : d / 2,
						g = B.interpolateZoom([(e -
							t.x) / t.k, (f - t.y) / t.k, c / t.k], [(e - b.x) / b.k, (f - b.y) / b.k, c / b.k]);
					return function(b) {
						b = g(b);
						var d = c / b[2];
						this.__chart__ = t = {
							x: e - b[0] * d,
							y: f - b[1] * d,
							k: d
						};
						k(a)
					}
				}).each("interrupt.zoom", function() {
					l(a)
				}).each("end.zoom", function() {
					l(a)
				}) : (this.__chart__ = t, h(a), k(a), l(a))
			})
		};
		b.translate = function(a) {
			if (!arguments.length) return [t.x, t.y];
			t = {
				x: +a[0],
				y: +a[1],
				k: t.k
			};
			g();
			return b
		};
		b.scale = function(a) {
			if (!arguments.length) return t.k;
			t = {
				x: t.x,
				y: t.y,
				k: null
			};
			d(+a);
			g();
			return b
		};
		b.scaleExtent = function(a) {
			if (!arguments.length) return z;
			z = null == a ? ii : [+a[0], +a[1]];
			return b
		};
		b.center = function(a) {
			if (!arguments.length) return x;
			x = a && [+a[0], +a[1]];
			return b
		};
		b.size = function(a) {
			if (!arguments.length) return y;
			y = a && [+a[0], +a[1]];
			return b
		};
		b.duration = function(a) {
			if (!arguments.length) return J;
			J = +a;
			return b
		};
		b.x = function(a) {
			if (!arguments.length) return H;
			H = a;
			G = a.copy();
			t = {
				x: 0,
				y: 0,
				k: 1
			};
			return b
		};
		b.y = function(a) {
			if (!arguments.length) return E;
			E = a;
			P = a.copy();
			t = {
				x: 0,
				y: 0,
				k: 1
			};
			return b
		};
		return B.rebind(b, Na, "on")
	};
	var ii = [0, Infinity],
		Gd, xf;
	B.color = Za;
	Za.prototype.toString = function() {
		return this.rgb() + ""
	};
	B.hsl = Ya;
	var yf = Ya.prototype = new Za;
	yf.brighter = function(a) {
		a = Math.pow(.7, arguments.length ? a : 1);
		return new Ya(this.h, this.s, this.l / a)
	};
	yf.darker = function(a) {
		a = Math.pow(.7, arguments.length ? a : 1);
		return new Ya(this.h, this.s, a * this.l)
	};
	yf.rgb = function() {
		return La(this.h, this.s, this.l)
	};
	B.hcl = Ia;
	var zf = Ia.prototype = new Za;
	zf.brighter = function(a) {
		return new Ia(this.h, this.c, Math.min(100, this.l + Hd * (arguments.length ? a : 1)))
	};
	zf.darker = function(a) {
		return new Ia(this.h,
			this.c, Math.max(0, this.l - Hd * (arguments.length ? a : 1)))
	};
	zf.rgb = function() {
		return ub(this.h, this.c, this.l).rgb()
	};
	B.lab = Ra;
	var Hd = 18,
		rg = .95047,
		sg = 1,
		tg = 1.08883,
		Af = Ra.prototype = new Za;
	Af.brighter = function(a) {
		return new Ra(Math.min(100, this.l + Hd * (arguments.length ? a : 1)), this.a, this.b)
	};
	Af.darker = function(a) {
		return new Ra(Math.max(0, this.l - Hd * (arguments.length ? a : 1)), this.a, this.b)
	};
	Af.rgb = function() {
		return Sa(this.l, this.a, this.b)
	};
	B.rgb = Ca;
	var Id = Ca.prototype = new Za;
	Id.brighter = function(a) {
		a = Math.pow(.7,
			arguments.length ? a : 1);
		var b = this.r,
			c = this.g,
			d = this.b;
		if (!b && !c && !d) return new Ca(30, 30, 30);
		b && 30 > b && (b = 30);
		c && 30 > c && (c = 30);
		d && 30 > d && (d = 30);
		return new Ca(Math.min(255, b / a), Math.min(255, c / a), Math.min(255, d / a))
	};
	Id.darker = function(a) {
		a = Math.pow(.7, arguments.length ? a : 1);
		return new Ca(a * this.r, a * this.g, a * this.b)
	};
	Id.hsl = function() {
		return Nb(this.r, this.g, this.b)
	};
	Id.toString = function() {
		return "#" + mb(this.r) + mb(this.g) + mb(this.b)
	};
	var Zc = B.map({
		aliceblue: 15792383,
		antiquewhite: 16444375,
		aqua: 65535,
		aquamarine: 8388564,
		azure: 15794175,
		beige: 16119260,
		bisque: 16770244,
		black: 0,
		blanchedalmond: 16772045,
		blue: 255,
		blueviolet: 9055202,
		brown: 10824234,
		burlywood: 14596231,
		cadetblue: 6266528,
		chartreuse: 8388352,
		chocolate: 13789470,
		coral: 16744272,
		cornflowerblue: 6591981,
		cornsilk: 16775388,
		crimson: 14423100,
		cyan: 65535,
		darkblue: 139,
		darkcyan: 35723,
		darkgoldenrod: 12092939,
		darkgray: 11119017,
		darkgreen: 25600,
		darkgrey: 11119017,
		darkkhaki: 12433259,
		darkmagenta: 9109643,
		darkolivegreen: 5597999,
		darkorange: 16747520,
		darkorchid: 10040012,
		darkred: 9109504,
		darksalmon: 15308410,
		darkseagreen: 9419919,
		darkslateblue: 4734347,
		darkslategray: 3100495,
		darkslategrey: 3100495,
		darkturquoise: 52945,
		darkviolet: 9699539,
		deeppink: 16716947,
		deepskyblue: 49151,
		dimgray: 6908265,
		dimgrey: 6908265,
		dodgerblue: 2003199,
		firebrick: 11674146,
		floralwhite: 16775920,
		forestgreen: 2263842,
		fuchsia: 16711935,
		gainsboro: 14474460,
		ghostwhite: 16316671,
		gold: 16766720,
		goldenrod: 14329120,
		gray: 8421504,
		green: 32768,
		greenyellow: 11403055,
		grey: 8421504,
		honeydew: 15794160,
		hotpink: 16738740,
		indianred: 13458524,
		indigo: 4915330,
		ivory: 16777200,
		khaki: 15787660,
		lavender: 15132410,
		lavenderblush: 16773365,
		lawngreen: 8190976,
		lemonchiffon: 16775885,
		lightblue: 11393254,
		lightcoral: 15761536,
		lightcyan: 14745599,
		lightgoldenrodyellow: 16448210,
		lightgray: 13882323,
		lightgreen: 9498256,
		lightgrey: 13882323,
		lightpink: 16758465,
		lightsalmon: 16752762,
		lightseagreen: 2142890,
		lightskyblue: 8900346,
		lightslategray: 7833753,
		lightslategrey: 7833753,
		lightsteelblue: 11584734,
		lightyellow: 16777184,
		lime: 65280,
		limegreen: 3329330,
		linen: 16445670,
		magenta: 16711935,
		maroon: 8388608,
		mediumaquamarine: 6737322,
		mediumblue: 205,
		mediumorchid: 12211667,
		mediumpurple: 9662683,
		mediumseagreen: 3978097,
		mediumslateblue: 8087790,
		mediumspringgreen: 64154,
		mediumturquoise: 4772300,
		mediumvioletred: 13047173,
		midnightblue: 1644912,
		mintcream: 16121850,
		mistyrose: 16770273,
		moccasin: 16770229,
		navajowhite: 16768685,
		navy: 128,
		oldlace: 16643558,
		olive: 8421376,
		olivedrab: 7048739,
		orange: 16753920,
		orangered: 16729344,
		orchid: 14315734,
		palegoldenrod: 15657130,
		palegreen: 10025880,
		paleturquoise: 11529966,
		palevioletred: 14381203,
		papayawhip: 16773077,
		peachpuff: 16767673,
		peru: 13468991,
		pink: 16761035,
		plum: 14524637,
		powderblue: 11591910,
		purple: 8388736,
		rebeccapurple: 6697881,
		red: 16711680,
		rosybrown: 12357519,
		royalblue: 4286945,
		saddlebrown: 9127187,
		salmon: 16416882,
		sandybrown: 16032864,
		seagreen: 3050327,
		seashell: 16774638,
		sienna: 10506797,
		silver: 12632256,
		skyblue: 8900331,
		slateblue: 6970061,
		slategray: 7372944,
		slategrey: 7372944,
		snow: 16775930,
		springgreen: 65407,
		steelblue: 4620980,
		tan: 13808780,
		teal: 32896,
		thistle: 14204888,
		tomato: 16737095,
		turquoise: 4251856,
		violet: 15631086,
		wheat: 16113331,
		white: 16777215,
		whitesmoke: 16119285,
		yellow: 16776960,
		yellowgreen: 10145074
	});
	Zc.forEach(function(a, b) {
		Zc.set(a, new Ca(b >> 16, b >> 8 & 255, b & 255))
	});
	B.functor = pa;
	B.xhr = E(v);
	B.dsv = function(a, b) {
		function c(a, c, f) {
			3 > arguments.length && (f = c, c = null);
			var g = Ob(a, b, null == c ? d : e(c), f);
			g.row = function(a) {
				return arguments.length ? g.response(null == (c = a) ? d : e(a)) : c
			};
			return g
		}

		function d(a) {
			return c.parse(a.responseText)
		}

		function e(a) {
			return function(b) {
				return c.parse(b.responseText, a)
			}
		}

		function f(b) {
			return b.map(g).join(a)
		}

		function g(a) {
			return h.test(a) ? '"' + a.replace(/\"/g, '""') + '"' : a
		}
		var h = new RegExp('["' + a + "\n]"),
			k = a.charCodeAt(0);
		c.parse = function(a, b) {
			var d;
			return c.parseRows(a, function(a, c) {
				if (d) return d(a, c - 1);
				var e = new Function("d", "return {" + a.map(function(a, b) {
					return JSON.stringify(a) + ": d[" + b + "]"
				}).join(",") + "}");
				d = b ? function(a, c) {
					return b(e(a), c)
				} : e
			})
		};
		c.parseRows = function(a, b) {
			function c() {
				if (h >= g) return e;
				if (n) return n = !1, d;
				var b = h;
				if (34 === a.charCodeAt(b)) {
					for (var c = b; c++ < g;)
						if (34 === a.charCodeAt(c)) {
							if (34 !==
								a.charCodeAt(c + 1)) break;
							++c
						}
					h = c + 2;
					var f = a.charCodeAt(c + 1);
					13 === f ? (n = !0, 10 === a.charCodeAt(c + 2) && ++h) : 10 === f && (n = !0);
					return a.slice(b + 1, c).replace(/""/g, '"')
				}
				for (; h < g;) {
					f = a.charCodeAt(h++);
					c = 1;
					if (10 === f) n = !0;
					else if (13 === f) n = !0, 10 === a.charCodeAt(h) && (++h, ++c);
					else if (f !== k) continue;
					return a.slice(b, h - c)
				}
				return a.slice(b)
			}
			for (var d = {}, e = {}, f = [], g = a.length, h = 0, l = 0, m, n;
				(m = c()) !== e;) {
				for (var r = []; m !== d && m !== e;) r.push(m), m = c();
				b && null == (r = b(r, l++)) || f.push(r)
			}
			return f
		};
		c.format = function(b) {
			if (Array.isArray(b[0])) return c.formatRows(b);
			var d = new w,
				e = [];
			b.forEach(function(a) {
				for (var b in a) d.has(b) || e.push(d.add(b))
			});
			return [e.map(g).join(a)].concat(b.map(function(b) {
				return e.map(function(a) {
					return g(b[a])
				}).join(a)
			})).join("\n")
		};
		c.formatRows = function(a) {
			return a.map(f).join("\n")
		};
		return c
	};
	B.csv = B.dsv(",", "text/csv");
	B.tsv = B.dsv("\t", "text/tab-separated-values");
	var bd, ad, cd, dd, ug = this[y(this, "requestAnimationFrame")] || function(a) {
		setTimeout(a, 17)
	};
	B.timer = function() {
		ua.apply(this, arguments)
	};
	B.timer.flush = function() {
		W();
		ra()
	};
	B.round = function(a, b) {
		return b ? Math.round(a * (b = Math.pow(10, b))) / b : Math.round(a)
	};
	var Tl = "y z a f p n \u00b5 m  k M G T P E Z Y".split(" ").map(Pb);
	B.formatPrefix = function(a, b) {
		var c = 0;
		if (a = +a) 0 > a && (a *= -1), b && (a = B.round(a, xb(a, b))), c = 1 + Math.floor(1E-12 + Math.log(a) / Math.LN10), c = Math.max(-24, Math.min(24, 3 * Math.floor((c - 1) / 3)));
		return Tl[8 + c / 3]
	};
	var vg = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i,
		Kj = B.map({
			b: function(a) {
				return a.toString(2)
			},
			c: function(a) {
				return String.fromCharCode(a)
			},
			o: function(a) {
				return a.toString(8)
			},
			x: function(a) {
				return a.toString(16)
			},
			X: function(a) {
				return a.toString(16).toUpperCase()
			},
			g: function(a, b) {
				return a.toPrecision(b)
			},
			e: function(a, b) {
				return a.toExponential(b)
			},
			f: function(a, b) {
				return a.toFixed(b)
			},
			r: function(a, b) {
				return (a = B.round(a, xb(a, b))).toFixed(Math.max(0, Math.min(20, xb(a * (1 + 1E-15), b))))
			}
		}),
		V = B.time = {},
		Ma = Date;
	hb.prototype = {
		getDate: function() {
			return this._.getUTCDate()
		},
		getDay: function() {
			return this._.getUTCDay()
		},
		getFullYear: function() {
			return this._.getUTCFullYear()
		},
		getHours: function() {
			return this._.getUTCHours()
		},
		getMilliseconds: function() {
			return this._.getUTCMilliseconds()
		},
		getMinutes: function() {
			return this._.getUTCMinutes()
		},
		getMonth: function() {
			return this._.getUTCMonth()
		},
		getSeconds: function() {
			return this._.getUTCSeconds()
		},
		getTime: function() {
			return this._.getTime()
		},
		getTimezoneOffset: function() {
			return 0
		},
		valueOf: function() {
			return this._.valueOf()
		},
		setDate: function() {
			Ab.setUTCDate.apply(this._, arguments)
		},
		setDay: function() {
			Ab.setUTCDay.apply(this._, arguments)
		},
		setFullYear: function() {
			Ab.setUTCFullYear.apply(this._, arguments)
		},
		setHours: function() {
			Ab.setUTCHours.apply(this._, arguments)
		},
		setMilliseconds: function() {
			Ab.setUTCMilliseconds.apply(this._, arguments)
		},
		setMinutes: function() {
			Ab.setUTCMinutes.apply(this._, arguments)
		},
		setMonth: function() {
			Ab.setUTCMonth.apply(this._, arguments)
		},
		setSeconds: function() {
			Ab.setUTCSeconds.apply(this._, arguments)
		},
		setTime: function() {
			Ab.setTime.apply(this._, arguments)
		}
	};
	var Ab = Date.prototype;
	V.year = ob(function(a) {
		a = V.day(a);
		a.setMonth(0,
			1);
		return a
	}, function(a, b) {
		a.setFullYear(a.getFullYear() + b)
	}, function(a) {
		return a.getFullYear()
	});
	V.years = V.year.range;
	V.years.utc = V.year.utc.range;
	V.day = ob(function(a) {
		var b = new Ma(2E3, 0);
		b.setFullYear(a.getFullYear(), a.getMonth(), a.getDate());
		return b
	}, function(a, b) {
		a.setDate(a.getDate() + b)
	}, function(a) {
		return a.getDate() - 1
	});
	V.days = V.day.range;
	V.days.utc = V.day.utc.range;
	V.dayOfYear = function(a) {
		var b = V.year(a);
		return Math.floor((a - b - 6E4 * (a.getTimezoneOffset() - b.getTimezoneOffset())) / 864E5)
	};
	"sunday monday tuesday wednesday thursday friday saturday".split(" ").forEach(function(a,
		b) {
		b = 7 - b;
		var c = V[a] = ob(function(a) {
			(a = V.day(a)).setDate(a.getDate() - (a.getDay() + b) % 7);
			return a
		}, function(a, b) {
			a.setDate(a.getDate() + 7 * Math.floor(b))
		}, function(a) {
			var c = V.year(a).getDay();
			return Math.floor((V.dayOfYear(a) + (c + b) % 7) / 7) - (c !== b)
		});
		V[a + "s"] = c.range;
		V[a + "s"].utc = c.utc.range;
		V[a + "OfYear"] = function(a) {
			var c = V.year(a).getDay();
			return Math.floor((V.dayOfYear(a) + (c + b) % 7) / 7)
		}
	});
	V.week = V.sunday;
	V.weeks = V.sunday.range;
	V.weeks.utc = V.sunday.utc.range;
	V.weekOfYear = V.sundayOfYear;
	var wg = {
			"-": "",
			_: " ",
			0: "0"
		},
		Ea = /^\s*\d+/,
		zg = /^%/;
	B.locale = function(a) {
		return {
			numberFormat: ec(a),
			timeFormat: He(a)
		}
	};
	var ji = B.locale({
		decimal: ".",
		thousands: ",",
		grouping: [3],
		currency: ["$", ""],
		dateTime: "%a %b %e %X %Y",
		date: "%m/%d/%Y",
		time: "%H:%M:%S",
		periods: ["AM", "PM"],
		days: "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),
		shortDays: "Sun Mon Tue Wed Thu Fri Sat".split(" "),
		months: "January February March April May June July August September October November December".split(" "),
		shortMonths: "Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec".split(" ")
	});
	B.format = ji.numberFormat;
	B.geo = {};
	Ie.prototype = {
		s: 0,
		t: 0,
		add: function(a) {
			Ag(a, this.t, Jd);
			Ag(Jd.s, this.s, this);
			this.s ? this.t += Jd.t : this.s = Jd.t
		},
		reset: function() {
			this.s = this.t = 0
		},
		valueOf: function() {
			return this.s
		}
	};
	var Jd = new Ie;
	B.geo.stream = function(a, b) {
		if (a && ki.hasOwnProperty(a.type)) ki[a.type](a, b);
		else ed(a, b)
	};
	var ki = {
			Feature: function(a, b) {
				ed(a.geometry, b)
			},
			FeatureCollection: function(a, b) {
				a = a.features;
				for (var c = -1, d = a.length; ++c < d;) ed(a[c].geometry, b)
			}
		},
		Bg = {
			Sphere: function(a, b) {
				b.sphere()
			},
			Point: function(a,
				b) {
				a = a.coordinates;
				b.point(a[0], a[1], a[2])
			},
			MultiPoint: function(a, b) {
				for (var c = a.coordinates, d = -1, e = c.length; ++d < e;) a = c[d], b.point(a[0], a[1], a[2])
			},
			LineString: function(a, b) {
				Je(a.coordinates, b, 0)
			},
			MultiLineString: function(a, b) {
				a = a.coordinates;
				for (var c = -1, d = a.length; ++c < d;) Je(a[c], b, 0)
			},
			Polygon: function(a, b) {
				Cg(a.coordinates, b)
			},
			MultiPolygon: function(a, b) {
				a = a.coordinates;
				for (var c = -1, d = a.length; ++c < d;) Cg(a[c], b)
			},
			GeometryCollection: function(a, b) {
				a = a.geometries;
				for (var c = -1, d = a.length; ++c < d;) ed(a[c],
					b)
			}
		};
	B.geo.area = function(a) {
		Kd = 0;
		B.geo.stream(a, ab);
		return Kd
	};
	var Kd, Qb = new Ie,
		ab = {
			sphere: function() {
				Kd += 4 * da
			},
			point: D,
			lineStart: D,
			lineEnd: D,
			polygonStart: function() {
				Qb.reset();
				ab.lineStart = Zj
			},
			polygonEnd: function() {
				var a = 2 * Qb;
				Kd += 0 > a ? 4 * da + a : a;
				ab.lineStart = ab.lineEnd = ab.point = D
			}
		};
	B.geo.bounds = function() {
		function a(a, b) {
			z.push(J = [m = a, r = a]);
			b < n && (n = b);
			b > t && (t = b)
		}

		function b(b, c) {
			var d = Rb([b * ea, c * ea]);
			if (x) {
				var e = gc(x, d),
					f = [e[1], -e[0], 0],
					e = gc(f, e);
				hd(e);
				var e = id(e),
					g = b - u,
					f = 0 < g ? 1 : -1,
					k = e[0] * ya * f,
					g = 180 <
					fa(g);
				g ^ (f * u < k && k < f * b) ? (c = e[1] * ya, c > t && (t = c)) : (k = (k + 360) % 360 - 180, g ^ (f * u < k && k < f * b)) ? (c = -e[1] * ya, c < n && (n = c)) : (c < n && (n = c), c > t && (t = c));
				g ? b < u ? h(m, b) > h(m, r) && (r = b) : h(b, r) > h(m, r) && (m = b) : r >= m ? (b < m && (m = b), b > r && (r = b)) : b > u ? h(m, b) > h(m, r) && (r = b) : h(b, r) > h(m, r) && (m = b)
			} else a(b, c);
			x = d;
			u = b
		}

		function c() {
			A.point = b
		}

		function d() {
			J[0] = m;
			J[1] = r;
			A.point = a;
			x = null
		}

		function e(a, c) {
			if (x) {
				var d = a - u;
				y += 180 < fa(d) ? d + (0 < d ? 360 : -360) : d
			} else v = a, w = c;
			ab.point(a, c);
			b(a, c)
		}

		function f() {
			ab.lineStart()
		}

		function g() {
			e(v, w);
			ab.lineEnd();
			1E-6 <
				fa(y) && (m = -(r = 180));
			J[0] = m;
			J[1] = r;
			x = null
		}

		function h(a, b) {
			return 0 > (b -= a) ? b + 360 : b
		}

		function k(a, b) {
			return a[0] - b[0]
		}

		function l(a, b) {
			return b[0] <= b[1] ? b[0] <= a && a <= b[1] : a < b[0] || b[1] < a
		}
		var m, n, r, t, u, v, w, x, y, z, J, A = {
			point: a,
			lineStart: c,
			lineEnd: d,
			polygonStart: function() {
				A.point = e;
				A.lineStart = f;
				A.lineEnd = g;
				y = 0;
				ab.polygonStart()
			},
			polygonEnd: function() {
				ab.polygonEnd();
				A.point = a;
				A.lineStart = c;
				A.lineEnd = d;
				0 > Qb ? (m = -(r = 180), n = -(t = 90)) : 1E-6 < y ? t = 90 : -1E-6 > y && (n = -90);
				J[0] = m;
				J[1] = r
			}
		};
		return function(a) {
			t = r = -(m = n = Infinity);
			z = [];
			B.geo.stream(a, A);
			if (a = z.length) {
				z.sort(k);
				for (var b = 1, c = z[0], d, e = [c]; b < a; ++b) d = z[b], l(d[0], c) || l(d[1], c) ? (h(c[0], d[1]) > h(c[0], c[1]) && (c[1] = d[1]), h(d[0], c[1]) > h(c[0], c[1]) && (c[0] = d[0])) : e.push(c = d);
				var f = -Infinity,
					g;
				a = e.length - 1;
				b = 0;
				for (c = e[a]; b <= a; c = d, ++b) d = e[b], (g = h(c[1], d[0])) > f && (f = g, m = d[0], r = c[1])
			}
			z = J = null;
			return Infinity === m || Infinity === n ? [
				[NaN, NaN],
				[NaN, NaN]
			] : [
				[m, n],
				[r, t]
			]
		}
	}();
	B.geo.centroid = function(a) {
		wc = kd = Sb = Tb = yb = Cb = Db = pb = hc = ic = Eb = 0;
		B.geo.stream(a, ib);
		a = hc;
		var b = ic,
			c = Eb,
			d = a * a + b * b +
			c * c;
		return 1E-12 > d && (a = Cb, b = Db, c = pb, 1E-6 > kd && (a = Sb, b = Tb, c = yb), d = a * a + b * b + c * c, 1E-12 > d) ? [NaN, NaN] : [Math.atan2(b, a) * ya, Ja(c / Math.sqrt(d)) * ya]
	};
	var wc, kd, Sb, Tb, yb, Cb, Db, pb, hc, ic, Eb, ib = {
			sphere: D,
			point: Le,
			lineStart: Dg,
			lineEnd: Eg,
			polygonStart: function() {
				ib.lineStart = ak
			},
			polygonEnd: function() {
				ib.lineStart = Dg
			}
		},
		Ug = Ig(xc, dk, ek, [-da, -da / 2]);
	B.geo.clipExtent = function() {
		var a, b, c, d, e, f, g = {
			stream: function(a) {
				e && (e.valid = !1);
				e = f(a);
				e.valid = !0;
				return e
			},
			extent: function(h) {
				if (!arguments.length) return [
					[a, b],
					[c, d]
				];
				f = Lg(a = +h[0][0], b = +h[0][1], c = +h[1][0], d = +h[1][1]);
				e && (e.valid = !1, e = null);
				return g
			}
		};
		return g.extent([
			[0, 0],
			[960, 500]
		])
	};
	(B.geo.conicEqualArea = function() {
		return Ne(Mg)
	}).raw = Mg;
	B.geo.albers = function() {
		return B.geo.conicEqualArea().rotate([96, 0]).center([-.6, 38.7]).parallels([29.5, 45.5]).scale(1070)
	};
	B.geo.albersUsa = function() {
		function a(a) {
			var b = a[0];
			a = a[1];
			e = null;
			(g(b, a), e) || (h(b, a), e) || k(b, a);
			return e
		}
		var b = B.geo.albers(),
			c = B.geo.conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
			d = B.geo.conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
			e, f = {
				point: function(a, b) {
					e = [a, b]
				}
			},
			g, h, k;
		a.invert = function(a) {
			var e = b.scale(),
				f = b.translate(),
				g = (a[0] - f[0]) / e,
				e = (a[1] - f[1]) / e;
			return (.12 <= e && .234 > e && -.425 <= g && -.214 > g ? c : .166 <= e && .234 > e && -.214 <= g && -.115 > g ? d : b).invert(a)
		};
		a.stream = function(a) {
			var e = b.stream(a),
				f = c.stream(a),
				g = d.stream(a);
			return {
				point: function(a, b) {
					e.point(a, b);
					f.point(a, b);
					g.point(a, b)
				},
				sphere: function() {
					e.sphere();
					f.sphere();
					g.sphere()
				},
				lineStart: function() {
					e.lineStart();
					f.lineStart();
					g.lineStart()
				},
				lineEnd: function() {
					e.lineEnd();
					f.lineEnd();
					g.lineEnd()
				},
				polygonStart: function() {
					e.polygonStart();
					f.polygonStart();
					g.polygonStart()
				},
				polygonEnd: function() {
					e.polygonEnd();
					f.polygonEnd();
					g.polygonEnd()
				}
			}
		};
		a.precision = function(e) {
			if (!arguments.length) return b.precision();
			b.precision(e);
			c.precision(e);
			d.precision(e);
			return a
		};
		a.scale = function(e) {
			if (!arguments.length) return b.scale();
			b.scale(e);
			c.scale(.35 * e);
			d.scale(e);
			return a.translate(b.translate())
		};
		a.translate = function(e) {
			if (!arguments.length) return b.translate();
			var l = b.scale(),
				m = +e[0],
				n = +e[1];
			g = b.translate(e).clipExtent([
				[m - .455 * l, n - .238 * l],
				[m + .455 * l, n + .238 * l]
			]).stream(f).point;
			h = c.translate([m - .307 * l, n + .201 * l]).clipExtent([
				[m - .425 * l + 1E-6, n + .12 * l + 1E-6],
				[m - .214 * l - 1E-6, n + .234 * l - 1E-6]
			]).stream(f).point;
			k = d.translate([m - .205 * l, n + .212 * l]).clipExtent([
				[m - .214 * l + 1E-6, n + .166 * l + 1E-6],
				[m - .115 * l - 1E-6, n + .234 * l - 1E-6]
			]).stream(f).point;
			return a
		};
		return a.scale(1070)
	};
	var Bf, Pe, Fb = {
			point: D,
			lineStart: D,
			lineEnd: D,
			polygonStart: function() {
				Pe = 0;
				Fb.lineStart = gk
			},
			polygonEnd: function() {
				Fb.lineStart =
					Fb.lineEnd = Fb.point = D;
				Bf += fa(Pe / 2)
			}
		},
		md, od, nd, pd, Ul = {
			point: hk,
			lineStart: D,
			lineEnd: D,
			polygonStart: D,
			polygonEnd: D
		},
		jb = {
			point: Ub,
			lineStart: Og,
			lineEnd: Pg,
			polygonStart: function() {
				jb.lineStart = jk
			},
			polygonEnd: function() {
				jb.point = Ub;
				jb.lineStart = Og;
				jb.lineEnd = Pg
			}
		};
	B.geo.path = function() {
		function a(a) {
			a && ("function" === typeof c && g.pointRadius(+c.apply(this, arguments)), h && h.valid || (h = f(g)), B.geo.stream(a, h));
			return g.result()
		}

		function b() {
			h = null;
			return a
		}
		var c = 4.5,
			d, e, f, g, h;
		a.area = function(a) {
			Bf = 0;
			B.geo.stream(a,
				f(Fb));
			return Bf
		};
		a.centroid = function(a) {
			Sb = Tb = yb = Cb = Db = pb = hc = ic = Eb = 0;
			B.geo.stream(a, f(jb));
			return Eb ? [hc / Eb, ic / Eb] : pb ? [Cb / pb, Db / pb] : yb ? [Sb / yb, Tb / yb] : [NaN, NaN]
		};
		a.bounds = function(a) {
			nd = pd = -(md = od = Infinity);
			B.geo.stream(a, f(Ul));
			return [
				[md, od],
				[nd, pd]
			]
		};
		a.projection = function(a) {
			if (!arguments.length) return d;
			f = (d = a) ? a.stream || lk(a) : v;
			return b()
		};
		a.context = function(a) {
			if (!arguments.length) return e;
			g = null == (e = a) ? new ik : new kk(a);
			"function" !== typeof c && g.pointRadius(c);
			return b()
		};
		a.pointRadius = function(b) {
			if (!arguments.length) return c;
			c = "function" === typeof b ? b : (g.pointRadius(+b), +b);
			return a
		};
		return a.projection(B.geo.albersUsa()).context(null)
	};
	B.geo.transform = function(a) {
		return {
			stream: function(b) {
				b = new Tg(b);
				for (var c in a) b[c] = a[c];
				return b
			}
		}
	};
	Tg.prototype = {
		point: function(a, b) {
			this.stream.point(a, b)
		},
		sphere: function() {
			this.stream.sphere()
		},
		lineStart: function() {
			this.stream.lineStart()
		},
		lineEnd: function() {
			this.stream.lineEnd()
		},
		polygonStart: function() {
			this.stream.polygonStart()
		},
		polygonEnd: function() {
			this.stream.polygonEnd()
		}
	};
	B.geo.projection = Gb;
	B.geo.projectionMutator = Oe;
	(B.geo.equirectangular = function() {
		return Gb(yc)
	}).raw = yc.invert = yc;
	B.geo.rotation = function(a) {
		function b(b) {
			b = a(b[0] * ea, b[1] * ea);
			return b[0] *= ya, b[1] *= ya, b
		}
		a = Qe(a[0] % 360 * ea, a[1] * ea, 2 < a.length ? a[2] * ea : 0);
		b.invert = function(b) {
			b = a.invert(b[0] * ea, b[1] * ea);
			return b[0] *= ya, b[1] *= ya, b
		};
		return b
	};
	Vg.invert = yc;
	B.geo.circle = function() {
		function a() {
			var a = "function" === typeof b ? b.apply(this, arguments) : b,
				c = Qe(-a[0] * ea, -a[1] * ea, 0).invert,
				d = [];
			e(null, null, 1, {
				point: function(a,
					b) {
					d.push(a = c(a, b));
					a[0] *= ya;
					a[1] *= ya
				}
			});
			return {
				type: "Polygon",
				coordinates: [d]
			}
		}
		var b = [0, 0],
			c, d = 6,
			e;
		a.origin = function(c) {
			if (!arguments.length) return b;
			b = c;
			return a
		};
		a.angle = function(b) {
			if (!arguments.length) return c;
			e = Me((c = +b) * ea, d * ea);
			return a
		};
		a.precision = function(b) {
			if (!arguments.length) return d;
			e = Me(c * ea, (d = +b) * ea);
			return a
		};
		return a.angle(90)
	};
	B.geo.distance = function(a, b) {
		var c = (b[0] - a[0]) * ea,
			d = a[1] * ea;
		a = b[1] * ea;
		b = Math.sin(c);
		var c = Math.cos(c),
			e = Math.sin(d),
			d = Math.cos(d),
			f = Math.sin(a);
		a = Math.cos(a);
		var g;
		return Math.atan2(Math.sqrt((g = a * b) * g + (g = d * f - e * a * c) * g), e * f + d * a * c)
	};
	B.geo.graticule = function() {
		function a() {
			return {
				type: "MultiLineString",
				coordinates: b()
			}
		}

		function b() {
			return B.range(Math.ceil(f / r) * r, e, r).map(w).concat(B.range(Math.ceil(l / t) * t, k, t).map(x)).concat(B.range(Math.ceil(d / m) * m, c, m).filter(function(a) {
				return 1E-6 < fa(a % r)
			}).map(u)).concat(B.range(Math.ceil(h / n) * n, g, n).filter(function(a) {
				return 1E-6 < fa(a % t)
			}).map(v))
		}
		var c, d, e, f, g, h, k, l, m = 10,
			n = m,
			r = 90,
			t = 360,
			u, v, w, x, y = 2.5;
		a.lines = function() {
			return b().map(function(a) {
				return {
					type: "LineString",
					coordinates: a
				}
			})
		};
		a.outline = function() {
			return {
				type: "Polygon",
				coordinates: [w(f).concat(x(k).slice(1), w(e).reverse().slice(1), x(l).reverse().slice(1))]
			}
		};
		a.extent = function(b) {
			return arguments.length ? a.majorExtent(b).minorExtent(b) : a.minorExtent()
		};
		a.majorExtent = function(b) {
			if (!arguments.length) return [
				[f, l],
				[e, k]
			];
			f = +b[0][0];
			e = +b[1][0];
			l = +b[0][1];
			k = +b[1][1];
			f > e && (b = f, f = e, e = b);
			l > k && (b = l, l = k, k = b);
			return a.precision(y)
		};
		a.minorExtent = function(b) {
			if (!arguments.length) return [
				[d, h],
				[c, g]
			];
			d = +b[0][0];
			c = +b[1][0];
			h = +b[0][1];
			g = +b[1][1];
			d > c && (b = d, d = c, c = b);
			h > g && (b = h, h = g, g = b);
			return a.precision(y)
		};
		a.step = function(b) {
			return arguments.length ? a.majorStep(b).minorStep(b) : a.minorStep()
		};
		a.majorStep = function(b) {
			if (!arguments.length) return [r, t];
			r = +b[0];
			t = +b[1];
			return a
		};
		a.minorStep = function(b) {
			if (!arguments.length) return [m, n];
			m = +b[0];
			n = +b[1];
			return a
		};
		a.precision = function(b) {
			if (!arguments.length) return y;
			y = +b;
			u = $g(h, g, 90);
			v = ah(d, c, y);
			w = $g(l, k, 90);
			x = ah(f, e, y);
			return a
		};
		return a.majorExtent([
			[-180, -89.999999],
			[180, 89.999999]
		]).minorExtent([
			[-180, -80.000001],
			[180, 80.000001]
		])
	};
	B.geo.greatArc = function() {
		function a() {
			return {
				type: "LineString",
				coordinates: [c || b.apply(this, arguments), e || d.apply(this, arguments)]
			}
		}
		var b = Re,
			c, d = Se,
			e;
		a.distance = function() {
			return B.geo.distance(c || b.apply(this, arguments), e || d.apply(this, arguments))
		};
		a.source = function(d) {
			if (!arguments.length) return b;
			b = d;
			c = "function" === typeof d ? null : d;
			return a
		};
		a.target = function(b) {
			if (!arguments.length) return d;
			d = b;
			e = "function" === typeof b ? null : b;
			return a
		};
		a.precision = function() {
			return arguments.length ?
				a : 0
		};
		return a
	};
	B.geo.interpolate = function(a, b) {
		return mk(a[0] * ea, a[1] * ea, b[0] * ea, b[1] * ea)
	};
	B.geo.length = function(a) {
		Te = 0;
		B.geo.stream(a, jc);
		return Te
	};
	var Te, jc = {
			sphere: D,
			point: D,
			lineStart: nk,
			lineEnd: D,
			polygonStart: D,
			polygonEnd: D
		},
		li = zc(function(a) {
			return Math.sqrt(2 / (1 + a))
		}, function(a) {
			return 2 * Math.asin(a / 2)
		});
	(B.geo.azimuthalEqualArea = function() {
		return Gb(li)
	}).raw = li;
	var mi = zc(function(a) {
		return (a = Math.acos(a)) && a / Math.sin(a)
	}, v);
	(B.geo.azimuthalEquidistant = function() {
		return Gb(mi)
	}).raw = mi;
	(B.geo.conicConformal =
		function() {
			return Ne(bh)
		}).raw = bh;
	(B.geo.conicEquidistant = function() {
		return Ne(ch)
	}).raw = ch;
	var ni = zc(function(a) {
		return 1 / a
	}, Math.atan);
	(B.geo.gnomonic = function() {
		return Gb(ni)
	}).raw = ni;
	qd.invert = function(a, b) {
		return [a, 2 * Math.atan(Math.exp(b)) - Da]
	};
	(B.geo.mercator = function() {
		return dh(qd)
	}).raw = qd;
	var oi = zc(function() {
		return 1
	}, Math.asin);
	(B.geo.orthographic = function() {
		return Gb(oi)
	}).raw = oi;
	var pi = zc(function(a) {
		return 1 / (1 + a)
	}, function(a) {
		return 2 * Math.atan(a)
	});
	(B.geo.stereographic = function() {
		return Gb(pi)
	}).raw =
		pi;
	Ue.invert = function(a, b) {
		return [-b, 2 * Math.atan(Math.exp(a)) - Da]
	};
	(B.geo.transverseMercator = function() {
		var a = dh(Ue),
			b = a.center,
			c = a.rotate;
		a.center = function(a) {
			return a ? b([-a[1], a[0]]) : (a = b(), [a[1], -a[0]])
		};
		a.rotate = function(a) {
			return a ? c([a[0], a[1], 2 < a.length ? a[2] + 90 : 90]) : (a = c(), [a[0], a[1], a[2] - 90])
		};
		return c([0, 0, 90])
	}).raw = Ue;
	B.geom = {};
	B.geom.hull = function(a) {
		function b(a) {
			if (3 > a.length) return [];
			var b = pa(c),
				e = pa(d),
				f, g = a.length,
				h = [],
				k = [];
			for (f = 0; f < g; f++) h.push([+b.call(this, a[f], f), +e.call(this,
				a[f], f), f]);
			h.sort(ok);
			for (f = 0; f < g; f++) k.push([h[f][0], -h[f][1]]);
			var b = eh(h),
				k = eh(k),
				e = k[0] === b[0],
				g = k[k.length - 1] === b[b.length - 1],
				l = [];
			for (f = b.length - 1; 0 <= f; --f) l.push(a[h[b[f]][2]]);
			for (f = +e; f < k.length - g; ++f) l.push(a[h[k[f]][2]]);
			return l
		}
		var c = kc,
			d = Ac;
		if (arguments.length) return b(a);
		b.x = function(a) {
			return arguments.length ? (c = a, b) : c
		};
		b.y = function(a) {
			return arguments.length ? (d = a, b) : d
		};
		return b
	};
	B.geom.polygon = function(a) {
		Xc(a, Ld);
		return a
	};
	var Ld = B.geom.polygon.prototype = [];
	Ld.area = function() {
		for (var a = -1, b = this.length, c, d = this[b - 1], e = 0; ++a < b;) c = d, d = this[a], e += c[1] * d[0] - c[0] * d[1];
		return .5 * e
	};
	Ld.centroid = function(a) {
		var b = -1,
			c = this.length,
			d = 0,
			e = 0,
			f, g = this[c - 1],
			h;
		for (arguments.length || (a = -1 / (6 * this.area())); ++b < c;) f = g, g = this[b], h = f[0] * g[1] - g[0] * f[1], d += (f[0] + g[0]) * h, e += (f[1] + g[1]) * h;
		return [d * a, e * a]
	};
	Ld.clip = function(a) {
		for (var b, c = fh(a), d = -1, e = this.length - fh(this), f, g, h = this[e - 1], k, l, m; ++d < e;) {
			b = a.slice();
			a.length = 0;
			k = this[d];
			l = b[(g = b.length - c) - 1];
			for (f = -1; ++f < g;) m = b[f], Ve(m, h, k) ? (Ve(l, h, k) || a.push(We(l,
				m, h, k)), a.push(m)) : Ve(l, h, k) && a.push(We(l, m, h, k)), l = m;
			c && a.push(a[0]);
			h = k
		}
		return a
	};
	var oc, Vb, mc, hh = [],
		Ye, Bc, lh = [];
	jh.prototype.prepare = function() {
		for (var a = this.edges, b = a.length, c; b--;) c = a[b].edge, c.b && c.a || a.splice(b, 1);
		a.sort(kh);
		return a.length
	};
	td.prototype = {
		start: function() {
			return this.edge.l === this.site ? this.edge.a : this.edge.b
		},
		end: function() {
			return this.edge.l === this.site ? this.edge.b : this.edge.a
		}
	};
	Ze.prototype = {
		insert: function(a, b) {
			var c, d;
			if (a) {
				b.P = a;
				if (b.N = a.N) a.N.P = b;
				a.N = b;
				if (a.R) {
					for (a =
						a.R; a.L;) a = a.L;
					a.L = b
				} else a.R = b;
				c = a
			} else this._ ? (a = nh(this._), b.P = null, b.N = a, a.P = a.L = b, c = a) : (b.P = b.N = null, this._ = b, c = null);
			b.L = b.R = null;
			b.U = c;
			b.C = !0;
			for (a = b; c && c.C;) b = c.U, c === b.L ? (d = b.R) && d.C ? (c.C = d.C = !1, b.C = !0, a = b) : (a === c.R && (Dc(this, c), a = c, c = a.U), c.C = !1, b.C = !0, Ec(this, b)) : (d = b.L) && d.C ? (c.C = d.C = !1, b.C = !0, a = b) : (a === c.L && (Ec(this, c), a = c, c = a.U), c.C = !1, b.C = !0, Dc(this, b)), c = a.U;
			this._.C = !1
		},
		remove: function(a) {
			a.N && (a.N.P = a.P);
			a.P && (a.P.N = a.N);
			a.N = a.P = null;
			var b = a.U,
				c = a.L,
				d = a.R,
				e, f;
			e = c ? d ? nh(d) : c : d;
			b ? b.L ===
				a ? b.L = e : b.R = e : this._ = e;
			c && d ? (f = e.C, e.C = a.C, e.L = c, c.U = e, e !== d ? (b = e.U, e.U = a.U, a = e.R, b.L = a, e.R = d, d.U = e) : (e.U = b, b = e, a = e.R)) : (f = a.C, a = e);
			a && (a.U = b);
			if (!f)
				if (a && a.C) a.C = !1;
				else {
					do {
						if (a === this._) break;
						if (a === b.L) {
							if (a = b.R, a.C && (a.C = !1, b.C = !0, Dc(this, b), a = b.R), a.L && a.L.C || a.R && a.R.C) {
								a.R && a.R.C || (a.L.C = !1, a.C = !0, Ec(this, a), a = b.R);
								a.C = b.C;
								b.C = a.R.C = !1;
								Dc(this, b);
								a = this._;
								break
							}
						} else if (a = b.L, a.C && (a.C = !1, b.C = !0, Ec(this, b), a = b.L), a.L && a.L.C || a.R && a.R.C) {
							a.L && a.L.C || (a.R.C = !1, a.C = !0, Dc(this, a), a = b.L);
							a.C = b.C;
							b.C = a.L.C = !1;
							Ec(this, b);
							a = this._;
							break
						}
						a.C = !0;
						a = b;
						b = b.U
					} while (!a.C);
					a && (a.C = !1)
				}
		}
	};
	B.geom.voronoi = function(a) {
		function b(a) {
			var b = Array(a.length),
				d = h[0][0],
				e = h[0][1],
				f = h[1][0],
				g = h[1][1];
			$e(c(a), h).cells.forEach(function(c, h) {
				var k = c.edges;
				c = c.site;
				k = b[h] = k.length ? k.map(function(a) {
					a = a.start();
					return [a.x, a.y]
				}) : c.x >= d && c.x <= f && c.y >= e && c.y <= g ? [
					[d, g],
					[f, g],
					[f, e],
					[d, e]
				] : [];
				k.point = a[h]
			});
			return b
		}

		function c(a) {
			return a.map(function(a, b) {
				return {
					x: 1E-6 * Math.round(f(a, b) / 1E-6),
					y: 1E-6 * Math.round(g(a, b) / 1E-6),
					i: b
				}
			})
		}
		var d = kc,
			e = Ac,
			f = d,
			g = e,
			h = Md;
		if (a) return b(a);
		b.links = function(a) {
			return $e(c(a)).edges.filter(function(a) {
				return a.l && a.r
			}).map(function(b) {
				return {
					source: a[b.l.i],
					target: a[b.r.i]
				}
			})
		};
		b.triangles = function(a) {
			var b = [];
			$e(c(a)).cells.forEach(function(c, d) {
				var e = c.site;
				c = c.edges.sort(kh);
				for (var f = -1, g = c.length, h, k = c[g - 1].edge, l = k.l === e ? k.r : k.l; ++f < g;) h = k, h = l, k = c[f].edge, l = k.l === e ? k.r : k.l, d < h.i && d < l.i && 0 > (e.x - l.x) * (h.y - e.y) - (e.x - h.x) * (l.y - e.y) && b.push([a[d], a[h.i], a[l.i]])
			});
			return b
		};
		b.x = function(a) {
			return arguments.length ?
				(f = pa(d = a), b) : d
		};
		b.y = function(a) {
			return arguments.length ? (g = pa(e = a), b) : e
		};
		b.clipExtent = function(a) {
			if (!arguments.length) return h === Md ? null : h;
			h = null == a ? Md : a;
			return b
		};
		b.size = function(a) {
			return arguments.length ? b.clipExtent(a && [
				[0, 0], a
			]) : h === Md ? null : h && h[1]
		};
		return b
	};
	var Md = [
		[-1E6, -1E6],
		[1E6, 1E6]
	];
	B.geom.delaunay = function(a) {
		return B.geom.voronoi().triangles(a)
	};
	B.geom.quadtree = function(a, b, c, d, e) {
		function f(a) {
			function f(a, b, c, d, e, f, g, h) {
				if (!isNaN(c) && !isNaN(d))
					if (a.leaf) {
						var k = a.x,
							m = a.y;
						if (null !=
							k) {
							if (!(.01 > fa(k - c) + fa(m - d))) {
								var n = a.point;
								a.x = a.y = a.point = null;
								l(a, n, k, m, e, f, g, h)
							}
							l(a, b, c, d, e, f, g, h)
						} else a.x = c, a.y = d, a.point = b
					} else l(a, b, c, d, e, f, g, h)
			}

			function l(a, b, c, d, e, g, h, k) {
				var l = .5 * (e + h),
					m = .5 * (g + k),
					n = c >= l,
					r = d >= m,
					t = r << 1 | n;
				a.leaf = !1;
				a = a.nodes[t] || (a.nodes[t] = oh());
				n ? e = l : h = l;
				r ? g = m : k = m;
				f(a, b, c, d, e, g, h, k)
			}
			var m, n = pa(g),
				r = pa(h),
				t, u, v, C, w, x, y, z;
			if (null != b) w = b, x = c, y = d, z = e;
			else if (y = z = -(w = x = Infinity), t = [], u = [], C = a.length, k)
				for (v = 0; v < C; ++v) m = a[v], m.x < w && (w = m.x), m.y < x && (x = m.y), m.x > y && (y = m.x), m.y > z &&
					(z = m.y), t.push(m.x), u.push(m.y);
			else
				for (v = 0; v < C; ++v) {
					var J = +n(m = a[v], v);
					m = +r(m, v);
					J < w && (w = J);
					m < x && (x = m);
					J > y && (y = J);
					m > z && (z = m);
					t.push(J);
					u.push(m)
				}
			J = y - w;
			m = z - x;
			J > m ? z = x + J : y = w + m;
			var A = oh();
			A.add = function(a) {
				f(A, a, +n(a, ++v), +r(a, v), w, x, y, z)
			};
			A.visit = function(a) {
				Fc(a, A, w, x, y, z)
			};
			A.find = function(a) {
				return wk(A, a[0], a[1], w, x, y, z)
			};
			v = -1;
			if (null == b) {
				for (; ++v < C;) f(A, a[v], t[v], u[v], w, x, y, z);
				--v
			} else a.forEach(A.add);
			t = u = a = m = null;
			return A
		}
		var g = kc,
			h = Ac,
			k;
		if (k = arguments.length) return g = uk, h = vk, 3 === k && (e = c, d = b,
			c = b = 0), f(a);
		f.x = function(a) {
			return arguments.length ? (g = a, f) : g
		};
		f.y = function(a) {
			return arguments.length ? (h = a, f) : h
		};
		f.extent = function(a) {
			if (!arguments.length) return null == b ? null : [
				[b, c],
				[d, e]
			];
			null == a ? b = c = d = e = null : (b = +a[0][0], c = +a[0][1], d = +a[1][0], e = +a[1][1]);
			return f
		};
		f.size = function(a) {
			if (!arguments.length) return null == b ? null : [d - b, e - c];
			null == a ? b = c = d = e = null : (b = c = 0, d = +a[0], e = +a[1]);
			return f
		};
		return f
	};
	B.interpolateRgb = af;
	B.interpolateObject = ph;
	B.interpolateNumber = zb;
	B.interpolateString = qh;
	var bf = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
		cf = new RegExp(bf.source, "g");
	B.interpolate = Wb;
	B.interpolators = [function(a, b) {
		var c = typeof b;
		return ("string" === c ? Zc.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? af : qh : b instanceof Za ? af : Array.isArray(b) ? ud : "object" === c && isNaN(b) ? ph : zb)(a, b)
	}];
	B.interpolateArray = ud;
	var qi = function() {
			return v
		},
		Vl = B.map({
			linear: qi,
			poly: Bk,
			quad: function() {
				return yk
			},
			cubic: function() {
				return zk
			},
			sin: function() {
				return Ck
			},
			exp: function() {
				return Dk
			},
			circle: function() {
				return Ek
			},
			elastic: Fk,
			back: Gk,
			bounce: function() {
				return Hk
			}
		}),
		Wl = B.map({
			"in": v,
			out: rh,
			"in-out": sh,
			"out-in": function(a) {
				return sh(rh(a))
			}
		});
	B.ease = function(a) {
		var b = a.indexOf("-"),
			c = 0 <= b ? a.slice(0, b) : a,
			b = 0 <= b ? a.slice(b + 1) : "in",
			c = Vl.get(c) || qi,
			b = Wl.get(b) || v;
		return xk(b(c.apply(null, fi.call(arguments, 1))))
	};
	B.interpolateHcl = Ik;
	B.interpolateHsl = Jk;
	B.interpolateLab = Kk;
	B.interpolateRound = th;
	B.transform = function(a) {
		var b = Ta.createElementNS(B.ns.prefix.svg, "g");
		return (B.transform = function(a) {
			if (null != a) {
				b.setAttribute("transform", a);
				var c = b.transform.baseVal.consolidate()
			}
			return new uh(c ?
				c.matrix : Xl)
		})(a)
	};
	uh.prototype.toString = function() {
		return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")"
	};
	var Xl = {
		a: 1,
		b: 0,
		c: 0,
		d: 1,
		e: 0,
		f: 0
	};
	B.interpolateTransform = wh;
	B.layout = {};
	B.layout.bundle = function() {
		return function(a) {
			for (var b = [], c = -1, d = a.length; ++c < d;) b.push(Rk(a[c]));
			return b
		}
	};
	B.layout.chord = function() {
		function a() {
			var a = {},
				c = [],
				n = B.range(g),
				r = [],
				t, u, v, C, w;
			d = [];
			e = [];
			t = 0;
			for (C = -1; ++C < g;) {
				u = 0;
				for (w = -1; ++w < g;) u += f[C][w];
				c.push(u);
				r.push(B.range(g));
				t += u
			}
			k && n.sort(function(a, b) {
				return k(c[a], c[b])
			});
			l && r.forEach(function(a, b) {
				a.sort(function(a, c) {
					return l(f[b][a], f[b][c])
				})
			});
			t = (bb - h * g) / t;
			u = 0;
			for (C = -1; ++C < g;) {
				v = u;
				for (w = -1; ++w < g;) {
					var x = n[C],
						y = r[x][w],
						z = f[x][y],
						J = u,
						A = u += z * t;
					a[x + "-" + y] = {
						index: x,
						subindex: y,
						startAngle: J,
						endAngle: A,
						value: z
					}
				}
				e[x] = {
					index: x,
					startAngle: v,
					endAngle: u,
					value: c[x]
				};
				u += h
			}
			for (C = -1; ++C < g;)
				for (w = C - 1; ++w < g;) n = a[C + "-" + w], r = a[w + "-" + C], (n.value || r.value) && d.push(n.value < r.value ? {
					source: r,
					target: n
				} : {
					source: n,
					target: r
				});
			m && b()
		}

		function b() {
			d.sort(function(a,
				b) {
				return m((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2)
			})
		}
		var c = {},
			d, e, f, g, h = 0,
			k, l, m;
		c.matrix = function(a) {
			if (!arguments.length) return f;
			g = (f = a) && f.length;
			d = e = null;
			return c
		};
		c.padding = function(a) {
			if (!arguments.length) return h;
			h = a;
			d = e = null;
			return c
		};
		c.sortGroups = function(a) {
			if (!arguments.length) return k;
			k = a;
			d = e = null;
			return c
		};
		c.sortSubgroups = function(a) {
			if (!arguments.length) return l;
			l = a;
			d = null;
			return c
		};
		c.sortChords = function(a) {
			if (!arguments.length) return m;
			m = a;
			d && b();
			return c
		};
		c.chords = function() {
			d || a();
			return d
		};
		c.groups = function() {
			e || a();
			return e
		};
		return c
	};
	B.layout.force = function() {
		function a(a) {
			return function(b, c, d, e) {
				if (b.point !== a) {
					var f = b.cx - a.x,
						g = b.cy - a.y;
					c = e - c;
					e = f * f + g * g;
					if (c * c / u < e) return e < r && (c = b.charge / e, a.px -= f * c, a.py -= g * c), !0;
					b.point && e && e < r && (c = b.pointCharge / e, a.px -= f * c, a.py -= g * c)
				}
				return !b.charge
			}
		}

		function b(a) {
			a.px = B.event.x;
			a.py = B.event.y;
			c.resume()
		}
		var c = {},
			d = B.dispatch("start", "tick", "end"),
			e, f = [1, 1],
			g, h, k = .9,
			l = Yl,
			m = Zl,
			n = -30,
			r = $l,
			t = .1,
			u = .64,
			w = [],
			x = [],
			y, z, J;
		c.tick = function() {
			if (.005 > (h *= .99)) return e = null, d.end({
				type: "end",
				alpha: h = 0
			}), !0;
			var b = w.length,
				c = x.length,
				g, l, m, r, u, v, C;
			for (g = 0; g < c; ++g)
				if (l = x[g], m = l.source, r = l.target, v = r.x - m.x, C = r.y - m.y, u = v * v + C * C) u = h * z[g] * ((u = Math.sqrt(u)) - y[g]) / u, v *= u, C *= u, r.x -= v * (u = m.weight + r.weight ? m.weight / (m.weight + r.weight) : .5), r.y -= C * u, m.x += v * (u = 1 - u), m.y += C * u;
			if (u = h * t)
				if (v = f[0] / 2, C = f[1] / 2, g = -1, u)
					for (; ++g < b;) l = w[g], l.x += (v - l.x) * u, l.y += (C - l.y) * u;
			if (n)
				for (yh(c = B.geom.quadtree(w), h, J), g = -1; ++g < b;)(l = w[g]).fixed || c.visit(a(l));
			for (g = -1; ++g < b;) l = w[g], l.fixed ? (l.x = l.px, l.y = l.py) : (l.x -= (l.px - (l.px = l.x)) * k, l.y -= (l.py - (l.py = l.y)) * k);
			d.tick({
				type: "tick",
				alpha: h
			})
		};
		c.nodes = function(a) {
			if (!arguments.length) return w;
			w = a;
			return c
		};
		c.links = function(a) {
			if (!arguments.length) return x;
			x = a;
			return c
		};
		c.size = function(a) {
			if (!arguments.length) return f;
			f = a;
			return c
		};
		c.linkDistance = function(a) {
			if (!arguments.length) return l;
			l = "function" === typeof a ? a : +a;
			return c
		};
		c.distance = c.linkDistance;
		c.linkStrength = function(a) {
			if (!arguments.length) return m;
			m = "function" === typeof a ? a : +a;
			return c
		};
		c.friction = function(a) {
			if (!arguments.length) return k;
			k = +a;
			return c
		};
		c.charge = function(a) {
			if (!arguments.length) return n;
			n = "function" === typeof a ? a : +a;
			return c
		};
		c.chargeDistance = function(a) {
			if (!arguments.length) return Math.sqrt(r);
			r = a * a;
			return c
		};
		c.gravity = function(a) {
			if (!arguments.length) return t;
			t = +a;
			return c
		};
		c.theta = function(a) {
			if (!arguments.length) return Math.sqrt(u);
			u = a * a;
			return c
		};
		c.alpha = function(a) {
			if (!arguments.length) return h;
			a = +a;
			h ? 0 < a ? h = a : (e.c = null,
				e.t = NaN, e = null, d.end({
					type: "end",
					alpha: h = 0
				})) : 0 < a && (d.start({
				type: "start",
				alpha: h = a
			}), e = ua(c.tick));
			return c
		};
		c.start = function() {
			function a(a, c) {
				if (!k) {
					k = Array(d);
					for (g = 0; g < d; ++g) k[g] = [];
					for (g = 0; g < e; ++g) {
						var f = x[g];
						k[f.source.index].push(f.target);
						k[f.target.index].push(f.source)
					}
				}
				for (var f = k[b], g = -1, h = f.length, l; ++g < h;)
					if (!isNaN(l = f[g][a])) return l;
				return Math.random() * c
			}
			var b, d = w.length,
				e = x.length,
				g = f[0],
				h = f[1],
				k, r;
			for (b = 0; b < d; ++b)(r = w[b]).index = b, r.weight = 0;
			for (b = 0; b < e; ++b) r = x[b], "number" == typeof r.source &&
				(r.source = w[r.source]), "number" == typeof r.target && (r.target = w[r.target]), ++r.source.weight, ++r.target.weight;
			for (b = 0; b < d; ++b) r = w[b], isNaN(r.x) && (r.x = a("x", g)), isNaN(r.y) && (r.y = a("y", h)), isNaN(r.px) && (r.px = r.x), isNaN(r.py) && (r.py = r.y);
			y = [];
			if ("function" === typeof l)
				for (b = 0; b < e; ++b) y[b] = +l.call(this, x[b], b);
			else
				for (b = 0; b < e; ++b) y[b] = l;
			z = [];
			if ("function" === typeof m)
				for (b = 0; b < e; ++b) z[b] = +m.call(this, x[b], b);
			else
				for (b = 0; b < e; ++b) z[b] = m;
			J = [];
			if ("function" === typeof n)
				for (b = 0; b < d; ++b) J[b] = +n.call(this, w[b],
					b);
			else
				for (b = 0; b < d; ++b) J[b] = n;
			return c.resume()
		};
		c.resume = function() {
			return c.alpha(.1)
		};
		c.stop = function() {
			return c.alpha(0)
		};
		c.drag = function() {
			g || (g = B.behavior.drag().origin(v).on("dragstart.force", Sk).on("drag.force", b).on("dragend.force", Tk));
			if (!arguments.length) return g;
			this.on("mouseover.force", Uk).on("mouseout.force", Vk).call(g)
		};
		return B.rebind(c, d, "on")
	};
	var Yl = 20,
		Zl = 1,
		$l = Infinity;
	B.layout.hierarchy = function() {
		function a(e) {
			var f = [e],
				g = [],
				h;
			for (e.depth = 0; null != (h = f.pop());)
				if (g.push(h),
					(l = c.call(a, h, h.depth)) && (k = l.length)) {
					for (var k, l, m; 0 <= --k;) f.push(m = l[k]), m.parent = h, m.depth = h.depth + 1;
					d && (h.value = 0);
					h.children = l
				} else d && (h.value = +d.call(a, h, h.depth) || 0), delete h.children;
			qb(e, function(a) {
				var c, e;
				b && (c = a.children) && c.sort(b);
				d && (e = a.parent) && (e.value += a.value)
			});
			return g
		}
		var b = Zk,
			c = Xk,
			d = Yk;
		a.sort = function(c) {
			if (!arguments.length) return b;
			b = c;
			return a
		};
		a.children = function(b) {
			if (!arguments.length) return c;
			c = b;
			return a
		};
		a.value = function(b) {
			if (!arguments.length) return d;
			d = b;
			return a
		};
		a.revalue = function(b) {
			d && (Hc(b, function(a) {
				a.children && (a.value = 0)
			}), qb(b, function(b) {
				var c;
				b.children || (b.value = +d.call(a, b, b.depth) || 0);
				if (c = b.parent) c.value += b.value
			}));
			return b
		};
		return a
	};
	B.layout.partition = function() {
		function a(b, c, d, e) {
			var f = b.children;
			b.x = c;
			b.y = b.depth * e;
			b.dx = d;
			b.dy = e;
			if (f && (h = f.length)) {
				var g = -1,
					h, k;
				for (d = b.value ? d / b.value : 0; ++g < h;) a(k = f[g], c, b = k.value * d, e), c += b
			}
		}

		function b(a) {
			a = a.children;
			var c = 0;
			if (a && (e = a.length))
				for (var d = -1, e; ++d < e;) c = Math.max(c, b(a[d]));
			return 1 + c
		}

		function c(c,
			f) {
			c = d.call(this, c, f);
			a(c[0], 0, e[0], e[1] / b(c[0]));
			return c
		}
		var d = B.layout.hierarchy(),
			e = [1, 1];
		c.size = function(a) {
			if (!arguments.length) return e;
			e = a;
			return c
		};
		return Gc(c, d)
	};
	B.layout.pie = function() {
		function a(g) {
			var h = g.length,
				k = g.map(function(c, d) {
					return +b.call(a, c, d)
				}),
				l = +("function" === typeof d ? d.apply(this, arguments) : d),
				m = ("function" === typeof e ? e.apply(this, arguments) : e) - l,
				n = Math.min(Math.abs(m) / h, +("function" === typeof f ? f.apply(this, arguments) : f)),
				r = n * (0 > m ? -1 : 1),
				t = B.sum(k),
				u = t ? (m - h * r) / t : 0,
				h = B.range(h),
				v = [],
				w;
			null != c && h.sort(c === ri ? function(a, b) {
				return k[b] - k[a]
			} : function(a, b) {
				return c(g[a], g[b])
			});
			h.forEach(function(a) {
				v[a] = {
					data: g[a],
					value: w = k[a],
					startAngle: l,
					endAngle: l += w * u + r,
					padAngle: n
				}
			});
			return v
		}
		var b = Number,
			c = ri,
			d = 0,
			e = bb,
			f = 0;
		a.value = function(c) {
			if (!arguments.length) return b;
			b = c;
			return a
		};
		a.sort = function(b) {
			if (!arguments.length) return c;
			c = b;
			return a
		};
		a.startAngle = function(b) {
			if (!arguments.length) return d;
			d = b;
			return a
		};
		a.endAngle = function(b) {
			if (!arguments.length) return e;
			e = b;
			return a
		};
		a.padAngle =
			function(b) {
				if (!arguments.length) return f;
				f = b;
				return a
			};
		return a
	};
	var ri = {};
	B.layout.stack = function() {
		function a(h, k) {
			if (!(r = h.length)) return h;
			var l = h.map(function(c, d) {
					return b.call(a, c, d)
				}),
				m = l.map(function(b) {
					return b.map(function(b, c) {
						return [f.call(a, b, c), g.call(a, b, c)]
					})
				}),
				n = c.call(a, m, k),
				l = B.permute(l, n),
				m = B.permute(m, n);
			k = d.call(a, m, k);
			var n = l[0].length,
				r, t, u, v;
			for (u = 0; u < n; ++u)
				for (e.call(a, l[0][u], v = k[u], m[0][u][1]), t = 1; t < r; ++t) e.call(a, l[t][u], v += m[t - 1][u][1], m[t][u][1]);
			return h
		}
		var b = v,
			c = df,
			d = ef,
			e = bl,
			f = $k,
			g = al;
		a.values = function(c) {
			if (!arguments.length) return b;
			b = c;
			return a
		};
		a.order = function(b) {
			if (!arguments.length) return c;
			c = "function" === typeof b ? b : am.get(b) || df;
			return a
		};
		a.offset = function(b) {
			if (!arguments.length) return d;
			d = "function" === typeof b ? b : bm.get(b) || ef;
			return a
		};
		a.x = function(b) {
			if (!arguments.length) return f;
			f = b;
			return a
		};
		a.y = function(b) {
			if (!arguments.length) return g;
			g = b;
			return a
		};
		a.out = function(b) {
			if (!arguments.length) return e;
			e = b;
			return a
		};
		return a
	};
	var am = B.map({
			"inside-out": function(a) {
				var b =
					a.length,
					c, d = a.map(cl),
					e = a.map(dl),
					f = B.range(b).sort(function(a, b) {
						return d[a] - d[b]
					}),
					g = 0,
					h = 0,
					k = [],
					l = [];
				for (a = 0; a < b; ++a) c = f[a], g < h ? (g += e[c], k.push(c)) : (h += e[c], l.push(c));
				return l.reverse().concat(k)
			},
			reverse: function(a) {
				return B.range(a.length).reverse()
			},
			"default": df
		}),
		bm = B.map({
			silhouette: function(a) {
				var b = a.length,
					c = a[0].length,
					d = [],
					e = 0,
					f, g, h, k = [];
				for (g = 0; g < c; ++g) {
					for (h = f = 0; f < b; f++) h += a[f][g][1];
					h > e && (e = h);
					d.push(h)
				}
				for (g = 0; g < c; ++g) k[g] = (e - d[g]) / 2;
				return k
			},
			wiggle: function(a) {
				var b = a.length,
					c =
					a[0],
					d = c.length,
					e, f, g, h, k, l, m, n, r, t = [];
				t[0] = n = r = 0;
				for (f = 1; f < d; ++f) {
					for (h = e = 0; e < b; ++e) h += a[e][f][1];
					k = e = 0;
					for (m = c[f][0] - c[f - 1][0]; e < b; ++e) {
						g = 0;
						for (l = (a[e][f][1] - a[e][f - 1][1]) / (2 * m); g < e; ++g) l += (a[g][f][1] - a[g][f - 1][1]) / m;
						k += l * a[e][f][1]
					}
					t[f] = n -= h ? k / h * m : 0;
					n < r && (r = n)
				}
				for (f = 0; f < d; ++f) t[f] -= r;
				return t
			},
			expand: function(a) {
				var b = a.length,
					c = a[0].length,
					d = 1 / b,
					e, f, g, h = [];
				for (f = 0; f < c; ++f) {
					for (g = e = 0; e < b; e++) g += a[e][f][1];
					if (g)
						for (e = 0; e < b; e++) a[e][f][1] /= g;
					else
						for (e = 0; e < b; e++) a[e][f][1] = d
				}
				for (f = 0; f < c; ++f) h[f] =
					0;
				return h
			},
			zero: ef
		});
	B.layout.histogram = function() {
		function a(a, f) {
			var g = [],
				h = a.map(c, this),
				k = d.call(this, h, f),
				l = e.call(this, k, h, f),
				m;
			f = -1;
			for (var n = h.length, r = l.length - 1, t = b ? 1 : 1 / n; ++f < r;) m = g[f] = [], m.dx = l[f + 1] - (m.x = l[f]), m.y = 0;
			if (0 < r)
				for (f = -1; ++f < n;) m = h[f], m >= k[0] && m <= k[1] && (m = g[B.bisect(l, m, 1, r) - 1], m.y += t, m.push(a[f]));
			return g
		}
		var b = !0,
			c = Number,
			d = gl,
			e = fl;
		a.value = function(b) {
			if (!arguments.length) return c;
			c = b;
			return a
		};
		a.range = function(b) {
			if (!arguments.length) return d;
			d = pa(b);
			return a
		};
		a.bins = function(b) {
			if (!arguments.length) return e;
			e = "number" === typeof b ? function(a) {
				return zh(a, b)
			} : pa(b);
			return a
		};
		a.frequency = function(c) {
			if (!arguments.length) return b;
			b = !!c;
			return a
		};
		return a
	};
	B.layout.pack = function() {
		function a(a, f) {
			a = b.call(this, a, f);
			f = a[0];
			var g = d[0],
				h = d[1],
				k = null == e ? Math.sqrt : "function" === typeof e ? e : function() {
					return e
				};
			f.x = f.y = 0;
			qb(f, function(a) {
				a.r = +k(a.value)
			});
			qb(f, Ch);
			if (c) {
				var l = c * (e ? 1 : Math.max(2 * f.r / g, 2 * f.r / h)) / 2;
				qb(f, function(a) {
					a.r += l
				});
				qb(f, Ch);
				qb(f, function(a) {
					a.r -= l
				})
			}
			Eh(f, g / 2, h / 2, e ? 1 : 1 / Math.max(2 * f.r / g, 2 * f.r /
				h));
			return a
		}
		var b = B.layout.hierarchy().sort(hl),
			c = 0,
			d = [1, 1],
			e;
		a.size = function(b) {
			if (!arguments.length) return d;
			d = b;
			return a
		};
		a.radius = function(b) {
			if (!arguments.length) return e;
			e = null == b || "function" === typeof b ? b : +b;
			return a
		};
		a.padding = function(b) {
			if (!arguments.length) return c;
			c = +b;
			return a
		};
		return Gc(a, b)
	};
	B.layout.tree = function() {
		function a(a, l) {
			a = f.call(this, a, l);
			l = a[0];
			var m = b(l);
			qb(m, c);
			m.parent.m = -m.z;
			Hc(m, d);
			if (k) Hc(l, e);
			else {
				var n = l,
					r = l,
					t = l;
				Hc(l, function(a) {
					a.x < n.x && (n = a);
					a.x > r.x && (r = a);
					a.depth >
						t.depth && (t = a)
				});
				var u = g(n, r) / 2 - n.x,
					v = h[0] / (r.x + g(r, n) / 2 + u),
					w = h[1] / (t.depth || 1);
				Hc(l, function(a) {
					a.x = (a.x + u) * v;
					a.y = a.depth * w
				})
			}
			return a
		}

		function b(a) {
			a = {
				A: null,
				children: [a]
			};
			for (var b = [a], c; null != (c = b.pop());)
				for (var d = c.children, e, f = 0, g = d.length; f < g; ++f) b.push((d[f] = e = {
					_: d[f],
					parent: c,
					children: (e = d[f].children) && e.slice() || [],
					A: null,
					a: null,
					z: 0,
					m: 0,
					c: 0,
					s: 0,
					t: null,
					i: f
				}).a = e);
			return a.children[0]
		}

		function c(a) {
			var b = a.children,
				c = a.parent.children,
				d = a.i ? c[a.i - 1] : null;
			if (b.length) {
				for (var e = 0, f = 0, h = a.children,
						k = h.length, l; 0 <= --k;) l = h[k], l.z += e, l.m += e, e += l.s + (f += l.c);
				b = (b[0].z + b[b.length - 1].z) / 2;
				d ? (a.z = d.z + g(a._, d._), a.m = a.z - b) : a.z = b
			} else d && (a.z = d.z + g(a._, d._));
			b = a.parent;
			e = a;
			a = a.parent.A || c[0];
			if (d) {
				f = c = e;
				h = c.parent.children[0];
				k = c.m;
				l = f.m;
				for (var m = d.m, n = h.m, r; d = hf(d), c = gf(c), d && c;) {
					h = gf(h);
					f = hf(f);
					f.a = e;
					r = d.z + m - c.z - k + g(d._, c._);
					if (0 < r) {
						var t = d.a.parent === e.parent ? d.a : a,
							u = e,
							v = r,
							w = v / (u.i - t.i);
						u.c -= w;
						u.s += v;
						t.c += w;
						u.z += v;
						u.m += v;
						k += r;
						l += r
					}
					m += d.m;
					k += c.m;
					n += h.m;
					l += f.m
				}
				d && !hf(f) && (f.t = d, f.m += m - l);
				c && !gf(h) &&
					(h.t = c, h.m += k - n, a = e)
			}
			e = a;
			b.A = e
		}

		function d(a) {
			a._.x = a.z + a.parent.m;
			a.m += a.parent.m
		}

		function e(a) {
			a.x *= h[0];
			a.y = a.depth * h[1]
		}
		var f = B.layout.hierarchy().sort(null).value(null),
			g = Fh,
			h = [1, 1],
			k = null;
		a.separation = function(b) {
			if (!arguments.length) return g;
			g = b;
			return a
		};
		a.size = function(b) {
			if (!arguments.length) return k ? null : h;
			k = null == (h = b) ? e : null;
			return a
		};
		a.nodeSize = function(b) {
			if (!arguments.length) return k ? h : null;
			k = null == (h = b) ? null : e;
			return a
		};
		return Gc(a, f)
	};
	B.layout.cluster = function() {
		function a(a, f) {
			a =
				b.call(this, a, f);
			var g = a[0],
				h, k = 0;
			qb(g, function(a) {
				var b = a.children;
				b && b.length ? (a.x = ll(b), a.y = kl(b)) : (a.x = h ? k += c(a, h) : 0, a.y = 0, h = a)
			});
			f = Gh(g);
			var l = Hh(g),
				m = f.x - c(f, l) / 2,
				n = l.x + c(l, f) / 2;
			qb(g, e ? function(a) {
				a.x = (a.x - g.x) * d[0];
				a.y = (g.y - a.y) * d[1]
			} : function(a) {
				a.x = (a.x - m) / (n - m) * d[0];
				a.y = (1 - (g.y ? a.y / g.y : 1)) * d[1]
			});
			return a
		}
		var b = B.layout.hierarchy().sort(null).value(null),
			c = Fh,
			d = [1, 1],
			e = !1;
		a.separation = function(b) {
			if (!arguments.length) return c;
			c = b;
			return a
		};
		a.size = function(b) {
			if (!arguments.length) return e ?
				null : d;
			e = null == (d = b);
			return a
		};
		a.nodeSize = function(b) {
			if (!arguments.length) return e ? d : null;
			e = null != (d = b);
			return a
		};
		return Gc(a, b)
	};
	B.layout.treemap = function() {
		function a(a, b) {
			for (var c = -1, d = a.length, e, f; ++c < d;) f = (e = a[c]).value * (0 > b ? 0 : b), e.area = isNaN(f) || 0 >= f ? 0 : f
		}

		function b(c) {
			var e = c.children;
			if (e && e.length) {
				var f = l(c),
					g = [],
					h = e.slice(),
					k = Infinity,
					m, n = "slice" === r ? f.dx : "dice" === r ? f.dy : "slice-dice" === r ? c.depth & 1 ? f.dy : f.dx : Math.min(f.dx, f.dy);
				a(h, f.dx * f.dy / c.value);
				for (g.area = 0; 0 < (c = h.length);) {
					g.push(c =
						h[c - 1]);
					g.area += c.area;
					if (!(c = "squarify" !== r)) {
						m = void 0;
						c = n;
						for (var u = g.area, v = 0, w = Infinity, x = -1, C = g.length; ++x < C;)
							if (m = g[x].area) m < w && (w = m), m > v && (v = m);
						u *= u;
						c *= c;
						m = u ? Math.max(c * v * t / u, u / (c * w * t)) : Infinity;
						c = m <= k
					}
					c ? (h.pop(), k = m) : (g.area -= g.pop().area, d(g, n, f, !1), n = Math.min(f.dx, f.dy), g.length = g.area = 0, k = Infinity)
				}
				g.length && (d(g, n, f, !0), g.length = g.area = 0);
				e.forEach(b)
			}
		}

		function c(b) {
			var e = b.children;
			if (e && e.length) {
				var f = l(b),
					g = e.slice(),
					h = [];
				a(g, f.dx * f.dy / b.value);
				for (h.area = 0; b = g.pop();) h.push(b), h.area +=
					b.area, null != b.z && (d(h, b.z ? f.dx : f.dy, f, !g.length), h.length = h.area = 0);
				e.forEach(c)
			}
		}

		function d(a, b, c, d) {
			var e = -1,
				f = a.length,
				h = c.x,
				k = c.y,
				l = b ? g(a.area / b) : 0,
				m;
			if (b == c.dx) {
				if (d || l > c.dy) l = c.dy;
				for (; ++e < f;) m = a[e], m.x = h, m.y = k, m.dy = l, h += m.dx = Math.min(c.x + c.dx - h, l ? g(m.area / l) : 0);
				m.z = !0;
				m.dx += c.x + c.dx - h;
				c.y += l;
				c.dy -= l
			} else {
				if (d || l > c.dx) l = c.dx;
				for (; ++e < f;) m = a[e], m.x = h, m.y = k, m.dx = l, k += m.dy = Math.min(c.y + c.dy - k, l ? g(m.area / l) : 0);
				m.z = !1;
				m.dy += c.y + c.dy - k;
				c.x += l;
				c.dx -= l
			}
		}

		function e(d) {
			d = n || f(d);
			var e = d[0];
			e.x = e.y = 0;
			e.value ? (e.dx = h[0], e.dy = h[1]) : e.dx = e.dy = 0;
			n && f.revalue(e);
			a([e], e.dx * e.dy / e.value);
			(n ? c : b)(e);
			m && (n = d);
			return d
		}
		var f = B.layout.hierarchy(),
			g = Math.round,
			h = [1, 1],
			k = null,
			l = jf,
			m = !1,
			n, r = "squarify",
			t = .5 * (1 + Math.sqrt(5));
		e.size = function(a) {
			if (!arguments.length) return h;
			h = a;
			return e
		};
		e.padding = function(a) {
			function b(b) {
				var c = a.call(e, b, b.depth);
				return null == c ? jf(b) : Ih(b, "number" === typeof c ? [c, c, c, c] : c)
			}

			function c(b) {
				return Ih(b, a)
			}
			if (!arguments.length) return k;
			var d;
			l = null == (k = a) ? jf : "function" === (d = typeof a) ?
				b : "number" === d ? (a = [a, a, a, a], c) : c;
			return e
		};
		e.round = function(a) {
			if (!arguments.length) return g != Number;
			g = a ? Math.round : Number;
			return e
		};
		e.sticky = function(a) {
			if (!arguments.length) return m;
			m = a;
			n = null;
			return e
		};
		e.ratio = function(a) {
			if (!arguments.length) return t;
			t = a;
			return e
		};
		e.mode = function(a) {
			if (!arguments.length) return r;
			r = a + "";
			return e
		};
		return Gc(e, f)
	};
	B.random = {
		normal: function(a, b) {
			var c = arguments.length;
			2 > c && (b = 1);
			1 > c && (a = 0);
			return function() {
				var c, d;
				do c = 2 * Math.random() - 1, d = 2 * Math.random() - 1, d = c * c +
					d * d; while (!d || 1 < d);
				return a + b * c * Math.sqrt(-2 * Math.log(d) / d)
			}
		},
		logNormal: function() {
			var a = B.random.normal.apply(B, arguments);
			return function() {
				return Math.exp(a())
			}
		},
		bates: function(a) {
			var b = B.random.irwinHall(a);
			return function() {
				return b() / a
			}
		},
		irwinHall: function(a) {
			return function() {
				for (var b = 0, c = 0; c < a; c++) b += Math.random();
				return b
			}
		}
	};
	B.scale = {};
	var nl = {
		floor: v,
		ceil: v
	};
	B.scale.linear = function() {
		return Kh([0, 1], [0, 1], Wb, !1)
	};
	var ql = {
		s: 1,
		g: 1,
		p: 1,
		r: 1,
		e: 1
	};
	B.scale.log = function() {
		return Mh(B.scale.linear().domain([0,
			1
		]), 10, !0, [1, 10])
	};
	var Nh = B.format(".0e"),
		rl = {
			floor: function(a) {
				return -Math.ceil(-a)
			},
			ceil: function(a) {
				return -Math.floor(-a)
			}
		};
	B.scale.pow = function() {
		return Oh(B.scale.linear(), 1, [0, 1])
	};
	B.scale.sqrt = function() {
		return B.scale.pow().exponent(.5)
	};
	B.scale.ordinal = function() {
		return Ph([], {
			t: "range",
			a: [
				[]
			]
		})
	};
	B.scale.category10 = function() {
		return B.scale.ordinal().range(cm)
	};
	B.scale.category20 = function() {
		return B.scale.ordinal().range(dm)
	};
	B.scale.category20b = function() {
		return B.scale.ordinal().range(em)
	};
	B.scale.category20c = function() {
		return B.scale.ordinal().range(fm)
	};
	var cm = [2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175].map(wb),
		dm = [2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725].map(wb),
		em = [3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683,
			10834324, 13528509, 14589654
		].map(wb),
		fm = [3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081].map(wb);
	B.scale.quantile = function() {
		return Qh([], [])
	};
	B.scale.quantize = function() {
		return Rh(0, 1, [0, 1])
	};
	B.scale.threshold = function() {
		return Sh([.5], [0, 1])
	};
	B.scale.identity = function() {
		return Th([0, 1])
	};
	B.svg = {};
	B.svg.arc = function() {
		function a() {
			var a = Math.max(0, +c.apply(this, arguments)),
				l = Math.max(0, +d.apply(this, arguments)),
				m = g.apply(this, arguments) - Da,
				n = h.apply(this, arguments) - Da,
				r = Math.abs(n - m),
				t = m > n ? 0 : 1;
			l < a && (u = l, l = a, a = u);
			if (r >= Sl) return b(l, t) + (a ? b(a, 1 - t) : "") + "Z";
			var u, v, w, x, y = 0,
				C = 0,
				z, J, A, D, K, na = [];
			if (x = (+k.apply(this, arguments) || 0) / 2) w = f === Nd ? Math.sqrt(a * a + l * l) : +f.apply(this, arguments), t || (C *= -1), l && (C = Ja(w / l * Math.sin(x))), a && (y = Ja(w / a * Math.sin(x)));
			l ? (w = l * Math.cos(m + C), x = l * Math.sin(m + C), z = l * Math.cos(n - C), J = l * Math.sin(n - C), v = Math.abs(n - m - 2 * C) <= da ? 0 : 1, C && zd(w, x, z, J) === t ^ v &&
				(z = (m + n) / 2, w = l * Math.cos(z), x = l * Math.sin(z), z = J = null)) : w = x = 0;
			if (a) {
				C = a * Math.cos(n - y);
				A = a * Math.sin(n - y);
				D = a * Math.cos(m + y);
				K = a * Math.sin(m + y);
				var B = Math.abs(m - n + 2 * y) <= da ? 0 : 1;
				y && zd(C, A, D, K) === 1 - t ^ B && (D = (m + n) / 2, C = a * Math.cos(D), A = a * Math.sin(D), D = K = null)
			} else C = A = 0;
			1E-6 < r && .001 < (u = Math.min(Math.abs(l - a) / 2, +e.apply(this, arguments))) ? (v = a < l ^ t ? 0 : 1, B = m = u, r < da && (r = null == D ? [C, A] : null == z ? [w, x] : We([w, x], [D, K], [z, J], [C, A]), B = w - r[0], m = x - r[1], n = z - r[0], y = J - r[1], m = 1 / Math.sin(Math.acos((B * n + m * y) / (Math.sqrt(B * B + m * m) * Math.sqrt(n *
				n + y * y))) / 2), r = Math.sqrt(r[0] * r[0] + r[1] * r[1]), B = Math.min(u, (a - r) / (m - 1)), m = Math.min(u, (l - r) / (m + 1))), null != z ? (r = Ad(null == D ? [C, A] : [D, K], [w, x], l, m, t), n = Ad([z, J], [C, A], l, m, t), u === m ? na.push("M", r[0], "A", m, ",", m, " 0 0,", v, " ", r[1], "A", l, ",", l, " 0 ", 1 - t ^ zd(r[1][0], r[1][1], n[1][0], n[1][1]), ",", t, " ", n[1], "A", m, ",", m, " 0 0,", v, " ", n[0]) : na.push("M", r[0], "A", m, ",", m, " 0 1,", v, " ", n[0])) : na.push("M", w, ",", x), null != D ? (l = Ad([w, x], [D, K], a, -B, t), z = Ad([C, A], null == z ? [w, x] : [z, J], a, -B, t), u === B ? na.push("L", z[0], "A", B,
				",", B, " 0 0,", v, " ", z[1], "A", a, ",", a, " 0 ", t ^ zd(z[1][0], z[1][1], l[1][0], l[1][1]), ",", 1 - t, " ", l[1], "A", B, ",", B, " 0 0,", v, " ", l[0]) : na.push("L", z[0], "A", B, ",", B, " 0 0,", v, " ", l[0])) : na.push("L", C, ",", A)) : (na.push("M", w, ",", x), null != z && na.push("A", l, ",", l, " 0 ", v, ",", t, " ", z, ",", J), na.push("L", C, ",", A), null != D && na.push("A", a, ",", a, " 0 ", B, ",", 1 - t, " ", D, ",", K));
			na.push("Z");
			return na.join("")
		}

		function b(a, b) {
			return "M0," + a + "A" + a + "," + a + " 0 1," + b + " 0," + -a + "A" + a + "," + a + " 0 1," + b + " 0," + a
		}
		var c = tl,
			d = ul,
			e = sl,
			f = Nd,
			g = Uh,
			h = Vh,
			k = vl;
		a.innerRadius = function(b) {
			if (!arguments.length) return c;
			c = pa(b);
			return a
		};
		a.outerRadius = function(b) {
			if (!arguments.length) return d;
			d = pa(b);
			return a
		};
		a.cornerRadius = function(b) {
			if (!arguments.length) return e;
			e = pa(b);
			return a
		};
		a.padRadius = function(b) {
			if (!arguments.length) return f;
			f = b == Nd ? Nd : pa(b);
			return a
		};
		a.startAngle = function(b) {
			if (!arguments.length) return g;
			g = pa(b);
			return a
		};
		a.endAngle = function(b) {
			if (!arguments.length) return h;
			h = pa(b);
			return a
		};
		a.padAngle = function(b) {
			if (!arguments.length) return k;
			k = pa(b);
			return a
		};
		a.centroid = function() {
			var a = (+c.apply(this, arguments) + +d.apply(this, arguments)) / 2,
				b = (+g.apply(this, arguments) + +h.apply(this, arguments)) / 2 - Da;
			return [Math.cos(b) * a, Math.sin(b) * a]
		};
		return a
	};
	var Nd = "auto";
	B.svg.line = function() {
		return Wh(v)
	};
	var mf = B.map({
		linear: kb,
		"linear-closed": Xh,
		step: wl,
		"step-before": nf,
		"step-after": of,
		basis: Yh,
		"basis-open": Al,
		"basis-closed": Bl,
		bundle: Cl,
		cardinal: zl,
		"cardinal-open": xl,
		"cardinal-closed": yl,
		monotone: Dl
	});
	mf.forEach(function(a, b) {
		b.key = a;
		b.closed =
			/-closed$/.test(a)
	});
	var Zh = [0, 2 / 3, 1 / 3, 0],
		$h = [0, 1 / 3, 2 / 3, 0],
		Ib = [0, 1 / 6, 2 / 3, 1 / 6];
	B.svg.line.radial = function() {
		var a = Wh(ai);
		a.radius = a.x;
		delete a.x;
		a.angle = a.y;
		delete a.y;
		return a
	};
	nf.reverse = of;
	of.reverse = nf;
	B.svg.area = function() {
		return bi(v)
	};
	B.svg.area.radial = function() {
		var a = bi(ai);
		a.radius = a.x;
		delete a.x;
		a.innerRadius = a.x0;
		delete a.x0;
		a.outerRadius = a.x1;
		delete a.x1;
		a.angle = a.y;
		delete a.y;
		a.startAngle = a.y0;
		delete a.y0;
		a.endAngle = a.y1;
		delete a.y1;
		return a
	};
	B.svg.chord = function() {
		function a(a, f) {
			var g =
				b(this, d, a, f);
			a = b(this, e, a, f);
			return "M" + g.p0 + c(g.r, g.p1, g.a1 - g.a0) + (g.a0 == a.a0 && g.a1 == a.a1 ? "Q 0,0 " + g.p0 : "Q 0,0 " + a.p0 + c(a.r, a.p1, a.a1 - a.a0) + ("Q 0,0 " + g.p0)) + "Z"
		}

		function b(a, b, c, d) {
			var e = b.call(a, c, d);
			b = f.call(a, e, d);
			c = g.call(a, e, d) - Da;
			a = h.call(a, e, d) - Da;
			return {
				r: b,
				a0: c,
				a1: a,
				p0: [b * Math.cos(c), b * Math.sin(c)],
				p1: [b * Math.cos(a), b * Math.sin(a)]
			}
		}

		function c(a, b, c) {
			return "A" + a + "," + a + " 0 " + +(c > da) + ",1 " + b
		}
		var d = Re,
			e = Se,
			f = El,
			g = Uh,
			h = Vh;
		a.radius = function(b) {
			if (!arguments.length) return f;
			f = pa(b);
			return a
		};
		a.source = function(b) {
			if (!arguments.length) return d;
			d = pa(b);
			return a
		};
		a.target = function(b) {
			if (!arguments.length) return e;
			e = pa(b);
			return a
		};
		a.startAngle = function(b) {
			if (!arguments.length) return g;
			g = pa(b);
			return a
		};
		a.endAngle = function(b) {
			if (!arguments.length) return h;
			h = pa(b);
			return a
		};
		return a
	};
	B.svg.diagonal = function() {
		function a(a, e) {
			var f = b.call(this, a, e);
			a = c.call(this, a, e);
			e = (f.y + a.y) / 2;
			f = [f, {
				x: f.x,
				y: e
			}, {
				x: a.x,
				y: e
			}, a];
			f = f.map(d);
			return "M" + f[0] + "C" + f[1] + " " + f[2] + " " + f[3]
		}
		var b = Re,
			c = Se,
			d = ci;
		a.source =
			function(c) {
				if (!arguments.length) return b;
				b = pa(c);
				return a
			};
		a.target = function(b) {
			if (!arguments.length) return c;
			c = pa(b);
			return a
		};
		a.projection = function(b) {
			if (!arguments.length) return d;
			d = b;
			return a
		};
		return a
	};
	B.svg.diagonal.radial = function() {
		var a = B.svg.diagonal(),
			b = ci,
			c = a.projection;
		a.projection = function(a) {
			return arguments.length ? c(Fl(b = a)) : b
		};
		return a
	};
	B.svg.symbol = function() {
		function a(a, d) {
			return (si.get(b.call(this, a, d)) || di)(c.call(this, a, d))
		}
		var b = Hl,
			c = Gl;
		a.type = function(c) {
			if (!arguments.length) return b;
			b = pa(c);
			return a
		};
		a.size = function(b) {
			if (!arguments.length) return c;
			c = pa(b);
			return a
		};
		return a
	};
	var si = B.map({
		circle: di,
		cross: function(a) {
			a = Math.sqrt(a / 5) / 2;
			return "M" + -3 * a + "," + -a + "H" + -a + "V" + -3 * a + "H" + a + "V" + -a + "H" + 3 * a + "V" + a + "H" + a + "V" + 3 * a + "H" + -a + "V" + a + "H" + -3 * a + "Z"
		},
		diamond: function(a) {
			a = Math.sqrt(a / (2 * ti));
			var b = a * ti;
			return "M0," + -a + "L" + b + ",0 0," + a + " " + -b + ",0Z"
		},
		square: function(a) {
			a = Math.sqrt(a) / 2;
			return "M" + -a + "," + -a + "L" + a + "," + -a + " " + a + "," + a + " " + -a + "," + a + "Z"
		},
		"triangle-down": function(a) {
			a = Math.sqrt(a /
				Od);
			var b = a * Od / 2;
			return "M0," + b + "L" + a + "," + -b + " " + -a + "," + -b + "Z"
		},
		"triangle-up": function(a) {
			a = Math.sqrt(a / Od);
			var b = a * Od / 2;
			return "M0," + -b + "L" + a + "," + b + " " + -a + "," + b + "Z"
		}
	});
	B.svg.symbolTypes = si.keys();
	var Od = Math.sqrt(3),
		ti = Math.tan(30 * ea);
	qa.transition = function(a) {
		var b = Yb || ++ui;
		a = tf(a);
		for (var c = [], d, e, f = Pd || {
				time: Date.now(),
				ease: Ak,
				delay: 0,
				duration: 250
			}, g = -1, h = this.length; ++g < h;) {
			c.push(d = []);
			for (var k = this[g], l = -1, m = k.length; ++l < m;)(e = k[l]) && Cd(e, l, a, b, f), d.push(e)
		}
		return Ic(c, a, b)
	};
	qa.interrupt = function(a) {
		return this.each(null ==
			a ? Fd : ei(tf(a)))
	};
	var Fd = ei(tf()),
		Ha = [],
		ui = 0,
		Yb, Pd;
	Ha.call = qa.call;
	Ha.empty = qa.empty;
	Ha.node = qa.node;
	Ha.size = qa.size;
	B.transition = function(a, b) {
		return a && a.transition ? Yb ? a.transition(b) : a : B.selection().transition(a)
	};
	B.transition.prototype = Ha;
	Ha.select = function(a) {
		var b = this.id,
			c = this.namespace,
			d = [],
			e, f, g;
		a = J(a);
		for (var h = -1, k = this.length; ++h < k;) {
			d.push(e = []);
			for (var l = this[h], m = -1, n = l.length; ++m < n;)(g = l[m]) && (f = a.call(g, g.__data__, m, h)) ? ("__data__" in g && (f.__data__ = g.__data__), Cd(f, m, c, b, g[c][b]),
				e.push(f)) : e.push(null)
		}
		return Ic(d, c, b)
	};
	Ha.selectAll = function(a) {
		var b = this.id,
			c = this.namespace,
			d = [],
			e, f, g, h;
		a = P(a);
		for (var k = -1, l = this.length; ++k < l;)
			for (var m = this[k], n = -1, r = m.length; ++n < r;)
				if (e = m[n]) {
					h = e[c][b];
					f = a.call(e, e.__data__, n, k);
					d.push(e = []);
					for (var t = -1, u = f.length; ++t < u;)(g = f[t]) && Cd(g, t, c, b, h), e.push(g)
				}
		return Ic(d, c, b)
	};
	Ha.filter = function(a) {
		var b = [],
			c, d, e;
		"function" !== typeof a && (a = Y(a));
		for (var f = 0, g = this.length; f < g; f++) {
			b.push(c = []);
			d = this[f];
			for (var h = 0, k = d.length; h < k; h++)(e = d[h]) &&
				a.call(e, e.__data__, h, f) && c.push(e)
		}
		return Ic(b, this.namespace, this.id)
	};
	Ha.tween = function(a, b) {
		var c = this.id,
			d = this.namespace;
		return 2 > arguments.length ? this.node()[d][c].tween.get(a) : Z(this, null == b ? function(b) {
			b[d][c].tween.remove(a)
		} : function(e) {
			e[d][c].tween.set(a, b)
		})
	};
	Ha.attr = function(a, b) {
		function c() {
			this.removeAttribute(h)
		}

		function d() {
			this.removeAttributeNS(h.space, h.local)
		}

		function e(a) {
			return null == a ? c : (a += "", function() {
				var b = this.getAttribute(h),
					c;
				return b !== a && (c = g(b, a), function(a) {
					this.setAttribute(h,
						c(a))
				})
			})
		}

		function f(a) {
			return null == a ? d : (a += "", function() {
				var b = this.getAttributeNS(h.space, h.local),
					c;
				return b !== a && (c = g(b, a), function(a) {
					this.setAttributeNS(h.space, h.local, c(a))
				})
			})
		}
		if (2 > arguments.length) {
			for (b in a) this.attr(b, a[b]);
			return this
		}
		var g = "transform" == a ? wh : Wb,
			h = B.ns.qualify(a);
		return sf(this, "attr." + a, b, h.local ? f : e)
	};
	Ha.attrTween = function(a, b) {
		function c(a, c) {
			var d = b.call(this, a, c, this.getAttribute(e));
			return d && function(a) {
				this.setAttribute(e, d(a))
			}
		}

		function d(a, c) {
			var d = b.call(this,
				a, c, this.getAttributeNS(e.space, e.local));
			return d && function(a) {
				this.setAttributeNS(e.space, e.local, d(a))
			}
		}
		var e = B.ns.qualify(a);
		return this.tween("attr." + a, e.local ? d : c)
	};
	Ha.style = function(b, c, d) {
		function e() {
			this.style.removeProperty(b)
		}

		function f(c) {
			return null == c ? e : (c += "", function() {
				var e = a(this).getComputedStyle(this, null).getPropertyValue(b),
					f;
				return e !== c && (f = Wb(e, c), function(a) {
					this.style.setProperty(b, f(a), d)
				})
			})
		}
		var g = arguments.length;
		if (3 > g) {
			if ("string" !== typeof b) {
				2 > g && (c = "");
				for (d in b) this.style(d,
					b[d], c);
				return this
			}
			d = ""
		}
		return sf(this, "style." + b, c, f)
	};
	Ha.styleTween = function(b, c, d) {
		function e(e, f) {
			var g = c.call(this, e, f, a(this).getComputedStyle(this, null).getPropertyValue(b));
			return g && function(a) {
				this.style.setProperty(b, g(a), d)
			}
		}
		3 > arguments.length && (d = "");
		return this.tween("style." + b, e)
	};
	Ha.text = function(a) {
		return sf(this, "text", a, Il)
	};
	Ha.remove = function() {
		var a = this.namespace;
		return this.each("end.transition", function() {
			var b;
			2 > this[a].count && (b = this.parentNode) && b.removeChild(this)
		})
	};
	Ha.ease = function(a) {
		var b = this.id,
			c = this.namespace;
		if (1 > arguments.length) return this.node()[c][b].ease;
		"function" !== typeof a && (a = B.ease.apply(B, arguments));
		return Z(this, function(d) {
			d[c][b].ease = a
		})
	};
	Ha.delay = function(a) {
		var b = this.id,
			c = this.namespace;
		return 1 > arguments.length ? this.node()[c][b].delay : Z(this, "function" === typeof a ? function(d, e, f) {
			d[c][b].delay = +a.call(d, d.__data__, e, f)
		} : (a = +a, function(d) {
			d[c][b].delay = a
		}))
	};
	Ha.duration = function(a) {
		var b = this.id,
			c = this.namespace;
		return 1 > arguments.length ?
			this.node()[c][b].duration : Z(this, "function" === typeof a ? function(d, e, f) {
				d[c][b].duration = Math.max(1, a.call(d, d.__data__, e, f))
			} : (a = Math.max(1, a), function(d) {
				d[c][b].duration = a
			}))
	};
	Ha.each = function(a, b) {
		var c = this.id,
			d = this.namespace;
		if (2 > arguments.length) {
			var e = Pd,
				f = Yb;
			try {
				Yb = c, Z(this, function(b, e, f) {
					Pd = b[d][c];
					a.call(b, b.__data__, e, f)
				})
			} finally {
				Pd = e, Yb = f
			}
		} else Z(this, function(e) {
			e = e[d][c];
			(e.event || (e.event = B.dispatch("start", "end", "interrupt"))).on(a, b)
		});
		return this
	};
	Ha.transition = function() {
		for (var a =
				this.id, b = ++ui, c = this.namespace, d = [], e, f, g, h, k = 0, l = this.length; k < l; k++) {
			d.push(e = []);
			f = this[k];
			for (var m = 0, n = f.length; m < n; m++) {
				if (g = f[m]) h = g[c][a], Cd(g, m, c, b, {
					time: h.time,
					ease: h.ease,
					delay: h.delay + h.duration,
					duration: h.duration
				});
				e.push(g)
			}
		}
		return Ic(d, c, b)
	};
	B.svg.axis = function() {
		function a(a) {
			a.each(function() {
				var a = B.select(this),
					l = this.__chart__ || b,
					m = this.__chart__ = b.copy(),
					n = null == h ? m.ticks ? m.ticks.apply(m, g) : m.domain() : h,
					r = null == k ? m.tickFormat ? m.tickFormat.apply(m, g) : v : k,
					t = a.selectAll(".tick").data(n,
						m),
					n = t.enter().insert("g", ".domain").attr("class", "tick").style("opacity", 1E-6),
					u = B.transition(t.exit()).style("opacity", 1E-6).remove(),
					w = B.transition(t.order()).style("opacity", 1),
					x = Math.max(d, 0) + f,
					y = vd(m),
					a = a.selectAll(".domain").data([0]),
					a = (a.enter().append("path").attr("class", "domain"), B.transition(a));
				n.append("line");
				n.append("text");
				var z = n.select("line"),
					J = w.select("line"),
					t = t.select("text").text(r),
					A = n.select("text"),
					C = w.select("text"),
					D = "top" === c || "left" === c ? -1 : 1,
					K, na, Na, G;
				"bottom" ===
				c || "top" === c ? (r = Jl, K = "x", Na = "y", na = "x2", G = "y2", t.attr("dy", 0 > D ? "0em" : ".71em").style("text-anchor", "middle"), a.attr("d", "M" + y[0] + "," + D * e + "V0H" + y[1] + "V" + D * e)) : (r = Kl, K = "y", Na = "x", na = "y2", G = "x2", t.attr("dy", ".32em").style("text-anchor", 0 > D ? "end" : "start"), a.attr("d", "M" + D * e + "," + y[0] + "H0V" + y[1] + "H" + D * e));
				z.attr(G, D * d);
				A.attr(Na, D * x);
				J.attr(na, 0).attr(G, D * d);
				C.attr(K, 0).attr(Na, D * x);
				if (m.rangeBand) var H = m,
					P = H.rangeBand() / 2,
					l = m = function(a) {
						return H(a) + P
					};
				else l.rangeBand ? l = m : u.call(r, m, l);
				n.call(r, l, m);
				w.call(r,
					m, m)
			})
		}
		var b = B.scale.linear(),
			c = vi,
			d = 6,
			e = 6,
			f = 3,
			g = [10],
			h = null,
			k;
		a.scale = function(c) {
			if (!arguments.length) return b;
			b = c;
			return a
		};
		a.orient = function(b) {
			if (!arguments.length) return c;
			c = b in gm ? b + "" : vi;
			return a
		};
		a.ticks = function() {
			if (!arguments.length) return g;
			g = lb(arguments);
			return a
		};
		a.tickValues = function(b) {
			if (!arguments.length) return h;
			h = b;
			return a
		};
		a.tickFormat = function(b) {
			if (!arguments.length) return k;
			k = b;
			return a
		};
		a.tickSize = function(b) {
			var c = arguments.length;
			if (!c) return d;
			d = +b;
			e = +arguments[c - 1];
			return a
		};
		a.innerTickSize = function(b) {
			if (!arguments.length) return d;
			d = +b;
			return a
		};
		a.outerTickSize = function(b) {
			if (!arguments.length) return e;
			e = +b;
			return a
		};
		a.tickPadding = function(b) {
			if (!arguments.length) return f;
			f = +b;
			return a
		};
		a.tickSubdivide = function() {
			return arguments.length && a
		};
		return a
	};
	var vi = "bottom",
		gm = {
			top: 1,
			right: 1,
			bottom: 1,
			left: 1
		};
	B.svg.brush = function() {
		function b(a) {
			a.each(function() {
				var a = B.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush",
						f).on("touchstart.brush", f),
					g = a.selectAll(".background").data([0]);
				g.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
				a.selectAll(".extent").data([0]).enter().append("rect").attr("class", "extent").style("cursor", "move");
				var l = a.selectAll(".resize").data(w, v);
				l.exit().remove();
				l.enter().append("g").attr("class", function(a) {
					return "resize " + a
				}).style("cursor", function(a) {
					return hm[a]
				}).append("rect").attr("x", function(a) {
					return /[ew]$/.test(a) ?
						-3 : null
				}).attr("y", function(a) {
					return /^[ns]/.test(a) ? -3 : null
				}).attr("width", 6).attr("height", 6).style("visibility", "hidden");
				l.style("display", b.empty() ? "none" : null);
				a = B.transition(a);
				g = B.transition(g);
				h && (l = vd(h), g.attr("x", l[0]).attr("width", l[1] - l[0]), d(a));
				k && (l = vd(k), g.attr("y", l[0]).attr("height", l[1] - l[0]), e(a));
				c(a)
			})
		}

		function c(a) {
			a.selectAll(".resize").attr("transform", function(a) {
				return "translate(" + l[+/e$/.test(a)] + "," + m[+/^s/.test(a)] + ")"
			})
		}

		function d(a) {
			a.select(".extent").attr("x", l[0]);
			a.selectAll(".extent,.n>rect,.s>rect").attr("width", l[1] - l[0])
		}

		function e(a) {
			a.select(".extent").attr("y", m[0]);
			a.selectAll(".extent,.e>rect,.w>rect").attr("height", m[1] - m[0])
		}

		function f() {
			function f() {
				32 == B.event.keyCode && (G || (P = null, E[0] -= l[1], E[1] -= m[1], G = 2), A())
			}

			function v() {
				32 == B.event.keyCode && 2 == G && (E[0] += l[1], E[1] += m[1], G = 0, A())
			}

			function w() {
				var a = B.mouse(z),
					b = !1;
				I && (a[0] += I[0], a[1] += I[1]);
				G || (B.event.altKey ? (P || (P = [(l[0] + l[1]) / 2, (m[0] + m[1]) / 2]), E[0] = l[+(a[0] < P[0])], E[1] = m[+(a[1] < P[1])]) :
					P = null);
				na && x(a, h, 0) && (d(C), b = !0);
				Na && x(a, k, 1) && (e(C), b = !0);
				b && (c(C), D({
					type: "brush",
					mode: G ? "move" : "resize"
				}))
			}

			function x(a, b, c) {
				var d = vd(b);
				b = d[0];
				var e = d[1],
					d = E[c],
					f = c ? m : l,
					g = f[1] - f[0];
				G && (b -= d, e -= g + d);
				a = (c ? u : t) ? Math.max(b, Math.min(e, a[c])) : a[c];
				G ? b = (a += d) + g : (P && (d = Math.max(b, Math.min(e, 2 * P[c] - a))), d < a ? (b = a, a = d) : b = d);
				if (f[0] != a || f[1] != b) return c ? r = null : n = null, f[0] = a, f[1] = b, !0
			}

			function y() {
				w();
				C.style("pointer-events", "all").selectAll(".resize").style("display", b.empty() ? "none" : null);
				B.select("body").style("cursor",
					null);
				L.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
				H();
				D({
					type: "brushend"
				})
			}
			var z = this,
				J = B.select(B.event.target),
				D = g.of(z, arguments),
				C = B.select(z),
				K = J.datum(),
				na = !/^(n|s)$/.test(K) && h,
				Na = !/^(e|w)$/.test(K) && k,
				G = J.classed("extent"),
				H = Fa(z),
				P, E = B.mouse(z),
				I, L = B.select(a(z)).on("keydown.brush", f).on("keyup.brush", v);
			if (B.event.changedTouches) L.on("touchmove.brush", w).on("touchend.brush", y);
			else L.on("mousemove.brush", w).on("mouseup.brush", y);
			C.interrupt().selectAll("*").interrupt();
			if (G) E[0] = l[0] - E[0], E[1] = m[0] - E[1];
			else if (K) {
				var O = +/w$/.test(K),
					K = +/^n/.test(K);
				I = [l[1 - O] - E[0], m[1 - K] - E[1]];
				E[0] = l[O];
				E[1] = m[K]
			} else B.event.altKey && (P = E.slice());
			C.style("pointer-events", "none").selectAll(".resize").style("display", null);
			B.select("body").style("cursor", J.style("cursor"));
			D({
				type: "brushstart"
			});
			w()
		}
		var g = O(b, "brushstart", "brush", "brushend"),
			h = null,
			k = null,
			l = [0, 0],
			m = [0, 0],
			n, r, t = !0,
			u = !0,
			w =
			Cf[0];
		b.event = function(a) {
			a.each(function() {
				var a = g.of(this, arguments),
					b = {
						x: l,
						y: m,
						i: n,
						j: r
					},
					c = this.__chart__ || b;
				this.__chart__ = b;
				Yb ? B.select(this).transition().each("start.brush", function() {
					n = c.i;
					r = c.j;
					l = c.x;
					m = c.y;
					a({
						type: "brushstart"
					})
				}).tween("brush:brush", function() {
					var c = ud(l, b.x),
						d = ud(m, b.y);
					n = r = null;
					return function(e) {
						l = b.x = c(e);
						m = b.y = d(e);
						a({
							type: "brush",
							mode: "resize"
						})
					}
				}).each("end.brush", function() {
					n = b.i;
					r = b.j;
					a({
						type: "brush",
						mode: "resize"
					});
					a({
						type: "brushend"
					})
				}) : (a({
						type: "brushstart"
					}),
					a({
						type: "brush",
						mode: "resize"
					}), a({
						type: "brushend"
					}))
			})
		};
		b.x = function(a) {
			if (!arguments.length) return h;
			h = a;
			w = Cf[!h << 1 | !k];
			return b
		};
		b.y = function(a) {
			if (!arguments.length) return k;
			k = a;
			w = Cf[!h << 1 | !k];
			return b
		};
		b.clamp = function(a) {
			if (!arguments.length) return h && k ? [t, u] : h ? t : k ? u : null;
			h && k ? (t = !!a[0], u = !!a[1]) : h ? t = !!a : k && (u = !!a);
			return b
		};
		b.extent = function(a) {
			var c, d, e, f, g;
			if (!arguments.length) return h && (n ? (c = n[0], d = n[1]) : (c = l[0], d = l[1], h.invert && (c = h.invert(c), d = h.invert(d)), d < c && (g = c, c = d, d = g))), k && (r ? (e =
				r[0], f = r[1]) : (e = m[0], f = m[1], k.invert && (e = k.invert(e), f = k.invert(f)), f < e && (g = e, e = f, f = g))), h && k ? [
				[c, e],
				[d, f]
			] : h ? [c, d] : k && [e, f];
			h && (c = a[0], d = a[1], k && (c = c[0], d = d[0]), n = [c, d], h.invert && (c = h(c), d = h(d)), d < c && (g = c, c = d, d = g), c != l[0] || d != l[1]) && (l = [c, d]);
			k && (e = a[0], f = a[1], h && (e = e[1], f = f[1]), r = [e, f], k.invert && (e = k(e), f = k(f)), f < e && (g = e, e = f, f = g), e != m[0] || f != m[1]) && (m = [e, f]);
			return b
		};
		b.clear = function() {
			b.empty() || (l = [0, 0], m = [0, 0], n = r = null);
			return b
		};
		b.empty = function() {
			return !!h && l[0] == l[1] || !!k && m[0] == m[1]
		};
		return B.rebind(b,
			g, "on")
	};
	var hm = {
			n: "ns-resize",
			e: "ew-resize",
			s: "ns-resize",
			w: "ew-resize",
			nw: "nwse-resize",
			ne: "nesw-resize",
			se: "nwse-resize",
			sw: "nesw-resize"
		},
		Cf = ["n e s w nw ne se sw".split(" "), ["e", "w"],
			["n", "s"],
			[]
		],
		Df = V.format = ji.timeFormat,
		wi = Df.utc,
		xi = wi("%Y-%m-%dT%H:%M:%S.%LZ");
	Df.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? uf : xi;
	uf.parse = function(a) {
		a = new Date(a);
		return isNaN(a) ? null : a
	};
	uf.toString = xi.toString;
	V.second = ob(function(a) {
		return new Ma(1E3 * Math.floor(a / 1E3))
	}, function(a,
		b) {
		a.setTime(a.getTime() + 1E3 * Math.floor(b))
	}, function(a) {
		return a.getSeconds()
	});
	V.seconds = V.second.range;
	V.seconds.utc = V.second.utc.range;
	V.minute = ob(function(a) {
		return new Ma(6E4 * Math.floor(a / 6E4))
	}, function(a, b) {
		a.setTime(a.getTime() + 6E4 * Math.floor(b))
	}, function(a) {
		return a.getMinutes()
	});
	V.minutes = V.minute.range;
	V.minutes.utc = V.minute.utc.range;
	V.hour = ob(function(a) {
			var b = a.getTimezoneOffset() / 60;
			return new Ma(36E5 * (Math.floor(a / 36E5 - b) + b))
		}, function(a, b) {
			a.setTime(a.getTime() + 36E5 * Math.floor(b))
		},
		function(a) {
			return a.getHours()
		});
	V.hours = V.hour.range;
	V.hours.utc = V.hour.utc.range;
	V.month = ob(function(a) {
		a = V.day(a);
		a.setDate(1);
		return a
	}, function(a, b) {
		a.setMonth(a.getMonth() + b)
	}, function(a) {
		return a.getMonth()
	});
	V.months = V.month.range;
	V.months.utc = V.month.utc.range;
	var Dd = [1E3, 5E3, 15E3, 3E4, 6E4, 3E5, 9E5, 18E5, 36E5, 108E5, 216E5, 432E5, 864E5, 1728E5, 6048E5, 2592E6, 7776E6, 31536E6],
		Ef = [
			[V.second, 1],
			[V.second, 5],
			[V.second, 15],
			[V.second, 30],
			[V.minute, 1],
			[V.minute, 5],
			[V.minute, 15],
			[V.minute, 30],
			[V.hour, 1],
			[V.hour, 3],
			[V.hour, 6],
			[V.hour, 12],
			[V.day, 1],
			[V.day, 2],
			[V.week, 1],
			[V.month, 1],
			[V.month, 3],
			[V.year, 1]
		],
		im = Df.multi([
			[".%L", function(a) {
				return a.getMilliseconds()
			}],
			[":%S", function(a) {
				return a.getSeconds()
			}],
			["%I:%M", function(a) {
				return a.getMinutes()
			}],
			["%I %p", function(a) {
				return a.getHours()
			}],
			["%a %d", function(a) {
				return a.getDay() && 1 != a.getDate()
			}],
			["%b %d", function(a) {
				return 1 != a.getDate()
			}],
			["%B", function(a) {
				return a.getMonth()
			}],
			["%Y", xc]
		]),
		Ll = {
			range: function(a, b, c) {
				return B.range(Math.ceil(a / c) *
					c, +b, c).map(Xb)
			},
			floor: v,
			ceil: v
		};
	Ef.year = V.year;
	V.scale = function() {
		return vf(B.scale.linear(), Ef, im)
	};
	var yi = Ef.map(function(a) {
			return [a[0].utc, a[1]]
		}),
		jm = wi.multi([
			[".%L", function(a) {
				return a.getUTCMilliseconds()
			}],
			[":%S", function(a) {
				return a.getUTCSeconds()
			}],
			["%I:%M", function(a) {
				return a.getUTCMinutes()
			}],
			["%I %p", function(a) {
				return a.getUTCHours()
			}],
			["%a %d", function(a) {
				return a.getUTCDay() && 1 != a.getUTCDate()
			}],
			["%b %d", function(a) {
				return 1 != a.getUTCDate()
			}],
			["%B", function(a) {
				return a.getUTCMonth()
			}],
			["%Y", xc]
		]);
	yi.year = V.year.utc;
	V.scale.utc = function() {
		return vf(B.scale.linear(), yi, jm)
	};
	B.text = E(function(a) {
		return a.responseText
	});
	B.json = function(a, b) {
		return Ob(a, "application/json", Ml, b)
	};
	B.html = function(a, b) {
		return Ob(a, "text/html", Nl, b)
	};
	B.xml = E(function(a) {
		return a.responseXML
	});
	return B
}.call(window);
/*

  Numeric Javascript
  Copyright (C) 2011 by S?bastien Loisel

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE.
*/
var numeric = "undefined" === typeof exports ? function se() {} : exports;
"undefined" !== typeof global && (global.numeric = numeric);
"undefined" !== typeof window && (window.numeric = numeric);
numeric.version = "1.2.6";
numeric.bench = function te(b, c) {
	var d, e, f;
	"undefined" === typeof c && (c = 15);
	f = .5;
	for (d = new Date;;) {
		for (e = f *= 2; 3 < e; e -= 4) b(), b(), b(), b();
		for (; 0 < e;) b(), e--;
		e = new Date;
		if (e - d > c) break
	}
	for (e = f; 3 < e; e -= 4) b(), b(), b(), b();
	for (; 0 < e;) b(), e--;
	e = new Date;
	return 1E3 * (3 * f - 1) / (e - d)
};
numeric._myIndexOf = function _myIndexOf(b) {
	var c = this.length,
		d;
	for (d = 0; d < c; ++d)
		if (this[d] === b) return d;
	return -1
};
numeric.myIndexOf = Array.prototype.indexOf ? Array.prototype.indexOf : numeric._myIndexOf;
numeric.Function = Function;
numeric.precision = 4;
numeric.largeArray = 50;
numeric.prettyPrint = function ue(b) {
	function c(b) {
		if (0 === b) return "0";
		if (isNaN(b)) return "NaN";
		if (0 > b) return "-" + c(-b);
		if (isFinite(b)) {
			var d = Math.floor(Math.log(b) / Math.log(10));
			b /= Math.pow(10, d);
			b = b.toPrecision(numeric.precision);
			10 === parseFloat(b) && (d++, b = 1, b = b.toPrecision(numeric.precision));
			return parseFloat(b).toString() + "e" + d.toString()
		}
		return "Infinity"
	}

	function d(b) {
		var f;
		if ("undefined" === typeof b) return e.push(Array(numeric.precision + 8).join(" ")), !1;
		if ("string" === typeof b) return e.push('"' + b +
			'"'), !1;
		if ("boolean" === typeof b) return e.push(b.toString()), !1;
		if ("number" === typeof b) {
			var h = c(b);
			f = b.toPrecision(numeric.precision);
			b = parseFloat(b.toString()).toString();
			b = [h, f, b, parseFloat(f).toString(), parseFloat(b).toString()];
			for (f = 1; f < b.length; f++) b[f].length < h.length && (h = b[f]);
			e.push(Array(numeric.precision + 8 - h.length).join(" ") + h);
			return !1
		}
		if (null === b) return e.push("null"), !1;
		if ("function" === typeof b) {
			e.push(b.toString());
			h = !1;
			for (f in b) b.hasOwnProperty(f) && (h ? e.push(",\n") : e.push("\n{"),
				h = !0, e.push(f), e.push(": \n"), d(b[f]));
			h && e.push("}\n");
			return !0
		}
		if (b instanceof Array) {
			if (b.length > numeric.largeArray) return e.push("...Large Array..."), !0;
			h = !1;
			e.push("[");
			for (f = 0; f < b.length; f++) 0 < f && (e.push(","), h && e.push("\n ")), h = d(b[f]);
			e.push("]");
			return !0
		}
		e.push("{");
		h = !1;
		for (f in b) b.hasOwnProperty(f) && (h && e.push(",\n"), h = !0, e.push(f), e.push(": \n"), d(b[f]));
		e.push("}");
		return !0
	}
	var e = [];
	d(b);
	return e.join("")
};
numeric.parseDate = function ve(b) {
	function c(b) {
		if ("string" === typeof b) return Date.parse(b.replace(/-/g, "/"));
		if (!(b instanceof Array)) throw Error("parseDate: parameter must be arrays of strings");
		var d = [],
			f;
		for (f = 0; f < b.length; f++) d[f] = c(b[f]);
		return d
	}
	return c(b)
};
numeric.parseFloat = function we(b) {
	function c(b) {
		if ("string" === typeof b) return parseFloat(b);
		if (!(b instanceof Array)) throw Error("parseFloat: parameter must be arrays of strings");
		var d = [],
			f;
		for (f = 0; f < b.length; f++) d[f] = c(b[f]);
		return d
	}
	return c(b)
};
numeric.parseCSV = function xe(b) {
	b = b.split("\n");
	var c, d, e = [],
		f = /(([^'",]*)|('[^']*')|("[^"]*")),/g,
		g = /^\s*(([+-]?[0-9]+(\.[0-9]*)?(e[+-]?[0-9]+)?)|([+-]?[0-9]*(\.[0-9]+)?(e[+-]?[0-9]+)?))\s*$/,
		h = 0;
	for (d = 0; d < b.length; d++) {
		var k = (b[d] + ",").match(f),
			l;
		if (0 < k.length) {
			e[h] = [];
			for (c = 0; c < k.length; c++) l = k[c], l = l.substr(0, l.length - 1), g.test(l) ? e[h][c] = parseFloat(l) : e[h][c] = l;
			h++
		}
	}
	return e
};
numeric.toCSV = function ye(b) {
	var c = numeric.dim(b),
		d, e, f, g;
	e = c[0];
	c = c[1];
	g = [];
	for (c = 0; c < e; c++) {
		f = [];
		for (d = 0; d < e; d++) f[d] = b[c][d].toString();
		g[c] = f.join(", ")
	}
	return g.join("\n") + "\n"
};
numeric.getURL = function ze(b) {
	var c = new XMLHttpRequest;
	c.open("GET", b, !1);
	c.send();
	return c
};
numeric.imageURL = function Ae(b) {
	function c(b) {
		var c = b.length,
			d, e, f, g, h, k = "";
		for (d = 0; d < c; d += 3) e = b[d], f = b[d + 1], g = b[d + 2], h = e >> 2, e = ((e & 3) << 4) + (f >> 4), f = ((f & 15) << 2) + (g >> 6), g &= 63, d + 1 >= c ? f = g = 64 : d + 2 >= c && (g = 64), k += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(h) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(e) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(f) + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(g);
		return k
	}

	function d(b, c, d) {
		"undefined" === typeof c && (c = 0);
		"undefined" === typeof d && (d = b.length);
		for (var e = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687,
				3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925,
				453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842,
				3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408,
				1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406,
				1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117
			], f = -1, g = 0, g = b.length; c < d; c++) g = (f ^ b[c]) & 255, f = f >>> 8 ^ e[g];
		return f ^ -1
	}
	var e = b[0].length,
		f = b[0][0].length,
		g, h, k, l, m, n, r;
	k = [137, 80, 78, 71, 13, 10, 26, 10, 0, 0, 0, 13, 73, 72, 68, 82, f >> 24 & 255, f >>
		16 & 255, f >> 8 & 255, f & 255, e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, e & 255, 8, 2, 0, 0, 0, -1, -2, -3, -4, -5, -6, -7, -8, 73, 68, 65, 84, 8, 29
	];
	g = d(k, 12, 29);
	k[29] = g >> 24 & 255;
	k[30] = g >> 16 & 255;
	k[31] = g >> 8 & 255;
	k[32] = g & 255;
	g = 1;
	for (n = h = 0; n < e; n++) {
		n < e - 1 ? k.push(0) : k.push(1);
		m = 3 * f + 1 + (0 === n) & 255;
		l = 3 * f + 1 + (0 === n) >> 8 & 255;
		k.push(m);
		k.push(l);
		k.push(~m & 255);
		k.push(~l & 255);
		0 === n && k.push(0);
		for (r = 0; r < f; r++)
			for (l = 0; 3 > l; l++) m = b[l][n][r], m = 255 < m ? 255 : 0 > m ? 0 : Math.round(m), g = (g + m) % 65521, h = (h + g) % 65521, k.push(m);
		k.push(0)
	}
	b = (h << 16) + g;
	k.push(b >> 24 & 255);
	k.push(b >>
		16 & 255);
	k.push(b >> 8 & 255);
	k.push(b & 255);
	b = k.length - 41;
	k[33] = b >> 24 & 255;
	k[34] = b >> 16 & 255;
	k[35] = b >> 8 & 255;
	k[36] = b & 255;
	g = d(k, 37);
	k.push(g >> 24 & 255);
	k.push(g >> 16 & 255);
	k.push(g >> 8 & 255);
	k.push(g & 255);
	k.push(0);
	k.push(0);
	k.push(0);
	k.push(0);
	k.push(73);
	k.push(69);
	k.push(78);
	k.push(68);
	k.push(174);
	k.push(66);
	k.push(96);
	k.push(130);
	return "data:image/png;base64," + c(k)
};
numeric._dim = function _dim(b) {
	for (var c = [];
		"object" === typeof b;) c.push(b.length), b = b[0];
	return c
};
numeric.dim = function Ff(b) {
	var c, d;
	return "object" === typeof b ? (c = b[0], "object" === typeof c ? (d = c[0], "object" === typeof d ? numeric._dim(b) : [b.length, c.length]) : [b.length]) : []
};
numeric.mapreduce = function Gf(b, c) {
	return Function("x", "accum", "_s", "_k", 'if(typeof accum === "undefined") accum = ' + c + ';\nif(typeof x === "number") { var xi = x; ' + b + '; return accum; }\nif(typeof _s === "undefined") _s = numeric.dim(x);\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i,xi;\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) {\n        accum = arguments.callee(x[i],accum,_s,_k+1);\n    }    return accum;\n}\nfor(i=_n-1;i>=1;i-=2) { \n    xi = x[i];\n    ' + b + ";\n    xi = x[i-1];\n    " +
		b + ";\n}\nif(i === 0) {\n    xi = x[i];\n    " + b + "\n}\nreturn accum;")
};
numeric.mapreduce2 = function Hf(b, c) {
	return Function("x", "var n = x.length;\nvar i,xi;\n" + c + ";\nfor(i=n-1;i!==-1;--i) { \n    xi = x[i];\n    " + b + ";\n}\nreturn accum;")
};
numeric.same = function If(b, c) {
	var d, e;
	if (!(b instanceof Array && c instanceof Array)) return !1;
	e = b.length;
	if (e !== c.length) return !1;
	for (d = 0; d < e; d++)
		if (b[d] !== c[d])
			if ("object" === typeof b[d]) {
				if (!If(b[d], c[d])) return !1
			} else return !1;
	return !0
};
numeric.rep = function Jf(b, c, d) {
	"undefined" === typeof d && (d = 0);
	var e = b[d],
		f = Array(e);
	if (d === b.length - 1) {
		for (e -= 2; 0 <= e; e -= 2) f[e + 1] = c, f[e] = c; - 1 === e && (f[0] = c);
		return f
	}
	for (--e; 0 <= e; e--) f[e] = numeric.rep(b, c, d + 1);
	return f
};
numeric.dotMMsmall = function Kf(b, c) {
	var d, e, f, g, h, k, l, m, n, r;
	d = b.length;
	g = c.length;
	h = c[0].length;
	k = Array(d);
	for (--d; 0 <= d; d--) {
		l = Array(h);
		m = b[d];
		for (f = h - 1; 0 <= f; f--) {
			n = m[g - 1] * c[g - 1][f];
			for (e = g - 2; 1 <= e; e -= 2) r = e - 1, n += m[e] * c[e][f] + m[r] * c[r][f];
			0 === e && (n += m[0] * c[0][f]);
			l[f] = n
		}
		k[d] = l
	}
	return k
};
numeric._getCol = function _getCol(b, c, d) {
	for (var e = b.length, e = e - 1; 0 < e; --e) d[e] = b[e][c], --e, d[e] = b[e][c];
	0 === e && (d[0] = b[0][c])
};
numeric.dotMMbig = function Lf(b, c) {
	var d = numeric._getCol,
		e = c.length,
		f = Array(e),
		g = b.length,
		h = c[0].length,
		k = Array(g),
		l, m = numeric.dotVV;
	--e;
	--g;
	for (e = g; - 1 !== e; --e) k[e] = Array(h);
	--h;
	for (e = h; - 1 !== e; --e)
		for (d(c, e, f), h = g; - 1 !== h; --h) l = 0, l = b[h], k[h][e] = m(l, f);
	return k
};
numeric.dotMV = function Mf(b, c) {
	for (var d = b.length, e = c.length, e = Array(d), f = numeric.dotVV, d = d - 1; 0 <= d; d--) e[d] = f(b[d], c);
	return e
};
numeric.dotVM = function Nf(b, c) {
	var d, e, f, g, h, k;
	f = b.length;
	d = c[0].length;
	g = Array(d);
	for (e = d - 1; 0 <= e; e--) {
		h = b[f - 1] * c[f - 1][e];
		for (d = f - 2; 1 <= d; d -= 2) k = d - 1, h += b[d] * c[d][e] + b[k] * c[k][e];
		0 === d && (h += b[0] * c[0][e]);
		g[e] = h
	}
	return g
};
numeric.dotVV = function Of(b, c) {
	var d;
	d = b.length;
	var e, f = b[d - 1] * c[d - 1];
	for (d -= 2; 1 <= d; d -= 2) e = d - 1, f += b[d] * c[d] + b[e] * c[e];
	0 === d && (f += b[0] * c[0]);
	return f
};
numeric.dot = function Pf(b, c) {
	var d = numeric.dim;
	switch (1E3 * d(b).length + d(c).length) {
		case 2002:
			return 10 > c.length ? numeric.dotMMsmall(b, c) : numeric.dotMMbig(b, c);
		case 2001:
			return numeric.dotMV(b, c);
		case 1002:
			return numeric.dotVM(b, c);
		case 1001:
			return numeric.dotVV(b, c);
		case 1E3:
			return numeric.mulVS(b, c);
		case 1:
			return numeric.mulSV(b, c);
		case 0:
			return b * c;
		default:
			throw Error("numeric.dot only works on vectors and matrices");
	}
};
numeric.diag = function Qf(b) {
	var c, d, e, f = b.length,
		g = Array(f),
		h;
	for (c = f - 1; 0 <= c; c--) {
		h = Array(f);
		d = c + 2;
		for (e = f - 1; e >= d; e -= 2) h[e] = 0, h[e - 1] = 0;
		e > c && (h[e] = 0);
		h[c] = b[c];
		for (e = c - 1; 1 <= e; e -= 2) h[e] = 0, h[e - 1] = 0;
		0 === e && (h[0] = 0);
		g[c] = h
	}
	return g
};
numeric.getDiag = function(a) {
	for (var b = Math.min(a.length, a[0].length), c = Array(b), b = b - 1; 1 <= b; --b) c[b] = a[b][b], --b, c[b] = a[b][b];
	0 === b && (c[0] = a[0][0]);
	return c
};
numeric.identity = function Rf(b) {
	return numeric.diag(numeric.rep([b], 1))
};
numeric.pointwise = function Sf(b, c, d) {
	"undefined" === typeof d && (d = "");
	var e = [],
		f, g = /\[i\]$/,
		h, k = "",
		l = !1;
	for (f = 0; f < b.length; f++) g.test(b[f]) ? k = h = b[f].substring(0, b[f].length - 3) : h = b[f], "ret" === h && (l = !0), e.push(h);
	e[b.length] = "_s";
	e[b.length + 1] = "_k";
	e[b.length + 2] = 'if(typeof _s === "undefined") _s = numeric.dim(' + k + ');\nif(typeof _k === "undefined") _k = 0;\nvar _n = _s[_k];\nvar i' + (l ? "" : ", ret = Array(_n)") + ";\nif(_k < _s.length-1) {\n    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(" + b.join(",") + ",_s,_k+1);\n    return ret;\n}\n" +
		d + "\nfor(i=_n-1;i!==-1;--i) {\n    " + c + "\n}\nreturn ret;";
	return Function.apply(null, e)
};
numeric.pointwise2 = function Tf(b, c, d) {
	"undefined" === typeof d && (d = "");
	var e = [],
		f, g = /\[i\]$/,
		h, k = "",
		l = !1;
	for (f = 0; f < b.length; f++) g.test(b[f]) ? k = h = b[f].substring(0, b[f].length - 3) : h = b[f], "ret" === h && (l = !0), e.push(h);
	e[b.length] = "var _n = " + k + ".length;\nvar i" + (l ? "" : ", ret = Array(_n)") + ";\n" + d + "\nfor(i=_n-1;i!==-1;--i) {\n" + c + "\n}\nreturn ret;";
	return Function.apply(null, e)
};
numeric._biforeach = function _biforeach(b, c, d, e, f) {
	if (e === d.length - 1) f(b, c);
	else {
		var g;
		g = d[e];
		for (--g; 0 <= g; g--) _biforeach("object" === typeof b ? b[g] : b, "object" === typeof c ? c[g] : c, d, e + 1, f)
	}
};
numeric._biforeach2 = function _biforeach2(b, c, d, e, f) {
	if (e === d.length - 1) return f(b, c);
	var g;
	g = d[e];
	var h = Array(g);
	for (--g; 0 <= g; --g) h[g] = _biforeach2("object" === typeof b ? b[g] : b, "object" === typeof c ? c[g] : c, d, e + 1, f);
	return h
};
numeric._foreach = function _foreach(b, c, d, e) {
	if (d === c.length - 1) e(b);
	else {
		var f;
		f = c[d];
		for (--f; 0 <= f; f--) _foreach(b[f], c, d + 1, e)
	}
};
numeric._foreach2 = function _foreach2(b, c, d, e) {
	if (d === c.length - 1) return e(b);
	var f;
	f = c[d];
	var g = Array(f);
	for (--f; 0 <= f; f--) g[f] = _foreach2(b[f], c, d + 1, e);
	return g
};
numeric.ops2 = {
	add: "+",
	sub: "-",
	mul: "*",
	div: "/",
	mod: "%",
	and: "&&",
	or: "||",
	eq: "===",
	neq: "!==",
	lt: "<",
	gt: ">",
	leq: "<=",
	geq: ">=",
	band: "&",
	bor: "|",
	bxor: "^",
	lshift: "<<",
	rshift: ">>",
	rrshift: ">>>"
};
numeric.opseq = {
	addeq: "+=",
	subeq: "-=",
	muleq: "*=",
	diveq: "/=",
	modeq: "%=",
	lshifteq: "<<=",
	rshifteq: ">>=",
	rrshifteq: ">>>=",
	bandeq: "&=",
	boreq: "|=",
	bxoreq: "^="
};
numeric.mathfuns = "abs acos asin atan ceil cos exp floor log round sin sqrt tan isNaN isFinite".split(" ");
numeric.mathfuns2 = ["atan2", "pow", "max", "min"];
numeric.ops1 = {
	neg: "-",
	not: "!",
	bnot: "~",
	clone: ""
};
numeric.mapreducers = {
	any: ["if(xi) return true;", "var accum = false;"],
	all: ["if(!xi) return false;", "var accum = true;"],
	sum: ["accum += xi;", "var accum = 0;"],
	prod: ["accum *= xi;", "var accum = 1;"],
	norm2Squared: ["accum += xi*xi;", "var accum = 0;"],
	norminf: ["accum = max(accum,abs(xi));", "var accum = 0, max = Math.max, abs = Math.abs;"],
	norm1: ["accum += abs(xi)", "var accum = 0, abs = Math.abs;"],
	sup: ["accum = max(accum,xi);", "var accum = -Infinity, max = Math.max;"],
	inf: ["accum = min(accum,xi);", "var accum = Infinity, min = Math.min;"]
};
(function() {
	var a, b;
	for (a = 0; a < numeric.mathfuns2.length; ++a) b = numeric.mathfuns2[a], numeric.ops2[b] = b;
	for (a in numeric.ops2)
		if (numeric.ops2.hasOwnProperty(a)) {
			b = numeric.ops2[a];
			var c, d, e = ""; - 1 !== numeric.myIndexOf.call(numeric.mathfuns2, a) ? (e = "var " + b + " = Math." + b + ";\n", c = function(a, c, d) {
				return a + " = " + b + "(" + c + "," + d + ")"
			}, d = function(a, c) {
				return a + " = " + b + "(" + a + "," + c + ")"
			}) : (c = function(a, c, d) {
				return a + " = " + c + " " + b + " " + d
			}, d = numeric.opseq.hasOwnProperty(a + "eq") ? function(a, c) {
				return a + " " + b + "= " + c
			} : function(a,
				c) {
				return a + " = " + a + " " + b + " " + c
			});
			numeric[a + "VV"] = numeric.pointwise2(["x[i]", "y[i]"], c("ret[i]", "x[i]", "y[i]"), e);
			numeric[a + "SV"] = numeric.pointwise2(["x", "y[i]"], c("ret[i]", "x", "y[i]"), e);
			numeric[a + "VS"] = numeric.pointwise2(["x[i]", "y"], c("ret[i]", "x[i]", "y"), e);
			numeric[a] = Function("var n = arguments.length, i, x = arguments[0], y;\nvar VV = numeric." + a + "VV, VS = numeric." + a + "VS, SV = numeric." + a + 'SV;\nvar dim = numeric.dim;\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof x === "object") {\n      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);\n      else x = numeric._biforeach2(x,y,dim(x),0,VS);\n  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);\n  else ' +
				d("x", "y") + "\n}\nreturn x;\n");
			numeric[b] = numeric[a];
			numeric[a + "eqV"] = numeric.pointwise2(["ret[i]", "x[i]"], d("ret[i]", "x[i]"), e);
			numeric[a + "eqS"] = numeric.pointwise2(["ret[i]", "x"], d("ret[i]", "x"), e);
			numeric[a + "eq"] = Function("var n = arguments.length, i, x = arguments[0], y;\nvar V = numeric." + a + "eqV, S = numeric." + a + 'eqS\nvar s = numeric.dim(x);\nfor(i=1;i!==n;++i) { \n  y = arguments[i];\n  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);\n  else numeric._biforeach(x,y,s,0,S);\n}\nreturn x;\n')
		}
	for (a =
		0; a < numeric.mathfuns2.length; ++a) b = numeric.mathfuns2[a], delete numeric.ops2[b];
	for (a = 0; a < numeric.mathfuns.length; ++a) b = numeric.mathfuns[a], numeric.ops1[b] = b;
	for (a in numeric.ops1) numeric.ops1.hasOwnProperty(a) && (e = "", b = numeric.ops1[a], -1 !== numeric.myIndexOf.call(numeric.mathfuns, a) && Math.hasOwnProperty(b) && (e = "var " + b + " = Math." + b + ";\n"), numeric[a + "eqV"] = numeric.pointwise2(["ret[i]"], "ret[i] = " + b + "(ret[i]);", e), numeric[a + "eq"] = Function("x", 'if(typeof x !== "object") return ' + b + "x\nvar i;\nvar V = numeric." +
		a + "eqV;\nvar s = numeric.dim(x);\nnumeric._foreach(x,s,0,V);\nreturn x;\n"), numeric[a + "V"] = numeric.pointwise2(["x[i]"], "ret[i] = " + b + "(x[i]);", e), numeric[a] = Function("x", 'if(typeof x !== "object") return ' + b + "(x)\nvar i;\nvar V = numeric." + a + "V;\nvar s = numeric.dim(x);\nreturn numeric._foreach2(x,s,0,V);\n"));
	for (a = 0; a < numeric.mathfuns.length; ++a) b = numeric.mathfuns[a], delete numeric.ops1[b];
	for (a in numeric.mapreducers) numeric.mapreducers.hasOwnProperty(a) && (b = numeric.mapreducers[a], numeric[a + "V"] =
		numeric.mapreduce2(b[0], b[1]), numeric[a] = Function("x", "s", "k", b[1] + 'if(typeof x !== "object") {    xi = x;\n' + b[0] + ';\n    return accum;\n}if(typeof s === "undefined") s = numeric.dim(x);\nif(typeof k === "undefined") k = 0;\nif(k === s.length-1) return numeric.' + a + "V(x);\nvar xi;\nvar n = x.length, i;\nfor(i=n-1;i!==-1;--i) {\n   xi = arguments.callee(x[i]);\n" + b[0] + ";\n}\nreturn accum;\n"))
})();
numeric.truncVV = numeric.pointwise(["x[i]", "y[i]"], "ret[i] = round(x[i]/y[i])*y[i];", "var round = Math.round;");
numeric.truncVS = numeric.pointwise(["x[i]", "y"], "ret[i] = round(x[i]/y)*y;", "var round = Math.round;");
numeric.truncSV = numeric.pointwise(["x", "y[i]"], "ret[i] = round(x/y[i])*y[i];", "var round = Math.round;");
numeric.trunc = function Uf(b, c) {
	return "object" === typeof b ? "object" === typeof c ? numeric.truncVV(b, c) : numeric.truncVS(b, c) : "object" === typeof c ? numeric.truncSV(b, c) : Math.round(b / c) * c
};
numeric.inv = function Vf(b) {
	var c = numeric.dim(b),
		d = Math.abs,
		e = c[0],
		c = c[1],
		f = numeric.clone(b),
		g, h, k = numeric.identity(e),
		l, m, n, r, t;
	for (r = 0; r < c; ++r) {
		h = b = -1;
		for (n = r; n !== e; ++n) t = d(f[n][r]), t > h && (b = n, h = t);
		h = f[b];
		f[b] = f[r];
		f[r] = h;
		m = k[b];
		k[b] = k[r];
		k[r] = m;
		b = h[r];
		for (t = r; t !== c; ++t) h[t] /= b;
		for (t = c - 1; - 1 !== t; --t) m[t] /= b;
		for (n = e - 1; - 1 !== n; --n)
			if (n !== r) {
				g = f[n];
				l = k[n];
				b = g[r];
				for (t = r + 1; t !== c; ++t) g[t] -= h[t] * b;
				for (t = c - 1; 0 < t; --t) l[t] -= m[t] * b, --t, l[t] -= m[t] * b;
				0 === t && (l[0] -= m[0] * b)
			}
	}
	return k
};
numeric.det = function Wf(b) {
	var c = numeric.dim(b);
	if (2 !== c.length || c[0] !== c[1]) throw Error("numeric: det() only works on square matrices");
	var c = c[0],
		d = 1,
		e, f, g = numeric.clone(b),
		h, k, l, m;
	for (b = 0; b < c - 1; b++) {
		f = b;
		for (e = b + 1; e < c; e++) Math.abs(g[e][b]) > Math.abs(g[f][b]) && (f = e);
		f !== b && (e = g[f], g[f] = g[b], g[b] = e, d *= -1);
		h = g[b];
		for (e = b + 1; e < c; e++) {
			k = g[e];
			l = k[b] / h[b];
			for (f = b + 1; f < c - 1; f += 2) m = f + 1, k[f] -= h[f] * l, k[m] -= h[m] * l;
			f !== c && (k[f] -= h[f] * l)
		}
		if (0 === h[b]) return 0;
		d *= h[b]
	}
	return d * g[b][b]
};
numeric.transpose = function Xf(b) {
	var c, d;
	c = b.length;
	var e = b[0].length,
		f = Array(e),
		g, h, k;
	for (d = 0; d < e; d++) f[d] = Array(c);
	for (--c; 1 <= c; c -= 2) {
		h = b[c];
		g = b[c - 1];
		for (d = e - 1; 1 <= d; --d) k = f[d], k[c] = h[d], k[c - 1] = g[d], --d, k = f[d], k[c] = h[d], k[c - 1] = g[d];
		0 === d && (k = f[0], k[c] = h[0], k[c - 1] = g[0])
	}
	if (0 === c) {
		g = b[0];
		for (d = e - 1; 1 <= d; --d) f[d][0] = g[d], --d, f[d][0] = g[d];
		0 === d && (f[0][0] = g[0])
	}
	return f
};
numeric.negtranspose = function Yf(b) {
	var c, d;
	c = b.length;
	var e = b[0].length,
		f = Array(e),
		g, h, k;
	for (d = 0; d < e; d++) f[d] = Array(c);
	for (--c; 1 <= c; c -= 2) {
		h = b[c];
		g = b[c - 1];
		for (d = e - 1; 1 <= d; --d) k = f[d], k[c] = -h[d], k[c - 1] = -g[d], --d, k = f[d], k[c] = -h[d], k[c - 1] = -g[d];
		0 === d && (k = f[0], k[c] = -h[0], k[c - 1] = -g[0])
	}
	if (0 === c) {
		g = b[0];
		for (d = e - 1; 1 <= d; --d) f[d][0] = -g[d], --d, f[d][0] = -g[d];
		0 === d && (f[0][0] = -g[0])
	}
	return f
};
numeric._random = function _random(b, c) {
	var d;
	d = b[c];
	var e = Array(d);
	if (c === b.length - 1) {
		b = Math.random;
		for (--d; 1 <= d; d -= 2) e[d] = b(), e[d - 1] = b();
		0 === d && (e[0] = b());
		return e
	}
	for (--d; 0 <= d; d--) e[d] = _random(b, c + 1);
	return e
};
numeric.random = function Zf(b) {
	return numeric._random(b, 0)
};
numeric.norm2 = function $f(b) {
	return Math.sqrt(numeric.norm2Squared(b))
};
numeric.linspace = function ag(b, c, d) {
	"undefined" === typeof d && (d = Math.max(Math.round(c - b) + 1, 1));
	if (2 > d) return 1 === d ? [b] : [];
	var e, f = Array(d);
	d--;
	for (e = d; 0 <= e; e--) f[e] = (e * c + (d - e) * b) / d;
	return f
};
numeric.getBlock = function bg(b, c, d) {
	function e(b, h) {
		var g, l = c[h];
		g = d[h] - l;
		var m = Array(g);
		if (h === f.length - 1) {
			for (; 0 <= g; g--) m[g] = b[g + l];
			return m
		}
		for (; 0 <= g; g--) m[g] = e(b[g + l], h + 1);
		return m
	}
	var f = numeric.dim(b);
	return e(b, 0)
};
numeric.setBlock = function cg(b, c, d, e) {
	function f(b, e, l) {
		var h, k = c[l],
			r = d[l] - k;
		if (l === g.length - 1)
			for (h = r; 0 <= h; h--) b[h + k] = e[h];
		for (h = r; 0 <= h; h--) f(b[h + k], e[h], l + 1)
	}
	var g = numeric.dim(b);
	f(b, e, 0);
	return b
};
numeric.getRange = function dg(b, c, d) {
	for (var e = c.length, f = d.length, g, h = Array(e), k, l, e = e - 1; - 1 !== e; --e)
		for (h[e] = Array(f), k = h[e], l = b[c[e]], g = f - 1; - 1 !== g; --g) k[g] = l[d[g]];
	return h
};
numeric.blockMatrix = function eg(b) {
	var c = numeric.dim(b);
	if (4 > c.length) return numeric.blockMatrix([b]);
	var d = c[0],
		c = c[1],
		e, f, g, h;
	for (g = f = e = 0; g < d; ++g) e += b[g][0].length;
	for (h = 0; h < c; ++h) f += b[0][h][0].length;
	var k = Array(e);
	for (g = 0; g < e; ++g) k[g] = Array(f);
	var l = 0,
		m, n, r, t, u;
	for (g = 0; g < d; ++g) {
		m = f;
		for (h = c - 1; - 1 !== h; --h)
			for (e = b[g][h], m -= e[0].length, r = e.length - 1; - 1 !== r; --r)
				for (u = e[r], n = k[l + r], t = u.length - 1; - 1 !== t; --t) n[m + t] = u[t];
		l += b[g][0].length
	}
	return k
};
numeric.tensor = function fg(b, c) {
	if ("number" === typeof b || "number" === typeof c) return numeric.mul(b, c);
	var d = numeric.dim(b),
		e = numeric.dim(c);
	if (1 !== d.length || 1 !== e.length) throw Error("numeric: tensor product is only defined for vectors");
	var f = d[0],
		e = e[0],
		d = Array(f),
		g, h, k;
	for (g = f - 1; 0 <= g; g--) {
		f = Array(e);
		k = b[g];
		for (h = e - 1; 3 <= h; --h) f[h] = k * c[h], --h, f[h] = k * c[h], --h, f[h] = k * c[h], --h, f[h] = k * c[h];
		for (; 0 <= h;) f[h] = k * c[h], --h;
		d[g] = f
	}
	return d
};
numeric.T = function gg(b, c) {
	this.x = b;
	this.y = c
};
numeric.t = function hg(b, c) {
	return new numeric.T(b, c)
};
numeric.Tbinop = function ig(b, c, d, e, f) {
	var g = numeric.indexOf;
	if ("string" !== typeof f) {
		var h;
		f = "";
		for (h in numeric) numeric.hasOwnProperty(h) && (0 <= b.indexOf(h) || 0 <= c.indexOf(h) || 0 <= d.indexOf(h) || 0 <= e.indexOf(h)) && 1 < h.length && (f += "var " + h + " = numeric." + h + ";\n")
	}
	return Function(["y"], "var x = this;\nif(!(y instanceof numeric.T)) { y = new numeric.T(y); }\n" + f + "\nif(x.y) {  if(y.y) {    return new numeric.T(" + e + ");\n  }\n  return new numeric.T(" + d + ");\n}\nif(y.y) {\n  return new numeric.T(" + c + ");\n}\nreturn new numeric.T(" +
		b + ");\n")
};
q = numeric.T.prototype;
q.add = numeric.Tbinop("add(x.x,y.x)", "add(x.x,y.x),y.y", "add(x.x,y.x),x.y", "add(x.x,y.x),add(x.y,y.y)");
q.sub = numeric.Tbinop("sub(x.x,y.x)", "sub(x.x,y.x),neg(y.y)", "sub(x.x,y.x),x.y", "sub(x.x,y.x),sub(x.y,y.y)");
q.mul = numeric.Tbinop("mul(x.x,y.x)", "mul(x.x,y.x),mul(x.x,y.y)", "mul(x.x,y.x),mul(x.y,y.x)", "sub(mul(x.x,y.x),mul(x.y,y.y)),add(mul(x.x,y.y),mul(x.y,y.x))");
q.reciprocal = function jg() {
	var b = numeric.mul,
		c = numeric.div;
	return this.y ? (b = numeric.add(b(this.x, this.x), b(this.y, this.y)), new numeric.T(c(this.x, b), c(numeric.neg(this.y), b))) : new T(c(1, this.x))
};
q.div = function kg(b) {
	b instanceof numeric.T || (b = new numeric.T(b));
	if (b.y) return this.mul(b.reciprocal());
	var c = numeric.div;
	return this.y ? new numeric.T(c(this.x, b.x), c(this.y, b.x)) : new numeric.T(c(this.x, b.x))
};
q.dot = numeric.Tbinop("dot(x.x,y.x)", "dot(x.x,y.x),dot(x.x,y.y)", "dot(x.x,y.x),dot(x.y,y.x)", "sub(dot(x.x,y.x),dot(x.y,y.y)),add(dot(x.x,y.y),dot(x.y,y.x))");
q.transpose = function lg() {
	var b = numeric.transpose,
		c = this.x,
		d = this.y;
	return d ? new numeric.T(b(c), b(d)) : new numeric.T(b(c))
};
q.transjugate = function mg() {
	var b = numeric.transpose,
		c = this.x,
		d = this.y;
	return d ? new numeric.T(b(c), numeric.negtranspose(d)) : new numeric.T(b(c))
};
numeric.Tunop = function ng(b, c, d) {
	"string" !== typeof d && (d = "");
	return Function("var x = this;\n" + d + "\nif(x.y) {  " + c + ";\n}\n" + b + ";\n")
};
q = numeric.T.prototype;
q.exp = numeric.Tunop("return new numeric.T(ex)", "return new numeric.T(mul(cos(x.y),ex),mul(sin(x.y),ex))", "var ex = numeric.exp(x.x), cos = numeric.cos, sin = numeric.sin, mul = numeric.mul;");
q.conj = numeric.Tunop("return new numeric.T(x.x);", "return new numeric.T(x.x,numeric.neg(x.y));");
q.neg = numeric.Tunop("return new numeric.T(neg(x.x));", "return new numeric.T(neg(x.x),neg(x.y));", "var neg = numeric.neg;");
q.sin = numeric.Tunop("return new numeric.T(numeric.sin(x.x))", "return x.exp().sub(x.neg().exp()).div(new numeric.T(0,2));");
q.cos = numeric.Tunop("return new numeric.T(numeric.cos(x.x))", "return x.exp().add(x.neg().exp()).div(2);");
q.abs = numeric.Tunop("return new numeric.T(numeric.abs(x.x));", "return new numeric.T(numeric.sqrt(numeric.add(mul(x.x,x.x),mul(x.y,x.y))));", "var mul = numeric.mul;");
q.log = numeric.Tunop("return new numeric.T(numeric.log(x.x));", "var theta = new numeric.T(numeric.atan2(x.y,x.x)), r = x.abs();\nreturn new numeric.T(numeric.log(r.x),theta.x);");
q.norm2 = numeric.Tunop("return numeric.norm2(x.x);", "var f = numeric.norm2Squared;\nreturn Math.sqrt(f(x.x)+f(x.y));");
q.inv = function og() {
	var b = this;
	if ("undefined" === typeof b.y) return new numeric.T(numeric.inv(b.x));
	for (var c = b.x.length, d, e, f = numeric.identity(c), g = numeric.rep([c, c], 0), h = numeric.clone(b.x), k = numeric.clone(b.y), l, m, n, r, t, u, w, v, x, y, D, z, b = 0; b < c; b++) {
		x = h[b][b];
		y = k[b][b];
		n = x * x + y * y;
		e = b;
		for (d = b + 1; d < c; d++) x = h[d][b], y = k[d][b], l = x * x + y * y, l > n && (e = d, n = l);
		e !== b && (d = h[b], h[b] = h[e], h[e] = d, d = k[b], k[b] = k[e], k[e] = d, d = f[b], f[b] = f[e], f[e] = d, d = g[b], g[b] = g[e], g[e] = d);
		l = h[b];
		m = k[b];
		t = f[b];
		u = g[b];
		x = l[b];
		y = m[b];
		for (d = b + 1; d <
			c; d++) D = l[d], z = m[d], l[d] = (D * x + z * y) / n, m[d] = (z * x - D * y) / n;
		for (d = 0; d < c; d++) D = t[d], z = u[d], t[d] = (D * x + z * y) / n, u[d] = (z * x - D * y) / n;
		for (d = b + 1; d < c; d++) {
			n = h[d];
			r = k[d];
			w = f[d];
			v = g[d];
			x = n[b];
			y = r[b];
			for (e = b + 1; e < c; e++) D = l[e], z = m[e], n[e] -= D * x - z * y, r[e] -= z * x + D * y;
			for (e = 0; e < c; e++) D = t[e], z = u[e], w[e] -= D * x - z * y, v[e] -= z * x + D * y
		}
	}
	for (b = c - 1; 0 < b; b--)
		for (t = f[b], u = g[b], d = b - 1; 0 <= d; d--)
			for (w = f[d], v = g[d], x = h[d][b], y = k[d][b], e = c - 1; 0 <= e; e--) D = t[e], z = u[e], w[e] -= x * D - y * z, v[e] -= x * z + y * D;
	return new numeric.T(f, g)
};
q.get = function pg(b) {
	var c = this.x,
		d = this.y,
		e = 0,
		f, g = b.length;
	if (d) {
		for (; e < g;) f = b[e], c = c[f], d = d[f], e++;
		return new numeric.T(c, d)
	}
	for (; e < g;) f = b[e], c = c[f], e++;
	return new numeric.T(c)
};
q.set = function zi(b, c) {
	var d = this.x,
		e = this.y,
		f = 0,
		g = b.length,
		h = c.x,
		k = c.y;
	if (0 === g) return k ? this.y = k : e && (this.y = void 0), this.x = d, this;
	if (k) {
		e || (this.y = e = numeric.rep(numeric.dim(d), 0));
		for (; f < g - 1;) c = b[f], d = d[c], e = e[c], f++;
		c = b[f];
		d[c] = h;
		e[c] = k;
		return this
	}
	if (e) {
		for (; f < g - 1;) c = b[f], d = d[c], e = e[c], f++;
		c = b[f];
		d[c] = h;
		e[c] = h instanceof Array ? numeric.rep(numeric.dim(h), 0) : 0;
		return this
	}
	for (; f < g - 1;) c = b[f], d = d[c], f++;
	c = b[f];
	d[c] = h;
	return this
};
q.getRows = function Ai(b, c) {
	var d = c - b + 1,
		e, f = Array(d),
		g = this.x,
		h = this.y;
	for (e = b; e <= c; e++) f[e - b] = g[e];
	if (h) {
		d = Array(d);
		for (e = b; e <= c; e++) d[e - b] = h[e];
		return new numeric.T(f, d)
	}
	return new numeric.T(f)
};
q.setRows = function Bi(b, c, d) {
	var e = this.x,
		f = this.y,
		g = d.x,
		h = d.y;
	for (d = b; d <= c; d++) e[d] = g[d - b];
	if (h)
		for (f || (this.y = f = numeric.rep(numeric.dim(e), 0)), d = b; d <= c; d++) f[d] = h[d - b];
	else if (f)
		for (d = b; d <= c; d++) f[d] = numeric.rep([g[d - b].length], 0);
	return this
};
q.getRow = function Ci(b) {
	var c = this.x,
		d = this.y;
	return d ? new numeric.T(c[b], d[b]) : new numeric.T(c[b])
};
q.setRow = function Di(b, c) {
	var d = this.x,
		e = this.y,
		f = c.x;
	c = c.y;
	d[b] = f;
	c ? (e || (this.y = e = numeric.rep(numeric.dim(d), 0)), e[b] = c) : e && (e = numeric.rep([f.length], 0));
	return this
};
q.getBlock = function Ei(b, c) {
	var d = this.x,
		e = this.y,
		f = numeric.getBlock;
	return e ? new numeric.T(f(d, b, c), f(e, b, c)) : new numeric.T(f(d, b, c))
};
q.setBlock = function Fi(b, c, d) {
	d instanceof numeric.T || (d = new numeric.T(d));
	var e = this.x,
		f = this.y,
		g = numeric.setBlock,
		h = d.x;
	if (d = d.y) return f || (f = this.y = numeric.rep(numeric.dim(this), 0)), g(e, b, c, h), g(f, b, c, d), this;
	g(e, b, c, h);
	f && g(f, b, c, numeric.rep(numeric.dim(h), 0))
};
numeric.T.rep = function Gi(b, c) {
	var d = numeric.T;
	c instanceof d || (c = new d(c));
	var e = c.x;
	c = c.y;
	var f = numeric.rep;
	return c ? new d(f(b, e), f(b, c)) : new d(f(b, e))
};
numeric.T.diag = function Hi(b) {
	b instanceof numeric.T || (b = new numeric.T(b));
	var c = b.x;
	b = b.y;
	var d = numeric.diag;
	return b ? new numeric.T(d(c), d(b)) : new numeric.T(d(c))
};
numeric.T.eig = function Ii() {
	if (this.y) throw Error("eig: not implemented for complex matrices.");
	return numeric.eig(this.x)
};
numeric.T.identity = function Ji(b) {
	return new numeric.T(numeric.identity(b))
};
numeric.T.prototype.getDiag = function Ki() {
	var b = numeric,
		c = this.x,
		d = this.y;
	return d ? new b.T(b.getDiag(c), b.getDiag(d)) : new b.T(b.getDiag(c))
};
numeric.house = function Li(b) {
	var c = numeric.clone(b),
		d = 0 <= b[0] ? 1 : -1;
	b = d * numeric.norm2(b);
	c[0] += b;
	b = numeric.norm2(c);
	if (0 === b) throw Error("eig: internal error");
	return numeric.div(c, b)
};
numeric.toUpperHessenberg = function Mi(b) {
	var c = numeric.dim(b);
	if (2 !== c.length || c[0] !== c[1]) throw Error("numeric: toUpperHessenberg() only works on square matrices");
	var c = c[0],
		d, e, f, g = numeric.clone(b),
		h, k, l, m = numeric.identity(c);
	for (d = 0; d < c - 2; d++) {
		e = Array(c - d - 1);
		for (b = d + 1; b < c; b++) e[b - d - 1] = g[b][d];
		if (0 < numeric.norm2(e)) {
			f = numeric.house(e);
			e = numeric.getBlock(g, [d + 1, d], [c - 1, c - 1]);
			h = numeric.tensor(f, numeric.dot(f, e));
			for (b = d + 1; b < c; b++)
				for (k = g[b], l = h[b - d - 1], e = d; e < c; e++) k[e] -= 2 * l[e - d];
			e = numeric.getBlock(g, [0, d + 1], [c - 1, c - 1]);
			h = numeric.tensor(numeric.dot(e, f), f);
			for (b = 0; b < c; b++)
				for (k = g[b], l = h[b], e = d + 1; e < c; e++) k[e] -= 2 * l[e - d - 1];
			e = Array(c - d - 1);
			for (b = d + 1; b < c; b++) e[b - d - 1] = m[b];
			h = numeric.tensor(f, numeric.dot(f, e));
			for (b = d + 1; b < c; b++)
				for (f = m[b], l = h[b - d - 1], e = 0; e < c; e++) f[e] -= 2 * l[e]
		}
	}
	return {
		H: g,
		Q: m
	}
};
numeric.epsilon = 2.220446049250313E-16;
numeric.QRFrancis = function(a, b) {
	"undefined" === typeof b && (b = 1E4);
	a = numeric.clone(a);
	var c = numeric.clone(a),
		c = numeric.dim(a),
		c = c[0],
		d, e, f, g, h, k, l = numeric.identity(c),
		m, n, r;
	if (3 > c) return {
		Q: l,
		B: [
			[0, c - 1]
		]
	};
	var t = numeric.epsilon;
	for (r = 0; r < b; r++) {
		for (f = 0; f < c - 1; f++)
			if (Math.abs(a[f + 1][f]) < t * (Math.abs(a[f][f]) + Math.abs(a[f + 1][f + 1]))) {
				r = numeric.QRFrancis(numeric.getBlock(a, [0, 0], [f, f]), b);
				a = numeric.QRFrancis(numeric.getBlock(a, [f + 1, f + 1], [c - 1, c - 1]), b);
				g = Array(f + 1);
				for (k = 0; k <= f; k++) g[k] = l[k];
				g = numeric.dot(r.Q,
					g);
				for (k = 0; k <= f; k++) l[k] = g[k];
				g = Array(c - f - 1);
				for (k = f + 1; k < c; k++) g[k - f - 1] = l[k];
				g = numeric.dot(a.Q, g);
				for (k = f + 1; k < c; k++) l[k] = g[k - f - 1];
				return {
					Q: l,
					B: r.B.concat(numeric.add(a.B, f + 1))
				}
			}
		f = a[c - 2][c - 2];
		d = a[c - 2][c - 1];
		g = a[c - 1][c - 2];
		h = a[c - 1][c - 1];
		k = f + h;
		g = f * h - d * g;
		f = numeric.getBlock(a, [0, 0], [2, 2]);
		k * k >= 4 * g ? (d = .5 * (k + Math.sqrt(k * k - 4 * g)), k = .5 * (k - Math.sqrt(k * k - 4 * g)), f = numeric.add(numeric.sub(numeric.dot(f, f), numeric.mul(f, d + k)), numeric.diag(numeric.rep([3], d * k)))) : f = numeric.add(numeric.sub(numeric.dot(f, f), numeric.mul(f,
			k)), numeric.diag(numeric.rep([3], g)));
		d = [f[0][0], f[1][0], f[2][0]];
		e = numeric.house(d);
		g = [a[0], a[1], a[2]];
		g = numeric.tensor(e, numeric.dot(e, g));
		for (k = 0; 3 > k; k++)
			for (m = a[k], n = g[k], d = 0; d < c; d++) m[d] -= 2 * n[d];
		g = numeric.getBlock(a, [0, 0], [c - 1, 2]);
		g = numeric.tensor(numeric.dot(g, e), e);
		for (k = 0; k < c; k++)
			for (m = a[k], n = g[k], d = 0; 3 > d; d++) m[d] -= 2 * n[d];
		g = [l[0], l[1], l[2]];
		g = numeric.tensor(e, numeric.dot(e, g));
		for (k = 0; 3 > k; k++)
			for (e = l[k], n = g[k], d = 0; d < c; d++) e[d] -= 2 * n[d];
		for (f = 0; f < c - 2; f++) {
			for (d = f; d <= f + 1; d++)
				if (Math.abs(a[d +
						1][d]) < t * (Math.abs(a[d][d]) + Math.abs(a[d + 1][d + 1]))) {
					r = numeric.QRFrancis(numeric.getBlock(a, [0, 0], [d, d]), b);
					a = numeric.QRFrancis(numeric.getBlock(a, [d + 1, d + 1], [c - 1, c - 1]), b);
					g = Array(d + 1);
					for (k = 0; k <= d; k++) g[k] = l[k];
					g = numeric.dot(r.Q, g);
					for (k = 0; k <= d; k++) l[k] = g[k];
					g = Array(c - d - 1);
					for (k = d + 1; k < c; k++) g[k - d - 1] = l[k];
					g = numeric.dot(a.Q, g);
					for (k = d + 1; k < c; k++) l[k] = g[k - d - 1];
					return {
						Q: l,
						B: r.B.concat(numeric.add(a.B, d + 1))
					}
				}
			h = Math.min(c - 1, f + 3);
			d = Array(h - f);
			for (k = f + 1; k <= h; k++) d[k - f - 1] = a[k][f];
			e = numeric.house(d);
			g = numeric.getBlock(a, [f + 1, f], [h, c - 1]);
			g = numeric.tensor(e, numeric.dot(e, g));
			for (k = f + 1; k <= h; k++)
				for (m = a[k], n = g[k - f - 1], d = f; d < c; d++) m[d] -= 2 * n[d - f];
			g = numeric.getBlock(a, [0, f + 1], [c - 1, h]);
			g = numeric.tensor(numeric.dot(g, e), e);
			for (k = 0; k < c; k++)
				for (m = a[k], n = g[k], d = f + 1; d <= h; d++) m[d] -= 2 * n[d - f - 1];
			g = Array(h - f);
			for (k = f + 1; k <= h; k++) g[k - f - 1] = l[k];
			g = numeric.tensor(e, numeric.dot(e, g));
			for (k = f + 1; k <= h; k++)
				for (e = l[k], n = g[k - f - 1], d = 0; d < c; d++) e[d] -= 2 * n[d]
		}
	}
	throw Error("numeric: eigenvalue iteration does not converge -- increase maxiter?");
};
numeric.eig = function Ni(b, c) {
	var d = numeric.toUpperHessenberg(b);
	c = numeric.QRFrancis(d.H, c);
	var e = numeric.T,
		f = b.length,
		g, f = c.B,
		h = numeric.dot(c.Q, numeric.dot(d.H, numeric.transpose(c.Q)));
	c = new e(numeric.dot(c.Q, d.Q));
	for (var k, l = f.length, m, n, r, t, u, w, v, x, y = Math.sqrt, d = 0; d < l; d++)
		if (g = f[d][0], g !== f[d][1] && (m = g + 1, n = h[g][g], r = h[g][m], t = h[m][g], u = h[m][m], 0 !== r || 0 !== t)) k = -n - u, w = n * u - r * t, w = k * k - 4 * w, 0 <= w ? (k = 0 > k ? -.5 * (k - y(w)) : -.5 * (k + y(w)), v = (n - k) * (n - k) + r * r, x = t * t + (u - k) * (u - k), v > x ? (v = y(v), n = (n - k) / v, r /= v) : (x = y(x), n =
			t / x, r = (u - k) / x), k = new e([
			[r, -n],
			[n, r]
		])) : (k *= -.5, w = .5 * y(-w), v = (n - k) * (n - k) + r * r, x = t * t + (u - k) * (u - k), v > x ? (v = y(v + w * w), n = (n - k) / v, r /= v, k = 0, w /= v) : (x = y(x + w * w), n = t / x, r = (u - k) / x, k = w / x, w = 0), k = new e([
			[r, -n],
			[n, r]
		], [
			[k, w],
			[w, -k]
		])), c.setRows(g, m, k.dot(c.getRows(g, m)));
	e = c.dot(b).dot(c.transjugate());
	f = b.length;
	b = numeric.T.identity(f);
	for (m = 0; m < f; m++)
		if (0 < m)
			for (d = m - 1; 0 <= d; d--) h = e.get([d, d]), g = e.get([m, m]), numeric.neq(h.x, g.x) || numeric.neq(h.y, g.y) ? (k = e.getRow(d).getBlock([d], [m - 1]), w = b.getRow(m).getBlock([d], [m - 1]),
				b.set([m, d], e.get([d, m]).neg().sub(k.dot(w)).div(h.sub(g)))) : b.setRow(m, b.getRow(d));
	for (m = 0; m < f; m++) k = b.getRow(m), b.setRow(m, k.div(k.norm2()));
	b = b.transpose();
	b = c.transjugate().dot(b);
	return {
		lambda: e.getDiag(),
		E: b
	}
};
numeric.ccsSparse = function Oi(b) {
	var c = b.length,
		d, e, f, g = [];
	for (e = c - 1; - 1 !== e; --e)
		for (f in d = b[e], d) {
			for (f = parseInt(f); f >= g.length;) g[g.length] = 0;
			0 !== d[f] && g[f]++
		}
	d = g.length;
	var h = Array(d + 1);
	for (e = h[0] = 0; e < d; ++e) h[e + 1] = h[e] + g[e];
	var k = Array(h[d]),
		l = Array(h[d]);
	for (e = c - 1; - 1 !== e; --e)
		for (f in d = b[e], d) 0 !== d[f] && (g[f]--, k[h[f] + g[f]] = e, l[h[f] + g[f]] = d[f]);
	return [h, k, l]
};
numeric.ccsFull = function Pi(b) {
	var c = b[0],
		d = b[1],
		e = b[2];
	b = numeric.ccsDim(b);
	var f = b[0];
	b = b[1];
	for (var g, h, k = numeric.rep([f, b], 0), f = 0; f < b; f++)
		for (g = c[f], h = c[f + 1]; g < h; ++g) k[d[g]][f] = e[g];
	return k
};
numeric.ccsTSolve = function Qi(b, c, d, e, f) {
	function g(b) {
		var c;
		if (0 === d[b]) {
			d[b] = 1;
			for (c = h[b]; c < h[b + 1]; ++c) g(k[c]);
			f[n] = b;
			++n
		}
	}
	var h = b[0],
		k = b[1];
	b = b[2];
	var l = h.length - 1,
		m = Math.max,
		n = 0;
	"undefined" === typeof e && (d = numeric.rep([l], 0));
	"undefined" === typeof e && (e = numeric.linspace(0, d.length - 1));
	"undefined" === typeof f && (f = []);
	for (var r, t, u, l = e.length - 1; - 1 !== l; --l) g(e[l]);
	f.length = n;
	for (l = f.length - 1; - 1 !== l; --l) d[f[l]] = 0;
	for (l = e.length - 1; - 1 !== l; --l) r = e[l], d[r] = c[r];
	for (l = f.length - 1; - 1 !== l; --l) {
		r = f[l];
		t = h[r];
		c = m(h[r + 1], t);
		for (e = t; e !== c; ++e)
			if (k[e] === r) {
				d[r] /= b[e];
				break
			}
		u = d[r];
		for (e = t; e !== c; ++e) t = k[e], t !== r && (d[t] -= u * b[e])
	}
	return d
};
numeric.ccsDFS = function Ri(b) {
	this.k = Array(b);
	this.k1 = Array(b);
	this.j = Array(b)
};
numeric.ccsDFS.prototype.dfs = function Si(b, c, d, e, f, g) {
	var h = 0,
		k = f.length,
		l = this.k,
		m = this.k1,
		n = this.j,
		r, t;
	if (0 === e[b])
		for (e[b] = 1, n[0] = b, l[0] = r = c[b], m[0] = t = c[b + 1];;)
			if (r >= t) {
				f[k] = n[h];
				if (0 === h) break;
				++k;
				--h;
				r = l[h];
				t = m[h]
			} else b = g[d[r]], 0 === e[b] ? (e[b] = 1, l[h] = r, ++h, n[h] = b, r = c[b], m[h] = t = c[b + 1]) : ++r
};
numeric.ccsLPSolve = function Ti(b, c, d, e, f, g, h) {
	var k = b[0],
		l = b[1];
	b = b[2];
	var m = k.length - 1,
		n = c[0],
		m = c[1];
	c = c[2];
	var r;
	r = n[f];
	n = n[f + 1];
	e.length = 0;
	for (f = r; f < n; ++f) h.dfs(g[m[f]], k, l, d, e, g);
	for (f = e.length - 1; - 1 !== f; --f) d[e[f]] = 0;
	for (f = r; f !== n; ++f) h = g[m[f]], d[h] = c[f];
	for (f = e.length - 1; - 1 !== f; --f) {
		h = e[f];
		n = k[h];
		m = k[h + 1];
		for (c = n; c < m; ++c)
			if (g[l[c]] === h) {
				d[h] /= b[c];
				break
			}
		r = d[h];
		for (c = n; c < m; ++c) n = g[l[c]], n !== h && (d[n] -= r * b[c])
	}
	return d
};
numeric.ccsLUP1 = function Ui(b, c) {
	var d = b[0].length - 1,
		e = [numeric.rep([d + 1], 0), [],
			[]
		],
		f = [numeric.rep([d + 1], 0), [],
			[]
		],
		g = e[0],
		h = e[1],
		k = e[2],
		l = f[0],
		m = f[1],
		n = f[2],
		r = numeric.rep([d], 0),
		t = numeric.rep([d], 0),
		u, w, v, x, y, D, z, G = numeric.ccsLPSolve;
	u = Math.max;
	var A = Math.abs,
		H = numeric.linspace(0, d - 1),
		O = numeric.linspace(0, d - 1),
		M = new numeric.ccsDFS(d);
	"undefined" === typeof c && (c = 1);
	for (u = 0; u < d; ++u) {
		G(e, b, r, t, u, O, M);
		y = x = -1;
		for (w = t.length - 1; - 1 !== w; --w) v = t[w], v <= u || (D = A(r[v]), D > x && (y = v, x = D));
		A(r[u]) < c * x && (w = H[u], x = H[y],
			H[u] = x, O[x] = u, H[y] = w, O[w] = y, x = r[u], r[u] = r[y], r[y] = x);
		x = g[u];
		y = l[u];
		z = r[u];
		h[x] = H[u];
		k[x] = 1;
		++x;
		for (w = t.length - 1; - 1 !== w; --w) v = t[w], D = r[v], t[w] = 0, r[v] = 0, v <= u ? (m[y] = v, n[y] = D, ++y) : (h[x] = H[v], k[x] = D / z, ++x);
		g[u + 1] = x;
		l[u + 1] = y
	}
	for (w = h.length - 1; - 1 !== w; --w) h[w] = O[h[w]];
	return {
		L: e,
		U: f,
		P: H,
		Pinv: O
	}
};
numeric.ccsDFS0 = function Vi(b) {
	this.k = Array(b);
	this.k1 = Array(b);
	this.j = Array(b)
};
numeric.ccsDFS0.prototype.dfs = function Wi(b, c, d, e, f, g, h) {
	h = 0;
	var k = f.length,
		l = this.k,
		m = this.k1,
		n = this.j,
		r, t;
	if (0 === e[b])
		for (e[b] = 1, n[0] = b, l[0] = r = c[g[b]], m[0] = t = c[g[b] + 1];;) {
			if (isNaN(r)) throw Error("Ow!");
			if (r >= t) {
				f[k] = g[n[h]];
				if (0 === h) break;
				++k;
				--h;
				r = l[h];
				t = m[h]
			} else b = d[r], 0 === e[b] ? (e[b] = 1, l[h] = r, ++h, n[h] = b, b = g[b], r = c[b], m[h] = t = c[b + 1]) : ++r
		}
};
numeric.ccsLPSolve0 = function Xi(b, c, d, e, f, g, h, k) {
	var l = b[0],
		m = b[1];
	b = b[2];
	var n = l.length - 1,
		r = c[0],
		n = c[1];
	c = c[2];
	var t;
	t = r[f];
	r = r[f + 1];
	e.length = 0;
	for (f = t; f < r; ++f) k.dfs(n[f], l, m, d, e, g, h);
	for (f = e.length - 1; - 1 !== f; --f) g = e[f], d[h[g]] = 0;
	for (f = t; f !== r; ++f) g = n[f], d[g] = c[f];
	for (f = e.length - 1; - 1 !== f; --f) {
		g = e[f];
		n = h[g];
		k = l[g];
		g = l[g + 1];
		for (c = k; c < g; ++c)
			if (m[c] === n) {
				d[n] /= b[c];
				break
			}
		t = d[n];
		for (c = k; c < g; ++c) d[m[c]] -= t * b[c];
		d[n] = t
	}
};
numeric.ccsLUP0 = function Yi(b, c) {
	var d = b[0].length - 1,
		e = [numeric.rep([d + 1], 0), [],
			[]
		],
		f = [numeric.rep([d + 1], 0), [],
			[]
		],
		g = e[0],
		h = e[1],
		k = e[2],
		l = f[0],
		m = f[1],
		n = f[2],
		r = numeric.rep([d], 0),
		t = numeric.rep([d], 0),
		u, w, v, x, y, D, z, G = numeric.ccsLPSolve0;
	u = Math.max;
	var A = Math.abs,
		H = numeric.linspace(0, d - 1),
		O = numeric.linspace(0, d - 1),
		M = new numeric.ccsDFS0(d);
	"undefined" === typeof c && (c = 1);
	for (u = 0; u < d; ++u) {
		G(e, b, r, t, u, O, H, M);
		y = x = -1;
		for (w = t.length - 1; - 1 !== w; --w) v = t[w], v <= u || (D = A(r[H[v]]), D > x && (y = v, x = D));
		A(r[H[u]]) < c * x && (w =
			H[u], x = H[y], H[u] = x, O[x] = u, H[y] = w, O[w] = y);
		x = g[u];
		y = l[u];
		z = r[H[u]];
		h[x] = H[u];
		k[x] = 1;
		++x;
		for (w = t.length - 1; - 1 !== w; --w) v = t[w], D = r[H[v]], t[w] = 0, r[H[v]] = 0, v <= u ? (m[y] = v, n[y] = D, ++y) : (h[x] = H[v], k[x] = D / z, ++x);
		g[u + 1] = x;
		l[u + 1] = y
	}
	for (w = h.length - 1; - 1 !== w; --w) h[w] = O[h[w]];
	return {
		L: e,
		U: f,
		P: H,
		Pinv: O
	}
};
numeric.ccsLUP = numeric.ccsLUP0;
numeric.ccsDim = function Zi(b) {
	return [numeric.sup(b[1]) + 1, b[0].length - 1]
};
numeric.ccsGetBlock = function $i(b, c, d) {
	var e = numeric.ccsDim(b),
		f = e[0],
		g = e[1];
	"undefined" === typeof c ? c = numeric.linspace(0, f - 1) : "number" === typeof c && (c = [c]);
	"undefined" === typeof d ? d = numeric.linspace(0, g - 1) : "number" === typeof d && (d = [d]);
	var h, e = c.length,
		k = d.length,
		l, g = numeric.rep([g], 0),
		m = [],
		n = [],
		r = [g, m, n],
		t = b[0],
		u = b[1];
	b = b[2];
	for (var w = numeric.rep([f], 0), v = 0, x = numeric.rep([f], 0), f = 0; f < k; ++f) {
		h = d[f];
		var y = t[h],
			D = t[h + 1];
		for (h = y; h < D; ++h) l = u[h], x[l] = 1, w[l] = b[h];
		for (h = 0; h < e; ++h) l = c[h], x[l] && (m[v] = h, n[v] =
			w[c[h]], ++v);
		for (h = y; h < D; ++h) l = u[h], x[l] = 0;
		g[f + 1] = v
	}
	return r
};
numeric.ccsDot = function aj(b, c) {
	var d = b[0],
		e = b[1],
		f = b[2],
		g = c[0],
		h = c[1],
		k = c[2];
	b = numeric.ccsDim(b);
	c = numeric.ccsDim(c);
	var l = b[0];
	b = b[1];
	b = c[1];
	c = numeric.rep([l], 0);
	var m = numeric.rep([l], 0),
		l = Array(l),
		n = numeric.rep([b], 0),
		r = [],
		t = [],
		u = [n, r, t],
		w, v, x, y, D, z, G, A;
	for (x = 0; x !== b; ++x) {
		y = g[x];
		D = g[x + 1];
		G = 0;
		for (v = y; v < D; ++v)
			for (y = h[v], A = k[v], w = d[y], y = d[y + 1]; w < y; ++w) z = e[w], 0 === m[z] && (l[G] = z, m[z] = 1, G += 1), c[z] += f[w] * A;
		y = n[x];
		D = y + G;
		n[x + 1] = D;
		for (v = G - 1; - 1 !== v; --v) A = y + v, w = l[v], r[A] = w, t[A] = c[w], m[w] = 0, c[w] = 0;
		n[x + 1] = n[x] +
			G
	}
	return u
};
numeric.ccsLUPSolve = function bj(b, c) {
	var d = b.L,
		e = b.U,
		f = b.P,
		f = c[0],
		g = !1;
	"object" !== typeof f && (c = [
		[0, c.length], numeric.linspace(0, c.length - 1), c
	], f = c[0], g = !0);
	var h = c[1];
	c = c[2];
	var k = d[0].length - 1,
		l = f.length - 1,
		m = numeric.rep([k], 0),
		n = Array(k),
		r = numeric.rep([k], 0),
		k = Array(k),
		t = numeric.rep([l + 1], 0),
		u = [],
		w = [],
		v = numeric.ccsTSolve,
		x, y, D, z, G, A = 0;
	for (x = 0; x < l; ++x) {
		z = 0;
		y = f[x];
		for (D = f[x + 1]; y < D; ++y) G = b.Pinv[h[y]], k[z] = G, r[G] = c[y], ++z;
		k.length = z;
		v(d, r, m, k, n);
		for (y = k.length - 1; - 1 !== y; --y) r[k[y]] = 0;
		v(e, m, r, n, k);
		if (g) return r;
		for (y = n.length - 1; - 1 !== y; --y) m[n[y]] = 0;
		for (y = k.length - 1; - 1 !== y; --y) G = k[y], u[A] = G, w[A] = r[G], r[G] = 0, ++A;
		t[x + 1] = A
	}
	return [t, u, w]
};
numeric.ccsbinop = function cj(b, c) {
	"undefined" === typeof c && (c = "");
	return Function("X", "Y", "var Xi = X[0], Xj = X[1], Xv = X[2];\nvar Yi = Y[0], Yj = Y[1], Yv = Y[2];\nvar n = Xi.length-1,m = Math.max(numeric.sup(Xj),numeric.sup(Yj))+1;\nvar Zi = numeric.rep([n+1],0), Zj = [], Zv = [];\nvar x = numeric.rep([m],0),y = numeric.rep([m],0);\nvar xk,yk,zk;\nvar i,j,j0,j1,k,p=0;\n" + c + "for(i=0;i<n;++i) {\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Xj[j];\n    x[k] = 1;\n    Zj[p] = k;\n    ++p;\n  }\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Yj[j];\n    y[k] = Yv[j];\n    if(x[k] === 0) {\n      Zj[p] = k;\n      ++p;\n    }\n  }\n  Zi[i+1] = p;\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = Xv[j];\n  j0 = Zi[i]; j1 = Zi[i+1];\n  for(j=j0;j!==j1;++j) {\n    k = Zj[j];\n    xk = x[k];\n    yk = y[k];\n" +
		b + "\n    Zv[j] = zk;\n  }\n  j0 = Xi[i]; j1 = Xi[i+1];\n  for(j=j0;j!==j1;++j) x[Xj[j]] = 0;\n  j0 = Yi[i]; j1 = Yi[i+1];\n  for(j=j0;j!==j1;++j) y[Yj[j]] = 0;\n}\nreturn [Zi,Zj,Zv];")
};
(function() {
	var a, b, c, d;
	for (a in numeric.ops2) b = isFinite(eval("1" + numeric.ops2[a] + "0")) ? "[Y[0],Y[1],numeric." + a + "(X,Y[2])]" : "NaN", c = isFinite(eval("0" + numeric.ops2[a] + "1")) ? "[X[0],X[1],numeric." + a + "(X[2],Y)]" : "NaN", d = isFinite(eval("1" + numeric.ops2[a] + "0")) && isFinite(eval("0" + numeric.ops2[a] + "1")) ? "numeric.ccs" + a + "MM(X,Y)" : "NaN", numeric["ccs" + a + "MM"] = numeric.ccsbinop("zk = xk " + numeric.ops2[a] + "yk;"), numeric["ccs" + a] = Function("X", "Y", 'if(typeof X === "number") return ' + b + ';\nif(typeof Y === "number") return ' +
		c + ";\nreturn " + d + ";\n")
})();
numeric.ccsScatter = function dj(b) {
	var c = b[0],
		d = b[1];
	b = b[2];
	var e = numeric.sup(d) + 1,
		f = c.length,
		g = numeric.rep([e], 0),
		h = Array(f),
		k = Array(f),
		l = numeric.rep([e], 0),
		m;
	for (m = 0; m < f; ++m) l[d[m]]++;
	for (m = 0; m < e; ++m) g[m + 1] = g[m] + l[m];
	var e = g.slice(0),
		n;
	for (m = 0; m < f; ++m) n = d[m], l = e[n], h[l] = c[m], k[l] = b[m], e[n] += 1;
	return [g, h, k]
};
numeric.ccsGather = function ej(b) {
	var c = b[0],
		d = b[1];
	b = b[2];
	var e = c.length - 1,
		f = d.length,
		g = Array(f),
		h = Array(f),
		f = Array(f),
		k, l, m, n;
	for (k = n = 0; k < e; ++k)
		for (l = c[k], m = c[k + 1]; l !== m; ++l) h[n] = k, g[n] = d[l], f[n] = b[l], ++n;
	return [g, h, f]
};
numeric.sdim = function fj(b, c, d) {
	"undefined" === typeof c && (c = []);
	if ("object" !== typeof b) return c;
	"undefined" === typeof d && (d = 0);
	d in c || (c[d] = 0);
	b.length > c[d] && (c[d] = b.length);
	for (var e in b) b.hasOwnProperty(e) && fj(b[e], c, d + 1);
	return c
};
numeric.sclone = function gj(b, c, d) {
	"undefined" === typeof c && (c = 0);
	"undefined" === typeof d && (d = numeric.sdim(b).length);
	var e, f = Array(b.length);
	if (c === d - 1) {
		for (e in b) b.hasOwnProperty(e) && (f[e] = b[e]);
		return f
	}
	for (e in b) b.hasOwnProperty(e) && (f[e] = gj(b[e], c + 1, d));
	return f
};
numeric.sdiag = function hj(b) {
	for (var c = b.length, d = Array(c), e, c = c - 1; 1 <= c; c -= 2) e = c - 1, d[c] = [], d[c][c] = b[c], d[e] = [], d[e][e] = b[e];
	0 === c && (d[0] = [], d[0][0] = b[c]);
	return d
};
numeric.sidentity = function ij(b) {
	return numeric.sdiag(numeric.rep([b], 1))
};
numeric.stranspose = function jj(b) {
	var c = [],
		d = b.length,
		e, f;
	for (e in b)
		if (b.hasOwnProperty(e))
			for (f in d = b[e], d) d.hasOwnProperty(f) && ("object" !== typeof c[f] && (c[f] = []), c[f][e] = d[f]);
	return c
};
numeric.sLUP = function kj(b, c) {
	throw Error("The function numeric.sLUP had a bug in it and has been removed. Please use the new numeric.ccsLUP function instead.");
};
numeric.sdotMM = function lj(b, c) {
	var d = b.length,
		e = c.length;
	c = numeric.stranspose(c);
	var e = c.length,
		f, g, h, k, l, m = Array(d),
		n;
	for (g = d - 1; 0 <= g; g--) {
		n = [];
		d = b[g];
		for (k = e - 1; 0 <= k; k--) {
			l = 0;
			f = c[k];
			for (h in d) d.hasOwnProperty(h) && h in f && (l += d[h] * f[h]);
			l && (n[k] = l)
		}
		m[g] = n
	}
	return m
};
numeric.sdotMV = function mj(b, c) {
	var d = b.length,
		e, f, g = Array(d),
		h;
	for (e = d - 1; 0 <= e; e--) {
		d = b[e];
		h = 0;
		for (f in d) d.hasOwnProperty(f) && c[f] && (h += d[f] * c[f]);
		h && (g[e] = h)
	}
	return g
};
numeric.sdotVM = function nj(b, c) {
	var d, e, f, g, h = [];
	for (d in b)
		if (b.hasOwnProperty(d))
			for (e in f = c[d], g = b[d], f) f.hasOwnProperty(e) && (h[e] || (h[e] = 0), h[e] += g * f[e]);
	return h
};
numeric.sdotVV = function oj(b, c) {
	var d, e = 0;
	for (d in b) b[d] && c[d] && (e += b[d] * c[d]);
	return e
};
numeric.sdot = function pj(b, c) {
	var d = numeric.sdim(b).length,
		e = numeric.sdim(c).length,
		f = 1E3 * d + e;
	switch (f) {
		case 0:
			return b * c;
		case 1001:
			return numeric.sdotVV(b, c);
		case 2001:
			return numeric.sdotMV(b, c);
		case 1002:
			return numeric.sdotVM(b, c);
		case 2002:
			return numeric.sdotMM(b, c);
		default:
			throw Error("numeric.sdot not implemented for tensors of order " + d + " and " + e);
	}
};
numeric.sscatter = function qj(b) {
	var c = b[0].length,
		d, e, f = b.length,
		g = [],
		h;
	for (d = c - 1; 0 <= d; --d)
		if (b[f - 1][d]) {
			h = g;
			for (e = 0; e < f - 2; e++) c = b[e][d], h[c] || (h[c] = []), h = h[c];
			h[b[e][d]] = b[e + 1][d]
		}
	return g
};
numeric.sgather = function rj(b, c, d) {
	"undefined" === typeof c && (c = []);
	"undefined" === typeof d && (d = []);
	var e, f, g;
	e = d.length;
	for (f in b)
		if (b.hasOwnProperty(f))
			if (d[e] = parseInt(f), g = b[f], "number" === typeof g) {
				if (g) {
					if (0 === c.length)
						for (f = e + 1; 0 <= f; --f) c[f] = [];
					for (f = e; 0 <= f; --f) c[f].push(d[f]);
					c[e + 1].push(g)
				}
			} else rj(g, c, d);
	d.length > e && d.pop();
	return c
};
numeric.cLU = function sj(b) {
	var c = b[0],
		d = b[1],
		e = b[2],
		f = c.length;
	b = 0;
	var g, h, k;
	for (g = 0; g < f; g++) c[g] > b && (b = c[g]);
	b++;
	var l = Array(b),
		m = Array(b),
		n = numeric.rep([b], Infinity),
		r = numeric.rep([b], -Infinity),
		t, u;
	for (k = 0; k < f; k++) g = c[k], h = d[k], h < n[g] && (n[g] = h), h > r[g] && (r[g] = h);
	for (g = 0; g < b - 1; g++) r[g] > r[g + 1] && (r[g + 1] = r[g]);
	for (g = b - 1; 1 <= g; g--) n[g] < n[g - 1] && (n[g - 1] = n[g]);
	for (g = t = h = 0; g < b; g++) m[g] = numeric.rep([r[g] - n[g] + 1], 0), l[g] = numeric.rep([g - n[g]], 0), h += g - n[g] + 1, t += r[g] - g + 1;
	for (k = 0; k < f; k++) g = c[k], m[g][d[k] - n[g]] =
		e[k];
	for (g = 0; g < b - 1; g++)
		for (c = g - n[g], e = m[g], h = g + 1; n[h] <= g && h < b; h++)
			if (d = g - n[h], f = r[g] - g, t = m[h], u = t[d] / e[c]) {
				for (k = 1; k <= f; k++) t[k + d] -= u * e[k + c];
				l[h][g - n[h]] = u
			}
	e = [];
	t = [];
	k = [];
	u = [];
	var w = [],
		v = [],
		x, y;
	for (g = x = f = 0; g < b; g++) {
		c = n[g];
		d = r[g];
		y = m[g];
		for (h = g; h <= d; h++) y[h - c] && (e[f] = g, t[f] = h, k[f] = y[h - c], f++);
		y = l[g];
		for (h = c; h < g; h++) y[h - c] && (u[x] = g, w[x] = h, v[x] = y[h - c], x++);
		u[x] = g;
		w[x] = g;
		v[x] = 1;
		x++
	}
	return {
		U: [e, t, k],
		L: [u, w, v]
	}
};
numeric.cLUsolve = function tj(b, c) {
	var d = b.L,
		e = b.U;
	c = numeric.clone(c);
	var f = d[0];
	b = d[1];
	var d = d[2],
		g = e[0],
		h = e[1],
		e = e[2],
		g = g.length,
		f = f.length,
		f = c.length,
		k, l;
	for (k = l = 0; k < f; k++) {
		for (; b[l] < k;) c[k] -= d[l] * c[b[l]], l++;
		l++
	}
	l = g - 1;
	for (k = f - 1; 0 <= k; k--) {
		for (; h[l] > k;) c[k] -= e[l] * c[h[l]], l--;
		c[k] /= e[l];
		l--
	}
	return c
};
numeric.cgrid = function uj(b, c) {
	"number" === typeof b && (b = [b, b]);
	var d = numeric.rep(b, -1),
		e, f, g;
	if ("function" !== typeof c) switch (c) {
		case "L":
			c = function(c, d) {
				return c >= b[0] / 2 || d < b[1] / 2
			};
			break;
		default:
			c = function(b, c) {
				return !0
			}
	}
	g = 0;
	for (e = 1; e < b[0] - 1; e++)
		for (f = 1; f < b[1] - 1; f++) c(e, f) && (d[e][f] = g, g++);
	return d
};
numeric.cdelsq = function vj(b) {
	var c = [
			[-1, 0],
			[0, -1],
			[0, 1],
			[1, 0]
		],
		d = numeric.dim(b),
		e = d[0],
		d = d[1],
		f, g, h, k, l, m = [],
		n = [],
		r = [];
	for (f = 1; f < e - 1; f++)
		for (g = 1; g < d - 1; g++)
			if (!(0 > b[f][g])) {
				for (h = 0; 4 > h; h++) k = f + c[h][0], l = g + c[h][1], 0 > b[k][l] || (m.push(b[f][g]), n.push(b[k][l]), r.push(-1));
				m.push(b[f][g]);
				n.push(b[f][g]);
				r.push(4)
			}
	return [m, n, r]
};
numeric.cdotMV = function wj(b, c) {
	var d, e = b[0],
		f = b[1];
	b = b[2];
	var g, h = e.length;
	for (g = d = 0; g < h; g++) e[g] > d && (d = e[g]);
	d++;
	d = numeric.rep([d], 0);
	for (g = 0; g < h; g++) d[e[g]] += b[g] * c[f[g]];
	return d
};
numeric.Spline = function xj(b, c, d, e, f) {
	this.x = b;
	this.yl = c;
	this.yr = d;
	this.kl = e;
	this.kr = f
};
numeric.Spline.prototype._at = function _at(b, c) {
	var d = this.x,
		e = this.yl,
		f = this.yr,
		g = this.kl,
		h = this.kr,
		k = numeric.add,
		l = numeric.sub,
		m = numeric.mul,
		g = l(m(g[c], d[c + 1] - d[c]), l(f[c + 1], e[c])),
		h = k(m(h[c + 1], d[c] - d[c + 1]), l(f[c + 1], e[c]));
	b = (b - d[c]) / (d[c + 1] - d[c]);
	d = b * (1 - b);
	return k(k(k(m(1 - b, e[c]), m(b, f[c + 1])), m(g, d * (1 - b))), m(h, d * b))
};
numeric.Spline.prototype.at = function yj(b) {
	if ("number" === typeof b) {
		var c = this.x,
			d = c.length,
			e, f, g = Math.floor;
		e = 0;
		for (--d; 1 < d - e;) f = g((e + d) / 2), c[f] <= b ? e = f : d = f;
		return this._at(b, e)
	}
	d = b.length;
	c = Array(d);
	for (e = d - 1; - 1 !== e; --e) c[e] = this.at(b[e]);
	return c
};
numeric.Spline.prototype.diff = function zj() {
	for (var b = this.x, c = this.yl, d = this.yr, e = this.kl, f = this.kr, g = c.length, h, k, l = e, m = f, n = Array(g), r = Array(g), t = numeric.add, u = numeric.mul, w = numeric.div, v = numeric.sub, g = g - 1; - 1 !== g; --g) h = b[g + 1] - b[g], k = v(d[g + 1], c[g]), n[g] = w(t(u(k, 6), u(e[g], -4 * h), u(f[g + 1], -2 * h)), h * h), r[g + 1] = w(t(u(k, -6), u(e[g], 2 * h), u(f[g + 1], 4 * h)), h * h);
	return new numeric.Spline(b, l, m, n, r)
};
numeric.Spline.prototype.roots = function Aj() {
	var b = [],
		c = this.x,
		d = this.yl,
		e = this.yr,
		f = this.kl,
		g = this.kr;
	"number" === typeof d[0] && (d = [d], e = [e], f = [f], g = [g]);
	var h = d.length,
		k = c.length - 1,
		l, m, n, r, t, u, w, b = Array(h),
		v, x, y, D, z, G, A, H, O = Math.sqrt;
	for (l = 0; l !== h; ++l) {
		r = d[l];
		t = e[l];
		u = f[l];
		w = g[l];
		v = [];
		for (m = 0; m !== k; m++) {
			0 < m && 0 > t[m] * r[m] && v.push(c[m]);
			y = c[m + 1] - c[m];
			x = c[m];
			n = r[m];
			D = t[m + 1];
			x = u[m] / y;
			y = w[m + 1] / y;
			z = x - y + 3 * (n - D);
			z *= z;
			G = z + 12 * y * n;
			z = y + 3 * n + 2 * x - 3 * D;
			n = 3 * (y + x + 2 * (n - D));
			0 >= G ? (x = z / n, D = x > c[m] && x < c[m + 1] ? [c[m], x, c[m + 1]] : [c[m], c[m + 1]]) : (x = (z - O(G)) / n, A = (z + O(G)) / n, D = [c[m]], x > c[m] && x < c[m + 1] && D.push(x), A > c[m] && A < c[m + 1] && D.push(A), D.push(c[m + 1]));
			z = D[0];
			x = this._at(z, m);
			for (n = 0; n < D.length - 1; n++)
				if (H = D[n + 1], A = this._at(H, m), 0 === x) v.push(z), z = H, x = A;
				else if (0 === A || 0 < x * A) z = H, x = A;
			else {
				for (var M = 0;;) {
					G = (x * H - A * z) / (x - A);
					if (G <= z || G >= H) break;
					y = this._at(G, m);
					if (0 < y * A) H = G, A = y, -1 === M && (x *= .5), M = -1;
					else if (0 < y * x) z = G, x = y, 1 === M && (A *= .5), M = 1;
					else break
				}
				v.push(G);
				z = D[n + 1];
				x = this._at(z, m)
			}
			0 === A && v.push(H)
		}
		b[l] = v
	}
	return "number" === typeof this.yl[0] ?
		b[0] : b
};
numeric.spline = function Bj(b, c, d, e) {
	var f = b.length,
		g = [],
		h = [],
		k = [],
		l, m = numeric.sub,
		n = numeric.mul,
		r = numeric.add;
	for (l = f - 2; 0 <= l; l--) h[l] = b[l + 1] - b[l], k[l] = m(c[l + 1], c[l]);
	if ("string" === typeof d || "string" === typeof e) d = e = "periodic";
	m = [
		[],
		[],
		[]
	];
	switch (typeof d) {
		case "undefined":
			g[0] = n(3 / (h[0] * h[0]), k[0]);
			m[0].push(0, 0);
			m[1].push(0, 1);
			m[2].push(2 / h[0], 1 / h[0]);
			break;
		case "string":
			g[0] = r(n(3 / (h[f - 2] * h[f - 2]), k[f - 2]), n(3 / (h[0] * h[0]), k[0]));
			m[0].push(0, 0, 0);
			m[1].push(f - 2, 0, 1);
			m[2].push(1 / h[f - 2], 2 / h[f - 2] + 2 / h[0],
				1 / h[0]);
			break;
		default:
			g[0] = d, m[0].push(0), m[1].push(0), m[2].push(1)
	}
	for (l = 1; l < f - 1; l++) g[l] = r(n(3 / (h[l - 1] * h[l - 1]), k[l - 1]), n(3 / (h[l] * h[l]), k[l])), m[0].push(l, l, l), m[1].push(l - 1, l, l + 1), m[2].push(1 / h[l - 1], 2 / h[l - 1] + 2 / h[l], 1 / h[l]);
	switch (typeof e) {
		case "undefined":
			g[f - 1] = n(3 / (h[f - 2] * h[f - 2]), k[f - 2]);
			m[0].push(f - 1, f - 1);
			m[1].push(f - 2, f - 1);
			m[2].push(1 / h[f - 2], 2 / h[f - 2]);
			break;
		case "string":
			m[1][m[1].length - 1] = 0;
			break;
		default:
			g[f - 1] = e, m[0].push(f - 1), m[1].push(f - 1), m[2].push(1)
	}
	g = "number" !== typeof g[0] ? numeric.transpose(g) : [g];
	e = Array(g.length);
	if ("string" === typeof d)
		for (l = e.length - 1; - 1 !== l; --l) e[l] = numeric.ccsLUPSolve(numeric.ccsLUP(numeric.ccsScatter(m)), g[l]), e[l][f - 1] = e[l][0];
	else
		for (l = e.length - 1; - 1 !== l; --l) e[l] = numeric.cLUsolve(numeric.cLU(m), g[l]);
	e = "number" === typeof c[0] ? e[0] : numeric.transpose(e);
	return new numeric.Spline(b, c, c, e, e)
};
numeric.fftpow2 = function Cj(b, c) {
	var d = b.length;
	if (1 !== d) {
		var e = Math.cos,
			f = Math.sin,
			g, h, k = Array(d / 2),
			l = Array(d / 2),
			m = Array(d / 2),
			n = Array(d / 2);
		h = d / 2;
		for (g = d - 1; - 1 !== g; --g) --h, m[h] = b[g], n[h] = c[g], --g, k[h] = b[g], l[h] = c[g];
		Cj(k, l);
		Cj(m, n);
		h = d / 2;
		var r, t = -6.283185307179586 / d,
			u;
		for (g = d - 1; - 1 !== g; --g) --h, -1 === h && (h = d / 2 - 1), r = t * g, u = e(r), r = f(r), b[g] = k[h] + u * m[h] - r * n[h], c[g] = l[h] + u * n[h] + r * m[h]
	}
};
numeric._ifftpow2 = function _ifftpow2(b, c) {
	var d = b.length;
	if (1 !== d) {
		var e = Math.cos,
			f = Math.sin,
			g, h, k = Array(d / 2),
			l = Array(d / 2),
			m = Array(d / 2),
			n = Array(d / 2);
		h = d / 2;
		for (g = d - 1; - 1 !== g; --g) --h, m[h] = b[g], n[h] = c[g], --g, k[h] = b[g], l[h] = c[g];
		_ifftpow2(k, l);
		_ifftpow2(m, n);
		h = d / 2;
		var r, t = 6.283185307179586 / d,
			u;
		for (g = d - 1; - 1 !== g; --g) --h, -1 === h && (h = d / 2 - 1), r = t * g, u = e(r), r = f(r), b[g] = k[h] + u * m[h] - r * n[h], c[g] = l[h] + u * n[h] + r * m[h]
	}
};
numeric.ifftpow2 = function Dj(b, c) {
	numeric._ifftpow2(b, c);
	numeric.diveq(b, b.length);
	numeric.diveq(c, c.length)
};
numeric.convpow2 = function Ej(b, c, d, e) {
	numeric.fftpow2(b, c);
	numeric.fftpow2(d, e);
	var f;
	f = b.length;
	var g, h, k, l;
	for (--f; - 1 !== f; --f) g = b[f], k = c[f], h = d[f], l = e[f], b[f] = g * h - k * l, c[f] = g * l + k * h;
	numeric.ifftpow2(b, c)
};
numeric.T.prototype.fft = function Fj() {
	var b = this.x,
		c = this.y,
		d = b.length,
		e = Math.log,
		f = e(2),
		e = Math.ceil(e(2 * d - 1) / f),
		g = Math.pow(2, e),
		e = numeric.rep([g], 0),
		f = numeric.rep([g], 0),
		h = Math.cos,
		k = Math.sin,
		l, m = -3.141592653589793 / d,
		n = numeric.rep([g], 0),
		r = numeric.rep([g], 0);
	l = Math.floor(d / 2);
	for (l = 0; l < d; l++) n[l] = b[l];
	if ("undefined" !== typeof c)
		for (l = 0; l < d; l++) r[l] = c[l];
	for (l = e[0] = 1; l <= g / 2; l++) b = m * l * l, e[l] = h(b), f[l] = k(b), e[g - l] = h(b), f[g - l] = k(b);
	b = new numeric.T(n, r);
	c = new numeric.T(e, f);
	b = b.mul(c);
	numeric.convpow2(b.x,
		b.y, numeric.clone(c.x), numeric.neg(c.y));
	b = b.mul(c);
	b.x.length = d;
	b.y.length = d;
	return b
};
numeric.T.prototype.ifft = function Gj() {
	var b = this.x,
		c = this.y,
		d = b.length,
		e = Math.log,
		f = e(2),
		e = Math.ceil(e(2 * d - 1) / f),
		g = Math.pow(2, e),
		e = numeric.rep([g], 0),
		f = numeric.rep([g], 0),
		h = Math.cos,
		k = Math.sin,
		l, m = 3.141592653589793 / d,
		n = numeric.rep([g], 0),
		r = numeric.rep([g], 0);
	l = Math.floor(d / 2);
	for (l = 0; l < d; l++) n[l] = b[l];
	if ("undefined" !== typeof c)
		for (l = 0; l < d; l++) r[l] = c[l];
	for (l = e[0] = 1; l <= g / 2; l++) b = m * l * l, e[l] = h(b), f[l] = k(b), e[g - l] = h(b), f[g - l] = k(b);
	b = new numeric.T(n, r);
	c = new numeric.T(e, f);
	b = b.mul(c);
	numeric.convpow2(b.x,
		b.y, numeric.clone(c.x), numeric.neg(c.y));
	b = b.mul(c);
	b.x.length = d;
	b.y.length = d;
	return b.div(d)
};
numeric.gradient = function Hj(b, c) {
	var d = c.length,
		e = b(c);
	if (isNaN(e)) throw Error("gradient: f(x) is a NaN!");
	var f = Math.max,
		g, h = numeric.clone(c),
		k, l, m = Array(d),
		f = numeric.div,
		f = numeric.sub,
		n, f = Math.max,
		r = Math.abs,
		t = Math.min,
		u, w, v, x = 0,
		y;
	for (g = 0; g < d; g++)
		for (var D = f(1E-6 * e, 1E-8);;) {
			++x;
			if (20 < x) throw Error("Numerical gradient fails");
			h[g] = c[g] + D;
			k = b(h);
			h[g] = c[g] - D;
			l = b(h);
			h[g] = c[g];
			if (isNaN(k) || isNaN(l)) D /= 16;
			else if (m[g] = (k - l) / (2 * D), u = c[g] - D, w = c[g], v = c[g] + D, n = (k - e) / D, y = (e - l) / D, k = f(r(m[g]), r(e), r(k), r(l),
					r(u), r(w), r(v), 1E-8), n = t(f(r(n - m[g]), r(y - m[g]), r(n - y)) / k, D / k), .001 < n) D /= 16;
			else break
		}
	return m
};
numeric.uncmin = function km(b, c, d, e, f, g, h) {
	var k = numeric.gradient;
	"undefined" === typeof h && (h = {});
	"undefined" === typeof d && (d = 1E-8);
	"undefined" === typeof e && (e = function(c) {
		return k(b, c)
	});
	"undefined" === typeof f && (f = 1E3);
	c = numeric.clone(c);
	var l = c.length,
		m = b(c),
		n, r;
	if (isNaN(m)) throw Error("uncmin: f(x0) is a NaN!");
	var t = Math.max,
		u = numeric.norm2;
	d = t(d, numeric.epsilon);
	var w, v;
	h = h.Hinv || numeric.identity(l);
	var l = numeric.dot,
		t = numeric.inv,
		t = numeric.sub,
		x = numeric.add,
		y = numeric.tensor,
		D = numeric.div,
		z = numeric.mul,
		G = numeric.all,
		A = numeric.isFinite,
		H = numeric.neg,
		O = 0,
		M, J, P, L, Q = "";
	for (v = e(c); O < f;) {
		if ("function" === typeof g && g(O, c, m, v, h)) {
			Q = "Callback returned true";
			break
		}
		if (!G(A(v))) {
			Q = "Gradient has Infinity or NaN";
			break
		}
		w = H(l(h, v));
		if (!G(A(w))) {
			Q = "Search direction has Infinity or NaN";
			break
		}
		L = u(w);
		if (L < d) {
			Q = "Newton step smaller than tol";
			break
		}
		P = 1;
		r = l(v, w);
		for (J = c; O < f && !(P * L < d);)
			if (M = z(w, P), J = x(c, M), n = b(J), n - m >= .1 * P * r || isNaN(n)) P *= .5, ++O;
			else break;
		if (P * L < d) {
			Q = "Line search step size smaller than tol";
			break
		}
		if (O ===
			f) {
			Q = "maxit reached during line search";
			break
		}
		r = e(J);
		c = t(r, v);
		v = l(c, M);
		m = l(h, c);
		h = t(x(h, z((v + l(c, m)) / (v * v), y(M, M))), D(x(y(m, M), y(M, m)), v));
		c = J;
		m = n;
		v = r;
		++O
	}
	return {
		solution: c,
		f: m,
		gradient: v,
		invHessian: h,
		iterations: O,
		message: Q
	}
};
numeric.Dopri = function lm(b, c, d, e, f, g, h) {
	this.x = b;
	this.y = c;
	this.f = d;
	this.ymid = e;
	this.iterations = f;
	this.events = h;
	this.message = g
};
numeric.Dopri.prototype._at = function _at$jscomp$1(b, c) {
	function d(b) {
		return b * b
	}
	var e = this,
		f = e.x,
		g = e.y,
		h = e.f,
		k = e.ymid,
		e = f.length,
		l, m, n, e = Math.floor,
		e = numeric.add,
		r = numeric.mul,
		t = numeric.sub,
		u;
	l = f[c];
	m = f[c + 1];
	f = g[c];
	g = g[c + 1];
	n = m - l;
	n = l + .5 * n;
	k = k[c];
	u = t(h[c], r(f, 1 / (l - n) + 2 / (l - m)));
	c = t(h[c + 1], r(g, 1 / (m - n) + 2 / (m - l)));
	b = [d(b - m) * (b - n) / d(l - m) / (l - n), d(b - l) * d(b - m) / d(l - n) / d(m - n), d(b - l) * (b - n) / d(m - l) / (m - n), (b - l) * d(b - m) * (b - n) / d(l - m) / (l - n), (b - m) * d(b - l) * (b - n) / d(l - m) / (m - n)];
	return e(e(e(e(r(f, b[0]), r(k, b[1])), r(g, b[2])),
		r(u, b[3])), r(c, b[4]))
};
numeric.Dopri.prototype.at = function mm(b) {
	var c, d, e, f = Math.floor;
	if ("number" !== typeof b) {
		c = b.length;
		d = Array(c);
		for (--c; - 1 !== c; --c) d[c] = this.at(b[c]);
		return d
	}
	var g = this.x;
	c = 0;
	for (d = g.length - 1; 1 < d - c;) e = f(.5 * (c + d)), g[e] <= b ? c = e : d = e;
	return this._at(b, c)
};
numeric.dopri = function nm(b, c, d, e, f, g, h) {
	"undefined" === typeof f && (f = 1E-6);
	"undefined" === typeof g && (g = 1E3);
	var k = [b],
		l = [d],
		m = [e(b, d)],
		n, r, t, u, w, v, x = [],
		y = [.075, .225],
		D = [44 / 45, -56 / 15, 32 / 9],
		z = [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729],
		G = [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656],
		A = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84],
		H = [.10013431883002395, 0, .3918321794184259, -.02982460176594817, .05893268337240795, -.04497888809104361, .023904308236133973],
		O = [.2, .3, .8, 8 / 9, 1, 1],
		M = [-71 / 57600, 0, 71 / 16695, -71 /
			1920, 17253 / 339200, -22 / 525, .025
		],
		J = 0,
		P, L = (c - b) / 10,
		Q = 0,
		S = numeric.add,
		K = numeric.mul,
		X = Math.max,
		X = Math.min,
		ba = Math.abs,
		ca = numeric.norminf,
		ia = Math.pow,
		Y = numeric.any,
		ha = numeric.lt,
		Z = numeric.and,
		aa = numeric.sub,
		I, ma, aa = new numeric.Dopri(k, l, m, x, -1, "");
	for ("function" === typeof h && (I = h(b, d)); b < c && Q < g;)
		if (++Q, b + L > c && (L = c - b), n = e(b + O[0] * L, S(d, K(.2 * L, m[J]))), r = e(b + O[1] * L, S(S(d, K(y[0] * L, m[J])), K(y[1] * L, n))), t = e(b + O[2] * L, S(S(S(d, K(D[0] * L, m[J])), K(D[1] * L, n)), K(D[2] * L, r))), u = e(b + O[3] * L, S(S(S(S(d, K(z[0] * L, m[J])), K(z[1] *
				L, n)), K(z[2] * L, r)), K(z[3] * L, t))), w = e(b + O[4] * L, S(S(S(S(S(d, K(G[0] * L, m[J])), K(G[1] * L, n)), K(G[2] * L, r)), K(G[3] * L, t)), K(G[4] * L, u))), n = S(S(S(S(S(d, K(m[J], L * A[0])), K(r, L * A[2])), K(t, L * A[3])), K(u, L * A[4])), K(w, L * A[5])), v = e(b + L, n), P = S(S(S(S(S(K(m[J], L * M[0]), K(r, L * M[2])), K(t, L * M[3])), K(u, L * M[4])), K(w, L * M[5])), K(v, L * M[6])), P = "number" === typeof P ? ba(P) : ca(P), P > f) {
			if (L = .2 * L * ia(f / P, .25), b + L === b) {
				aa.msg = "Step size became too small";
				break
			}
		} else {
			x[J] = S(S(S(S(S(S(d, K(m[J], L * H[0])), K(r, L * H[2])), K(t, L * H[3])), K(u, L * H[4])),
				K(w, L * H[5])), K(v, L * H[6]));
			++J;
			k[J] = b + L;
			l[J] = n;
			m[J] = v;
			if ("function" === typeof h) {
				var ka;
				r = b;
				t = b + .5 * L;
				ma = h(t, x[J - 1]);
				d = Z(ha(I, 0), ha(0, ma));
				Y(d) || (r = t, t = b + L, I = ma, ma = h(t, n), d = Z(ha(I, 0), ha(0, ma)));
				if (Y(d)) {
					f = 0;
					for (k = g = 1;;) {
						if ("number" === typeof I) c = (k * ma * r - g * I * t) / (k * ma - g * I);
						else
							for (c = t, l = I.length - 1; - 1 !== l; --l) 0 > I[l] && 0 < ma[l] && (c = X(c, (k * ma[l] * r - g * I[l] * t) / (k * ma[l] - g * I[l])));
						if (c <= r || c >= t) break;
						ka = aa._at(c, J - 1);
						m = h(c, ka);
						l = Z(ha(I, 0), ha(0, m));
						Y(l) ? (t = c, ma = m, d = l, k = 1, g = -1 === f ? .5 * g : 1, f = -1) : (r = c, I = m, g = 1, k = 1 ===
							f ? .5 * k : 1, f = 1)
					}
					n = aa._at(.5 * (b + c), J - 1);
					aa.f[J] = e(c, ka);
					aa.x[J] = c;
					aa.y[J] = ka;
					aa.ymid[J - 1] = n;
					aa.events = d;
					aa.iterations = Q;
					return aa
				}
			}
			b += L;
			d = n;
			I = ma;
			L = X(.8 * L * ia(f / P, .25), 4 * L)
		}
	aa.iterations = Q;
	return aa
};
numeric.LU = function(a, b) {
	b = b || !1;
	var c = Math.abs,
		d, e, f, g, h, k = a.length,
		l = k - 1,
		m = Array(k);
	b || (a = numeric.clone(a));
	for (b = 0; b < k; ++b) {
		g = b;
		f = a[b];
		h = c(f[b]);
		for (e = b + 1; e < k; ++e) d = c(a[e][b]), h < d && (h = d, g = e);
		m[b] = g;
		g != b && (a[b] = a[g], a[g] = f, f = a[b]);
		e = f[b];
		for (d = b + 1; d < k; ++d) a[d][b] /= e;
		for (d = b + 1; d < k; ++d) {
			g = a[d];
			for (e = b + 1; e < l; ++e) g[e] -= g[b] * f[e], ++e, g[e] -= g[b] * f[e];
			e === l && (g[e] -= g[b] * f[e])
		}
	}
	return {
		LU: a,
		P: m
	}
};
numeric.LUsolve = function om(b, c) {
	var d = b.LU,
		e = d.length,
		f = numeric.clone(c),
		g = b.P,
		h;
	for (b = e - 1; - 1 !== b; --b) f[b] = c[b];
	for (b = 0; b < e; ++b)
		for (c = g[b], g[b] !== b && (h = f[b], f[b] = f[c], f[c] = h), h = d[b], c = 0; c < b; ++c) f[b] -= f[c] * h[c];
	for (b = e - 1; 0 <= b; --b) {
		h = d[b];
		for (c = b + 1; c < e; ++c) f[b] -= f[c] * h[c];
		f[b] /= h[b]
	}
	return f
};
numeric.solve = function pm(b, c, d) {
	return numeric.LUsolve(numeric.LU(b, d), c)
};
numeric.echelonize = function qm(b) {
	var c = numeric.dim(b),
		d = c[0],
		c = c[1],
		e = numeric.identity(d),
		f = Array(d),
		g, h, k, l, m, n, r, t, u = Math.abs,
		w = numeric.diveq;
	b = numeric.clone(b);
	for (g = 0; g < d; ++g) {
		k = 0;
		m = b[g];
		n = e[g];
		for (h = 1; h < c; ++h) u(m[k]) < u(m[h]) && (k = h);
		f[g] = k;
		w(n, m[k]);
		w(m, m[k]);
		for (h = 0; h < d; ++h)
			if (h !== g) {
				r = b[h];
				t = r[k];
				for (l = c - 1; - 1 !== l; --l) r[l] -= m[l] * t;
				r = e[h];
				for (l = d - 1; - 1 !== l; --l) r[l] -= n[l] * t
			}
	}
	return {
		I: e,
		A: b,
		P: f
	}
};
numeric.__solveLP = function __solveLP(b, c, d, e, f, g, h) {
	var k = numeric.sum,
		l = numeric.log,
		l = numeric.mul,
		m = numeric.sub,
		n = numeric.dot,
		r = numeric.div,
		t = numeric.add,
		u = b.length,
		w = d.length,
		v, x = !1,
		y = 1,
		D = numeric.transpose(c),
		D = numeric.svd,
		D = numeric.transpose,
		z = numeric.leq,
		z = Math.sqrt,
		G = Math.abs,
		A = numeric.muleq,
		A = numeric.norminf,
		A = numeric.any,
		A = Math.min,
		H = numeric.all,
		O = numeric.gt,
		M = Array(u),
		J = Array(w),
		P = numeric.rep([w], 1),
		P = numeric.solve,
		L = m(d, n(c, g)),
		Q, S = n(b, b);
	for (Q = 0; Q < f; ++Q) {
		var K;
		for (K = w - 1; - 1 !== K; --K) J[K] = r(c[K],
			L[K]);
		v = D(J);
		for (K = u - 1; - 1 !== K; --K) M[K] = k(v[K]);
		y = .25 * G(S / n(b, M));
		K = 100 * z(S / n(M, M));
		if (!isFinite(y) || y > K) y = K;
		x = t(b, l(y, M));
		v = n(v, J);
		for (K = u - 1; - 1 !== K; --K) v[K][K] += 1;
		v = P(v, r(x, y), !0);
		var L = r(L, n(c, v)),
			X = 1;
		for (K = w - 1; - 1 !== K; --K) 0 > L[K] && (X = A(X, -.999 * L[K]));
		v = m(g, l(v, X));
		L = m(d, n(c, v));
		if (!H(O(L, 0))) return {
			solution: g,
			message: "",
			iterations: Q
		};
		g = v;
		if (y < e) return {
			solution: v,
			message: "",
			iterations: Q
		};
		if (h)
			for (y = n(b, x), X = n(c, x), x = !0, K = w - 1; - 1 !== K; --K) {
				if (0 > y * X[K]) {
					x = !1;
					break
				}
			} else x = 0 <= g[u - 1] ? !1 : !0;
		if (x) return {
			solution: v,
			message: "Unbounded",
			iterations: Q
		}
	}
	return {
		solution: g,
		message: "maximum iteration count exceeded",
		iterations: Q
	}
};
numeric._solveLP = function _solveLP(b, c, d, e, f) {
	var g = b.length,
		h = d.length,
		k = numeric.sum,
		k = numeric.log,
		k = numeric.mul,
		k = numeric.sub,
		l = numeric.dot,
		m = numeric.div,
		m = numeric.add,
		m = numeric.rep([g], 0).concat([1]),
		h = numeric.rep([h, 1], -1),
		n = numeric.blockMatrix([
			[c, h]
		]),
		r = d,
		h = numeric.rep([g], 0).concat(Math.max(0, numeric.sup(numeric.neg(d))) + 1),
		h = numeric.__solveLP(m, n, r, e, f, h, !1),
		m = numeric.clone(h.solution);
	m.length = g;
	g = numeric.inf(k(d, l(c, m)));
	if (0 > g) return {
		solution: NaN,
		message: "Infeasible",
		iterations: h.iterations
	};
	b = numeric.__solveLP(b, c, d, e, f - h.iterations, m, !0);
	b.iterations += h.iterations;
	return b
};
numeric.solveLP = function rm(b, c, d, e, f, g, h) {
	"undefined" === typeof h && (h = 1E3);
	"undefined" === typeof g && (g = numeric.epsilon);
	if ("undefined" === typeof e) return numeric._solveLP(b, c, d, g, h);
	var k = e.length,
		l = e[0].length,
		m = c.length,
		n = numeric.echelonize(e),
		r = numeric.rep([l], 0),
		t = n.P,
		u = [],
		w;
	for (w = t.length - 1; - 1 !== w; --w) r[t[w]] = 1;
	for (w = l - 1; - 1 !== w; --w) 0 === r[w] && u.push(w);
	w = numeric.getRange;
	k = numeric.linspace(0, k - 1);
	m = numeric.linspace(0, m - 1);
	e = w(e, k, u);
	k = w(c, m, t);
	w = w(c, m, u);
	c = numeric.dot;
	m = numeric.sub;
	l = c(k, n.I);
	k =
		m(w, c(l, e));
	d = m(d, c(l, f));
	l = Array(t.length);
	r = Array(u.length);
	for (w = t.length - 1; - 1 !== w; --w) l[w] = b[t[w]];
	for (w = u.length - 1; - 1 !== w; --w) r[w] = b[u[w]];
	w = m(r, c(l, c(n.I, e)));
	g = numeric._solveLP(w, k, d, g, h);
	h = g.solution;
	if (h !== h) return g;
	f = c(n.I, m(f, c(e, h)));
	b = Array(b.length);
	for (w = t.length - 1; - 1 !== w; --w) b[t[w]] = f[w];
	for (w = u.length - 1; - 1 !== w; --w) b[u[w]] = h[w];
	return {
		solution: b,
		message: g.message,
		iterations: g.iterations
	}
};
numeric.MPStoLP = function sm(b) {
	function c(c) {
		throw Error("MPStoLP: " + c + "\nLine " + g + ": " + b[g] + "\nCurrent state: " + e[d] + "\n");
	}
	b instanceof String && b.split("\n");
	var d = 0,
		e = "Initial state;NAME;ROWS;COLUMNS;RHS;BOUNDS;ENDATA".split(";"),
		f = b.length,
		g, h, k, l = 0,
		m = {},
		n = [],
		r = 0,
		t = {},
		u = 0,
		w, v = [],
		x = [],
		y = [];
	for (g = 0; g < f; ++g) {
		k = b[g];
		var D = k.match(/\S*/g),
			z = [];
		for (h = 0; h < D.length; ++h) "" !== D[h] && z.push(D[h]);
		if (0 !== z.length) {
			for (h = 0; h < e.length && k.substr(0, e[h].length) !== e[h]; ++h);
			if (h < e.length) {
				if (d = h, 1 === h && (w = z[1]),
					6 === h) return {
					name: w,
					c: v,
					A: numeric.transpose(x),
					b: y,
					rows: m,
					vars: t
				}
			} else switch (d) {
				case 0:
				case 1:
					c("Unexpected line");
				case 2:
					switch (z[0]) {
						case "N":
							0 === l ? l = z[1] : c("Two or more N rows");
							break;
						case "L":
							m[z[1]] = r;
							n[r] = 1;
							y[r] = 0;
							++r;
							break;
						case "G":
							m[z[1]] = r;
							n[r] = -1;
							y[r] = 0;
							++r;
							break;
						case "E":
							m[z[1]] = r;
							n[r] = 0;
							y[r] = 0;
							++r;
							break;
						default:
							c("Parse error " + numeric.prettyPrint(z))
					}
					break;
				case 3:
					t.hasOwnProperty(z[0]) || (t[z[0]] = u, v[u] = 0, x[u] = numeric.rep([r], 0), ++u);
					k = t[z[0]];
					for (h = 1; h < z.length; h += 2) z[h] === l ? v[k] = parseFloat(z[h +
						1]) : (D = m[z[h]], x[k][D] = (0 > n[D] ? -1 : 1) * parseFloat(z[h + 1]));
					break;
				case 4:
					for (h = 1; h < z.length; h += 2) y[m[z[h]]] = (0 > n[m[z[h]]] ? -1 : 1) * parseFloat(z[h + 1]);
					break;
				case 6:
					c("Internal error")
			}
		}
	}
	c("Reached end of file without ENDATA")
};
numeric.seedrandom = {
	pow: Math.pow,
	random: Math.random
};
(function(a, b, c, d, e, f, g) {
	function h(a) {
		var b, d, e = this,
			f = a.length,
			g = 0,
			h = e.i = e.j = e.m = 0;
		e.S = [];
		e.c = [];
		for (f || (a = [f++]); g < c;) e.S[g] = g++;
		for (g = 0; g < c; g++) b = e.S[g], h = h + b + a[g % f] & c - 1, d = e.S[h], e.S[g] = d, e.S[h] = b;
		e.g = function y(a) {
			var b = e.S,
				d = e.i + 1 & c - 1,
				f = b[d],
				g = e.j + f & c - 1,
				h = b[g];
			b[d] = h;
			b[g] = f;
			for (var k = b[f + h & c - 1]; --a;) d = d + 1 & c - 1, f = b[d], g = g + f & c - 1, h = b[g], b[d] = h, b[g] = f, k = k * c + b[f + h & c - 1];
			e.i = d;
			e.j = g;
			return k
		};
		e.g(c)
	}

	function k(a, b, c, d, e) {
		c = [];
		e = typeof a;
		if (b && "object" == e)
			for (d in a)
				if (5 > d.indexOf("S")) try {
					c.push(k(a[d],
						b - 1))
				} catch (w) {}
				return c.length ? c : a + ("string" != e ? "\x00" : "")
	}

	function l(a, b, d, e) {
		a += "";
		for (e = d = 0; e < a.length; e++) b[e & c - 1] = (d ^= 19 * b[e & c - 1]) + a.charCodeAt(e) & c - 1;
		a = "";
		for (e in b) a += String.fromCharCode(b[e]);
		return a
	}
	b.seedrandom = function n(r, t) {
		var u = [],
			w;
		r = l(k(t ? [r, a] : arguments.length ? r : [(new Date).getTime(), a, window], 3), u);
		w = new h(u);
		l(w.S, a);
		b.random = function x() {
			for (var a = w.g(d), b = g, h = 0; a < e;) a = (a + h) * c, b *= c, h = w.g(1);
			for (; a >= f;) a /= 2, b /= 2, h >>>= 1;
			return (a + h) / b
		};
		return r
	};
	g = b.pow(c, d);
	e = b.pow(2, e);
	f = 2 *
		e;
	l(b.random(), a)
})([], numeric.seedrandom, 256, 6, 52);
(function(a) {
	function b(a) {
		if ("object" !== typeof a) return a;
		var c = [],
			d, e = a.length;
		for (d = 0; d < e; d++) c[d + 1] = b(a[d]);
		return c
	}

	function c(a) {
		if ("object" !== typeof a) return a;
		var b = [],
			d, e = a.length;
		for (d = 1; d < e; d++) b[d - 1] = c(a[d]);
		return b
	}

	function d(a, b, c) {
		var d, e, f;
		for (b = 1; b <= c; b += 1) {
			a[b][b] = 1 / a[b][b];
			f = -a[b][b];
			for (d = 1; d < b; d += 1) a[d][b] *= f;
			d = b + 1;
			if (c < d) break;
			for (e = d; e <= c; e += 1)
				for (f = a[b][e], a[b][e] = 0, d = 1; d <= b; d += 1) a[d][e] += f * a[d][b]
		}
	}

	function e(a, b, c, d) {
		var e, f, g;
		for (e = 1; e <= c; e += 1) {
			g = 0;
			for (b = 1; b < e; b += 1) g +=
				a[b][e] * d[b];
			d[e] = (d[e] - g) / a[e][e]
		}
		for (f = 1; f <= c; f += 1)
			for (e = c + 1 - f, d[e] /= a[e][e], g = -d[e], b = 1; b < e; b += 1) d[b] += g * a[b][e]
	}

	function f(a, b, c, d) {
		var e, f, g, h, k;
		for (e = 1; e <= c; e += 1) {
			d[1] = e;
			k = 0;
			f = e - 1;
			if (!(1 > f))
				for (g = 1; g <= f; g += 1) {
					h = a[g][e];
					for (b = 1; b < g; b += 1) h -= a[b][e] * a[b][g];
					h /= a[g][g];
					a[g][e] = h;
					k += h * h
				}
			k = a[e][e] - k;
			if (0 >= k) break;
			a[e][e] = Math.sqrt(k);
			d[1] = 0
		}
	}

	function g(a, b, c, g, h, t, u, w, v, x, y, D, z, G, A, H) {
		function k() {
			for (m = 1; m <= g; m += 1) {
				aa = 0;
				for (n = 1; n <= g; n += 1) aa += a[n][m] * u[n][ha];
				A[m] = aa
			}
			Q = X;
			for (m = 1; m <= g; m += 1) A[Q + m] =
				0;
			for (n = z + 1; n <= g; n += 1)
				for (m = 1; m <= g; m += 1) A[Q + m] += a[m][n] * A[n];
			Pa = !0;
			for (m = z; 1 <= m; --m) {
				aa = A[m];
				r = ca + m * (m + 3) / 2;
				Q = r - m;
				for (n = m + 1; n <= z; n += 1) aa -= A[r] * A[ba + n], r += n;
				aa /= A[Q];
				A[ba + m] = aa;
				if (D[m] < y) break;
				if (0 > aa) break;
				Pa = !1;
				K = m
			}
			if (!Pa)
				for (I = A[Y + K] / A[ba + K], m = 1; m <= z && !(D[m] < y) && !(0 > A[ba + m]); m += 1) Z = A[Y + m] / A[ba + m], Z < I && (I = Z, K = m);
			aa = 0;
			for (m = X + 1; m <= X + g; m += 1) aa += A[m] * A[m];
			if (Math.abs(aa) <= Ba) {
				if (Pa) return H[1] = 1, 999;
				for (m = 1; m <= z; m += 1) A[Y + m] -= I * A[ba + m];
				A[Y + z + 1] += I;
				return 700
			}
			aa = 0;
			for (m = 1; m <= g; m += 1) aa += A[X + m] * u[m][ha];
			ma = -A[ia + ha] / aa;
			Xa = !0;
			!Pa && I < ma && (ma = I, Xa = !1);
			for (m = 1; m <= g; m += 1) h[m] += ma * A[X + m], Math.abs(h[m]) < Ba && (h[m] = 0);
			t[1] += ma * aa * (ma / 2 + A[Y + z + 1]);
			for (m = 1; m <= z; m += 1) A[Y + m] -= ma * A[ba + m];
			A[Y + z + 1] += ma;
			if (Xa) {
				z += 1;
				D[z] = ha;
				r = ca + (z - 1) * z / 2 + 1;
				for (m = 1; m <= z - 1; m += 1) A[r] = A[m], r += 1;
				if (z === g) A[r] = A[g];
				else {
					for (m = g; m >= z + 1 && 0 !== A[m]; --m) {
						ka = Math.max(Math.abs(A[m - 1]), Math.abs(A[m]));
						oa = Math.min(Math.abs(A[m - 1]), Math.abs(A[m]));
						Z = 0 <= A[m - 1] ? Math.abs(ka * Math.sqrt(1 + oa * oa / (ka * ka))) : -Math.abs(ka * Math.sqrt(1 + oa * oa / (ka * ka)));
						ka = A[m -
							1] / Z;
						oa = A[m] / Z;
						if (1 === ka) break;
						if (0 === ka)
							for (A[m - 1] = oa * Z, n = 1; n <= g; n += 1) Z = a[n][m - 1], a[n][m - 1] = a[n][m], a[n][m] = Z;
						else
							for (A[m - 1] = Z, Fa = oa / (1 + ka), n = 1; n <= g; n += 1) Z = ka * a[n][m - 1] + oa * a[n][m], a[n][m] = Fa * (a[n][m - 1] + Z) - a[n][m], a[n][m - 1] = Z
					}
					A[r] = A[z]
				}
			} else {
				aa = -w[ha];
				for (n = 1; n <= g; n += 1) aa += h[n] * u[n][ha];
				if (ha > y) A[ia + ha] = aa;
				else if (A[ia + ha] = -Math.abs(aa), 0 < aa) {
					for (n = 1; n <= g; n += 1) u[n][ha] = -u[n][ha];
					w[ha] = -w[ha]
				}
				return 700
			}
			return 0
		}

		function l() {
			r = ca + K * (K + 1) / 2 + 1;
			Q = r + K;
			if (0 === A[Q]) return 798;
			ka = Math.max(Math.abs(A[Q - 1]),
				Math.abs(A[Q]));
			oa = Math.min(Math.abs(A[Q - 1]), Math.abs(A[Q]));
			Z = 0 <= A[Q - 1] ? Math.abs(ka * Math.sqrt(1 + oa * oa / (ka * ka))) : -Math.abs(ka * Math.sqrt(1 + oa * oa / (ka * ka)));
			ka = A[Q - 1] / Z;
			oa = A[Q] / Z;
			if (1 === ka) return 798;
			if (0 === ka) {
				for (m = K + 1; m <= z; m += 1) Z = A[Q - 1], A[Q - 1] = A[Q], A[Q] = Z, Q += m;
				for (m = 1; m <= g; m += 1) Z = a[m][K], a[m][K] = a[m][K + 1], a[m][K + 1] = Z
			} else {
				Fa = oa / (1 + ka);
				for (m = K + 1; m <= z; m += 1) Z = ka * A[Q - 1] + oa * A[Q], A[Q] = Fa * (A[Q - 1] + Z) - A[Q], A[Q - 1] = Z, Q += m;
				for (m = 1; m <= g; m += 1) Z = ka * a[m][K] + oa * a[m][K + 1], a[m][K + 1] = Fa * (a[m][K] + Z) - a[m][K + 1], a[m][K] =
					Z
			}
			return 0
		}
		var m, n, r, Q, S, K, X, ba, ca, ia, Y, ha, Z, aa, I, ma, ka, oa, Fa, Pa, Xa, Ba, Qa;
		v = Math.min(g, x);
		r = 2 * g + v * (v + 5) / 2 + 2 * x + 1;
		Ba = 1E-60;
		do Ba += Ba, S = 1 + .1 * Ba, Qa = 1 + .2 * Ba; while (1 >= S || 1 >= Qa);
		for (m = 1; m <= g; m += 1) A[m] = b[m];
		for (m = g + 1; m <= r; m += 1) A[m] = 0;
		for (m = 1; m <= x; m += 1) D[m] = 0;
		S = [];
		if (0 === H[1]) {
			f(a, c, g, S);
			if (0 !== S[1]) {
				H[1] = 2;
				return
			}
			e(a, c, g, b);
			d(a, c, g)
		} else {
			for (n = 1; n <= g; n += 1)
				for (h[n] = 0, m = 1; m <= n; m += 1) h[n] += a[m][n] * b[m];
			for (n = 1; n <= g; n += 1)
				for (b[n] = 0, m = n; m <= g; m += 1) b[n] += a[n][m] * h[m]
		}
		t[1] = 0;
		for (n = 1; n <= g; n += 1)
			for (h[n] = b[n], t[1] +=
				A[n] * h[n], A[n] = 0, m = n + 1; m <= g; m += 1) a[m][n] = 0;
		t[1] = -t[1] / 2;
		H[1] = 0;
		X = g;
		ba = X + g;
		Y = ba + v;
		ca = Y + v + 1;
		ia = ca + v * (v + 1) / 2;
		b = ia + x;
		for (m = 1; m <= x; m += 1) {
			aa = 0;
			for (n = 1; n <= g; n += 1) aa += u[n][m] * u[n][m];
			A[b + m] = Math.sqrt(aa)
		}
		z = 0;
		G[1] = 0;
		for (c = G[2] = 0;;) {
			G[1] += 1;
			r = ia;
			for (m = 1; m <= x; m += 1) {
				r += 1;
				aa = -w[m];
				for (n = 1; n <= g; n += 1) aa += u[n][m] * h[n];
				Math.abs(aa) < Ba && (aa = 0);
				if (m > y) A[r] = aa;
				else if (A[r] = -Math.abs(aa), 0 < aa) {
					for (n = 1; n <= g; n += 1) u[n][m] = -u[n][m];
					w[m] = -w[m]
				}
			}
			for (m = 1; m <= z; m += 1) A[ia + D[m]] = 0;
			Z = ha = 0;
			for (m = 1; m <= x; m += 1) A[ia + m] < Z * A[b + m] && (ha =
				m, Z = A[ia + m] / A[b + m]);
			c = 0 === ha ? 999 : 0;
			if (999 === c) break;
			for (;;) {
				c = k();
				if (0 === c) break;
				if (999 === c) return;
				if (700 === c) {
					if (K !== z)
						for (;;) {
							l();
							Q = r - K;
							for (m = 1; m <= K; m += 1) A[Q] = A[r], r += 1, Q += 1;
							A[Y + K] = A[Y + K + 1];
							D[K] = D[K + 1];
							K += 1;
							c = K < z ? 797 : 0;
							if (797 !== c) break
						}
					A[Y + z] = A[Y + z + 1];
					A[Y + z + 1] = 0;
					D[z] = 0;
					--z;
					G[2] += 1
				}
			}
		}
	}

	function h(a, d, e, f, h, t) {
		a = b(a);
		d = b(d);
		e = b(e);
		var k, l, m, n, r, D = [],
			z = [],
			G = [],
			A = [],
			H = [];
		h = h || 0;
		t = t ? b(t) : [void 0, 0];
		f = f ? b(f) : [];
		l = a.length - 1;
		m = e[1].length - 1;
		if (!f)
			for (k = 1; k <= m; k += 1) f[k] = 0;
		for (k = 1; k <= m; k += 1) z[k] = 0;
		n = 0;
		r =
			Math.min(l, m);
		for (k = 1; k <= l; k += 1) G[k] = 0;
		D[1] = 0;
		for (k = 1; k <= 2 * l + r * (r + 5) / 2 + 2 * m + 1; k += 1) A[k] = 0;
		for (k = 1; 2 >= k; k += 1) H[k] = 0;
		g(a, d, l, l, G, D, e, f, l, m, h, z, n, H, A, t);
		a = "";
		1 === t[1] && (a = "constraints are inconsistent, no solution!");
		2 === t[1] && (a = "matrix D in quadratic function is not positive definite!");
		return {
			solution: c(G),
			value: c(D),
			unconstrained_solution: c(d),
			iterations: c(H),
			iact: c(z),
			message: a
		}
	}
	a.solveQP = h
})(numeric);
numeric.svd = function tm(b) {
	function c(b, c) {
		b = Math.abs(b);
		c = Math.abs(c);
		return b > c ? b * Math.sqrt(1 + c * c / b / b) : 0 == c ? b : c * Math.sqrt(1 + b * b / c / c)
	}
	var d;
	d = numeric.epsilon;
	var e = 1E-64 / d,
		f = 0,
		g = 0,
		h = 0,
		k = 0,
		l = 0;
	b = numeric.clone(b);
	var m = b.length,
		n = b[0].length;
	if (m < n) throw "Need more rows than columns";
	for (var r = Array(n), t = Array(n), g = 0; g < n; g++) r[g] = t[g] = 0;
	for (var u = numeric.rep([n, n], 0), w = 0, v = 0, x = 0, y = 0, D = 0, z = 0, G = 0, g = 0; g < n; g++) {
		r[g] = v;
		G = 0;
		l = g + 1;
		for (h = g; h < m; h++) G += b[h][g] * b[h][g];
		if (G <= e) v = 0;
		else
			for (w = b[g][g], v = Math.sqrt(G),
				0 <= w && (v = -v), x = w * v - G, b[g][g] = w - v, h = l; h < n; h++) {
				G = 0;
				for (k = g; k < m; k++) G += b[k][g] * b[k][h];
				w = G / x;
				for (k = g; k < m; k++) b[k][h] += w * b[k][g]
			}
		t[g] = v;
		G = 0;
		for (h = l; h < n; h++) G += b[g][h] * b[g][h];
		if (G <= e) v = 0;
		else {
			w = b[g][g + 1];
			v = Math.sqrt(G);
			0 <= w && (v = -v);
			x = w * v - G;
			b[g][g + 1] = w - v;
			for (h = l; h < n; h++) r[h] = b[g][h] / x;
			for (h = l; h < m; h++) {
				G = 0;
				for (k = l; k < n; k++) G += b[h][k] * b[g][k];
				for (k = l; k < n; k++) b[h][k] += G * r[k]
			}
		}
		D = Math.abs(t[g]) + Math.abs(r[g]);
		D > y && (y = D)
	}
	for (g = n - 1; - 1 != g; g += -1) {
		if (0 != v) {
			x = v * b[g][g + 1];
			for (h = l; h < n; h++) u[h][g] = b[g][h] / x;
			for (h = l; h <
				n; h++) {
				G = 0;
				for (k = l; k < n; k++) G += b[g][k] * u[k][h];
				for (k = l; k < n; k++) u[k][h] += G * u[k][g]
			}
		}
		for (h = l; h < n; h++) u[g][h] = 0, u[h][g] = 0;
		u[g][g] = 1;
		v = r[g];
		l = g
	}
	for (g = n - 1; - 1 != g; g += -1) {
		l = g + 1;
		v = t[g];
		for (h = l; h < n; h++) b[g][h] = 0;
		if (0 != v) {
			x = b[g][g] * v;
			for (h = l; h < n; h++) {
				G = 0;
				for (k = l; k < m; k++) G += b[k][g] * b[k][h];
				w = G / x;
				for (k = g; k < m; k++) b[k][h] += w * b[k][g]
			}
			for (h = g; h < m; h++) b[h][g] /= v
		} else
			for (h = g; h < m; h++) b[h][g] = 0;
		b[g][g] += 1
	}
	d *= y;
	for (k = n - 1; - 1 != k; k += -1)
		for (e = 0; 50 > e; e++) {
			g = !1;
			for (l = k; - 1 != l; l += -1) {
				if (Math.abs(r[l]) <= d) {
					g = !0;
					break
				}
				if (Math.abs(t[l -
						1]) <= d) break
			}
			if (!g)
				for (f = 0, G = 1, y = l - 1, g = l; g < k + 1; g++) {
					w = G * r[g];
					r[g] *= f;
					if (Math.abs(w) <= d) break;
					v = t[g];
					x = c(w, v);
					t[g] = x;
					f = v / x;
					G = -w / x;
					for (h = 0; h < m; h++) D = b[h][y], z = b[h][g], b[h][y] = D * f + z * G, b[h][g] = -D * G + z * f
				}
			z = t[k];
			if (l == k) {
				if (0 > z)
					for (t[k] = -z, h = 0; h < n; h++) u[h][k] = -u[h][k];
				break
			}
			if (49 <= e) throw "Error: no convergence.";
			y = t[l];
			D = t[k - 1];
			v = r[k - 1];
			x = r[k];
			w = ((D - z) * (D + z) + (v - x) * (v + x)) / (2 * x * D);
			v = c(w, 1);
			w = 0 > w ? ((y - z) * (y + z) + x * (D / (w - v) - x)) / y : ((y - z) * (y + z) + x * (D / (w + v) - x)) / y;
			G = f = 1;
			for (g = l + 1; g < k + 1; g++) {
				v = r[g];
				D = t[g];
				x = G * v;
				v *= f;
				z = c(w, x);
				r[g - 1] = z;
				f = w / z;
				G = x / z;
				w = y * f + v * G;
				v = -y * G + v * f;
				x = D * G;
				D *= f;
				for (h = 0; h < n; h++) y = u[h][g - 1], z = u[h][g], u[h][g - 1] = y * f + z * G, u[h][g] = -y * G + z * f;
				z = c(w, x);
				t[g - 1] = z;
				f = w / z;
				G = x / z;
				w = f * v + G * D;
				y = -G * v + f * D;
				for (h = 0; h < m; h++) D = b[h][g - 1], z = b[h][g], b[h][g - 1] = D * f + z * G, b[h][g] = -D * G + z * f
			}
			r[l] = 0;
			r[k] = w;
			t[k] = y
		}
	for (g = 0; g < t.length; g++) t[g] < d && (t[g] = 0);
	for (g = 0; g < n; g++)
		for (h = g - 1; 0 <= h; h--)
			if (t[h] < t[g]) {
				f = t[h];
				t[h] = t[g];
				t[g] = f;
				for (k = 0; k < b.length; k++) d = b[k][g], b[k][g] = b[k][h], b[k][h] = d;
				for (k = 0; k < u.length; k++) d = u[k][g], u[k][g] = u[k][h],
					u[k][h] = d;
				g = h
			}
	return {
		U: b,
		S: t,
		V: u
	}
};
/*

 The MIT License

 Copyright (c) 2010-2013 three.js authors

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/
var THREE = {
	REVISION: "77"
};
"function" === typeof define && define.amd ? define("three", THREE) : "undefined" !== typeof exports && "undefined" !== typeof module && (module.exports = THREE);
void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52));
void 0 === Math.sign && (Math.sign = function(a) {
	return 0 > a ? -1 : 0 < a ? 1 : +a
});
void 0 === Function.prototype.name && Object.defineProperty(Function.prototype, "name", {
	get: function() {
		return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
	}
});
void 0 === Object.assign && function() {
	Object.assign = function(a) {
		if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
		for (var b = Object(a), c = 1; c < arguments.length; c++) {
			var d = arguments[c];
			if (void 0 !== d && null !== d)
				for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
		}
		return b
	}
}();
Object.assign(THREE, {
	MOUSE: {
		LEFT: 0,
		MIDDLE: 1,
		RIGHT: 2
	},
	CullFaceNone: 0,
	CullFaceBack: 1,
	CullFaceFront: 2,
	CullFaceFrontBack: 3,
	FrontFaceDirectionCW: 0,
	FrontFaceDirectionCCW: 1,
	BasicShadowMap: 0,
	PCFShadowMap: 1,
	PCFSoftShadowMap: 2,
	FrontSide: 0,
	BackSide: 1,
	DoubleSide: 2,
	FlatShading: 1,
	SmoothShading: 2,
	NoColors: 0,
	FaceColors: 1,
	VertexColors: 2,
	NoBlending: 0,
	NormalBlending: 1,
	AdditiveBlending: 2,
	SubtractiveBlending: 3,
	MultiplyBlending: 4,
	CustomBlending: 5,
	AddEquation: 100,
	SubtractEquation: 101,
	ReverseSubtractEquation: 102,
	MinEquation: 103,
	MaxEquation: 104,
	ZeroFactor: 200,
	OneFactor: 201,
	SrcColorFactor: 202,
	OneMinusSrcColorFactor: 203,
	SrcAlphaFactor: 204,
	OneMinusSrcAlphaFactor: 205,
	DstAlphaFactor: 206,
	OneMinusDstAlphaFactor: 207,
	DstColorFactor: 208,
	OneMinusDstColorFactor: 209,
	SrcAlphaSaturateFactor: 210,
	NeverDepth: 0,
	AlwaysDepth: 1,
	LessDepth: 2,
	LessEqualDepth: 3,
	EqualDepth: 4,
	GreaterEqualDepth: 5,
	GreaterDepth: 6,
	NotEqualDepth: 7,
	MultiplyOperation: 0,
	MixOperation: 1,
	AddOperation: 2,
	NoToneMapping: 0,
	LinearToneMapping: 1,
	ReinhardToneMapping: 2,
	Uncharted2ToneMapping: 3,
	CineonToneMapping: 4,
	UVMapping: 300,
	CubeReflectionMapping: 301,
	CubeRefractionMapping: 302,
	EquirectangularReflectionMapping: 303,
	EquirectangularRefractionMapping: 304,
	SphericalReflectionMapping: 305,
	CubeUVReflectionMapping: 306,
	CubeUVRefractionMapping: 307,
	RepeatWrapping: 1E3,
	ClampToEdgeWrapping: 1001,
	MirroredRepeatWrapping: 1002,
	NearestFilter: 1003,
	NearestMipMapNearestFilter: 1004,
	NearestMipMapLinearFilter: 1005,
	LinearFilter: 1006,
	LinearMipMapNearestFilter: 1007,
	LinearMipMapLinearFilter: 1008,
	UnsignedByteType: 1009,
	ByteType: 1010,
	ShortType: 1011,
	UnsignedShortType: 1012,
	IntType: 1013,
	UnsignedIntType: 1014,
	FloatType: 1015,
	HalfFloatType: 1025,
	UnsignedShort4444Type: 1016,
	UnsignedShort5551Type: 1017,
	UnsignedShort565Type: 1018,
	AlphaFormat: 1019,
	RGBFormat: 1020,
	RGBAFormat: 1021,
	LuminanceFormat: 1022,
	LuminanceAlphaFormat: 1023,
	RGBEFormat: THREE.RGBAFormat,
	DepthFormat: 1026,
	RGB_S3TC_DXT1_Format: 2001,
	RGBA_S3TC_DXT1_Format: 2002,
	RGBA_S3TC_DXT3_Format: 2003,
	RGBA_S3TC_DXT5_Format: 2004,
	RGB_PVRTC_4BPPV1_Format: 2100,
	RGB_PVRTC_2BPPV1_Format: 2101,
	RGBA_PVRTC_4BPPV1_Format: 2102,
	RGBA_PVRTC_2BPPV1_Format: 2103,
	RGB_ETC1_Format: 2151,
	LoopOnce: 2200,
	LoopRepeat: 2201,
	LoopPingPong: 2202,
	InterpolateDiscrete: 2300,
	InterpolateLinear: 2301,
	InterpolateSmooth: 2302,
	ZeroCurvatureEnding: 2400,
	ZeroSlopeEnding: 2401,
	WrapAroundEnding: 2402,
	TrianglesDrawMode: 0,
	TriangleStripDrawMode: 1,
	TriangleFanDrawMode: 2,
	LinearEncoding: 3E3,
	sRGBEncoding: 3001,
	GammaEncoding: 3007,
	RGBEEncoding: 3002,
	LogLuvEncoding: 3003,
	RGBM7Encoding: 3004,
	RGBM16Encoding: 3005,
	RGBDEncoding: 3006,
	BasicDepthPacking: 3200,
	RGBADepthPacking: 3201
});
THREE.Color = function(a, b, c) {
	return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
};
THREE.Color.prototype = {
	constructor: THREE.Color,
	r: 1,
	g: 1,
	b: 1,
	set: function(a) {
		a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
		return this
	},
	setScalar: function(a) {
		this.b = this.g = this.r = a
	},
	setHex: function(a) {
		a = Math.floor(a);
		this.r = (a >> 16 & 255) / 255;
		this.g = (a >> 8 & 255) / 255;
		this.b = (a & 255) / 255;
		return this
	},
	setRGB: function(a, b, c) {
		this.r = a;
		this.g = b;
		this.b = c;
		return this
	},
	setHSL: function() {
		function a(a, c, d) {
			0 > d && (d += 1);
			1 < d && --d;
			return d < 1 / 6 ? a + 6 * (c - a) * d :
				.5 > d ? c : d < 2 / 3 ? a + 6 * (c - a) * (2 / 3 - d) : a
		}
		return function(b, c, d) {
			b = THREE.Math.euclideanModulo(b, 1);
			c = THREE.Math.clamp(c, 0, 1);
			d = THREE.Math.clamp(d, 0, 1);
			0 === c ? this.r = this.g = this.b = d : (c = .5 >= d ? d * (1 + c) : d + c - d * c, d = 2 * d - c, this.r = a(d, c, b + 1 / 3), this.g = a(d, c, b), this.b = a(d, c, b - 1 / 3));
			return this
		}
	}(),
	setStyle: function(a) {
		function b(b) {
			void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
		}
		var c;
		if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
			var d;
			d = c[1];
			c = c[2];
			switch (d) {
				case "rgb":
				case "rgba":
					if (d =
						/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) return this.r = Math.min(255, parseInt(d[1], 10)) / 255, this.g = Math.min(255, parseInt(d[2], 10)) / 255, this.b = Math.min(255, parseInt(d[3], 10)) / 255, b(d[5]), this;
					if (d = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) return this.r = Math.min(100, parseInt(d[1], 10)) / 100, this.g = Math.min(100, parseInt(d[2], 10)) / 100, this.b = Math.min(100, parseInt(d[3], 10)) / 100, b(d[5]), this;
					break;
				case "hsl":
				case "hsla":
					if (d = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(c)) {
						c =
							parseFloat(d[1]) / 360;
						var e = parseInt(d[2], 10) / 100,
							f = parseInt(d[3], 10) / 100;
						b(d[5]);
						return this.setHSL(c, e, f)
					}
			}
		} else if (c = /^\#([A-Fa-f0-9]+)$/.exec(a)) {
			d = c[1];
			c = d.length;
			if (3 === c) return this.r = parseInt(d.charAt(0) + d.charAt(0), 16) / 255, this.g = parseInt(d.charAt(1) + d.charAt(1), 16) / 255, this.b = parseInt(d.charAt(2) + d.charAt(2), 16) / 255, this;
			if (6 === c) return this.r = parseInt(d.charAt(0) + d.charAt(1), 16) / 255, this.g = parseInt(d.charAt(2) + d.charAt(3), 16) / 255, this.b = parseInt(d.charAt(4) + d.charAt(5), 16) / 255, this
		}
		a && 0 <
			a.length && (d = THREE.ColorKeywords[a], void 0 !== d ? this.setHex(d) : console.warn("THREE.Color: Unknown color " + a));
		return this
	},
	clone: function() {
		return new this.constructor(this.r, this.g, this.b)
	},
	copy: function(a) {
		this.r = a.r;
		this.g = a.g;
		this.b = a.b;
		return this
	},
	copyGammaToLinear: function(a, b) {
		void 0 === b && (b = 2);
		this.r = Math.pow(a.r, b);
		this.g = Math.pow(a.g, b);
		this.b = Math.pow(a.b, b);
		return this
	},
	copyLinearToGamma: function(a, b) {
		void 0 === b && (b = 2);
		b = 0 < b ? 1 / b : 1;
		this.r = Math.pow(a.r, b);
		this.g = Math.pow(a.g, b);
		this.b = Math.pow(a.b,
			b);
		return this
	},
	convertGammaToLinear: function() {
		var a = this.r,
			b = this.g,
			c = this.b;
		this.r = a * a;
		this.g = b * b;
		this.b = c * c;
		return this
	},
	convertLinearToGamma: function() {
		this.r = Math.sqrt(this.r);
		this.g = Math.sqrt(this.g);
		this.b = Math.sqrt(this.b);
		return this
	},
	getHex: function() {
		return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
	},
	getHexString: function() {
		return ("000000" + this.getHex().toString(16)).slice(-6)
	},
	getHSL: function(a) {
		a = a || {
			h: 0,
			s: 0,
			l: 0
		};
		var b = this.r,
			c = this.g,
			d = this.b,
			e = Math.max(b, c, d),
			f = Math.min(b, c, d),
			g, h =
			(f + e) / 2;
		if (f === e) f = g = 0;
		else {
			var k = e - f,
				f = .5 >= h ? k / (e + f) : k / (2 - e - f);
			switch (e) {
				case b:
					g = (c - d) / k + (c < d ? 6 : 0);
					break;
				case c:
					g = (d - b) / k + 2;
					break;
				case d:
					g = (b - c) / k + 4
			}
			g /= 6
		}
		a.h = g;
		a.s = f;
		a.l = h;
		return a
	},
	getStyle: function() {
		return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
	},
	offsetHSL: function(a, b, c) {
		var d = this.getHSL();
		d.h += a;
		d.s += b;
		d.l += c;
		this.setHSL(d.h, d.s, d.l);
		return this
	},
	add: function(a) {
		this.r += a.r;
		this.g += a.g;
		this.b += a.b;
		return this
	},
	addColors: function(a, b) {
		this.r = a.r + b.r;
		this.g = a.g + b.g;
		this.b =
			a.b + b.b;
		return this
	},
	addScalar: function(a) {
		this.r += a;
		this.g += a;
		this.b += a;
		return this
	},
	multiply: function(a) {
		this.r *= a.r;
		this.g *= a.g;
		this.b *= a.b;
		return this
	},
	multiplyScalar: function(a) {
		this.r *= a;
		this.g *= a;
		this.b *= a;
		return this
	},
	lerp: function(a, b) {
		this.r += (a.r - this.r) * b;
		this.g += (a.g - this.g) * b;
		this.b += (a.b - this.b) * b;
		return this
	},
	equals: function(a) {
		return a.r === this.r && a.g === this.g && a.b === this.b
	},
	fromArray: function(a, b) {
		void 0 === b && (b = 0);
		this.r = a[b];
		this.g = a[b + 1];
		this.b = a[b + 2];
		return this
	},
	toArray: function(a,
		b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		a[b] = this.r;
		a[b + 1] = this.g;
		a[b + 2] = this.b;
		return a
	}
};
THREE.ColorKeywords = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
THREE.Quaternion = function(a, b, c, d) {
	this._x = a || 0;
	this._y = b || 0;
	this._z = c || 0;
	this._w = void 0 !== d ? d : 1
};
THREE.Quaternion.prototype = {
	constructor: THREE.Quaternion,
	get x() {
		return this._x
	},
	set x(a) {
		this._x = a;
		this.onChangeCallback()
	},
	get y() {
		return this._y
	},
	set y(a) {
		this._y = a;
		this.onChangeCallback()
	},
	get z() {
		return this._z
	},
	set z(a) {
		this._z = a;
		this.onChangeCallback()
	},
	get w() {
		return this._w
	},
	set w(a) {
		this._w = a;
		this.onChangeCallback()
	},
	set: function(a, b, c, d) {
		this._x = a;
		this._y = b;
		this._z = c;
		this._w = d;
		this.onChangeCallback();
		return this
	},
	clone: function() {
		return new this.constructor(this._x, this._y, this._z, this._w)
	},
	copy: function(a) {
		this._x = a.x;
		this._y = a.y;
		this._z = a.z;
		this._w = a.w;
		this.onChangeCallback();
		return this
	},
	setFromEuler: function(a, b) {
		if (!1 === a instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
		var c = Math.cos(a._x / 2),
			d = Math.cos(a._y / 2),
			e = Math.cos(a._z / 2),
			f = Math.sin(a._x / 2),
			g = Math.sin(a._y / 2),
			h = Math.sin(a._z / 2);
		a = a.order;
		"XYZ" === a ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "YXZ" ===
			a ? (this._x = f * d * e + c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "ZXY" === a ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e - f * g * h) : "ZYX" === a ? (this._x = f * d * e - c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e + f * g * h) : "YZX" === a ? (this._x = f * d * e + c * g * h, this._y = c * g * e + f * d * h, this._z = c * d * h - f * g * e, this._w = c * d * e - f * g * h) : "XZY" === a && (this._x = f * d * e - c * g * h, this._y = c * g * e - f * d * h, this._z = c * d * h + f * g * e, this._w = c * d * e + f * g * h);
		if (!1 !== b) this.onChangeCallback();
		return this
	},
	setFromAxisAngle: function(a,
		b) {
		b /= 2;
		var c = Math.sin(b);
		this._x = a.x * c;
		this._y = a.y * c;
		this._z = a.z * c;
		this._w = Math.cos(b);
		this.onChangeCallback();
		return this
	},
	setFromRotationMatrix: function(a) {
		var b = a.elements,
			c = b[0];
		a = b[4];
		var d = b[8],
			e = b[1],
			f = b[5],
			g = b[9],
			h = b[2],
			k = b[6],
			b = b[10],
			l = c + f + b;
		0 < l ? (c = .5 / Math.sqrt(l + 1), this._w = .25 / c, this._x = (k - g) * c, this._y = (d - h) * c, this._z = (e - a) * c) : c > f && c > b ? (c = 2 * Math.sqrt(1 + c - f - b), this._w = (k - g) / c, this._x = .25 * c, this._y = (a + e) / c, this._z = (d + h) / c) : f > b ? (c = 2 * Math.sqrt(1 + f - c - b), this._w = (d - h) / c, this._x = (a + e) / c, this._y =
			.25 * c, this._z = (g + k) / c) : (c = 2 * Math.sqrt(1 + b - c - f), this._w = (e - a) / c, this._x = (d + h) / c, this._y = (g + k) / c, this._z = .25 * c);
		this.onChangeCallback();
		return this
	},
	setFromUnitVectors: function() {
		var a, b;
		return function(c, d) {
			void 0 === a && (a = new THREE.Vector3);
			b = c.dot(d) + 1;
			1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ? a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
			this._x = a.x;
			this._y = a.y;
			this._z = a.z;
			this._w = b;
			return this.normalize()
		}
	}(),
	inverse: function() {
		return this.conjugate().normalize()
	},
	conjugate: function() {
		this._x *=
			-1;
		this._y *= -1;
		this._z *= -1;
		this.onChangeCallback();
		return this
	},
	dot: function(a) {
		return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
	},
	lengthSq: function() {
		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
	},
	length: function() {
		return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
	},
	normalize: function() {
		var a = this.length();
		0 === a ? (this._z = this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
		this.onChangeCallback();
		return this
	},
	multiply: function(a, b) {
		return void 0 !== b ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
	},
	premultiply: function(a) {
		return this.multiplyQuaternions(a, this)
	},
	multiplyQuaternions: function(a, b) {
		var c = a._x,
			d = a._y,
			e = a._z;
		a = a._w;
		var f = b._x,
			g = b._y,
			h = b._z;
		b = b._w;
		this._x = c * b + a * f + d * h - e * g;
		this._y = d * b + a * g + e * f - c * h;
		this._z = e * b + a * h + c * g - d * f;
		this._w = a * b - c * f - d * g - e * h;
		this.onChangeCallback();
		return this
	},
	slerp: function(a, b) {
		if (0 === b) return this;
		if (1 === b) return this.copy(a);
		var c = this._x,
			d = this._y,
			e = this._z,
			f = this._w,
			g = f * a._w + c * a._x + d * a._y + e * a._z;
		0 > g ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, g = -g) : this.copy(a);
		if (1 <= g) return this._w = f, this._x = c, this._y = d, this._z = e, this;
		a = Math.sqrt(1 - g * g);
		if (.001 > Math.abs(a)) return this._w = .5 * (f + this._w), this._x = .5 * (c + this._x), this._y = .5 * (d + this._y), this._z = .5 * (e + this._z), this;
		var h = Math.atan2(a, g),
			g = Math.sin((1 - b) * h) / a;
		b = Math.sin(b * h) / a;
		this._w = f * g + this._w * b;
		this._x = c * g + this._x * b;
		this._y = d * g + this._y * b;
		this._z = e * g + this._z * b;
		this.onChangeCallback();
		return this
	},
	equals: function(a) {
		return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
	},
	fromArray: function(a, b) {
		void 0 === b && (b = 0);
		this._x = a[b];
		this._y = a[b + 1];
		this._z = a[b + 2];
		this._w = a[b + 3];
		this.onChangeCallback();
		return this
	},
	toArray: function(a, b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		a[b] = this._x;
		a[b + 1] = this._y;
		a[b + 2] = this._z;
		a[b + 3] = this._w;
		return a
	},
	onChange: function(a) {
		this.onChangeCallback =
			a;
		return this
	},
	onChangeCallback: function() {}
};
Object.assign(THREE.Quaternion, {
	slerp: function(a, b, c, d) {
		return c.copy(a).slerp(b, d)
	},
	slerpFlat: function(a, b, c, d, e, f, g) {
		var h = c[d + 0],
			k = c[d + 1],
			l = c[d + 2];
		c = c[d + 3];
		d = e[f + 0];
		var m = e[f + 1],
			n = e[f + 2];
		e = e[f + 3];
		if (c !== e || h !== d || k !== m || l !== n) {
			f = 1 - g;
			var r = h * d + k * m + l * n + c * e,
				t = 0 <= r ? 1 : -1,
				u = 1 - r * r;
			u > Number.EPSILON && (u = Math.sqrt(u), r = Math.atan2(u, r * t), f = Math.sin(f * r) / u, g = Math.sin(g * r) / u);
			t *= g;
			h = h * f + d * t;
			k = k * f + m * t;
			l = l * f + n * t;
			c = c * f + e * t;
			f === 1 - g && (g = 1 / Math.sqrt(h * h + k * k + l * l + c * c), h *= g, k *= g, l *= g, c *= g)
		}
		a[b] = h;
		a[b + 1] = k;
		a[b + 2] = l;
		a[b + 3] = c
	}
});
THREE.Vector2 = function(a, b) {
	this.x = a || 0;
	this.y = b || 0
};
THREE.Vector2.prototype = {
	constructor: THREE.Vector2,
	get width() {
		return this.x
	},
	set width(a) {
		this.x = a
	},
	get height() {
		return this.y
	},
	set height(a) {
		this.y = a
	},
	set: function(a, b) {
		this.x = a;
		this.y = b;
		return this
	},
	setScalar: function(a) {
		this.y = this.x = a;
		return this
	},
	setX: function(a) {
		this.x = a;
		return this
	},
	setY: function(a) {
		this.y = a;
		return this
	},
	setComponent: function(a, b) {
		switch (a) {
			case 0:
				this.x = b;
				break;
			case 1:
				this.y = b;
				break;
			default:
				throw Error("index is out of range: " + a);
		}
	},
	getComponent: function(a) {
		switch (a) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			default:
				throw Error("index is out of range: " + a);
		}
	},
	clone: function() {
		return new this.constructor(this.x, this.y)
	},
	copy: function(a) {
		this.x = a.x;
		this.y = a.y;
		return this
	},
	add: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
		this.x += a.x;
		this.y += a.y;
		return this
	},
	addScalar: function(a) {
		this.x += a;
		this.y += a;
		return this
	},
	addVectors: function(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		return this
	},
	addScaledVector: function(a, b) {
		this.x += a.x * b;
		this.y += a.y * b;
		return this
	},
	sub: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
		this.x -= a.x;
		this.y -= a.y;
		return this
	},
	subScalar: function(a) {
		this.x -= a;
		this.y -= a;
		return this
	},
	subVectors: function(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		return this
	},
	multiply: function(a) {
		this.x *= a.x;
		this.y *= a.y;
		return this
	},
	multiplyScalar: function(a) {
		isFinite(a) ? (this.x *= a,
			this.y *= a) : this.y = this.x = 0;
		return this
	},
	divide: function(a) {
		this.x /= a.x;
		this.y /= a.y;
		return this
	},
	divideScalar: function(a) {
		return this.multiplyScalar(1 / a)
	},
	min: function(a) {
		this.x = Math.min(this.x, a.x);
		this.y = Math.min(this.y, a.y);
		return this
	},
	max: function(a) {
		this.x = Math.max(this.x, a.x);
		this.y = Math.max(this.y, a.y);
		return this
	},
	clamp: function(a, b) {
		this.x = Math.max(a.x, Math.min(b.x, this.x));
		this.y = Math.max(a.y, Math.min(b.y, this.y));
		return this
	},
	clampScalar: function() {
		var a, b;
		return function d(e, f) {
			void 0 ===
				a && (a = new THREE.Vector2, b = new THREE.Vector2);
			a.set(e, e);
			b.set(f, f);
			return this.clamp(a, b)
		}
	}(),
	clampLength: function(a, b) {
		var c = this.length();
		return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
	},
	floor: function() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this
	},
	ceil: function() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this
	},
	round: function() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this
	},
	roundToZero: function() {
		this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
		return this
	},
	negate: function() {
		this.x = -this.x;
		this.y = -this.y;
		return this
	},
	dot: function(a) {
		return this.x * a.x + this.y * a.y
	},
	lengthSq: function() {
		return this.x * this.x + this.y * this.y
	},
	length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y)
	},
	lengthManhattan: function() {
		return Math.abs(this.x) + Math.abs(this.y)
	},
	normalize: function() {
		return this.divideScalar(this.length())
	},
	angle: function() {
		var a = Math.atan2(this.y, this.x);
		0 > a && (a += 2 * Math.PI);
		return a
	},
	distanceTo: function(a) {
		return Math.sqrt(this.distanceToSquared(a))
	},
	distanceToSquared: function(a) {
		var b = this.x - a.x;
		a = this.y - a.y;
		return b * b + a * a
	},
	setLength: function(a) {
		return this.multiplyScalar(a / this.length())
	},
	lerp: function(a, b) {
		this.x += (a.x - this.x) * b;
		this.y += (a.y - this.y) * b;
		return this
	},
	lerpVectors: function(a, b, c) {
		return this.subVectors(b, a).multiplyScalar(c).add(a)
	},
	equals: function(a) {
		return a.x === this.x && a.y === this.y
	},
	fromArray: function(a, b) {
		void 0 === b && (b = 0);
		this.x = a[b];
		this.y = a[b + 1];
		return this
	},
	toArray: function(a, b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		a[b] = this.x;
		a[b + 1] = this.y;
		return a
	},
	fromAttribute: function(a, b, c) {
		void 0 === c && (c = 0);
		b = b * a.itemSize + c;
		this.x = a.array[b];
		this.y = a.array[b + 1];
		return this
	},
	rotateAround: function(a, b) {
		var c = Math.cos(b);
		b = Math.sin(b);
		var d = this.x - a.x,
			e = this.y - a.y;
		this.x = d * c - e * b + a.x;
		this.y = d * b + e * c + a.y;
		return this
	}
};
THREE.Vector3 = function(a, b, c) {
	this.x = a || 0;
	this.y = b || 0;
	this.z = c || 0
};
THREE.Vector3.prototype = {
	constructor: THREE.Vector3,
	set: function(a, b, c) {
		this.x = a;
		this.y = b;
		this.z = c;
		return this
	},
	setScalar: function(a) {
		this.z = this.y = this.x = a;
		return this
	},
	setX: function(a) {
		this.x = a;
		return this
	},
	setY: function(a) {
		this.y = a;
		return this
	},
	setZ: function(a) {
		this.z = a;
		return this
	},
	setComponent: function(a, b) {
		switch (a) {
			case 0:
				this.x = b;
				break;
			case 1:
				this.y = b;
				break;
			case 2:
				this.z = b;
				break;
			default:
				throw Error("index is out of range: " + a);
		}
	},
	getComponent: function(a) {
		switch (a) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			default:
				throw Error("index is out of range: " + a);
		}
	},
	clone: function() {
		return new this.constructor(this.x, this.y, this.z)
	},
	copy: function(a) {
		this.x = a.x;
		this.y = a.y;
		this.z = a.z;
		return this
	},
	add: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
		this.x += a.x;
		this.y += a.y;
		this.z += a.z;
		return this
	},
	addScalar: function(a) {
		this.x += a;
		this.y += a;
		this.z += a;
		return this
	},
	addVectors: function(a,
		b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		return this
	},
	addScaledVector: function(a, b) {
		this.x += a.x * b;
		this.y += a.y * b;
		this.z += a.z * b;
		return this
	},
	sub: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
		this.x -= a.x;
		this.y -= a.y;
		this.z -= a.z;
		return this
	},
	subScalar: function(a) {
		this.x -= a;
		this.y -= a;
		this.z -= a;
		return this
	},
	subVectors: function(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		return this
	},
	multiply: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(a, b);
		this.x *= a.x;
		this.y *= a.y;
		this.z *= a.z;
		return this
	},
	multiplyScalar: function(a) {
		isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a) : this.z = this.y = this.x = 0;
		return this
	},
	multiplyVectors: function(a, b) {
		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;
		return this
	},
	applyEuler: function() {
		var a;
		return function c(d) {
			!1 === d instanceof THREE.Euler &&
				console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
			void 0 === a && (a = new THREE.Quaternion);
			return this.applyQuaternion(a.setFromEuler(d))
		}
	}(),
	applyAxisAngle: function() {
		var a;
		return function c(d, e) {
			void 0 === a && (a = new THREE.Quaternion);
			return this.applyQuaternion(a.setFromAxisAngle(d, e))
		}
	}(),
	applyMatrix3: function(a) {
		var b = this.x,
			c = this.y,
			d = this.z;
		a = a.elements;
		this.x = a[0] * b + a[3] * c + a[6] * d;
		this.y = a[1] * b + a[4] * c + a[7] * d;
		this.z = a[2] * b + a[5] * c + a[8] * d;
		return this
	},
	applyMatrix4: function(a) {
		var b = this.x,
			c = this.y,
			d = this.z;
		a = a.elements;
		this.x = a[0] * b + a[4] * c + a[8] * d + a[12];
		this.y = a[1] * b + a[5] * c + a[9] * d + a[13];
		this.z = a[2] * b + a[6] * c + a[10] * d + a[14];
		return this
	},
	applyProjection: function(a) {
		var b = this.x,
			c = this.y,
			d = this.z;
		a = a.elements;
		var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
		this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
		this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
		this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
		return this
	},
	applyQuaternion: function(a) {
		var b = this.x,
			c = this.y,
			d = this.z,
			e = a.x,
			f = a.y,
			g = a.z;
		a =
			a.w;
		var h = a * b + f * d - g * c,
			k = a * c + g * b - e * d,
			l = a * d + e * c - f * b,
			b = -e * b - f * c - g * d;
		this.x = h * a + b * -e + k * -g - l * -f;
		this.y = k * a + b * -f + l * -e - h * -g;
		this.z = l * a + b * -g + h * -f - k * -e;
		return this
	},
	project: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.multiplyMatrices(d.projectionMatrix, a.getInverse(d.matrixWorld));
			return this.applyProjection(a)
		}
	}(),
	unproject: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.multiplyMatrices(d.matrixWorld, a.getInverse(d.projectionMatrix));
			return this.applyProjection(a)
		}
	}(),
	transformDirection: function(a) {
		var b = this.x,
			c = this.y,
			d = this.z;
		a = a.elements;
		this.x = a[0] * b + a[4] * c + a[8] * d;
		this.y = a[1] * b + a[5] * c + a[9] * d;
		this.z = a[2] * b + a[6] * c + a[10] * d;
		return this.normalize()
	},
	divide: function(a) {
		this.x /= a.x;
		this.y /= a.y;
		this.z /= a.z;
		return this
	},
	divideScalar: function(a) {
		return this.multiplyScalar(1 / a)
	},
	min: function(a) {
		this.x = Math.min(this.x, a.x);
		this.y = Math.min(this.y, a.y);
		this.z = Math.min(this.z, a.z);
		return this
	},
	max: function(a) {
		this.x = Math.max(this.x, a.x);
		this.y = Math.max(this.y, a.y);
		this.z =
			Math.max(this.z, a.z);
		return this
	},
	clamp: function(a, b) {
		this.x = Math.max(a.x, Math.min(b.x, this.x));
		this.y = Math.max(a.y, Math.min(b.y, this.y));
		this.z = Math.max(a.z, Math.min(b.z, this.z));
		return this
	},
	clampScalar: function() {
		var a, b;
		return function d(e, f) {
			void 0 === a && (a = new THREE.Vector3, b = new THREE.Vector3);
			a.set(e, e, e);
			b.set(f, f, f);
			return this.clamp(a, b)
		}
	}(),
	clampLength: function(a, b) {
		var c = this.length();
		return this.multiplyScalar(Math.max(a, Math.min(b, c)) / c)
	},
	floor: function() {
		this.x = Math.floor(this.x);
		this.y =
			Math.floor(this.y);
		this.z = Math.floor(this.z);
		return this
	},
	ceil: function() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		return this
	},
	round: function() {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		return this
	},
	roundToZero: function() {
		this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
		return this
	},
	negate: function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		return this
	},
	dot: function(a) {
		return this.x * a.x + this.y * a.y + this.z * a.z
	},
	lengthSq: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z
	},
	length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	},
	lengthManhattan: function() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
	},
	normalize: function() {
		return this.divideScalar(this.length())
	},
	setLength: function(a) {
		return this.multiplyScalar(a / this.length())
	},
	lerp: function(a, b) {
		this.x += (a.x - this.x) * b;
		this.y +=
			(a.y - this.y) * b;
		this.z += (a.z - this.z) * b;
		return this
	},
	lerpVectors: function(a, b, c) {
		return this.subVectors(b, a).multiplyScalar(c).add(a)
	},
	cross: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(a, b);
		b = this.x;
		var c = this.y,
			d = this.z;
		this.x = c * a.z - d * a.y;
		this.y = d * a.x - b * a.z;
		this.z = b * a.y - c * a.x;
		return this
	},
	crossVectors: function(a, b) {
		var c = a.x,
			d = a.y;
		a = a.z;
		var e = b.x,
			f = b.y;
		b = b.z;
		this.x = d * b - a * f;
		this.y = a * e -
			c * b;
		this.z = c * f - d * e;
		return this
	},
	projectOnVector: function() {
		var a, b;
		return function d(e) {
			void 0 === a && (a = new THREE.Vector3);
			a.copy(e).normalize();
			b = this.dot(a);
			return this.copy(a).multiplyScalar(b)
		}
	}(),
	projectOnPlane: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Vector3);
			a.copy(this).projectOnVector(d);
			return this.sub(a)
		}
	}(),
	reflect: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Vector3);
			return this.sub(a.copy(d).multiplyScalar(2 * this.dot(d)))
		}
	}(),
	angleTo: function(a) {
		a =
			this.dot(a) / Math.sqrt(this.lengthSq() * a.lengthSq());
		return Math.acos(THREE.Math.clamp(a, -1, 1))
	},
	distanceTo: function(a) {
		return Math.sqrt(this.distanceToSquared(a))
	},
	distanceToSquared: function(a) {
		var b = this.x - a.x,
			c = this.y - a.y;
		a = this.z - a.z;
		return b * b + c * c + a * a
	},
	setFromSpherical: function(a) {
		var b = Math.sin(a.phi) * a.radius;
		this.x = b * Math.sin(a.theta);
		this.y = Math.cos(a.phi) * a.radius;
		this.z = b * Math.cos(a.theta);
		return this
	},
	setFromMatrixPosition: function(a) {
		return this.setFromMatrixColumn(a, 3)
	},
	setFromMatrixScale: function(a) {
		var b =
			this.setFromMatrixColumn(a, 0).length(),
			c = this.setFromMatrixColumn(a, 1).length();
		a = this.setFromMatrixColumn(a, 2).length();
		this.x = b;
		this.y = c;
		this.z = a;
		return this
	},
	setFromMatrixColumn: function(a, b) {
		if ("number" === typeof a) {
			console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).");
			var c = a;
			a = b;
			b = c
		}
		return this.fromArray(a.elements, 4 * b)
	},
	equals: function(a) {
		return a.x === this.x && a.y === this.y && a.z === this.z
	},
	fromArray: function(a, b) {
		void 0 === b && (b = 0);
		this.x = a[b];
		this.y = a[b + 1];
		this.z = a[b +
			2];
		return this
	},
	toArray: function(a, b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		a[b] = this.x;
		a[b + 1] = this.y;
		a[b + 2] = this.z;
		return a
	},
	fromAttribute: function(a, b, c) {
		void 0 === c && (c = 0);
		b = b * a.itemSize + c;
		this.x = a.array[b];
		this.y = a.array[b + 1];
		this.z = a.array[b + 2];
		return this
	}
};
THREE.Vector4 = function(a, b, c, d) {
	this.x = a || 0;
	this.y = b || 0;
	this.z = c || 0;
	this.w = void 0 !== d ? d : 1
};
THREE.Vector4.prototype = {
	constructor: THREE.Vector4,
	set: function(a, b, c, d) {
		this.x = a;
		this.y = b;
		this.z = c;
		this.w = d;
		return this
	},
	setScalar: function(a) {
		this.w = this.z = this.y = this.x = a;
		return this
	},
	setX: function(a) {
		this.x = a;
		return this
	},
	setY: function(a) {
		this.y = a;
		return this
	},
	setZ: function(a) {
		this.z = a;
		return this
	},
	setW: function(a) {
		this.w = a;
		return this
	},
	setComponent: function(a, b) {
		switch (a) {
			case 0:
				this.x = b;
				break;
			case 1:
				this.y = b;
				break;
			case 2:
				this.z = b;
				break;
			case 3:
				this.w = b;
				break;
			default:
				throw Error("index is out of range: " +
					a);
		}
	},
	getComponent: function(a) {
		switch (a) {
			case 0:
				return this.x;
			case 1:
				return this.y;
			case 2:
				return this.z;
			case 3:
				return this.w;
			default:
				throw Error("index is out of range: " + a);
		}
	},
	clone: function() {
		return new this.constructor(this.x, this.y, this.z, this.w)
	},
	copy: function(a) {
		this.x = a.x;
		this.y = a.y;
		this.z = a.z;
		this.w = void 0 !== a.w ? a.w : 1;
		return this
	},
	add: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a, b);
		this.x += a.x;
		this.y += a.y;
		this.z += a.z;
		this.w += a.w;
		return this
	},
	addScalar: function(a) {
		this.x += a;
		this.y += a;
		this.z += a;
		this.w += a;
		return this
	},
	addVectors: function(a, b) {
		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;
		return this
	},
	addScaledVector: function(a, b) {
		this.x += a.x * b;
		this.y += a.y * b;
		this.z += a.z * b;
		this.w += a.w * b;
		return this
	},
	sub: function(a, b) {
		if (void 0 !== b) return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a, b);
		this.x -=
			a.x;
		this.y -= a.y;
		this.z -= a.z;
		this.w -= a.w;
		return this
	},
	subScalar: function(a) {
		this.x -= a;
		this.y -= a;
		this.z -= a;
		this.w -= a;
		return this
	},
	subVectors: function(a, b) {
		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;
		return this
	},
	multiplyScalar: function(a) {
		isFinite(a) ? (this.x *= a, this.y *= a, this.z *= a, this.w *= a) : this.w = this.z = this.y = this.x = 0;
		return this
	},
	applyMatrix4: function(a) {
		var b = this.x,
			c = this.y,
			d = this.z,
			e = this.w;
		a = a.elements;
		this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
		this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
		this.z =
			a[2] * b + a[6] * c + a[10] * d + a[14] * e;
		this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
		return this
	},
	divideScalar: function(a) {
		return this.multiplyScalar(1 / a)
	},
	setAxisAngleFromQuaternion: function(a) {
		this.w = 2 * Math.acos(a.w);
		var b = Math.sqrt(1 - a.w * a.w);
		1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
		return this
	},
	setAxisAngleFromRotationMatrix: function(a) {
		var b, c, d;
		a = a.elements;
		var e = a[0];
		d = a[4];
		var f = a[8],
			g = a[1],
			h = a[5],
			k = a[9];
		c = a[2];
		b = a[6];
		var l = a[10];
		if (.01 > Math.abs(d - g) && .01 > Math.abs(f - c) && .01 >
			Math.abs(k - b)) {
			if (.1 > Math.abs(d + g) && .1 > Math.abs(f + c) && .1 > Math.abs(k + b) && .1 > Math.abs(e + h + l - 3)) return this.set(1, 0, 0, 0), this;
			a = Math.PI;
			e = (e + 1) / 2;
			h = (h + 1) / 2;
			l = (l + 1) / 2;
			d = (d + g) / 4;
			f = (f + c) / 4;
			k = (k + b) / 4;
			e > h && e > l ? .01 > e ? (b = 0, d = c = .707106781) : (b = Math.sqrt(e), c = d / b, d = f / b) : h > l ? .01 > h ? (b = .707106781, c = 0, d = .707106781) : (c = Math.sqrt(h), b = d / c, d = k / c) : .01 > l ? (c = b = .707106781, d = 0) : (d = Math.sqrt(l), b = f / d, c = k / d);
			this.set(b, c, d, a);
			return this
		}
		a = Math.sqrt((b - k) * (b - k) + (f - c) * (f - c) + (g - d) * (g - d));
		.001 > Math.abs(a) && (a = 1);
		this.x = (b - k) /
			a;
		this.y = (f - c) / a;
		this.z = (g - d) / a;
		this.w = Math.acos((e + h + l - 1) / 2);
		return this
	},
	min: function(a) {
		this.x = Math.min(this.x, a.x);
		this.y = Math.min(this.y, a.y);
		this.z = Math.min(this.z, a.z);
		this.w = Math.min(this.w, a.w);
		return this
	},
	max: function(a) {
		this.x = Math.max(this.x, a.x);
		this.y = Math.max(this.y, a.y);
		this.z = Math.max(this.z, a.z);
		this.w = Math.max(this.w, a.w);
		return this
	},
	clamp: function(a, b) {
		this.x = Math.max(a.x, Math.min(b.x, this.x));
		this.y = Math.max(a.y, Math.min(b.y, this.y));
		this.z = Math.max(a.z, Math.min(b.z, this.z));
		this.w = Math.max(a.w, Math.min(b.w, this.w));
		return this
	},
	clampScalar: function() {
		var a, b;
		return function d(e, f) {
			void 0 === a && (a = new THREE.Vector4, b = new THREE.Vector4);
			a.set(e, e, e, e);
			b.set(f, f, f, f);
			return this.clamp(a, b)
		}
	}(),
	floor: function() {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		this.z = Math.floor(this.z);
		this.w = Math.floor(this.w);
		return this
	},
	ceil: function() {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		this.z = Math.ceil(this.z);
		this.w = Math.ceil(this.w);
		return this
	},
	round: function() {
		this.x =
			Math.round(this.x);
		this.y = Math.round(this.y);
		this.z = Math.round(this.z);
		this.w = Math.round(this.w);
		return this
	},
	roundToZero: function() {
		this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
		this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
		this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
		this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
		return this
	},
	negate: function() {
		this.x = -this.x;
		this.y = -this.y;
		this.z = -this.z;
		this.w = -this.w;
		return this
	},
	dot: function(a) {
		return this.x * a.x + this.y * a.y + this.z *
			a.z + this.w * a.w
	},
	lengthSq: function() {
		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
	},
	length: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
	},
	lengthManhattan: function() {
		return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
	},
	normalize: function() {
		return this.divideScalar(this.length())
	},
	setLength: function(a) {
		return this.multiplyScalar(a / this.length())
	},
	lerp: function(a, b) {
		this.x += (a.x - this.x) * b;
		this.y += (a.y - this.y) * b;
		this.z += (a.z -
			this.z) * b;
		this.w += (a.w - this.w) * b;
		return this
	},
	lerpVectors: function(a, b, c) {
		return this.subVectors(b, a).multiplyScalar(c).add(a)
	},
	equals: function(a) {
		return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
	},
	fromArray: function(a, b) {
		void 0 === b && (b = 0);
		this.x = a[b];
		this.y = a[b + 1];
		this.z = a[b + 2];
		this.w = a[b + 3];
		return this
	},
	toArray: function(a, b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		a[b] = this.x;
		a[b + 1] = this.y;
		a[b + 2] = this.z;
		a[b + 3] = this.w;
		return a
	},
	fromAttribute: function(a, b, c) {
		void 0 === c && (c = 0);
		b = b * a.itemSize +
			c;
		this.x = a.array[b];
		this.y = a.array[b + 1];
		this.z = a.array[b + 2];
		this.w = a.array[b + 3];
		return this
	}
};
THREE.Euler = function(a, b, c, d) {
	this._x = a || 0;
	this._y = b || 0;
	this._z = c || 0;
	this._order = d || THREE.Euler.DefaultOrder
};
THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
THREE.Euler.DefaultOrder = "XYZ";
THREE.Euler.prototype = {
	constructor: THREE.Euler,
	get x() {
		return this._x
	},
	set x(a) {
		this._x = a;
		this.onChangeCallback()
	},
	get y() {
		return this._y
	},
	set y(a) {
		this._y = a;
		this.onChangeCallback()
	},
	get z() {
		return this._z
	},
	set z(a) {
		this._z = a;
		this.onChangeCallback()
	},
	get order() {
		return this._order
	},
	set order(a) {
		this._order = a;
		this.onChangeCallback()
	},
	set: function(a, b, c, d) {
		this._x = a;
		this._y = b;
		this._z = c;
		this._order = d || this._order;
		this.onChangeCallback();
		return this
	},
	clone: function() {
		return new this.constructor(this._x,
			this._y, this._z, this._order)
	},
	copy: function(a) {
		this._x = a._x;
		this._y = a._y;
		this._z = a._z;
		this._order = a._order;
		this.onChangeCallback();
		return this
	},
	setFromRotationMatrix: function(a, b, c) {
		var d = THREE.Math.clamp,
			e = a.elements;
		a = e[0];
		var f = e[4],
			g = e[8],
			h = e[1],
			k = e[5],
			l = e[9],
			m = e[2],
			n = e[6],
			e = e[10];
		b = b || this._order;
		"XYZ" === b ? (this._y = Math.asin(d(g, -1, 1)), .99999 > Math.abs(g) ? (this._x = Math.atan2(-l, e), this._z = Math.atan2(-f, a)) : (this._x = Math.atan2(n, k), this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-d(l, -1, 1)), .99999 > Math.abs(l) ?
			(this._y = Math.atan2(g, e), this._z = Math.atan2(h, k)) : (this._y = Math.atan2(-m, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(d(n, -1, 1)), .99999 > Math.abs(n) ? (this._y = Math.atan2(-m, e), this._z = Math.atan2(-f, k)) : (this._y = 0, this._z = Math.atan2(h, a))) : "ZYX" === b ? (this._y = Math.asin(-d(m, -1, 1)), .99999 > Math.abs(m) ? (this._x = Math.atan2(n, e), this._z = Math.atan2(h, a)) : (this._x = 0, this._z = Math.atan2(-f, k))) : "YZX" === b ? (this._z = Math.asin(d(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(-l, k), this._y = Math.atan2(-m, a)) : (this._x =
			0, this._y = Math.atan2(g, e))) : "XZY" === b ? (this._z = Math.asin(-d(f, -1, 1)), .99999 > Math.abs(f) ? (this._x = Math.atan2(n, k), this._y = Math.atan2(g, a)) : (this._x = Math.atan2(-l, e), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
		this._order = b;
		if (!1 !== c) this.onChangeCallback();
		return this
	},
	setFromQuaternion: function() {
		var a;
		return function(b, c, d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeRotationFromQuaternion(b);
			return this.setFromRotationMatrix(a, c, d)
		}
	}(),
	setFromVector3: function(a,
		b) {
		return this.set(a.x, a.y, a.z, b || this._order)
	},
	reorder: function() {
		var a = new THREE.Quaternion;
		return function(b) {
			a.setFromEuler(this);
			return this.setFromQuaternion(a, b)
		}
	}(),
	equals: function(a) {
		return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
	},
	fromArray: function(a) {
		this._x = a[0];
		this._y = a[1];
		this._z = a[2];
		void 0 !== a[3] && (this._order = a[3]);
		this.onChangeCallback();
		return this
	},
	toArray: function(a, b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		a[b] = this._x;
		a[b + 1] = this._y;
		a[b + 2] = this._z;
		a[b + 3] = this._order;
		return a
	},
	toVector3: function(a) {
		return a ? a.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z)
	},
	onChange: function(a) {
		this.onChangeCallback = a;
		return this
	},
	onChangeCallback: function() {}
};
THREE.Line3 = function(a, b) {
	this.start = void 0 !== a ? a : new THREE.Vector3;
	this.end = void 0 !== b ? b : new THREE.Vector3
};
THREE.Line3.prototype = {
	constructor: THREE.Line3,
	set: function(a, b) {
		this.start.copy(a);
		this.end.copy(b);
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.start.copy(a.start);
		this.end.copy(a.end);
		return this
	},
	center: function(a) {
		a = a || new THREE.Vector3;
		return a.addVectors(this.start, this.end).multiplyScalar(.5)
	},
	delta: function(a) {
		a = a || new THREE.Vector3;
		return a.subVectors(this.end, this.start)
	},
	distanceSq: function() {
		return this.start.distanceToSquared(this.end)
	},
	distance: function() {
		return this.start.distanceTo(this.end)
	},
	at: function(a, b) {
		b = b || new THREE.Vector3;
		return this.delta(b).multiplyScalar(a).add(this.start)
	},
	closestPointToPointParameter: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3;
		return function(c, d) {
			a.subVectors(c, this.start);
			b.subVectors(this.end, this.start);
			c = b.dot(b);
			var e = b.dot(a);
			c = e / c;
			d && (c = THREE.Math.clamp(c, 0, 1));
			return c
		}
	}(),
	closestPointToPoint: function(a, b, c) {
		a = this.closestPointToPointParameter(a, b);
		c = c || new THREE.Vector3;
		return this.delta(c).multiplyScalar(a).add(this.start)
	},
	applyMatrix4: function(a) {
		this.start.applyMatrix4(a);
		this.end.applyMatrix4(a);
		return this
	},
	equals: function(a) {
		return a.start.equals(this.start) && a.end.equals(this.end)
	}
};
THREE.Box2 = function(a, b) {
	this.min = void 0 !== a ? a : new THREE.Vector2(Infinity, Infinity);
	this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity, -Infinity)
};
THREE.Box2.prototype = {
	constructor: THREE.Box2,
	set: function(a, b) {
		this.min.copy(a);
		this.max.copy(b);
		return this
	},
	setFromPoints: function(a) {
		this.makeEmpty();
		for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
		return this
	},
	setFromCenterAndSize: function() {
		var a = new THREE.Vector2;
		return function(b, c) {
			c = a.copy(c).multiplyScalar(.5);
			this.min.copy(b).sub(c);
			this.max.copy(b).add(c);
			return this
		}
	}(),
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.min.copy(a.min);
		this.max.copy(a.max);
		return this
	},
	makeEmpty: function() {
		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = -Infinity;
		return this
	},
	isEmpty: function() {
		return this.max.x < this.min.x || this.max.y < this.min.y
	},
	center: function(a) {
		a = a || new THREE.Vector2;
		return a.addVectors(this.min, this.max).multiplyScalar(.5)
	},
	size: function(a) {
		a = a || new THREE.Vector2;
		return a.subVectors(this.max, this.min)
	},
	expandByPoint: function(a) {
		this.min.min(a);
		this.max.max(a);
		return this
	},
	expandByVector: function(a) {
		this.min.sub(a);
		this.max.add(a);
		return this
	},
	expandByScalar: function(a) {
		this.min.addScalar(-a);
		this.max.addScalar(a);
		return this
	},
	containsPoint: function(a) {
		return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
	},
	containsBox: function(a) {
		return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
	},
	getParameter: function(a, b) {
		b = b || new THREE.Vector2;
		return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
	},
	intersectsBox: function(a) {
		return a.max.x < this.min.x ||
			a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
	},
	clampPoint: function(a, b) {
		b = b || new THREE.Vector2;
		return b.copy(a).clamp(this.min, this.max)
	},
	distanceToPoint: function() {
		var a = new THREE.Vector2;
		return function(b) {
			var c = a.copy(b).clamp(this.min, this.max);
			return c.sub(b).length()
		}
	}(),
	intersect: function(a) {
		this.min.max(a.min);
		this.max.min(a.max);
		return this
	},
	union: function(a) {
		this.min.min(a.min);
		this.max.max(a.max);
		return this
	},
	translate: function(a) {
		this.min.add(a);
		this.max.add(a);
		return this
	},
	equals: function(a) {
		return a.min.equals(this.min) && a.max.equals(this.max)
	}
};
THREE.Box3 = function(a, b) {
	this.min = void 0 !== a ? a : new THREE.Vector3(Infinity, Infinity, Infinity);
	this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity, -Infinity, -Infinity)
};
THREE.Box3.prototype = {
	constructor: THREE.Box3,
	set: function(a, b) {
		this.min.copy(a);
		this.max.copy(b);
		return this
	},
	setFromArray: function(a) {
		for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, f = -Infinity, g = -Infinity, h = 0, k = a.length; h < k; h += 3) {
			var l = a[h],
				m = a[h + 1],
				n = a[h + 2];
			l < b && (b = l);
			m < c && (c = m);
			n < d && (d = n);
			l > e && (e = l);
			m > f && (f = m);
			n > g && (g = n)
		}
		this.min.set(b, c, d);
		this.max.set(e, f, g)
	},
	setFromPoints: function(a) {
		this.makeEmpty();
		for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
		return this
	},
	setFromCenterAndSize: function() {
		var a =
			new THREE.Vector3;
		return function(b, c) {
			c = a.copy(c).multiplyScalar(.5);
			this.min.copy(b).sub(c);
			this.max.copy(b).add(c);
			return this
		}
	}(),
	setFromObject: function() {
		var a = new THREE.Vector3;
		return function(b) {
			var c = this;
			b.updateMatrixWorld(!0);
			this.makeEmpty();
			b.traverse(function(b) {
				var d = b.geometry;
				if (void 0 !== d)
					if (d instanceof THREE.Geometry)
						for (var f = d.vertices, d = 0, g = f.length; d < g; d++) a.copy(f[d]), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a);
					else if (d instanceof THREE.BufferGeometry && void 0 !== d.attributes.position)
					for (f =
						d.attributes.position.array, d = 0, g = f.length; d < g; d += 3) a.fromArray(f, d), a.applyMatrix4(b.matrixWorld), c.expandByPoint(a)
			});
			return this
		}
	}(),
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.min.copy(a.min);
		this.max.copy(a.max);
		return this
	},
	makeEmpty: function() {
		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;
		return this
	},
	isEmpty: function() {
		return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
	},
	center: function(a) {
		a =
			a || new THREE.Vector3;
		return a.addVectors(this.min, this.max).multiplyScalar(.5)
	},
	size: function(a) {
		a = a || new THREE.Vector3;
		return a.subVectors(this.max, this.min)
	},
	expandByPoint: function(a) {
		this.min.min(a);
		this.max.max(a);
		return this
	},
	expandByVector: function(a) {
		this.min.sub(a);
		this.max.add(a);
		return this
	},
	expandByScalar: function(a) {
		this.min.addScalar(-a);
		this.max.addScalar(a);
		return this
	},
	containsPoint: function(a) {
		return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z ||
			a.z > this.max.z ? !1 : !0
	},
	containsBox: function(a) {
		return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
	},
	getParameter: function(a, b) {
		b = b || new THREE.Vector3;
		return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
	},
	intersectsBox: function(a) {
		return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z ||
			a.min.z > this.max.z ? !1 : !0
	},
	intersectsSphere: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Vector3);
			this.clampPoint(d.center, a);
			return a.distanceToSquared(d.center) <= d.radius * d.radius
		}
	}(),
	intersectsPlane: function(a) {
		var b, c;
		0 < a.normal.x ? (b = a.normal.x * this.min.x, c = a.normal.x * this.max.x) : (b = a.normal.x * this.max.x, c = a.normal.x * this.min.x);
		0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c += a.normal.y * this.min.y);
		0 < a.normal.z ? (b += a.normal.z * this.min.z,
			c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z, c += a.normal.z * this.min.z);
		return b <= a.constant && c >= a.constant
	},
	clampPoint: function(a, b) {
		b = b || new THREE.Vector3;
		return b.copy(a).clamp(this.min, this.max)
	},
	distanceToPoint: function() {
		var a = new THREE.Vector3;
		return function(b) {
			var c = a.copy(b).clamp(this.min, this.max);
			return c.sub(b).length()
		}
	}(),
	getBoundingSphere: function() {
		var a = new THREE.Vector3;
		return function(b) {
			b = b || new THREE.Sphere;
			b.center = this.center();
			b.radius = .5 * this.size(a).length();
			return b
		}
	}(),
	intersect: function(a) {
		this.min.max(a.min);
		this.max.min(a.max);
		this.isEmpty() && this.makeEmpty();
		return this
	},
	union: function(a) {
		this.min.min(a.min);
		this.max.max(a.max);
		return this
	},
	applyMatrix4: function() {
		var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
		return function(b) {
			if (this.isEmpty()) return this;
			a[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(b);
			a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
			a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
			a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
			a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
			a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
			a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
			a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
			this.setFromPoints(a);
			return this
		}
	}(),
	translate: function(a) {
		this.min.add(a);
		this.max.add(a);
		return this
	},
	equals: function(a) {
		return a.min.equals(this.min) &&
			a.max.equals(this.max)
	}
};
THREE.Matrix3 = function() {
	this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
	0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
};
THREE.Matrix3.prototype = {
	constructor: THREE.Matrix3,
	set: function(a, b, c, d, e, f, g, h, k) {
		var l = this.elements;
		l[0] = a;
		l[1] = d;
		l[2] = g;
		l[3] = b;
		l[4] = e;
		l[5] = h;
		l[6] = c;
		l[7] = f;
		l[8] = k;
		return this
	},
	identity: function() {
		this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
		return this
	},
	clone: function() {
		return (new this.constructor).fromArray(this.elements)
	},
	copy: function(a) {
		a = a.elements;
		this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
		return this
	},
	setFromMatrix4: function(a) {
		a = a.elements;
		this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
		return this
	},
	applyToVector3Array: function() {
		var a;
		return function(b, c, d) {
			void 0 === a && (a = new THREE.Vector3);
			void 0 === c && (c = 0);
			void 0 === d && (d = b.length);
			for (var e = 0; e < d; e += 3, c += 3) a.fromArray(b, c), a.applyMatrix3(this), a.toArray(b, c);
			return b
		}
	}(),
	applyToBuffer: function() {
		var a;
		return function c(d, e, f) {
			void 0 === a && (a = new THREE.Vector3);
			void 0 === e && (e = 0);
			void 0 === f && (f = d.length / d.itemSize);
			for (var g = 0; g < f; g++, e++) a.x = d.getX(e), a.y = d.getY(e), a.z = d.getZ(e), a.applyMatrix3(this), d.setXYZ(a.x, a.y, a.z);
			return d
		}
	}(),
	multiplyScalar: function(a) {
		var b = this.elements;
		b[0] *= a;
		b[3] *= a;
		b[6] *= a;
		b[1] *= a;
		b[4] *= a;
		b[7] *= a;
		b[2] *= a;
		b[5] *= a;
		b[8] *= a;
		return this
	},
	determinant: function() {
		var a = this.elements,
			b = a[0],
			c = a[1],
			d = a[2],
			e = a[3],
			f = a[4],
			g = a[5],
			h = a[6],
			k = a[7],
			a = a[8];
		return b * f * a - b * g * k - c * e * a + c * g * h + d * e * k - d * f * h
	},
	getInverse: function(a, b) {
		a instanceof THREE.Matrix4 && console.error("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
		var c = a.elements;
		a = this.elements;
		var d = c[0],
			e = c[1],
			f = c[2],
			g = c[3],
			h = c[4],
			k = c[5],
			l = c[6],
			m =
			c[7],
			c = c[8],
			n = c * h - k * m,
			r = k * l - c * g,
			t = m * g - h * l,
			u = d * n + e * r + f * t;
		if (0 === u) {
			a = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
			if (b) throw Error(a);
			console.warn(a);
			return this.identity()
		}
		b = 1 / u;
		a[0] = n * b;
		a[1] = (f * m - c * e) * b;
		a[2] = (k * e - f * h) * b;
		a[3] = r * b;
		a[4] = (c * d - f * l) * b;
		a[5] = (f * g - k * d) * b;
		a[6] = t * b;
		a[7] = (e * l - m * d) * b;
		a[8] = (h * d - e * g) * b;
		return this
	},
	transpose: function() {
		var a, b = this.elements;
		a = b[1];
		b[1] = b[3];
		b[3] = a;
		a = b[2];
		b[2] = b[6];
		b[6] = a;
		a = b[5];
		b[5] = b[7];
		b[7] = a;
		return this
	},
	flattenToArrayOffset: function(a,
		b) {
		console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead.");
		return this.toArray(a, b)
	},
	getNormalMatrix: function(a) {
		return this.setFromMatrix4(a).getInverse(this).transpose()
	},
	transposeIntoArray: function(a) {
		var b = this.elements;
		a[0] = b[0];
		a[1] = b[3];
		a[2] = b[6];
		a[3] = b[1];
		a[4] = b[4];
		a[5] = b[7];
		a[6] = b[2];
		a[7] = b[5];
		a[8] = b[8];
		return this
	},
	fromArray: function(a) {
		this.elements.set(a);
		return this
	},
	toArray: function(a, b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		var c = this.elements;
		a[b] = c[0];
		a[b + 1] = c[1];
		a[b + 2] = c[2];
		a[b + 3] = c[3];
		a[b + 4] = c[4];
		a[b + 5] = c[5];
		a[b + 6] = c[6];
		a[b + 7] = c[7];
		a[b + 8] = c[8];
		return a
	}
};
THREE.Matrix4 = function() {
	this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
	0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
};
THREE.Matrix4.prototype = {
	constructor: THREE.Matrix4,
	set: function(a, b, c, d, e, f, g, h, k, l, m, n, r, t, u, w) {
		var v = this.elements;
		v[0] = a;
		v[4] = b;
		v[8] = c;
		v[12] = d;
		v[1] = e;
		v[5] = f;
		v[9] = g;
		v[13] = h;
		v[2] = k;
		v[6] = l;
		v[10] = m;
		v[14] = n;
		v[3] = r;
		v[7] = t;
		v[11] = u;
		v[15] = w;
		return this
	},
	identity: function() {
		this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this
	},
	clone: function() {
		return (new THREE.Matrix4).fromArray(this.elements)
	},
	copy: function(a) {
		this.elements.set(a.elements);
		return this
	},
	copyPosition: function(a) {
		var b = this.elements;
		a = a.elements;
		b[12] = a[12];
		b[13] = a[13];
		b[14] = a[14];
		return this
	},
	extractBasis: function(a, b, c) {
		a.setFromMatrixColumn(this, 0);
		b.setFromMatrixColumn(this, 1);
		c.setFromMatrixColumn(this, 2);
		return this
	},
	makeBasis: function(a, b, c) {
		this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
		return this
	},
	extractRotation: function() {
		var a;
		return function(b) {
			void 0 === a && (a = new THREE.Vector3);
			var c = this.elements,
				d = b.elements,
				e = 1 / a.setFromMatrixColumn(b, 0).length(),
				f = 1 / a.setFromMatrixColumn(b, 1).length();
			b = 1 / a.setFromMatrixColumn(b,
				2).length();
			c[0] = d[0] * e;
			c[1] = d[1] * e;
			c[2] = d[2] * e;
			c[4] = d[4] * f;
			c[5] = d[5] * f;
			c[6] = d[6] * f;
			c[8] = d[8] * b;
			c[9] = d[9] * b;
			c[10] = d[10] * b;
			return this
		}
	}(),
	makeRotationFromEuler: function(a) {
		!1 === a instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
		var b = this.elements,
			c = a.x,
			d = a.y,
			e = a.z,
			f = Math.cos(c),
			c = Math.sin(c),
			g = Math.cos(d),
			d = Math.sin(d),
			h = Math.cos(e),
			e = Math.sin(e);
		if ("XYZ" === a.order) {
			a = f * h;
			var k = f * e,
				l = c * h,
				m = c * e;
			b[0] = g * h;
			b[4] = -g * e;
			b[8] = d;
			b[1] = k + l * d;
			b[5] = a - m * d;
			b[9] = -c * g;
			b[2] = m - a * d;
			b[6] = l + k * d;
			b[10] = f * g
		} else "YXZ" === a.order ? (a = g * h, k = g * e, l = d * h, m = d * e, b[0] = a + m * c, b[4] = l * c - k, b[8] = f * d, b[1] = f * e, b[5] = f * h, b[9] = -c, b[2] = k * c - l, b[6] = m + a * c, b[10] = f * g) : "ZXY" === a.order ? (a = g * h, k = g * e, l = d * h, m = d * e, b[0] = a - m * c, b[4] = -f * e, b[8] = l + k * c, b[1] = k + l * c, b[5] = f * h, b[9] = m - a * c, b[2] = -f * d, b[6] = c, b[10] = f * g) : "ZYX" === a.order ? (a = f * h, k = f * e, l = c * h, m = c * e, b[0] = g * h, b[4] = l * d - k, b[8] = a * d + m, b[1] = g * e, b[5] = m * d + a, b[9] = k * d - l, b[2] = -d, b[6] = c * g, b[10] = f * g) : "YZX" === a.order ? (a = f * g, k = f *
			d, l = c * g, m = c * d, b[0] = g * h, b[4] = m - a * e, b[8] = l * e + k, b[1] = e, b[5] = f * h, b[9] = -c * h, b[2] = -d * h, b[6] = k * e + l, b[10] = a - m * e) : "XZY" === a.order && (a = f * g, k = f * d, l = c * g, m = c * d, b[0] = g * h, b[4] = -e, b[8] = d * h, b[1] = a * e + m, b[5] = f * h, b[9] = k * e - l, b[2] = l * e - k, b[6] = c * h, b[10] = m * e + a);
		b[3] = 0;
		b[7] = 0;
		b[11] = 0;
		b[12] = 0;
		b[13] = 0;
		b[14] = 0;
		b[15] = 1;
		return this
	},
	makeRotationFromQuaternion: function(a) {
		var b = this.elements,
			c = a.x,
			d = a.y,
			e = a.z,
			f = a.w,
			g = c + c,
			h = d + d,
			k = e + e;
		a = c * g;
		var l = c * h,
			c = c * k,
			m = d * h,
			d = d * k,
			e = e * k,
			g = f * g,
			h = f * h,
			f = f * k;
		b[0] = 1 - (m + e);
		b[4] = l - f;
		b[8] = c + h;
		b[1] = l +
			f;
		b[5] = 1 - (a + e);
		b[9] = d - g;
		b[2] = c - h;
		b[6] = d + g;
		b[10] = 1 - (a + m);
		b[3] = 0;
		b[7] = 0;
		b[11] = 0;
		b[12] = 0;
		b[13] = 0;
		b[14] = 0;
		b[15] = 1;
		return this
	},
	lookAt: function() {
		var a, b, c;
		return function(d, e, f) {
			void 0 === a && (a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3);
			var g = this.elements;
			c.subVectors(d, e).normalize();
			0 === c.lengthSq() && (c.z = 1);
			a.crossVectors(f, c).normalize();
			0 === a.lengthSq() && (c.z += 1E-4, a.crossVectors(f, c).normalize());
			b.crossVectors(c, a);
			g[0] = a.x;
			g[4] = b.x;
			g[8] = c.x;
			g[1] = a.y;
			g[5] = b.y;
			g[9] = c.y;
			g[2] = a.z;
			g[6] = b.z;
			g[10] = c.z;
			return this
		}
	}(),
	multiply: function(a, b) {
		return void 0 !== b ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
	},
	premultiply: function(a) {
		return this.multiplyMatrices(a, this)
	},
	multiplyMatrices: function(a, b) {
		var c = a.elements,
			d = b.elements;
		b = this.elements;
		a = c[0];
		var e = c[4],
			f = c[8],
			g = c[12],
			h = c[1],
			k = c[5],
			l = c[9],
			m = c[13],
			n = c[2],
			r = c[6],
			t = c[10],
			u = c[14],
			w = c[3],
			v = c[7],
			x = c[11],
			c = c[15],
			y = d[0],
			D = d[4],
			z = d[8],
			G = d[12],
			A = d[1],
			H = d[5],
			O = d[9],
			M = d[13],
			J = d[2],
			P = d[6],
			L = d[10],
			Q = d[14],
			S = d[3],
			K = d[7],
			X = d[11],
			d = d[15];
		b[0] = a * y + e * A + f * J + g * S;
		b[4] = a * D + e * H + f * P + g * K;
		b[8] = a * z + e * O + f * L + g * X;
		b[12] = a * G + e * M + f * Q + g * d;
		b[1] = h * y + k * A + l * J + m * S;
		b[5] = h * D + k * H + l * P + m * K;
		b[9] = h * z + k * O + l * L + m * X;
		b[13] = h * G + k * M + l * Q + m * d;
		b[2] = n * y + r * A + t * J + u * S;
		b[6] = n * D + r * H + t * P + u * K;
		b[10] = n * z + r * O + t * L + u * X;
		b[14] = n * G + r * M + t * Q + u * d;
		b[3] = w * y + v * A + x * J + c * S;
		b[7] = w * D + v * H + x * P + c * K;
		b[11] = w * z + v * O + x * L + c * X;
		b[15] = w * G + v * M + x * Q + c * d;
		return this
	},
	multiplyToArray: function(a,
		b, c) {
		var d = this.elements;
		this.multiplyMatrices(a, b);
		c[0] = d[0];
		c[1] = d[1];
		c[2] = d[2];
		c[3] = d[3];
		c[4] = d[4];
		c[5] = d[5];
		c[6] = d[6];
		c[7] = d[7];
		c[8] = d[8];
		c[9] = d[9];
		c[10] = d[10];
		c[11] = d[11];
		c[12] = d[12];
		c[13] = d[13];
		c[14] = d[14];
		c[15] = d[15];
		return this
	},
	multiplyScalar: function(a) {
		var b = this.elements;
		b[0] *= a;
		b[4] *= a;
		b[8] *= a;
		b[12] *= a;
		b[1] *= a;
		b[5] *= a;
		b[9] *= a;
		b[13] *= a;
		b[2] *= a;
		b[6] *= a;
		b[10] *= a;
		b[14] *= a;
		b[3] *= a;
		b[7] *= a;
		b[11] *= a;
		b[15] *= a;
		return this
	},
	applyToVector3Array: function() {
		var a;
		return function(b, c, d) {
			void 0 === a &&
				(a = new THREE.Vector3);
			void 0 === c && (c = 0);
			void 0 === d && (d = b.length);
			for (var e = 0; e < d; e += 3, c += 3) a.fromArray(b, c), a.applyMatrix4(this), a.toArray(b, c);
			return b
		}
	}(),
	applyToBuffer: function() {
		var a;
		return function c(d, e, f) {
			void 0 === a && (a = new THREE.Vector3);
			void 0 === e && (e = 0);
			void 0 === f && (f = d.length / d.itemSize);
			for (var g = 0; g < f; g++, e++) a.x = d.getX(e), a.y = d.getY(e), a.z = d.getZ(e), a.applyMatrix4(this), d.setXYZ(a.x, a.y, a.z);
			return d
		}
	}(),
	determinant: function() {
		var a = this.elements,
			b = a[0],
			c = a[4],
			d = a[8],
			e = a[12],
			f = a[1],
			g = a[5],
			h = a[9],
			k = a[13],
			l = a[2],
			m = a[6],
			n = a[10],
			r = a[14],
			t = a[3],
			u = a[7],
			w = a[11],
			a = a[15];
		return t * (+e * h * m - d * k * m - e * g * n + c * k * n + d * g * r - c * h * r) + u * (+b * h * r - b * k * n + e * f * n - d * f * r + d * k * l - e * h * l) + w * (+b * k * m - b * g * r - e * f * m + c * f * r + e * g * l - c * k * l) + a * (-d * g * l - b * h * m + b * g * n + d * f * m - c * f * n + c * h * l)
	},
	transpose: function() {
		var a = this.elements,
			b;
		b = a[1];
		a[1] = a[4];
		a[4] = b;
		b = a[2];
		a[2] = a[8];
		a[8] = b;
		b = a[6];
		a[6] = a[9];
		a[9] = b;
		b = a[3];
		a[3] = a[12];
		a[12] = b;
		b = a[7];
		a[7] = a[13];
		a[13] = b;
		b = a[11];
		a[11] = a[14];
		a[14] = b;
		return this
	},
	flattenToArrayOffset: function(a, b) {
		console.warn("THREE.Matrix3: .flattenToArrayOffset is deprecated - just use .toArray instead.");
		return this.toArray(a, b)
	},
	getPosition: function() {
		var a;
		return function() {
			void 0 === a && (a = new THREE.Vector3);
			console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
			return a.setFromMatrixColumn(this, 3)
		}
	}(),
	setPosition: function(a) {
		var b = this.elements;
		b[12] = a.x;
		b[13] = a.y;
		b[14] = a.z;
		return this
	},
	getInverse: function(a, b) {
		var c = this.elements,
			d = a.elements;
		a = d[0];
		var e = d[1],
			f = d[2],
			g = d[3],
			h = d[4],
			k = d[5],
			l = d[6],
			m = d[7],
			n = d[8],
			r = d[9],
			t = d[10],
			u = d[11],
			w =
			d[12],
			v = d[13],
			x = d[14],
			d = d[15],
			y = r * x * m - v * t * m + v * l * u - k * x * u - r * l * d + k * t * d,
			D = w * t * m - n * x * m - w * l * u + h * x * u + n * l * d - h * t * d,
			z = n * v * m - w * r * m + w * k * u - h * v * u - n * k * d + h * r * d,
			G = w * r * l - n * v * l - w * k * t + h * v * t + n * k * x - h * r * x,
			A = a * y + e * D + f * z + g * G;
		if (0 === A) {
			c = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
			if (b) throw Error(c);
			console.warn(c);
			return this.identity()
		}
		b = 1 / A;
		c[0] = y * b;
		c[1] = (v * t * g - r * x * g - v * f * u + e * x * u + r * f * d - e * t * d) * b;
		c[2] = (k * x * g - v * l * g + v * f * m - e * x * m - k * f * d + e * l * d) * b;
		c[3] = (r * l * g - k * t * g - r * f * m + e * t * m + k * f * u - e * l * u) * b;
		c[4] = D * b;
		c[5] =
			(n * x * g - w * t * g + w * f * u - a * x * u - n * f * d + a * t * d) * b;
		c[6] = (w * l * g - h * x * g - w * f * m + a * x * m + h * f * d - a * l * d) * b;
		c[7] = (h * t * g - n * l * g + n * f * m - a * t * m - h * f * u + a * l * u) * b;
		c[8] = z * b;
		c[9] = (w * r * g - n * v * g - w * e * u + a * v * u + n * e * d - a * r * d) * b;
		c[10] = (h * v * g - w * k * g + w * e * m - a * v * m - h * e * d + a * k * d) * b;
		c[11] = (n * k * g - h * r * g - n * e * m + a * r * m + h * e * u - a * k * u) * b;
		c[12] = G * b;
		c[13] = (n * v * f - w * r * f + w * e * t - a * v * t - n * e * x + a * r * x) * b;
		c[14] = (w * k * f - h * v * f - w * e * l + a * v * l + h * e * x - a * k * x) * b;
		c[15] = (h * r * f - n * k * f + n * e * l - a * r * l - h * e * t + a * k * t) * b;
		return this
	},
	scale: function(a) {
		var b = this.elements,
			c = a.x,
			d = a.y;
		a = a.z;
		b[0] *= c;
		b[4] *= d;
		b[8] *= a;
		b[1] *= c;
		b[5] *= d;
		b[9] *= a;
		b[2] *= c;
		b[6] *= d;
		b[10] *= a;
		b[3] *= c;
		b[7] *= d;
		b[11] *= a;
		return this
	},
	getMaxScaleOnAxis: function() {
		var a = this.elements,
			b = a[0] * a[0] + a[1] * a[1] + a[2] * a[2],
			c = a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
			a = a[8] * a[8] + a[9] * a[9] + a[10] * a[10];
		return Math.sqrt(Math.max(b, c, a))
	},
	makeTranslation: function(a, b, c) {
		this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
		return this
	},
	makeRotationX: function(a) {
		var b = Math.cos(a);
		a = Math.sin(a);
		this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
		return this
	},
	makeRotationY: function(a) {
		var b =
			Math.cos(a);
		a = Math.sin(a);
		this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
		return this
	},
	makeRotationZ: function(a) {
		var b = Math.cos(a);
		a = Math.sin(a);
		this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
		return this
	},
	makeRotationAxis: function(a, b) {
		var c = Math.cos(b);
		b = Math.sin(b);
		var d = 1 - c,
			e = a.x,
			f = a.y;
		a = a.z;
		var g = d * e,
			h = d * f;
		this.set(g * e + c, g * f - b * a, g * a + b * f, 0, g * f + b * a, h * f + c, h * a - b * e, 0, g * a - b * f, h * a + b * e, d * a * a + c, 0, 0, 0, 0, 1);
		return this
	},
	makeScale: function(a, b, c) {
		this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
		return this
	},
	compose: function(a,
		b, c) {
		this.makeRotationFromQuaternion(b);
		this.scale(c);
		this.setPosition(a);
		return this
	},
	decompose: function() {
		var a, b;
		return function(c, d, e) {
			void 0 === a && (a = new THREE.Vector3, b = new THREE.Matrix4);
			var f = this.elements,
				g = a.set(f[0], f[1], f[2]).length(),
				h = a.set(f[4], f[5], f[6]).length(),
				k = a.set(f[8], f[9], f[10]).length(),
				l = this.determinant();
			0 > l && (g = -g);
			c.x = f[12];
			c.y = f[13];
			c.z = f[14];
			b.elements.set(this.elements);
			c = 1 / g;
			f = 1 / h;
			l = 1 / k;
			b.elements[0] *= c;
			b.elements[1] *= c;
			b.elements[2] *= c;
			b.elements[4] *= f;
			b.elements[5] *=
				f;
			b.elements[6] *= f;
			b.elements[8] *= l;
			b.elements[9] *= l;
			b.elements[10] *= l;
			d.setFromRotationMatrix(b);
			e.x = g;
			e.y = h;
			e.z = k;
			return this
		}
	}(),
	makeFrustum: function(a, b, c, d, e, f) {
		var g = this.elements,
			h = 2 * e / (b - a),
			k = 2 * e / (d - c);
		a = (b + a) / (b - a);
		c = (d + c) / (d - c);
		d = -(f + e) / (f - e);
		e = -2 * f * e / (f - e);
		g[0] = h;
		g[4] = 0;
		g[8] = a;
		g[12] = 0;
		g[1] = 0;
		g[5] = k;
		g[9] = c;
		g[13] = 0;
		g[2] = 0;
		g[6] = 0;
		g[10] = d;
		g[14] = e;
		g[3] = 0;
		g[7] = 0;
		g[11] = -1;
		g[15] = 0;
		return this
	},
	makePerspective: function(a, b, c, d) {
		a = c * Math.tan(THREE.Math.DEG2RAD * a * .5);
		var e = -a,
			f = e * b;
		b *= a;
		return this.makeFrustum(f,
			b, e, a, c, d)
	},
	makeOrthographic: function(a, b, c, d, e, f) {
		var g = this.elements,
			h = 1 / (b - a),
			k = 1 / (c - d),
			l = 1 / (f - e);
		a = (b + a) * h;
		c = (c + d) * k;
		e = (f + e) * l;
		g[0] = 2 * h;
		g[4] = 0;
		g[8] = 0;
		g[12] = -a;
		g[1] = 0;
		g[5] = 2 * k;
		g[9] = 0;
		g[13] = -c;
		g[2] = 0;
		g[6] = 0;
		g[10] = -2 * l;
		g[14] = -e;
		g[3] = 0;
		g[7] = 0;
		g[11] = 0;
		g[15] = 1;
		return this
	},
	equals: function(a) {
		var b = this.elements;
		a = a.elements;
		for (var c = 0; 16 > c; c++)
			if (b[c] !== a[c]) return !1;
		return !0
	},
	fromArray: function(a) {
		this.elements.set(a);
		return this
	},
	toArray: function(a, b) {
		void 0 === a && (a = []);
		void 0 === b && (b = 0);
		var c = this.elements;
		a[b] = c[0];
		a[b + 1] = c[1];
		a[b + 2] = c[2];
		a[b + 3] = c[3];
		a[b + 4] = c[4];
		a[b + 5] = c[5];
		a[b + 6] = c[6];
		a[b + 7] = c[7];
		a[b + 8] = c[8];
		a[b + 9] = c[9];
		a[b + 10] = c[10];
		a[b + 11] = c[11];
		a[b + 12] = c[12];
		a[b + 13] = c[13];
		a[b + 14] = c[14];
		a[b + 15] = c[15];
		return a
	}
};
THREE.Ray = function(a, b) {
	this.origin = void 0 !== a ? a : new THREE.Vector3;
	this.direction = void 0 !== b ? b : new THREE.Vector3
};
THREE.Ray.prototype = {
	constructor: THREE.Ray,
	set: function(a, b) {
		this.origin.copy(a);
		this.direction.copy(b);
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.origin.copy(a.origin);
		this.direction.copy(a.direction);
		return this
	},
	at: function(a, b) {
		b = b || new THREE.Vector3;
		return b.copy(this.direction).multiplyScalar(a).add(this.origin)
	},
	lookAt: function(a) {
		this.direction.copy(a).sub(this.origin).normalize();
		return this
	},
	recast: function() {
		var a = new THREE.Vector3;
		return function(b) {
			this.origin.copy(this.at(b,
				a));
			return this
		}
	}(),
	closestPointToPoint: function(a, b) {
		b = b || new THREE.Vector3;
		b.subVectors(a, this.origin);
		a = b.dot(this.direction);
		return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin)
	},
	distanceToPoint: function(a) {
		return Math.sqrt(this.distanceSqToPoint(a))
	},
	distanceSqToPoint: function() {
		var a = new THREE.Vector3;
		return function(b) {
			var c = a.subVectors(b, this.origin).dot(this.direction);
			if (0 > c) return this.origin.distanceToSquared(b);
			a.copy(this.direction).multiplyScalar(c).add(this.origin);
			return a.distanceToSquared(b)
		}
	}(),
	distanceSqToSegment: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3,
			c = new THREE.Vector3;
		return function(d, e, f, g) {
			a.copy(d).add(e).multiplyScalar(.5);
			b.copy(e).sub(d).normalize();
			c.copy(this.origin).sub(a);
			var h = .5 * d.distanceTo(e),
				k = -this.direction.dot(b),
				l = c.dot(this.direction),
				m = -c.dot(b),
				n = c.lengthSq(),
				r = Math.abs(1 - k * k),
				t;
			0 < r ? (d = k * m - l, e = k * l - m, t = h * r, 0 <= d ? e >= -t ? e <= t ? (h = 1 / r, d *= h, e *= h, k = d * (d + k * e + 2 * l) + e * (k * d + e + 2 * m) + n) : (e = h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 *
				m) + n) : (e = -h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * m) + n) : e <= -t ? (d = Math.max(0, -(-k * h + l)), e = 0 < d ? -h : Math.min(Math.max(-h, -m), h), k = -d * d + e * (e + 2 * m) + n) : e <= t ? (d = 0, e = Math.min(Math.max(-h, -m), h), k = e * (e + 2 * m) + n) : (d = Math.max(0, -(k * h + l)), e = 0 < d ? h : Math.min(Math.max(-h, -m), h), k = -d * d + e * (e + 2 * m) + n)) : (e = 0 < k ? -h : h, d = Math.max(0, -(k * e + l)), k = -d * d + e * (e + 2 * m) + n);
			f && f.copy(this.direction).multiplyScalar(d).add(this.origin);
			g && g.copy(b).multiplyScalar(e).add(a);
			return k
		}
	}(),
	intersectSphere: function() {
		var a = new THREE.Vector3;
		return function(b,
			c) {
			a.subVectors(b.center, this.origin);
			var d = a.dot(this.direction),
				e = a.dot(a) - d * d;
			b = b.radius * b.radius;
			if (e > b) return null;
			b = Math.sqrt(b - e);
			e = d - b;
			d += b;
			return 0 > e && 0 > d ? null : 0 > e ? this.at(d, c) : this.at(e, c)
		}
	}(),
	intersectsSphere: function(a) {
		return this.distanceToPoint(a.center) <= a.radius
	},
	distanceToPlane: function(a) {
		var b = a.normal.dot(this.direction);
		if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
		a = -(this.origin.dot(a.normal) + a.constant) / b;
		return 0 <= a ? a : null
	},
	intersectPlane: function(a, b) {
		a = this.distanceToPlane(a);
		return null === a ? null : this.at(a, b)
	},
	intersectsPlane: function(a) {
		var b = a.distanceToPoint(this.origin);
		if (0 === b) return !0;
		a = a.normal.dot(this.direction);
		return 0 > a * b ? !0 : !1
	},
	intersectBox: function(a, b) {
		var c, d, e, f;
		d = 1 / this.direction.x;
		f = 1 / this.direction.y;
		var g = 1 / this.direction.z,
			h = this.origin;
		0 <= d ? (c = (a.min.x - h.x) * d, d *= a.max.x - h.x) : (c = (a.max.x - h.x) * d, d *= a.min.x - h.x);
		0 <= f ? (e = (a.min.y - h.y) * f, f *= a.max.y - h.y) : (e = (a.max.y - h.y) * f, f *= a.min.y - h.y);
		if (c > f || e > d) return null;
		if (e > c || c !== c) c = e;
		if (f < d || d !== d) d = f;
		0 <=
			g ? (e = (a.min.z - h.z) * g, a = (a.max.z - h.z) * g) : (e = (a.max.z - h.z) * g, a = (a.min.z - h.z) * g);
		if (c > a || e > d) return null;
		if (e > c || c !== c) c = e;
		if (a < d || d !== d) d = a;
		return 0 > d ? null : this.at(0 <= c ? c : d, b)
	},
	intersectsBox: function() {
		var a = new THREE.Vector3;
		return function(b) {
			return null !== this.intersectBox(b, a)
		}
	}(),
	intersectTriangle: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3,
			c = new THREE.Vector3,
			d = new THREE.Vector3;
		return function(e, f, g, h, k) {
			b.subVectors(f, e);
			c.subVectors(g, e);
			d.crossVectors(b, c);
			f = this.direction.dot(d);
			if (0 < f) {
				if (h) return null;
				h = 1
			} else if (0 > f) h = -1, f = -f;
			else return null;
			a.subVectors(this.origin, e);
			e = h * this.direction.dot(c.crossVectors(a, c));
			if (0 > e) return null;
			g = h * this.direction.dot(b.cross(a));
			if (0 > g || e + g > f) return null;
			e = -h * a.dot(d);
			return 0 > e ? null : this.at(e / f, k)
		}
	}(),
	applyMatrix4: function(a) {
		this.direction.add(this.origin).applyMatrix4(a);
		this.origin.applyMatrix4(a);
		this.direction.sub(this.origin);
		this.direction.normalize();
		return this
	},
	equals: function(a) {
		return a.origin.equals(this.origin) && a.direction.equals(this.direction)
	}
};
THREE.Sphere = function(a, b) {
	this.center = void 0 !== a ? a : new THREE.Vector3;
	this.radius = void 0 !== b ? b : 0
};
THREE.Sphere.prototype = {
	constructor: THREE.Sphere,
	set: function(a, b) {
		this.center.copy(a);
		this.radius = b;
		return this
	},
	setFromPoints: function() {
		var a = new THREE.Box3;
		return function(b, c) {
			var d = this.center;
			void 0 !== c ? d.copy(c) : a.setFromPoints(b).center(d);
			for (var e = c = 0, f = b.length; e < f; e++) c = Math.max(c, d.distanceToSquared(b[e]));
			this.radius = Math.sqrt(c);
			return this
		}
	}(),
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.center.copy(a.center);
		this.radius = a.radius;
		return this
	},
	empty: function() {
		return 0 >=
			this.radius
	},
	containsPoint: function(a) {
		return a.distanceToSquared(this.center) <= this.radius * this.radius
	},
	distanceToPoint: function(a) {
		return a.distanceTo(this.center) - this.radius
	},
	intersectsSphere: function(a) {
		var b = this.radius + a.radius;
		return a.center.distanceToSquared(this.center) <= b * b
	},
	intersectsBox: function(a) {
		return a.intersectsSphere(this)
	},
	intersectsPlane: function(a) {
		return Math.abs(this.center.dot(a.normal) - a.constant) <= this.radius
	},
	clampPoint: function(a, b) {
		var c = this.center.distanceToSquared(a);
		b = b || new THREE.Vector3;
		b.copy(a);
		c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
		return b
	},
	getBoundingBox: function(a) {
		a = a || new THREE.Box3;
		a.set(this.center, this.center);
		a.expandByScalar(this.radius);
		return a
	},
	applyMatrix4: function(a) {
		this.center.applyMatrix4(a);
		this.radius *= a.getMaxScaleOnAxis();
		return this
	},
	translate: function(a) {
		this.center.add(a);
		return this
	},
	equals: function(a) {
		return a.center.equals(this.center) && a.radius === this.radius
	}
};
THREE.Frustum = function(a, b, c, d, e, f) {
	this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== f ? f : new THREE.Plane]
};
THREE.Frustum.prototype = {
	constructor: THREE.Frustum,
	set: function(a, b, c, d, e, f) {
		var g = this.planes;
		g[0].copy(a);
		g[1].copy(b);
		g[2].copy(c);
		g[3].copy(d);
		g[4].copy(e);
		g[5].copy(f);
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
		return this
	},
	setFromMatrix: function(a) {
		var b = this.planes,
			c = a.elements;
		a = c[0];
		var d = c[1],
			e = c[2],
			f = c[3],
			g = c[4],
			h = c[5],
			k = c[6],
			l = c[7],
			m = c[8],
			n = c[9],
			r = c[10],
			t = c[11],
			u = c[12],
			w = c[13],
			v = c[14],
			c = c[15];
		b[0].setComponents(f - a, l - g, t - m, c - u).normalize();
		b[1].setComponents(f + a, l + g, t + m, c + u).normalize();
		b[2].setComponents(f + d, l + h, t + n, c + w).normalize();
		b[3].setComponents(f - d, l - h, t - n, c - w).normalize();
		b[4].setComponents(f - e, l - k, t - r, c - v).normalize();
		b[5].setComponents(f + e, l + k, t + r, c + v).normalize();
		return this
	},
	intersectsObject: function() {
		var a = new THREE.Sphere;
		return function(b) {
			var c = b.geometry;
			null === c.boundingSphere && c.computeBoundingSphere();
			a.copy(c.boundingSphere).applyMatrix4(b.matrixWorld);
			return this.intersectsSphere(a)
		}
	}(),
	intersectsSprite: function() {
		var a = new THREE.Sphere;
		return function(b) {
			a.center.set(0, 0, 0);
			a.radius = .7071067811865476;
			a.applyMatrix4(b.matrixWorld);
			return this.intersectsSphere(a)
		}
	}(),
	intersectsSphere: function(a) {
		var b = this.planes,
			c = a.center;
		a = -a.radius;
		for (var d = 0; 6 > d; d++) {
			var e = b[d].distanceToPoint(c);
			if (e < a) return !1
		}
		return !0
	},
	intersectsBox: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3;
		return function(c) {
			for (var d = this.planes, e = 0; 6 > e; e++) {
				var f = d[e];
				a.x = 0 < f.normal.x ? c.min.x : c.max.x;
				b.x =
					0 < f.normal.x ? c.max.x : c.min.x;
				a.y = 0 < f.normal.y ? c.min.y : c.max.y;
				b.y = 0 < f.normal.y ? c.max.y : c.min.y;
				a.z = 0 < f.normal.z ? c.min.z : c.max.z;
				b.z = 0 < f.normal.z ? c.max.z : c.min.z;
				var g = f.distanceToPoint(a),
					f = f.distanceToPoint(b);
				if (0 > g && 0 > f) return !1
			}
			return !0
		}
	}(),
	containsPoint: function(a) {
		for (var b = this.planes, c = 0; 6 > c; c++)
			if (0 > b[c].distanceToPoint(a)) return !1;
		return !0
	}
};
THREE.Plane = function(a, b) {
	this.normal = void 0 !== a ? a : new THREE.Vector3(1, 0, 0);
	this.constant = void 0 !== b ? b : 0
};
THREE.Plane.prototype = {
	constructor: THREE.Plane,
	set: function(a, b) {
		this.normal.copy(a);
		this.constant = b;
		return this
	},
	setComponents: function(a, b, c, d) {
		this.normal.set(a, b, c);
		this.constant = d;
		return this
	},
	setFromNormalAndCoplanarPoint: function(a, b) {
		this.normal.copy(a);
		this.constant = -b.dot(this.normal);
		return this
	},
	setFromCoplanarPoints: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3;
		return function(c, d, e) {
			d = a.subVectors(e, d).cross(b.subVectors(c, d)).normalize();
			this.setFromNormalAndCoplanarPoint(d,
				c);
			return this
		}
	}(),
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.normal.copy(a.normal);
		this.constant = a.constant;
		return this
	},
	normalize: function() {
		var a = 1 / this.normal.length();
		this.normal.multiplyScalar(a);
		this.constant *= a;
		return this
	},
	negate: function() {
		this.constant *= -1;
		this.normal.negate();
		return this
	},
	distanceToPoint: function(a) {
		return this.normal.dot(a) + this.constant
	},
	distanceToSphere: function(a) {
		return this.distanceToPoint(a.center) - a.radius
	},
	projectPoint: function(a,
		b) {
		return this.orthoPoint(a, b).sub(a).negate()
	},
	orthoPoint: function(a, b) {
		a = this.distanceToPoint(a);
		b = b || new THREE.Vector3;
		return b.copy(this.normal).multiplyScalar(a)
	},
	intersectLine: function() {
		var a = new THREE.Vector3;
		return function(b, c) {
			c = c || new THREE.Vector3;
			var d = b.delta(a),
				e = this.normal.dot(d);
			if (0 === e) {
				if (0 === this.distanceToPoint(b.start)) return c.copy(b.start)
			} else if (e = -(b.start.dot(this.normal) + this.constant) / e, !(0 > e || 1 < e)) return c.copy(d).multiplyScalar(e).add(b.start)
		}
	}(),
	intersectsLine: function(a) {
		var b =
			this.distanceToPoint(a.start);
		a = this.distanceToPoint(a.end);
		return 0 > b && 0 < a || 0 > a && 0 < b
	},
	intersectsBox: function(a) {
		return a.intersectsPlane(this)
	},
	intersectsSphere: function(a) {
		return a.intersectsPlane(this)
	},
	coplanarPoint: function(a) {
		a = a || new THREE.Vector3;
		return a.copy(this.normal).multiplyScalar(-this.constant)
	},
	applyMatrix4: function() {
		var a = new THREE.Vector3,
			b = new THREE.Matrix3;
		return function(c, d) {
			var e = this.coplanarPoint(a).applyMatrix4(c);
			c = d || b.getNormalMatrix(c);
			c = this.normal.applyMatrix3(c).normalize();
			this.constant = -e.dot(c);
			return this
		}
	}(),
	translate: function(a) {
		this.constant -= a.dot(this.normal);
		return this
	},
	equals: function(a) {
		return a.normal.equals(this.normal) && a.constant === this.constant
	}
};
THREE.Spherical = function(a, b, c) {
	this.radius = void 0 !== a ? a : 1;
	this.phi = void 0 !== b ? b : 0;
	this.theta = void 0 !== c ? c : 0;
	return this
};
THREE.Spherical.prototype = {
	constructor: THREE.Spherical,
	set: function(a, b, c) {
		this.radius = a;
		this.phi = b;
		this.theta = c;
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.radius.copy(a.radius);
		this.phi.copy(a.phi);
		this.theta.copy(a.theta);
		return this
	},
	makeSafe: function() {
		this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
		return this
	},
	setFromVector3: function(a) {
		this.radius = a.length();
		0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a.x, a.z), this.phi =
			Math.acos(THREE.Math.clamp(a.y / this.radius, -1, 1)));
		return this
	}
};
THREE.Math = {
	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,
	generateUUID: function() {
		var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
			b = Array(36),
			c = 0,
			d;
		return function() {
			for (var e = 0; 36 > e; e++) 8 === e || 13 === e || 18 === e || 23 === e ? b[e] = "-" : 14 === e ? b[e] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0), d = c & 15, c >>= 4, b[e] = a[19 === e ? d & 3 | 8 : d]);
			return b.join("")
		}
	}(),
	clamp: function(a, b, c) {
		return Math.max(b, Math.min(c, a))
	},
	euclideanModulo: function(a, b) {
		return (a % b + b) % b
	},
	mapLinear: function(a, b, c,
		d, e) {
		return d + (a - b) * (e - d) / (c - b)
	},
	smoothstep: function(a, b, c) {
		if (a <= b) return 0;
		if (a >= c) return 1;
		a = (a - b) / (c - b);
		return a * a * (3 - 2 * a)
	},
	smootherstep: function(a, b, c) {
		if (a <= b) return 0;
		if (a >= c) return 1;
		a = (a - b) / (c - b);
		return a * a * a * (a * (6 * a - 15) + 10)
	},
	random16: function() {
		console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead.");
		return Math.random()
	},
	randInt: function(a, b) {
		return a + Math.floor(Math.random() * (b - a + 1))
	},
	randFloat: function(a, b) {
		return a + Math.random() * (b - a)
	},
	randFloatSpread: function(a) {
		return a *
			(.5 - Math.random())
	},
	degToRad: function(a) {
		return a * THREE.Math.DEG2RAD
	},
	radToDeg: function(a) {
		return a * THREE.Math.RAD2DEG
	},
	isPowerOfTwo: function(a) {
		return 0 === (a & a - 1) && 0 !== a
	},
	nearestPowerOfTwo: function(a) {
		return Math.pow(2, Math.round(Math.log(a) / Math.LN2))
	},
	nextPowerOfTwo: function(a) {
		a--;
		a |= a >> 1;
		a |= a >> 2;
		a |= a >> 4;
		a |= a >> 8;
		a |= a >> 16;
		a++;
		return a
	}
};
THREE.Spline = function(a) {
	function b(a, b, c, d, e, f, g) {
		a = .5 * (c - a);
		d = .5 * (d - b);
		return (2 * (b - c) + a + d) * g + (-3 * (b - c) - 2 * a - d) * f + a * e + b
	}
	this.points = a;
	var c = [],
		d = {
			x: 0,
			y: 0,
			z: 0
		},
		e, f, g, h, k, l, m, n, r;
	this.initFromArray = function(a) {
		this.points = [];
		for (var b = 0; b < a.length; b++) this.points[b] = {
			x: a[b][0],
			y: a[b][1],
			z: a[b][2]
		}
	};
	this.getPoint = function(a) {
		e = (this.points.length - 1) * a;
		f = Math.floor(e);
		g = e - f;
		c[0] = 0 === f ? f : f - 1;
		c[1] = f;
		c[2] = f > this.points.length - 2 ? this.points.length - 1 : f + 1;
		c[3] = f > this.points.length - 3 ? this.points.length - 1 : f +
			2;
		l = this.points[c[0]];
		m = this.points[c[1]];
		n = this.points[c[2]];
		r = this.points[c[3]];
		h = g * g;
		k = g * h;
		d.x = b(l.x, m.x, n.x, r.x, g, h, k);
		d.y = b(l.y, m.y, n.y, r.y, g, h, k);
		d.z = b(l.z, m.z, n.z, r.z, g, h, k);
		return d
	};
	this.getControlPointsArray = function() {
		var a, b, c = this.points.length,
			d = [];
		for (a = 0; a < c; a++) b = this.points[a], d[a] = [b.x, b.y, b.z];
		return d
	};
	this.getLength = function(a) {
		var b, c, d, e = b = b = 0,
			f = new THREE.Vector3,
			g = new THREE.Vector3,
			h = [],
			k = 0;
		h[0] = 0;
		a || (a = 100);
		c = this.points.length * a;
		f.copy(this.points[0]);
		for (a = 1; a < c; a++) b =
			a / c, d = this.getPoint(b), g.copy(d), k += g.distanceTo(f), f.copy(d), b *= this.points.length - 1, b = Math.floor(b), b !== e && (h[b] = k, e = b);
		h[h.length] = k;
		return {
			chunks: h,
			total: k
		}
	};
	this.reparametrizeByArcLength = function(a) {
		var b, c, d, e, f, g, h = [],
			k = new THREE.Vector3,
			l = this.getLength();
		h.push(k.copy(this.points[0]).clone());
		for (b = 1; b < this.points.length; b++) {
			c = l.chunks[b] - l.chunks[b - 1];
			g = Math.ceil(a * c / l.total);
			e = (b - 1) / (this.points.length - 1);
			f = b / (this.points.length - 1);
			for (c = 1; c < g - 1; c++) d = e + 1 / g * c * (f - e), d = this.getPoint(d),
				h.push(k.copy(d).clone());
			h.push(k.copy(this.points[b]).clone())
		}
		this.points = h
	}
};
THREE.Triangle = function(a, b, c) {
	this.a = void 0 !== a ? a : new THREE.Vector3;
	this.b = void 0 !== b ? b : new THREE.Vector3;
	this.c = void 0 !== c ? c : new THREE.Vector3
};
THREE.Triangle.normal = function() {
	var a = new THREE.Vector3;
	return function(b, c, d, e) {
		e = e || new THREE.Vector3;
		e.subVectors(d, c);
		a.subVectors(b, c);
		e.cross(a);
		b = e.lengthSq();
		return 0 < b ? e.multiplyScalar(1 / Math.sqrt(b)) : e.set(0, 0, 0)
	}
}();
THREE.Triangle.barycoordFromPoint = function() {
	var a = new THREE.Vector3,
		b = new THREE.Vector3,
		c = new THREE.Vector3;
	return function(d, e, f, g, h) {
		a.subVectors(g, e);
		b.subVectors(f, e);
		c.subVectors(d, e);
		d = a.dot(a);
		e = a.dot(b);
		f = a.dot(c);
		var k = b.dot(b);
		g = b.dot(c);
		var l = d * k - e * e;
		h = h || new THREE.Vector3;
		if (0 === l) return h.set(-2, -1, -1);
		l = 1 / l;
		k = (k * f - e * g) * l;
		d = (d * g - e * f) * l;
		return h.set(1 - k - d, d, k)
	}
}();
THREE.Triangle.containsPoint = function() {
	var a = new THREE.Vector3;
	return function(b, c, d, e) {
		b = THREE.Triangle.barycoordFromPoint(b, c, d, e, a);
		return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
	}
}();
THREE.Triangle.prototype = {
	constructor: THREE.Triangle,
	set: function(a, b, c) {
		this.a.copy(a);
		this.b.copy(b);
		this.c.copy(c);
		return this
	},
	setFromPointsAndIndices: function(a, b, c, d) {
		this.a.copy(a[b]);
		this.b.copy(a[c]);
		this.c.copy(a[d]);
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.a.copy(a.a);
		this.b.copy(a.b);
		this.c.copy(a.c);
		return this
	},
	area: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3;
		return function() {
			a.subVectors(this.c, this.b);
			b.subVectors(this.a,
				this.b);
			return .5 * a.cross(b).length()
		}
	}(),
	midpoint: function(a) {
		a = a || new THREE.Vector3;
		return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
	},
	normal: function(a) {
		return THREE.Triangle.normal(this.a, this.b, this.c, a)
	},
	plane: function(a) {
		a = a || new THREE.Plane;
		return a.setFromCoplanarPoints(this.a, this.b, this.c)
	},
	barycoordFromPoint: function(a, b) {
		return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
	},
	containsPoint: function(a) {
		return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
	},
	closestPointToPoint: function() {
		var a, b, c, d;
		return function f(g, h) {
			void 0 === a && (a = new THREE.Plane, b = [new THREE.Line3, new THREE.Line3, new THREE.Line3], c = new THREE.Vector3, d = new THREE.Vector3);
			h = h || new THREE.Vector3;
			var k = Infinity;
			a.setFromCoplanarPoints(this.a, this.b, this.c);
			a.projectPoint(g, c);
			if (!0 === this.containsPoint(c)) h.copy(c);
			else
				for (b[0].set(this.a, this.b), b[1].set(this.b, this.c), b[2].set(this.c, this.a), g = 0; g < b.length; g++) {
					b[g].closestPointToPoint(c, !0, d);
					var l = c.distanceToSquared(d);
					l < k &&
						(k = l, h.copy(d))
				}
			return h
		}
	}(),
	equals: function(a) {
		return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
	}
};
THREE.Interpolant = function(a, b, c, d) {
	this.parameterPositions = a;
	this._cachedIndex = 0;
	this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
	this.sampleValues = b;
	this.valueSize = c
};
THREE.Interpolant.prototype = {
	constructor: THREE.Interpolant,
	evaluate: function(a) {
		var b = this.parameterPositions,
			c = this._cachedIndex,
			d = b[c],
			e = b[c - 1];
		a: {
			b: {
				c: {
					d: if (!(a < d)) {
						for (var f = c + 2;;) {
							if (void 0 === d) {
								if (a < e) break d;
								this._cachedIndex = c = b.length;
								return this.afterEnd_(c - 1, a, e)
							}
							if (c === f) break;
							e = d;
							d = b[++c];
							if (a < d) break b
						}
						d = b.length;
						break c
					}if (a >= e) break a;
					else {
						f = b[1];
						a < f && (c = 2, e = f);
						for (f = c - 2;;) {
							if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
							if (c === f) break;
							d = e;
							e = b[--c - 1];
							if (a >= e) break b
						}
						d =
							c;
						c = 0
					}
				}
				for (; c < d;) e = c + d >>> 1,
				a < b[e] ? d = e : c = e + 1;d = b[c];e = b[c - 1];
				if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
				if (void 0 === d) return this._cachedIndex = c = b.length, this.afterEnd_(c - 1, e, a)
			}
			this._cachedIndex = c;this.intervalChanged_(c, e, d)
		}
		return this.interpolate_(c, e, a, d)
	},
	settings: null,
	DefaultSettings_: {},
	getSettings_: function() {
		return this.settings || this.DefaultSettings_
	},
	copySampleValue_: function(a) {
		var b = this.resultBuffer,
			c = this.sampleValues,
			d = this.valueSize;
		a *= d;
		for (var e = 0; e !== d; ++e) b[e] =
			c[a + e];
		return b
	},
	interpolate_: function(a, b, c, d) {
		throw Error("call to abstract method");
	},
	intervalChanged_: function(a, b, c) {}
};
Object.assign(THREE.Interpolant.prototype, {
	beforeStart_: THREE.Interpolant.prototype.copySampleValue_,
	afterEnd_: THREE.Interpolant.prototype.copySampleValue_
});
THREE.CubicInterpolant = function(a, b, c, d) {
	THREE.Interpolant.call(this, a, b, c, d);
	this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
};
THREE.CubicInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
	constructor: THREE.CubicInterpolant,
	DefaultSettings_: {
		endingStart: THREE.ZeroCurvatureEnding,
		endingEnd: THREE.ZeroCurvatureEnding
	},
	intervalChanged_: function(a, b, c) {
		var d = this.parameterPositions,
			e = a - 2,
			f = a + 1,
			g = d[e],
			h = d[f];
		if (void 0 === g) switch (this.getSettings_().endingStart) {
			case THREE.ZeroSlopeEnding:
				e = a;
				g = 2 * b - c;
				break;
			case THREE.WrapAroundEnding:
				e = d.length - 2;
				g = b + d[e] - d[e + 1];
				break;
			default:
				e = a, g = c
		}
		if (void 0 === h) switch (this.getSettings_().endingEnd) {
			case THREE.ZeroSlopeEnding:
				f =
					a;
				h = 2 * c - b;
				break;
			case THREE.WrapAroundEnding:
				f = 1;
				h = c + d[1] - d[0];
				break;
			default:
				f = a - 1, h = b
		}
		a = .5 * (c - b);
		d = this.valueSize;
		this._weightPrev = a / (b - g);
		this._weightNext = a / (h - c);
		this._offsetPrev = e * d;
		this._offsetNext = f * d
	},
	interpolate_: function(a, b, c, d) {
		var e = this.resultBuffer,
			f = this.sampleValues,
			g = this.valueSize;
		a *= g;
		var h = a - g,
			k = this._offsetPrev,
			l = this._offsetNext,
			m = this._weightPrev,
			n = this._weightNext,
			r = (c - b) / (d - b);
		c = r * r;
		d = c * r;
		b = -m * d + 2 * m * c - m * r;
		m = (1 + m) * d + (-1.5 - 2 * m) * c + (-.5 + m) * r + 1;
		r = (-1 - n) * d + (1.5 + n) * c + .5 * r;
		n = n * d - n *
			c;
		for (c = 0; c !== g; ++c) e[c] = b * f[k + c] + m * f[h + c] + r * f[a + c] + n * f[l + c];
		return e
	}
});
THREE.DiscreteInterpolant = function(a, b, c, d) {
	THREE.Interpolant.call(this, a, b, c, d)
};
THREE.DiscreteInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
	constructor: THREE.DiscreteInterpolant,
	interpolate_: function(a, b, c, d) {
		return this.copySampleValue_(a - 1)
	}
});
THREE.LinearInterpolant = function(a, b, c, d) {
	THREE.Interpolant.call(this, a, b, c, d)
};
THREE.LinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
	constructor: THREE.LinearInterpolant,
	interpolate_: function(a, b, c, d) {
		var e = this.resultBuffer,
			f = this.sampleValues,
			g = this.valueSize;
		a *= g;
		var h = a - g;
		b = (c - b) / (d - b);
		c = 1 - b;
		for (d = 0; d !== g; ++d) e[d] = f[h + d] * c + f[a + d] * b;
		return e
	}
});
THREE.QuaternionLinearInterpolant = function(a, b, c, d) {
	THREE.Interpolant.call(this, a, b, c, d)
};
THREE.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
	constructor: THREE.QuaternionLinearInterpolant,
	interpolate_: function(a, b, c, d) {
		var e = this.resultBuffer,
			f = this.sampleValues,
			g = this.valueSize;
		a *= g;
		b = (c - b) / (d - b);
		for (c = a + g; a !== c; a += 4) THREE.Quaternion.slerpFlat(e, 0, f, a - g, f, a, b);
		return e
	}
});
THREE.Clock = function(a) {
	this.autoStart = void 0 !== a ? a : !0;
	this.elapsedTime = this.oldTime = this.startTime = 0;
	this.running = !1
};
THREE.Clock.prototype = {
	constructor: THREE.Clock,
	start: function() {
		this.oldTime = this.startTime = (performance || Date).now();
		this.running = !0
	},
	stop: function() {
		this.getElapsedTime();
		this.running = !1
	},
	getElapsedTime: function() {
		this.getDelta();
		return this.elapsedTime
	},
	getDelta: function() {
		var a = 0;
		this.autoStart && !this.running && this.start();
		if (this.running) {
			var b = (performance || Date).now(),
				a = (b - this.oldTime) / 1E3;
			this.oldTime = b;
			this.elapsedTime += a
		}
		return a
	}
};
THREE.EventDispatcher = function() {};
Object.assign(THREE.EventDispatcher.prototype, {
	addEventListener: function(a, b) {
		void 0 === this._listeners && (this._listeners = {});
		var c = this._listeners;
		void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) && c[a].push(b)
	},
	hasEventListener: function(a, b) {
		if (void 0 === this._listeners) return !1;
		var c = this._listeners;
		return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1
	},
	removeEventListener: function(a, b) {
		if (void 0 !== this._listeners) {
			var c = this._listeners;
			a = c[a];
			void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b, 1))
		}
	},
	dispatchEvent: function(a) {
		if (void 0 !==
			this._listeners) {
			var b = this._listeners,
				b = b[a.type];
			if (void 0 !== b) {
				a.target = this;
				for (var c = [], d = 0, e = b.length, d = 0; d < e; d++) c[d] = b[d];
				for (d = 0; d < e; d++) c[d].call(this, a)
			}
		}
	}
});
THREE.Layers = function() {
	this.mask = 1
};
THREE.Layers.prototype = {
	constructor: THREE.Layers,
	set: function(a) {
		this.mask = 1 << a
	},
	enable: function(a) {
		this.mask |= 1 << a
	},
	toggle: function(a) {
		this.mask ^= 1 << a
	},
	disable: function(a) {
		this.mask &= ~(1 << a)
	},
	test: function(a) {
		return 0 !== (this.mask & a.mask)
	}
};
(function(a) {
	function b(a, b) {
		return a.distance - b.distance
	}

	function c(a, b, f, g) {
		if (!1 !== a.visible && (a.raycast(b, f), !0 === g)) {
			a = a.children;
			g = 0;
			for (var d = a.length; g < d; g++) c(a[g], b, f, !0)
		}
	}
	a.Raycaster = function(b, c, f, g) {
		this.ray = new a.Ray(b, c);
		this.near = f || 0;
		this.far = g || Infinity;
		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: {
				threshold: 1
			},
			Sprite: {}
		};
		Object.defineProperties(this.params, {
			PointCloud: {
				get: function() {
					console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
					return this.Points
				}
			}
		})
	};
	a.Raycaster.prototype = {
		constructor: a.Raycaster,
		linePrecision: 1,
		set: function(a, b) {
			this.ray.set(a, b)
		},
		setFromCamera: function(b, c) {
			c instanceof a.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(c.matrixWorld), this.ray.direction.set(b.x, b.y, .5).unproject(c).sub(this.ray.origin).normalize()) : c instanceof a.OrthographicCamera ? (this.ray.origin.set(b.x, b.y, -1).unproject(c), this.ray.direction.set(0, 0, -1).transformDirection(c.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
		},
		intersectObject: function(a, e) {
			var d = [];
			c(a, this, d, e);
			d.sort(b);
			return d
		},
		intersectObjects: function(a, e) {
			var d = [];
			if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), d;
			for (var g = 0, h = a.length; g < h; g++) c(a[g], this, d, e);
			d.sort(b);
			return d
		}
	}
})(THREE);
THREE.Object3D = function() {
	function a() {
		e.setFromEuler(d, !1)
	}

	function b() {
		d.setFromQuaternion(e, void 0, !1)
	}
	Object.defineProperty(this, "id", {
		value: THREE.Object3DIdCount++
	});
	this.uuid = THREE.Math.generateUUID();
	this.name = "";
	this.type = "Object3D";
	this.parent = null;
	this.children = [];
	this.up = THREE.Object3D.DefaultUp.clone();
	var c = new THREE.Vector3,
		d = new THREE.Euler,
		e = new THREE.Quaternion,
		f = new THREE.Vector3(1, 1, 1);
	d.onChange(a);
	e.onChange(b);
	Object.defineProperties(this, {
		position: {
			enumerable: !0,
			value: c
		},
		rotation: {
			enumerable: !0,
			value: d
		},
		quaternion: {
			enumerable: !0,
			value: e
		},
		scale: {
			enumerable: !0,
			value: f
		},
		modelViewMatrix: {
			value: new THREE.Matrix4
		},
		normalMatrix: {
			value: new THREE.Matrix3
		}
	});
	this.matrix = new THREE.Matrix4;
	this.matrixWorld = new THREE.Matrix4;
	this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = !1;
	this.layers = new THREE.Layers;
	this.visible = !0;
	this.receiveShadow = this.castShadow = !1;
	this.frustumCulled = !0;
	this.renderOrder = 0;
	this.userData = {}
};
THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0);
THREE.Object3D.DefaultMatrixAutoUpdate = !0;
Object.assign(THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {
	applyMatrix: function(a) {
		this.matrix.multiplyMatrices(a, this.matrix);
		this.matrix.decompose(this.position, this.quaternion, this.scale)
	},
	setRotationFromAxisAngle: function(a, b) {
		this.quaternion.setFromAxisAngle(a, b)
	},
	setRotationFromEuler: function(a) {
		this.quaternion.setFromEuler(a, !0)
	},
	setRotationFromMatrix: function(a) {
		this.quaternion.setFromRotationMatrix(a)
	},
	setRotationFromQuaternion: function(a) {
		this.quaternion.copy(a)
	},
	rotateOnAxis: function() {
		var a =
			new THREE.Quaternion;
		return function(b, c) {
			a.setFromAxisAngle(b, c);
			this.quaternion.multiply(a);
			return this
		}
	}(),
	rotateX: function() {
		var a = new THREE.Vector3(1, 0, 0);
		return function(b) {
			return this.rotateOnAxis(a, b)
		}
	}(),
	rotateY: function() {
		var a = new THREE.Vector3(0, 1, 0);
		return function(b) {
			return this.rotateOnAxis(a, b)
		}
	}(),
	rotateZ: function() {
		var a = new THREE.Vector3(0, 0, 1);
		return function(b) {
			return this.rotateOnAxis(a, b)
		}
	}(),
	translateOnAxis: function() {
		var a = new THREE.Vector3;
		return function(b, c) {
			a.copy(b).applyQuaternion(this.quaternion);
			this.position.add(a.multiplyScalar(c));
			return this
		}
	}(),
	translateX: function() {
		var a = new THREE.Vector3(1, 0, 0);
		return function(b) {
			return this.translateOnAxis(a, b)
		}
	}(),
	translateY: function() {
		var a = new THREE.Vector3(0, 1, 0);
		return function(b) {
			return this.translateOnAxis(a, b)
		}
	}(),
	translateZ: function() {
		var a = new THREE.Vector3(0, 0, 1);
		return function(b) {
			return this.translateOnAxis(a, b)
		}
	}(),
	localToWorld: function(a) {
		return a.applyMatrix4(this.matrixWorld)
	},
	worldToLocal: function() {
		var a = new THREE.Matrix4;
		return function(b) {
			return b.applyMatrix4(a.getInverse(this.matrixWorld))
		}
	}(),
	lookAt: function() {
		var a = new THREE.Matrix4;
		return function(b) {
			a.lookAt(b, this.position, this.up);
			this.quaternion.setFromRotationMatrix(a)
		}
	}(),
	add: function(a) {
		if (1 < arguments.length) {
			for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
			return this
		}
		if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.", a), this;
		a instanceof THREE.Object3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, a.dispatchEvent({
			type: "added"
		}), this.children.push(a)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",
			a);
		return this
	},
	remove: function(a) {
		if (1 < arguments.length)
			for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
		b = this.children.indexOf(a); - 1 !== b && (a.parent = null, a.dispatchEvent({
			type: "removed"
		}), this.children.splice(b, 1))
	},
	getObjectById: function(a) {
		return this.getObjectByProperty("id", a)
	},
	getObjectByName: function(a) {
		return this.getObjectByProperty("name", a)
	},
	getObjectByProperty: function(a, b) {
		if (this[a] === b) return this;
		for (var c = 0, d = this.children.length; c < d; c++) {
			var e = this.children[c],
				e = e.getObjectByProperty(a,
					b);
			if (void 0 !== e) return e
		}
	},
	getWorldPosition: function(a) {
		a = a || new THREE.Vector3;
		this.updateMatrixWorld(!0);
		return a.setFromMatrixPosition(this.matrixWorld)
	},
	getWorldQuaternion: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3;
		return function(c) {
			c = c || new THREE.Quaternion;
			this.updateMatrixWorld(!0);
			this.matrixWorld.decompose(a, c, b);
			return c
		}
	}(),
	getWorldRotation: function() {
		var a = new THREE.Quaternion;
		return function(b) {
			b = b || new THREE.Euler;
			this.getWorldQuaternion(a);
			return b.setFromQuaternion(a,
				this.rotation.order, !1)
		}
	}(),
	getWorldScale: function() {
		var a = new THREE.Vector3,
			b = new THREE.Quaternion;
		return function(c) {
			c = c || new THREE.Vector3;
			this.updateMatrixWorld(!0);
			this.matrixWorld.decompose(a, b, c);
			return c
		}
	}(),
	getWorldDirection: function() {
		var a = new THREE.Quaternion;
		return function(b) {
			b = b || new THREE.Vector3;
			this.getWorldQuaternion(a);
			return b.set(0, 0, 1).applyQuaternion(a)
		}
	}(),
	raycast: function() {},
	traverse: function(a) {
		a(this);
		for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
	},
	traverseVisible: function(a) {
		if (!1 !==
			this.visible) {
			a(this);
			for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
		}
	},
	traverseAncestors: function(a) {
		var b = this.parent;
		null !== b && (a(b), b.traverseAncestors(a))
	},
	updateMatrix: function() {
		this.matrix.compose(this.position, this.quaternion, this.scale);
		this.matrixWorldNeedsUpdate = !0
	},
	updateMatrixWorld: function(a) {
		!0 === this.matrixAutoUpdate && this.updateMatrix();
		if (!0 === this.matrixWorldNeedsUpdate || !0 === a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,
			this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
		for (var b = 0, c = this.children.length; b < c; b++) this.children[b].updateMatrixWorld(a)
	},
	toJSON: function(a) {
		function b(a) {
			var b = [],
				c;
			for (c in a) {
				var d = a[c];
				delete d.metadata;
				b.push(d)
			}
			return b
		}
		var c = void 0 === a || "" === a,
			d = {};
		c && (a = {
			geometries: {},
			materials: {},
			textures: {},
			images: {}
		}, d.metadata = {
			version: 4.4,
			type: "Object",
			generator: "Object3D.toJSON"
		});
		var e = {};
		e.uuid = this.uuid;
		e.type = this.type;
		"" !== this.name && (e.name = this.name);
		"{}" !== JSON.stringify(this.userData) &&
			(e.userData = this.userData);
		!0 === this.castShadow && (e.castShadow = !0);
		!0 === this.receiveShadow && (e.receiveShadow = !0);
		!1 === this.visible && (e.visible = !1);
		e.matrix = this.matrix.toArray();
		void 0 !== this.geometry && (void 0 === a.geometries[this.geometry.uuid] && (a.geometries[this.geometry.uuid] = this.geometry.toJSON(a)), e.geometry = this.geometry.uuid);
		void 0 !== this.material && (void 0 === a.materials[this.material.uuid] && (a.materials[this.material.uuid] = this.material.toJSON(a)), e.material = this.material.uuid);
		if (0 < this.children.length) {
			e.children = [];
			for (var f = 0; f < this.children.length; f++) e.children.push(this.children[f].toJSON(a).object)
		}
		if (c) {
			var c = b(a.geometries),
				f = b(a.materials),
				g = b(a.textures);
			a = b(a.images);
			0 < c.length && (d.geometries = c);
			0 < f.length && (d.materials = f);
			0 < g.length && (d.textures = g);
			0 < a.length && (d.images = a)
		}
		d.object = e;
		return d
	},
	clone: function(a) {
		return (new this.constructor).copy(this, a)
	},
	copy: function(a, b) {
		void 0 === b && (b = !0);
		this.name = a.name;
		this.up.copy(a.up);
		this.position.copy(a.position);
		this.quaternion.copy(a.quaternion);
		this.scale.copy(a.scale);
		this.matrix.copy(a.matrix);
		this.matrixWorld.copy(a.matrixWorld);
		this.matrixAutoUpdate = a.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
		this.visible = a.visible;
		this.castShadow = a.castShadow;
		this.receiveShadow = a.receiveShadow;
		this.frustumCulled = a.frustumCulled;
		this.renderOrder = a.renderOrder;
		this.userData = JSON.parse(JSON.stringify(a.userData));
		if (!0 === b)
			for (b = 0; b < a.children.length; b++) {
				var c = a.children[b];
				this.add(c.clone())
			}
		return this
	}
});
THREE.Object3DIdCount = 0;
THREE.Face3 = function(a, b, c, d, e, f) {
	this.a = a;
	this.b = b;
	this.c = c;
	this.normal = d instanceof THREE.Vector3 ? d : new THREE.Vector3;
	this.vertexNormals = Array.isArray(d) ? d : [];
	this.color = e instanceof THREE.Color ? e : new THREE.Color;
	this.vertexColors = Array.isArray(e) ? e : [];
	this.materialIndex = void 0 !== f ? f : 0
};
THREE.Face3.prototype = {
	constructor: THREE.Face3,
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.a = a.a;
		this.b = a.b;
		this.c = a.c;
		this.normal.copy(a.normal);
		this.color.copy(a.color);
		this.materialIndex = a.materialIndex;
		for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
		b = 0;
		for (c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
		return this
	}
};
THREE.BufferAttribute = function(a, b, c) {
	this.uuid = THREE.Math.generateUUID();
	this.array = a;
	this.itemSize = b;
	this.dynamic = !1;
	this.updateRange = {
		offset: 0,
		count: -1
	};
	this.version = 0;
	this.normalized = !0 === c
};
THREE.BufferAttribute.prototype = {
	constructor: THREE.BufferAttribute,
	get count() {
		return this.array.length / this.itemSize
	},
	set needsUpdate(a) {
		!0 === a && this.version++
	},
	setDynamic: function(a) {
		this.dynamic = a;
		return this
	},
	copy: function(a) {
		this.array = new a.array.constructor(a.array);
		this.itemSize = a.itemSize;
		this.dynamic = a.dynamic;
		return this
	},
	copyAt: function(a, b, c) {
		a *= this.itemSize;
		c *= b.itemSize;
		for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
		return this
	},
	copyArray: function(a) {
		this.array.set(a);
		return this
	},
	copyColorsArray: function(a) {
		for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
			var f = a[d];
			void 0 === f && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", d), f = new THREE.Color);
			b[c++] = f.r;
			b[c++] = f.g;
			b[c++] = f.b
		}
		return this
	},
	copyIndicesArray: function(a) {
		for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
			var f = a[d];
			b[c++] = f.a;
			b[c++] = f.b;
			b[c++] = f.c
		}
		return this
	},
	copyVector2sArray: function(a) {
		for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
			var f = a[d];
			void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
				d), f = new THREE.Vector2);
			b[c++] = f.x;
			b[c++] = f.y
		}
		return this
	},
	copyVector3sArray: function(a) {
		for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
			var f = a[d];
			void 0 === f && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), f = new THREE.Vector3);
			b[c++] = f.x;
			b[c++] = f.y;
			b[c++] = f.z
		}
		return this
	},
	copyVector4sArray: function(a) {
		for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
			var f = a[d];
			void 0 === f && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), f = new THREE.Vector4);
			b[c++] = f.x;
			b[c++] = f.y;
			b[c++] = f.z;
			b[c++] = f.w
		}
		return this
	},
	set: function(a, b) {
		void 0 === b && (b = 0);
		this.array.set(a, b);
		return this
	},
	getX: function(a) {
		return this.array[a * this.itemSize]
	},
	setX: function(a, b) {
		this.array[a * this.itemSize] = b;
		return this
	},
	getY: function(a) {
		return this.array[a * this.itemSize + 1]
	},
	setY: function(a, b) {
		this.array[a * this.itemSize + 1] = b;
		return this
	},
	getZ: function(a) {
		return this.array[a * this.itemSize + 2]
	},
	setZ: function(a, b) {
		this.array[a * this.itemSize + 2] = b;
		return this
	},
	getW: function(a) {
		return this.array[a *
			this.itemSize + 3]
	},
	setW: function(a, b) {
		this.array[a * this.itemSize + 3] = b;
		return this
	},
	setXY: function(a, b, c) {
		a *= this.itemSize;
		this.array[a + 0] = b;
		this.array[a + 1] = c;
		return this
	},
	setXYZ: function(a, b, c, d) {
		a *= this.itemSize;
		this.array[a + 0] = b;
		this.array[a + 1] = c;
		this.array[a + 2] = d;
		return this
	},
	setXYZW: function(a, b, c, d, e) {
		a *= this.itemSize;
		this.array[a + 0] = b;
		this.array[a + 1] = c;
		this.array[a + 2] = d;
		this.array[a + 3] = e;
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	}
};
THREE.Int8Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Int8Array(a), b)
};
THREE.Uint8Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Uint8Array(a), b)
};
THREE.Uint8ClampedAttribute = function(a, b) {
	return new THREE.BufferAttribute(new Uint8ClampedArray(a), b)
};
THREE.Int16Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Int16Array(a), b)
};
THREE.Uint16Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Uint16Array(a), b)
};
THREE.Int32Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Int32Array(a), b)
};
THREE.Uint32Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Uint32Array(a), b)
};
THREE.Float32Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Float32Array(a), b)
};
THREE.Float64Attribute = function(a, b) {
	return new THREE.BufferAttribute(new Float64Array(a), b)
};
THREE.DynamicBufferAttribute = function(a, b) {
	console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.");
	return (new THREE.BufferAttribute(a, b)).setDynamic(!0)
};
THREE.InstancedBufferAttribute = function(a, b, c) {
	THREE.BufferAttribute.call(this, a, b);
	this.meshPerAttribute = c || 1
};
THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype);
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;
THREE.InstancedBufferAttribute.prototype.copy = function(a) {
	THREE.BufferAttribute.prototype.copy.call(this, a);
	this.meshPerAttribute = a.meshPerAttribute;
	return this
};
THREE.InterleavedBuffer = function(a, b) {
	this.uuid = THREE.Math.generateUUID();
	this.array = a;
	this.stride = b;
	this.dynamic = !1;
	this.updateRange = {
		offset: 0,
		count: -1
	};
	this.version = 0
};
THREE.InterleavedBuffer.prototype = {
	constructor: THREE.InterleavedBuffer,
	get length() {
		return this.array.length
	},
	get count() {
		return this.array.length / this.stride
	},
	set needsUpdate(a) {
		!0 === a && this.version++
	},
	setDynamic: function(a) {
		this.dynamic = a;
		return this
	},
	copy: function(a) {
		this.array = new a.array.constructor(a.array);
		this.stride = a.stride;
		this.dynamic = a.dynamic;
		return this
	},
	copyAt: function(a, b, c) {
		a *= this.stride;
		c *= b.stride;
		for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
		return this
	},
	set: function(a,
		b) {
		void 0 === b && (b = 0);
		this.array.set(a, b);
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	}
};
THREE.InstancedInterleavedBuffer = function(a, b, c) {
	THREE.InterleavedBuffer.call(this, a, b);
	this.meshPerAttribute = c || 1
};
THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype);
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;
THREE.InstancedInterleavedBuffer.prototype.copy = function(a) {
	THREE.InterleavedBuffer.prototype.copy.call(this, a);
	this.meshPerAttribute = a.meshPerAttribute;
	return this
};
THREE.InterleavedBufferAttribute = function(a, b, c) {
	this.uuid = THREE.Math.generateUUID();
	this.data = a;
	this.itemSize = b;
	this.offset = c
};
THREE.InterleavedBufferAttribute.prototype = {
	constructor: THREE.InterleavedBufferAttribute,
	get length() {
		console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count.");
		return this.array.length
	},
	get count() {
		return this.data.count
	},
	setX: function(a, b) {
		this.data.array[a * this.data.stride + this.offset] = b;
		return this
	},
	setY: function(a, b) {
		this.data.array[a * this.data.stride + this.offset + 1] = b;
		return this
	},
	setZ: function(a, b) {
		this.data.array[a * this.data.stride + this.offset + 2] = b;
		return this
	},
	setW: function(a, b) {
		this.data.array[a * this.data.stride + this.offset + 3] = b;
		return this
	},
	getX: function(a) {
		return this.data.array[a * this.data.stride + this.offset]
	},
	getY: function(a) {
		return this.data.array[a * this.data.stride + this.offset + 1]
	},
	getZ: function(a) {
		return this.data.array[a * this.data.stride + this.offset + 2]
	},
	getW: function(a) {
		return this.data.array[a * this.data.stride + this.offset + 3]
	},
	setXY: function(a, b, c) {
		a = a * this.data.stride + this.offset;
		this.data.array[a + 0] = b;
		this.data.array[a + 1] = c;
		return this
	},
	setXYZ: function(a,
		b, c, d) {
		a = a * this.data.stride + this.offset;
		this.data.array[a + 0] = b;
		this.data.array[a + 1] = c;
		this.data.array[a + 2] = d;
		return this
	},
	setXYZW: function(a, b, c, d, e) {
		a = a * this.data.stride + this.offset;
		this.data.array[a + 0] = b;
		this.data.array[a + 1] = c;
		this.data.array[a + 2] = d;
		this.data.array[a + 3] = e;
		return this
	}
};
THREE.Geometry = function() {
	Object.defineProperty(this, "id", {
		value: THREE.GeometryIdCount++
	});
	this.uuid = THREE.Math.generateUUID();
	this.name = "";
	this.type = "Geometry";
	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [
		[]
	];
	this.morphTargets = [];
	this.morphNormals = [];
	this.skinWeights = [];
	this.skinIndices = [];
	this.lineDistances = [];
	this.boundingSphere = this.boundingBox = null;
	this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate =
		this.verticesNeedUpdate = !1
};
Object.assign(THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {
	applyMatrix: function(a) {
		for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) {
			var e = this.vertices[c];
			e.applyMatrix4(a)
		}
		c = 0;
		for (d = this.faces.length; c < d; c++) {
			a = this.faces[c];
			a.normal.applyMatrix3(b).normalize();
			for (var e = 0, f = a.vertexNormals.length; e < f; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
		}
		null !== this.boundingBox && this.computeBoundingBox();
		null !== this.boundingSphere && this.computeBoundingSphere();
		this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
		return this
	},
	rotateX: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeRotationX(d);
			this.applyMatrix(a);
			return this
		}
	}(),
	rotateY: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeRotationY(d);
			this.applyMatrix(a);
			return this
		}
	}(),
	rotateZ: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeRotationZ(d);
			this.applyMatrix(a);
			return this
		}
	}(),
	translate: function() {
		var a;
		return function c(d,
			e, f) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeTranslation(d, e, f);
			this.applyMatrix(a);
			return this
		}
	}(),
	scale: function() {
		var a;
		return function c(d, e, f) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeScale(d, e, f);
			this.applyMatrix(a);
			return this
		}
	}(),
	lookAt: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Object3D);
			a.lookAt(d);
			a.updateMatrix();
			this.applyMatrix(a.matrix)
		}
	}(),
	fromBufferGeometry: function(a) {
		function b(a, b, d, e) {
			var f = void 0 !== g ? [m[a].clone(), m[b].clone(), m[d].clone()] : [],
				t = void 0 !== h ? [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()] : [];
			e = new THREE.Face3(a, b, d, f, t, e);
			c.faces.push(e);
			void 0 !== k && c.faceVertexUvs[0].push([n[a].clone(), n[b].clone(), n[d].clone()]);
			void 0 !== l && c.faceVertexUvs[1].push([r[a].clone(), r[b].clone(), r[d].clone()])
		}
		var c = this,
			d = null !== a.index ? a.index.array : void 0,
			e = a.attributes,
			f = e.position.array,
			g = void 0 !== e.normal ? e.normal.array : void 0,
			h = void 0 !== e.color ? e.color.array : void 0,
			k = void 0 !== e.uv ? e.uv.array : void 0,
			l = void 0 !== e.uv2 ? e.uv2.array : void 0;
		void 0 !== l && (this.faceVertexUvs[1] = []);
		for (var m = [], n = [], r = [], t = e = 0; e < f.length; e += 3, t += 2) c.vertices.push(new THREE.Vector3(f[e], f[e + 1], f[e + 2])), void 0 !== g && m.push(new THREE.Vector3(g[e], g[e + 1], g[e + 2])), void 0 !== h && c.colors.push(new THREE.Color(h[e], h[e + 1], h[e + 2])), void 0 !== k && n.push(new THREE.Vector2(k[t], k[t + 1])), void 0 !== l && r.push(new THREE.Vector2(l[t], l[t + 1]));
		if (void 0 !== d)
			if (f = a.groups, 0 < f.length)
				for (e = 0; e < f.length; e++)
					for (var u = f[e], w = u.start, v = u.count, t = w, w = w + v; t < w; t += 3) b(d[t], d[t + 1], d[t +
						2], u.materialIndex);
			else
				for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
		else
			for (e = 0; e < f.length / 3; e += 3) b(e, e + 1, e + 2);
		this.computeFaceNormals();
		null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
		null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
		return this
	},
	center: function() {
		this.computeBoundingBox();
		var a = this.boundingBox.center().negate();
		this.translate(a.x, a.y, a.z);
		return a
	},
	normalize: function() {
		this.computeBoundingSphere();
		var a = this.boundingSphere.center,
			b = this.boundingSphere.radius,
			b = 0 === b ? 1 : 1 / b,
			c = new THREE.Matrix4;
		c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
		this.applyMatrix(c);
		return this
	},
	computeFaceNormals: function() {
		for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, d = this.faces.length; c < d; c++) {
			var e = this.faces[c],
				f = this.vertices[e.a],
				g = this.vertices[e.b],
				h = this.vertices[e.c];
			a.subVectors(h, g);
			b.subVectors(f, g);
			a.cross(b);
			a.normalize();
			e.normal.copy(a)
		}
	},
	computeVertexNormals: function(a) {
		void 0 === a && (a = !0);
		var b, c, d;
		d = Array(this.vertices.length);
		b = 0;
		for (c = this.vertices.length; b <
			c; b++) d[b] = new THREE.Vector3;
		if (a) {
			var e, f, g, h = new THREE.Vector3,
				k = new THREE.Vector3;
			a = 0;
			for (b = this.faces.length; a < b; a++) c = this.faces[a], e = this.vertices[c.a], f = this.vertices[c.b], g = this.vertices[c.c], h.subVectors(g, f), k.subVectors(e, f), h.cross(k), d[c.a].add(h), d[c.b].add(h), d[c.c].add(h)
		} else
			for (a = 0, b = this.faces.length; a < b; a++) c = this.faces[a], d[c.a].add(c.normal), d[c.b].add(c.normal), d[c.c].add(c.normal);
		b = 0;
		for (c = this.vertices.length; b < c; b++) d[b].normalize();
		a = 0;
		for (b = this.faces.length; a < b; a++) c =
			this.faces[a], e = c.vertexNormals, 3 === e.length ? (e[0].copy(d[c.a]), e[1].copy(d[c.b]), e[2].copy(d[c.c])) : (e[0] = d[c.a].clone(), e[1] = d[c.b].clone(), e[2] = d[c.c].clone());
		0 < this.faces.length && (this.normalsNeedUpdate = !0)
	},
	computeMorphNormals: function() {
		var a, b, c, d, e;
		c = 0;
		for (d = this.faces.length; c < d; c++)
			for (e = this.faces[c], e.__originalFaceNormal ? e.__originalFaceNormal.copy(e.normal) : e.__originalFaceNormal = e.normal.clone(), e.__originalVertexNormals || (e.__originalVertexNormals = []), a = 0, b = e.vertexNormals.length; a <
				b; a++) e.__originalVertexNormals[a] ? e.__originalVertexNormals[a].copy(e.vertexNormals[a]) : e.__originalVertexNormals[a] = e.vertexNormals[a].clone();
		var f = new THREE.Geometry;
		f.faces = this.faces;
		a = 0;
		for (b = this.morphTargets.length; a < b; a++) {
			if (!this.morphNormals[a]) {
				this.morphNormals[a] = {};
				this.morphNormals[a].faceNormals = [];
				this.morphNormals[a].vertexNormals = [];
				e = this.morphNormals[a].faceNormals;
				var g = this.morphNormals[a].vertexNormals,
					h, k;
				c = 0;
				for (d = this.faces.length; c < d; c++) h = new THREE.Vector3, k = {
					a: new THREE.Vector3,
					b: new THREE.Vector3,
					c: new THREE.Vector3
				}, e.push(h), g.push(k)
			}
			g = this.morphNormals[a];
			f.vertices = this.morphTargets[a].vertices;
			f.computeFaceNormals();
			f.computeVertexNormals();
			c = 0;
			for (d = this.faces.length; c < d; c++) e = this.faces[c], h = g.faceNormals[c], k = g.vertexNormals[c], h.copy(e.normal), k.a.copy(e.vertexNormals[0]), k.b.copy(e.vertexNormals[1]), k.c.copy(e.vertexNormals[2])
		}
		c = 0;
		for (d = this.faces.length; c < d; c++) e = this.faces[c], e.normal = e.__originalFaceNormal, e.vertexNormals = e.__originalVertexNormals
	},
	computeTangents: function() {
		console.warn("THREE.Geometry: .computeTangents() has been removed.")
	},
	computeLineDistances: function() {
		for (var a = 0, b = this.vertices, c = 0, d = b.length; c < d; c++) 0 < c && (a += b[c].distanceTo(b[c - 1])), this.lineDistances[c] = a
	},
	computeBoundingBox: function() {
		null === this.boundingBox && (this.boundingBox = new THREE.Box3);
		this.boundingBox.setFromPoints(this.vertices)
	},
	computeBoundingSphere: function() {
		null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
		this.boundingSphere.setFromPoints(this.vertices)
	},
	merge: function(a, b, c) {
		if (!1 === a instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",
			a);
		else {
			var d, e = this.vertices.length,
				f = this.vertices,
				g = a.vertices,
				h = this.faces,
				k = a.faces,
				l = this.faceVertexUvs[0];
			a = a.faceVertexUvs[0];
			void 0 === c && (c = 0);
			void 0 !== b && (d = (new THREE.Matrix3).getNormalMatrix(b));
			for (var m = 0, n = g.length; m < n; m++) {
				var r = g[m],
					r = r.clone();
				void 0 !== b && r.applyMatrix4(b);
				f.push(r)
			}
			m = 0;
			for (n = k.length; m < n; m++) {
				var g = k[m],
					t, u = g.vertexNormals,
					w = g.vertexColors,
					r = new THREE.Face3(g.a + e, g.b + e, g.c + e);
				r.normal.copy(g.normal);
				void 0 !== d && r.normal.applyMatrix3(d).normalize();
				b = 0;
				for (f = u.length; b <
					f; b++) t = u[b].clone(), void 0 !== d && t.applyMatrix3(d).normalize(), r.vertexNormals.push(t);
				r.color.copy(g.color);
				b = 0;
				for (f = w.length; b < f; b++) t = w[b], r.vertexColors.push(t.clone());
				r.materialIndex = g.materialIndex + c;
				h.push(r)
			}
			m = 0;
			for (n = a.length; m < n; m++)
				if (c = a[m], d = [], void 0 !== c) {
					b = 0;
					for (f = c.length; b < f; b++) d.push(c[b].clone());
					l.push(d)
				}
		}
	},
	mergeMesh: function(a) {
		!1 === a instanceof THREE.Mesh ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a) : (a.matrixAutoUpdate && a.updateMatrix(),
			this.merge(a.geometry, a.matrix))
	},
	mergeVertices: function() {
		var a = {},
			b = [],
			c = [],
			d, e = Math.pow(10, 4),
			f, g;
		f = 0;
		for (g = this.vertices.length; f < g; f++) d = this.vertices[f], d = Math.round(d.x * e) + "_" + Math.round(d.y * e) + "_" + Math.round(d.z * e), void 0 === a[d] ? (a[d] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[d]];
		a = [];
		f = 0;
		for (g = this.faces.length; f < g; f++)
			for (e = this.faces[f], e.a = c[e.a], e.b = c[e.b], e.c = c[e.c], e = [e.a, e.b, e.c], d = -1, d = 0; 3 > d; d++)
				if (e[d] === e[(d + 1) % 3]) {
					a.push(f);
					break
				}
		for (f = a.length - 1; 0 <= f; f--)
			for (e = a[f],
				this.faces.splice(e, 1), c = 0, g = this.faceVertexUvs.length; c < g; c++) this.faceVertexUvs[c].splice(e, 1);
		f = this.vertices.length - b.length;
		this.vertices = b;
		return f
	},
	sortFacesByMaterialIndex: function() {
		function a(a, b) {
			return a.materialIndex - b.materialIndex
		}
		for (var b = this.faces, c = b.length, d = 0; d < c; d++) b[d]._id = d;
		b.sort(a);
		var e = this.faceVertexUvs[0],
			f = this.faceVertexUvs[1],
			g, h;
		e && e.length === c && (g = []);
		f && f.length === c && (h = []);
		for (d = 0; d < c; d++) {
			var k = b[d]._id;
			g && g.push(e[k]);
			h && h.push(f[k])
		}
		g && (this.faceVertexUvs[0] =
			g);
		h && (this.faceVertexUvs[1] = h)
	},
	toJSON: function() {
		function a(a, b, c) {
			return c ? a | 1 << b : a & ~(1 << b)
		}

		function b(a) {
			var b = a.x.toString() + a.y.toString() + a.z.toString();
			if (void 0 !== l[b]) return l[b];
			l[b] = k.length / 3;
			k.push(a.x, a.y, a.z);
			return l[b]
		}

		function c(a) {
			var b = a.r.toString() + a.g.toString() + a.b.toString();
			if (void 0 !== n[b]) return n[b];
			n[b] = m.length;
			m.push(a.getHex());
			return n[b]
		}

		function d(a) {
			var b = a.x.toString() + a.y.toString();
			if (void 0 !== t[b]) return t[b];
			t[b] = r.length / 2;
			r.push(a.x, a.y);
			return t[b]
		}
		var e = {
			metadata: {
				version: 4.4,
				type: "Geometry",
				generator: "Geometry.toJSON"
			}
		};
		e.uuid = this.uuid;
		e.type = this.type;
		"" !== this.name && (e.name = this.name);
		if (void 0 !== this.parameters) {
			var f = this.parameters,
				g;
			for (g in f) void 0 !== f[g] && (e[g] = f[g]);
			return e
		}
		f = [];
		for (g = 0; g < this.vertices.length; g++) {
			var h = this.vertices[g];
			f.push(h.x, h.y, h.z)
		}
		var h = [],
			k = [],
			l = {},
			m = [],
			n = {},
			r = [],
			t = {};
		for (g = 0; g < this.faces.length; g++) {
			var u = this.faces[g],
				w = !0,
				v = !1,
				x = void 0 !== this.faceVertexUvs[0][g],
				y = 0 < u.normal.length(),
				D = 0 < u.vertexNormals.length,
				z = 1 !== u.color.r || 1 !== u.color.g || 1 !== u.color.b,
				G = 0 < u.vertexColors.length,
				A = 0,
				A = a(A, 0, 0),
				A = a(A, 1, w),
				A = a(A, 2, v),
				A = a(A, 3, x),
				A = a(A, 4, y),
				A = a(A, 5, D),
				A = a(A, 6, z),
				A = a(A, 7, G);
			h.push(A);
			h.push(u.a, u.b, u.c);
			h.push(u.materialIndex);
			x && (w = this.faceVertexUvs[0][g], h.push(d(w[0]), d(w[1]), d(w[2])));
			y && h.push(b(u.normal));
			D && (y = u.vertexNormals, h.push(b(y[0]), b(y[1]), b(y[2])));
			z && h.push(c(u.color));
			G && (u = u.vertexColors, h.push(c(u[0]), c(u[1]), c(u[2])))
		}
		e.data = {};
		e.data.vertices = f;
		e.data.normals = k;
		0 < m.length && (e.data.colors =
			m);
		0 < r.length && (e.data.uvs = [r]);
		e.data.faces = h;
		return e
	},
	clone: function() {
		return (new THREE.Geometry).copy(this)
	},
	copy: function(a) {
		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [
			[]
		];
		for (var b = a.vertices, c = 0, d = b.length; c < d; c++) this.vertices.push(b[c].clone());
		b = a.faces;
		c = 0;
		for (d = b.length; c < d; c++) this.faces.push(b[c].clone());
		c = 0;
		for (d = a.faceVertexUvs.length; c < d; c++) {
			b = a.faceVertexUvs[c];
			void 0 === this.faceVertexUvs[c] && (this.faceVertexUvs[c] = []);
			for (var e = 0, f = b.length; e < f; e++) {
				for (var g = b[e], h = [],
						k = 0, l = g.length; k < l; k++) {
					var m = g[k];
					h.push(m.clone())
				}
				this.faceVertexUvs[c].push(h)
			}
		}
		return this
	},
	dispose: function() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
});
THREE.GeometryIdCount = 0;
THREE.DirectGeometry = function() {
	Object.defineProperty(this, "id", {
		value: THREE.GeometryIdCount++
	});
	this.uuid = THREE.Math.generateUUID();
	this.name = "";
	this.type = "DirectGeometry";
	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];
	this.groups = [];
	this.morphTargets = {};
	this.skinWeights = [];
	this.skinIndices = [];
	this.boundingSphere = this.boundingBox = null;
	this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
};
Object.assign(THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {
	computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
	computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
	computeFaceNormals: function() {
		console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
	},
	computeVertexNormals: function() {
		console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
	},
	computeGroups: function(a) {
		var b,
			c = [],
			d;
		a = a.faces;
		for (var e = 0; e < a.length; e++) {
			var f = a[e];
			f.materialIndex !== d && (d = f.materialIndex, void 0 !== b && (b.count = 3 * e - b.start, c.push(b)), b = {
				start: 3 * e,
				materialIndex: d
			})
		}
		void 0 !== b && (b.count = 3 * e - b.start, c.push(b));
		this.groups = c
	},
	fromGeometry: function(a) {
		var b = a.faces,
			c = a.vertices,
			d = a.faceVertexUvs,
			e = d[0] && 0 < d[0].length,
			f = d[1] && 0 < d[1].length,
			g = a.morphTargets,
			h = g.length,
			k;
		if (0 < h) {
			k = [];
			for (var l = 0; l < h; l++) k[l] = [];
			this.morphTargets.position = k
		}
		var m = a.morphNormals,
			n = m.length,
			r;
		if (0 < n) {
			r = [];
			for (l = 0; l <
				n; l++) r[l] = [];
			this.morphTargets.normal = r
		}
		for (var t = a.skinIndices, u = a.skinWeights, w = t.length === c.length, v = u.length === c.length, l = 0; l < b.length; l++) {
			var x = b[l];
			this.vertices.push(c[x.a], c[x.b], c[x.c]);
			var y = x.vertexNormals;
			3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = x.normal, this.normals.push(y, y, y));
			y = x.vertexColors;
			3 === y.length ? this.colors.push(y[0], y[1], y[2]) : (y = x.color, this.colors.push(y, y, y));
			!0 === e && (y = d[0][l], void 0 !== y ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
				l), this.uvs.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2)));
			!0 === f && (y = d[1][l], void 0 !== y ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2)));
			for (y = 0; y < h; y++) {
				var D = g[y].vertices;
				k[y].push(D[x.a], D[x.b], D[x.c])
			}
			for (y = 0; y < n; y++) D = m[y].vertexNormals[l], r[y].push(D.a, D.b, D.c);
			w && this.skinIndices.push(t[x.a], t[x.b], t[x.c]);
			v && this.skinWeights.push(u[x.a], u[x.b],
				u[x.c])
		}
		this.computeGroups(a);
		this.verticesNeedUpdate = a.verticesNeedUpdate;
		this.normalsNeedUpdate = a.normalsNeedUpdate;
		this.colorsNeedUpdate = a.colorsNeedUpdate;
		this.uvsNeedUpdate = a.uvsNeedUpdate;
		this.groupsNeedUpdate = a.groupsNeedUpdate;
		return this
	},
	dispose: function() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
});
THREE.BufferGeometry = function() {
	Object.defineProperty(this, "id", {
		value: THREE.GeometryIdCount++
	});
	this.uuid = THREE.Math.generateUUID();
	this.name = "";
	this.type = "BufferGeometry";
	this.index = null;
	this.attributes = {};
	this.morphAttributes = {};
	this.groups = [];
	this.boundingSphere = this.boundingBox = null;
	this.drawRange = {
		start: 0,
		count: Infinity
	}
};
Object.assign(THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {
	getIndex: function() {
		return this.index
	},
	setIndex: function(a) {
		this.index = a
	},
	addAttribute: function(a, b, c) {
		if (!1 === b instanceof THREE.BufferAttribute && !1 === b instanceof THREE.InterleavedBufferAttribute) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(a, new THREE.BufferAttribute(b, c));
		else if ("index" === a) console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
			this.setIndex(b);
		else return this.attributes[a] = b, this
	},
	getAttribute: function(a) {
		return this.attributes[a]
	},
	removeAttribute: function(a) {
		delete this.attributes[a];
		return this
	},
	addGroup: function(a, b, c) {
		this.groups.push({
			start: a,
			count: b,
			materialIndex: void 0 !== c ? c : 0
		})
	},
	clearGroups: function() {
		this.groups = []
	},
	setDrawRange: function(a, b) {
		this.drawRange.start = a;
		this.drawRange.count = b
	},
	applyMatrix: function(a) {
		var b = this.attributes.position;
		void 0 !== b && (a.applyToVector3Array(b.array), b.needsUpdate = !0);
		b = this.attributes.normal;
		void 0 !== b && (a = (new THREE.Matrix3).getNormalMatrix(a), a.applyToVector3Array(b.array), b.needsUpdate = !0);
		null !== this.boundingBox && this.computeBoundingBox();
		null !== this.boundingSphere && this.computeBoundingSphere();
		return this
	},
	rotateX: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeRotationX(d);
			this.applyMatrix(a);
			return this
		}
	}(),
	rotateY: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeRotationY(d);
			this.applyMatrix(a);
			return this
		}
	}(),
	rotateZ: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeRotationZ(d);
			this.applyMatrix(a);
			return this
		}
	}(),
	translate: function() {
		var a;
		return function c(d, e, f) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeTranslation(d, e, f);
			this.applyMatrix(a);
			return this
		}
	}(),
	scale: function() {
		var a;
		return function c(d, e, f) {
			void 0 === a && (a = new THREE.Matrix4);
			a.makeScale(d, e, f);
			this.applyMatrix(a);
			return this
		}
	}(),
	lookAt: function() {
		var a;
		return function c(d) {
			void 0 === a && (a = new THREE.Object3D);
			a.lookAt(d);
			a.updateMatrix();
			this.applyMatrix(a.matrix)
		}
	}(),
	center: function() {
		this.computeBoundingBox();
		var a = this.boundingBox.center().negate();
		this.translate(a.x, a.y, a.z);
		return a
	},
	setFromObject: function(a) {
		var b = a.geometry;
		if (a instanceof THREE.Points || a instanceof THREE.Line) {
			a = new THREE.Float32Attribute(3 * b.vertices.length, 3);
			var c = new THREE.Float32Attribute(3 * b.colors.length, 3);
			this.addAttribute("position", a.copyVector3sArray(b.vertices));
			this.addAttribute("color", c.copyColorsArray(b.colors));
			b.lineDistances && b.lineDistances.length ===
				b.vertices.length && (a = new THREE.Float32Attribute(b.lineDistances.length, 1), this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
			null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
			null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
		} else a instanceof THREE.Mesh && b instanceof THREE.Geometry && this.fromGeometry(b);
		return this
	},
	updateFromObject: function(a) {
		var b = a.geometry;
		if (a instanceof THREE.Mesh) {
			var c = b.__directGeometry;
			if (void 0 === c) return this.fromGeometry(b);
			c.verticesNeedUpdate = b.verticesNeedUpdate;
			c.normalsNeedUpdate = b.normalsNeedUpdate;
			c.colorsNeedUpdate = b.colorsNeedUpdate;
			c.uvsNeedUpdate = b.uvsNeedUpdate;
			c.groupsNeedUpdate = b.groupsNeedUpdate;
			b.verticesNeedUpdate = !1;
			b.normalsNeedUpdate = !1;
			b.colorsNeedUpdate = !1;
			b.uvsNeedUpdate = !1;
			b.groupsNeedUpdate = !1;
			b = c
		}!0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices), c.needsUpdate = !0), b.verticesNeedUpdate = !1);
		!0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !==
			c && (c.copyVector3sArray(b.normals), c.needsUpdate = !0), b.normalsNeedUpdate = !1);
		!0 === b.colorsNeedUpdate && (c = this.attributes.color, void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1);
		b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !1);
		b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
		b.groupsNeedUpdate && (b.computeGroups(a.geometry),
			this.groups = b.groups, b.groupsNeedUpdate = !1);
		return this
	},
	fromGeometry: function(a) {
		a.__directGeometry = (new THREE.DirectGeometry).fromGeometry(a);
		return this.fromDirectGeometry(a.__directGeometry)
	},
	fromDirectGeometry: function(a) {
		var b = new Float32Array(3 * a.vertices.length);
		this.addAttribute("position", (new THREE.BufferAttribute(b, 3)).copyVector3sArray(a.vertices));
		0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new THREE.BufferAttribute(b, 3)).copyVector3sArray(a.normals)));
		0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new THREE.BufferAttribute(b, 3)).copyColorsArray(a.colors)));
		0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length), this.addAttribute("uv", (new THREE.BufferAttribute(b, 2)).copyVector2sArray(a.uvs)));
		0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new THREE.BufferAttribute(b, 2)).copyVector2sArray(a.uvs2)));
		0 < a.indices.length && (b = 65535 < a.vertices.length ? Uint32Array : Uint16Array, b = new b(3 * a.indices.length),
			this.setIndex((new THREE.BufferAttribute(b, 1)).copyIndicesArray(a.indices)));
		this.groups = a.groups;
		for (var c in a.morphTargets) {
			for (var b = [], d = a.morphTargets[c], e = 0, f = d.length; e < f; e++) {
				var g = d[e],
					h = new THREE.Float32Attribute(3 * g.length, 3);
				b.push(h.copyVector3sArray(g))
			}
			this.morphAttributes[c] = b
		}
		0 < a.skinIndices.length && (c = new THREE.Float32Attribute(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(a.skinIndices)));
		0 < a.skinWeights.length && (c = new THREE.Float32Attribute(4 * a.skinWeights.length,
			4), this.addAttribute("skinWeight", c.copyVector4sArray(a.skinWeights)));
		null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
		null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
		return this
	},
	computeBoundingBox: function() {
		null === this.boundingBox && (this.boundingBox = new THREE.Box3);
		var a = this.attributes.position.array;
		void 0 !== a ? this.boundingBox.setFromArray(a) : this.boundingBox.makeEmpty();
		(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
		console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
	},
	computeBoundingSphere: function() {
		var a = new THREE.Box3,
			b = new THREE.Vector3;
		return function d() {
			null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
			var e = this.attributes.position.array;
			if (e) {
				var f = this.boundingSphere.center;
				a.setFromArray(e);
				a.center(f);
				for (var g = 0, h = 0, k = e.length; h < k; h += 3) b.fromArray(e, h), g = Math.max(g, f.distanceToSquared(b));
				this.boundingSphere.radius = Math.sqrt(g);
				isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
			}
		}
	}(),
	computeFaceNormals: function() {},
	computeVertexNormals: function() {
		var a = this.index,
			b = this.attributes,
			c = this.groups;
		if (b.position) {
			var d = b.position.array;
			if (void 0 === b.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(d.length), 3));
			else
				for (var e = b.normal.array,
						f = 0, g = e.length; f < g; f++) e[f] = 0;
			var e = b.normal.array,
				h, k, l, m = new THREE.Vector3,
				n = new THREE.Vector3,
				r = new THREE.Vector3,
				t = new THREE.Vector3,
				u = new THREE.Vector3;
			if (a) {
				a = a.array;
				0 === c.length && this.addGroup(0, a.length);
				for (var w = 0, v = c.length; w < v; ++w)
					for (f = c[w], g = f.start, h = f.count, f = g, g += h; f < g; f += 3) h = 3 * a[f + 0], k = 3 * a[f + 1], l = 3 * a[f + 2], m.fromArray(d, h), n.fromArray(d, k), r.fromArray(d, l), t.subVectors(r, n), u.subVectors(m, n), t.cross(u), e[h] += t.x, e[h + 1] += t.y, e[h + 2] += t.z, e[k] += t.x, e[k + 1] += t.y, e[k + 2] += t.z, e[l] += t.x,
						e[l + 1] += t.y, e[l + 2] += t.z
			} else
				for (f = 0, g = d.length; f < g; f += 9) m.fromArray(d, f), n.fromArray(d, f + 3), r.fromArray(d, f + 6), t.subVectors(r, n), u.subVectors(m, n), t.cross(u), e[f] = t.x, e[f + 1] = t.y, e[f + 2] = t.z, e[f + 3] = t.x, e[f + 4] = t.y, e[f + 5] = t.z, e[f + 6] = t.x, e[f + 7] = t.y, e[f + 8] = t.z;
			this.normalizeNormals();
			b.normal.needsUpdate = !0
		}
	},
	merge: function(a, b) {
		if (!1 === a instanceof THREE.BufferGeometry) console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a);
		else {
			void 0 === b && (b = 0);
			var c = this.attributes,
				d;
			for (d in c)
				if (void 0 !== a.attributes[d])
					for (var e = c[d], e = e.array, f = a.attributes[d], g = f.array, h = f.itemSize, f = 0, h = h * b; f < g.length; f++, h++) e[h] = g[f];
			return this
		}
	},
	normalizeNormals: function() {
		for (var a = this.attributes.normal.array, b, c, d, e = 0, f = a.length; e < f; e += 3) b = a[e], c = a[e + 1], d = a[e + 2], b = 1 / Math.sqrt(b * b + c * c + d * d), a[e] *= b, a[e + 1] *= b, a[e + 2] *= b
	},
	toNonIndexed: function() {
		if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
		var a = new THREE.BufferGeometry,
			b = this.index.array,
			c = this.attributes,
			d;
		for (d in c) {
			for (var e = c[d], f = e.array, e = e.itemSize, g = new f.constructor(b.length * e), h = 0, k = 0, l = 0, m = b.length; l < m; l++)
				for (var h = b[l] * e, n = 0; n < e; n++) g[k++] = f[h++];
			a.addAttribute(d, new THREE.BufferAttribute(g, e))
		}
		return a
	},
	toJSON: function() {
		var a = {
			metadata: {
				version: 4.4,
				type: "BufferGeometry",
				generator: "BufferGeometry.toJSON"
			}
		};
		a.uuid = this.uuid;
		a.type = this.type;
		"" !== this.name && (a.name = this.name);
		if (void 0 !== this.parameters) {
			var b = this.parameters,
				c;
			for (c in b) void 0 !==
				b[c] && (a[c] = b[c]);
			return a
		}
		a.data = {
			attributes: {}
		};
		var d = this.index;
		null !== d && (b = Array.prototype.slice.call(d.array), a.data.index = {
			type: d.array.constructor.name,
			array: b
		});
		d = this.attributes;
		for (c in d) {
			var e = d[c],
				b = Array.prototype.slice.call(e.array);
			a.data.attributes[c] = {
				itemSize: e.itemSize,
				type: e.array.constructor.name,
				array: b,
				normalized: e.normalized
			}
		}
		c = this.groups;
		0 < c.length && (a.data.groups = JSON.parse(JSON.stringify(c)));
		c = this.boundingSphere;
		null !== c && (a.data.boundingSphere = {
			center: c.center.toArray(),
			radius: c.radius
		});
		return a
	},
	clone: function() {
		return (new THREE.BufferGeometry).copy(this)
	},
	copy: function(a) {
		var b = a.index;
		null !== b && this.setIndex(b.clone());
		var b = a.attributes,
			c;
		for (c in b) {
			var d = b[c];
			this.addAttribute(c, d.clone())
		}
		a = a.groups;
		c = 0;
		for (b = a.length; c < b; c++) d = a[c], this.addGroup(d.start, d.count, d.materialIndex);
		return this
	},
	dispose: function() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
});
THREE.BufferGeometry.MaxIndex = 65535;
THREE.InstancedBufferGeometry = function() {
	THREE.BufferGeometry.call(this);
	this.type = "InstancedBufferGeometry";
	this.maxInstancedCount = void 0
};
THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;
THREE.InstancedBufferGeometry.prototype.addGroup = function(a, b, c) {
	this.groups.push({
		start: a,
		count: b,
		instances: c
	})
};
THREE.InstancedBufferGeometry.prototype.copy = function(a) {
	var b = a.index;
	null !== b && this.setIndex(b.clone());
	var b = a.attributes,
		c;
	for (c in b) {
		var d = b[c];
		this.addAttribute(c, d.clone())
	}
	a = a.groups;
	c = 0;
	for (b = a.length; c < b; c++) d = a[c], this.addGroup(d.start, d.count, d.instances);
	return this
};
THREE.Uniform = function(a, b) {
	"string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."), a = b);
	this.value = a;
	this.dynamic = !1
};
THREE.Uniform.prototype = {
	constructor: THREE.Uniform,
	onUpdate: function(a) {
		this.dynamic = !0;
		this.onUpdateCallback = a;
		return this
	}
};
THREE.AnimationAction = function() {
	throw Error("THREE.AnimationAction: Use mixer.clipAction for construction.");
};
THREE.AnimationAction._new = function um(b, c, d) {
	this._mixer = b;
	this._clip = c;
	this._localRoot = d || null;
	b = c.tracks;
	c = b.length;
	d = Array(c);
	for (var e = {
			endingStart: THREE.ZeroCurvatureEnding,
			endingEnd: THREE.ZeroCurvatureEnding
		}, f = 0; f !== c; ++f) {
		var g = b[f].createInterpolant(null);
		d[f] = g;
		g.settings = e
	}
	this._interpolantSettings = e;
	this._interpolants = d;
	this._propertyBindings = Array(c);
	this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
	this.loop = THREE.LoopRepeat;
	this._loopCount = -1;
	this._startTime = null;
	this.time = 0;
	this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
	this.repetitions = Infinity;
	this.paused = !1;
	this.enabled = !0;
	this.clampWhenFinished = !1;
	this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
};
THREE.AnimationAction._new.prototype = {
	constructor: THREE.AnimationAction._new,
	play: function() {
		this._mixer._activateAction(this);
		return this
	},
	stop: function() {
		this._mixer._deactivateAction(this);
		return this.reset()
	},
	reset: function() {
		this.paused = !1;
		this.enabled = !0;
		this.time = 0;
		this._loopCount = -1;
		this._startTime = null;
		return this.stopFading().stopWarping()
	},
	isRunning: function() {
		var a = this._startTime;
		return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
	},
	isScheduled: function() {
		return this._mixer._isActiveAction(this)
	},
	startAt: function(a) {
		this._startTime = a;
		return this
	},
	setLoop: function(a, b) {
		this.loop = a;
		this.repetitions = b;
		return this
	},
	setEffectiveWeight: function(a) {
		this.weight = a;
		this._effectiveWeight = this.enabled ? a : 0;
		return this.stopFading()
	},
	getEffectiveWeight: function() {
		return this._effectiveWeight
	},
	fadeIn: function(a) {
		return this._scheduleFading(a, 0, 1)
	},
	fadeOut: function(a) {
		return this._scheduleFading(a, 1, 0)
	},
	crossFadeFrom: function(a, b, c) {
		var d = this._mixer;
		a.fadeOut(b);
		this.fadeIn(b);
		if (c) {
			var d = this._clip.duration,
				e = a._clip.duration;
			c = e / d;
			d /= e;
			a.warp(1, c, b);
			this.warp(d, 1, b)
		}
		return this
	},
	crossFadeTo: function(a, b, c) {
		return a.crossFadeFrom(this, b, c)
	},
	stopFading: function() {
		var a = this._weightInterpolant;
		null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
		return this
	},
	setEffectiveTimeScale: function(a) {
		this.timeScale = a;
		this._effectiveTimeScale = this.paused ? 0 : a;
		return this.stopWarping()
	},
	getEffectiveTimeScale: function() {
		return this._effectiveTimeScale
	},
	setDuration: function(a) {
		this.timeScale = this._clip.duration / a;
		return this.stopWarping()
	},
	syncWith: function(a) {
		this.time = a.time;
		this.timeScale = a.timeScale;
		return this.stopWarping()
	},
	halt: function(a) {
		return this.warp(this._effectiveTimeScale, 0, a)
	},
	warp: function(a, b, c) {
		var d = this._mixer,
			e = d.time,
			f = this._timeScaleInterpolant,
			g = this.timeScale;
		null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant());
		d = f.parameterPositions;
		f = f.sampleValues;
		d[0] = e;
		d[1] = e + c;
		f[0] = a / g;
		f[1] = b / g;
		return this
	},
	stopWarping: function() {
		var a =
			this._timeScaleInterpolant;
		null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
		return this
	},
	getMixer: function() {
		return this._mixer
	},
	getClip: function() {
		return this._clip
	},
	getRoot: function() {
		return this._localRoot || this._mixer._root
	},
	_update: function(a, b, c, d) {
		var e = this._startTime;
		if (null !== e) {
			b = (a - e) * c;
			if (0 > b || 0 === c) return;
			this._startTime = null;
			b *= c
		}
		b *= this._updateTimeScale(a);
		c = this._updateTime(b);
		a = this._updateWeight(a);
		if (0 < a) {
			b = this._interpolants;
			for (var e = this._propertyBindings,
					f = 0, g = b.length; f !== g; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
		}
	},
	_updateWeight: function(a) {
		var b = 0;
		if (this.enabled) {
			var b = this.weight,
				c = this._weightInterpolant;
			if (null !== c) {
				var d = c.evaluate(a)[0],
					b = b * d;
				a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
			}
		}
		return this._effectiveWeight = b
	},
	_updateTimeScale: function(a) {
		var b = 0;
		if (!this.paused) {
			var b = this.timeScale,
				c = this._timeScaleInterpolant;
			if (null !== c) {
				var d = c.evaluate(a)[0],
					b = b * d;
				a > c.parameterPositions[1] && (this.stopWarping(), 0 ===
					b ? this.paused = !0 : this.timeScale = b)
			}
		}
		return this._effectiveTimeScale = b
	},
	_updateTime: function(a) {
		var b = this.time + a;
		if (0 === a) return b;
		var c = this._clip.duration,
			d = this.loop,
			e = this._loopCount;
		if (d === THREE.LoopOnce) a: {
			if (-1 === e && (this.loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
			else if (0 > b) b = 0;
			else break a;this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;this._mixer.dispatchEvent({
				type: "finished",
				action: this,
				direction: 0 > a ? -1 : 1
			})
		}
		else {
			d = d === THREE.LoopPingPong; - 1 === e && (0 <= a ? (e = 0, this._setEndings(!0,
				0 === this.repetitions, d)) : this._setEndings(0 === this.repetitions, !0, d));
			if (b >= c || 0 > b) {
				var f = Math.floor(b / c),
					b = b - c * f,
					e = e + Math.abs(f),
					g = this.repetitions - e;
				0 > g ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, b = 0 < a ? c : 0, this._mixer.dispatchEvent({
					type: "finished",
					action: this,
					direction: 0 < a ? 1 : -1
				})) : (0 === g ? (a = 0 > a, this._setEndings(a, !a, d)) : this._setEndings(!1, !1, d), this._loopCount = e, this._mixer.dispatchEvent({
					type: "loop",
					action: this,
					loopDelta: f
				}))
			}
			if (d && 1 === (e & 1)) return this.time = b, c - b
		}
		return this.time =
			b
	},
	_setEndings: function(a, b, c) {
		var d = this._interpolantSettings;
		c ? (d.endingStart = THREE.ZeroSlopeEnding, d.endingEnd = THREE.ZeroSlopeEnding) : (d.endingStart = a ? this.zeroSlopeAtStart ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : THREE.WrapAroundEnding, d.endingEnd = b ? this.zeroSlopeAtEnd ? THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding : THREE.WrapAroundEnding)
	},
	_scheduleFading: function(a, b, c) {
		var d = this._mixer,
			e = d.time,
			f = this._weightInterpolant;
		null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
		d = f.parameterPositions;
		f = f.sampleValues;
		d[0] = e;
		f[0] = b;
		d[1] = e + a;
		f[1] = c;
		return this
	}
};
THREE.AnimationClip = function(a, b, c) {
	this.name = a;
	this.tracks = c;
	this.duration = void 0 !== b ? b : -1;
	this.uuid = THREE.Math.generateUUID();
	0 > this.duration && this.resetDuration();
	this.trim();
	this.optimize()
};
THREE.AnimationClip.prototype = {
	constructor: THREE.AnimationClip,
	resetDuration: function() {
		for (var a = this.tracks, b = 0, c = 0, a = a.length; c !== a; ++c) var d = this.tracks[c],
			b = Math.max(b, d.times[d.times.length - 1]);
		this.duration = b
	},
	trim: function() {
		for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
		return this
	},
	optimize: function() {
		for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
		return this
	}
};
Object.assign(THREE.AnimationClip, {
	parse: function(a) {
		for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, f = c.length; e !== f; ++e) b.push(THREE.KeyframeTrack.parse(c[e]).scale(d));
		return new THREE.AnimationClip(a.name, a.duration, b)
	},
	toJSON: function(a) {
		var b = [],
			c = a.tracks;
		a = {
			name: a.name,
			duration: a.duration,
			tracks: b
		};
		for (var d = 0, e = c.length; d !== e; ++d) b.push(THREE.KeyframeTrack.toJSON(c[d]));
		return a
	},
	CreateFromMorphTargetSequence: function(a, b, c, d) {
		for (var e = b.length, f = [], g = 0; g < e; g++) {
			var h = [],
				k = [];
			h.push((g + e - 1) %
				e, g, (g + 1) % e);
			k.push(0, 1, 0);
			var l = THREE.AnimationUtils.getKeyframeOrder(h),
				h = THREE.AnimationUtils.sortedArray(h, 1, l),
				k = THREE.AnimationUtils.sortedArray(k, 1, l);
			d || 0 !== h[0] || (h.push(e), k.push(k[0]));
			f.push((new THREE.NumberKeyframeTrack(".morphTargetInfluences[" + b[g].name + "]", h, k)).scale(1 / c))
		}
		return new THREE.AnimationClip(a, -1, f)
	},
	findByName: function(a, b) {
		var c = a;
		Array.isArray(a) || (c = a, c = c.geometry && c.geometry.animations || c.animations);
		for (a = 0; a < c.length; a++)
			if (c[a].name === b) return c[a];
		return null
	},
	CreateClipsFromMorphTargetSequences: function(a, b, c) {
		for (var d = {}, e = /^([\w-]*?)([\d]+)$/, f = 0, g = a.length; f < g; f++) {
			var h = a[f],
				k = h.name.match(e);
			if (k && 1 < k.length) {
				var l = k[1];
				(k = d[l]) || (d[l] = k = []);
				k.push(h)
			}
		}
		a = [];
		for (l in d) a.push(THREE.AnimationClip.CreateFromMorphTargetSequence(l, d[l], b, c));
		return a
	},
	parseAnimation: function(a, b, c) {
		if (!a) return console.error("  no animation in JSONLoader data"), null;
		c = function(a, b, c, d, e) {
			if (0 !== c.length) {
				var f = [],
					g = [];
				THREE.AnimationUtils.flattenJSON(c, f, g, d);
				0 !== f.length &&
					e.push(new a(b, f, g))
			}
		};
		var d = [],
			e = a.name || "default",
			f = a.length || -1,
			g = a.fps || 30;
		a = a.hierarchy || [];
		for (var h = 0; h < a.length; h++) {
			var k = a[h].keys;
			if (k && 0 !== k.length)
				if (k[0].morphTargets) {
					for (var f = {}, l = 0; l < k.length; l++)
						if (k[l].morphTargets)
							for (var m = 0; m < k[l].morphTargets.length; m++) f[k[l].morphTargets[m]] = -1;
					for (var n in f) {
						for (var r = [], t = [], m = 0; m !== k[l].morphTargets.length; ++m) {
							var u = k[l];
							r.push(u.time);
							t.push(u.morphTarget === n ? 1 : 0)
						}
						d.push(new THREE.NumberKeyframeTrack(".morphTargetInfluence[" + n + "]",
							r, t))
					}
					f = f.length * (g || 1)
				} else l = ".bones[" + b[h].name + "]", c(THREE.VectorKeyframeTrack, l + ".position", k, "pos", d), c(THREE.QuaternionKeyframeTrack, l + ".quaternion", k, "rot", d), c(THREE.VectorKeyframeTrack, l + ".scale", k, "scl", d)
		}
		return 0 === d.length ? null : b = new THREE.AnimationClip(e, f, d)
	}
});
THREE.AnimationMixer = function(a) {
	this._root = a;
	this._initMemoryManager();
	this.time = this._accuIndex = 0;
	this.timeScale = 1
};
Object.assign(THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {
	clipAction: function(a, b) {
		var c = b || this._root,
			d = c.uuid,
			c = "string" === typeof a ? THREE.AnimationClip.findByName(c, a) : a;
		a = null !== c ? c.uuid : a;
		var e = this._actionsByClip[a],
			f = null;
		if (void 0 !== e) {
			f = e.actionByRoot[d];
			if (void 0 !== f) return f;
			f = e.knownActions[0];
			null === c && (c = f._clip)
		}
		if (null === c) return null;
		b = new THREE.AnimationMixer._Action(this, c, b);
		this._bindAction(b, f);
		this._addInactiveAction(b, a, d);
		return b
	},
	existingAction: function(a,
		b) {
		var c = b || this._root;
		b = c.uuid;
		a = (c = "string" === typeof a ? THREE.AnimationClip.findByName(c, a) : a) ? c.uuid : a;
		a = this._actionsByClip[a];
		return void 0 !== a ? a.actionByRoot[b] || null : null
	},
	stopAllAction: function() {
		for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
		for (e = 0; e !== d; ++e) c[e].useCount = 0;
		return this
	},
	update: function(a) {
		a *= this.timeScale;
		for (var b = this._actions, c = this._nActiveActions, d = this.time +=
				a, e = Math.sign(a), f = this._accuIndex ^= 1, g = 0; g !== c; ++g) {
			var h = b[g];
			h.enabled && h._update(d, a, e, f)
		}
		a = this._bindings;
		b = this._nActiveBindings;
		for (g = 0; g !== b; ++g) a[g].apply(f);
		return this
	},
	getRoot: function() {
		return this._root
	},
	uncacheClip: function(a) {
		var b = this._actions;
		a = a.uuid;
		var c = this._actionsByClip,
			d = c[a];
		if (void 0 !== d) {
			for (var d = d.knownActions, e = 0, f = d.length; e !== f; ++e) {
				var g = d[e];
				this._deactivateAction(g);
				var h = g._cacheIndex,
					k = b[b.length - 1];
				g._cacheIndex = null;
				g._byClipCacheIndex = null;
				k._cacheIndex =
					h;
				b[h] = k;
				b.pop();
				this._removeInactiveBindingsForAction(g)
			}
			delete c[a]
		}
	},
	uncacheRoot: function(a) {
		a = a.uuid;
		var b = this._actionsByClip,
			c;
		for (c in b) {
			var d = b[c].actionByRoot,
				d = d[a];
			void 0 !== d && (this._deactivateAction(d), this._removeInactiveAction(d))
		}
		c = this._bindingsByRootAndName;
		a = c[a];
		if (void 0 !== a)
			for (var e in a) c = a[e], c.restoreOriginalState(), this._removeInactiveBinding(c)
	},
	uncacheAction: function(a, b) {
		a = this.existingAction(a, b);
		null !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
	}
});
THREE.AnimationMixer._Action = THREE.AnimationAction._new;
Object.assign(THREE.AnimationMixer.prototype, {
	_bindAction: function(a, b) {
		var c = a._localRoot || this._root,
			d = a._clip.tracks,
			e = d.length,
			f = a._propertyBindings;
		a = a._interpolants;
		var g = c.uuid,
			h = this._bindingsByRootAndName,
			k = h[g];
		void 0 === k && (k = {}, h[g] = k);
		for (h = 0; h !== e; ++h) {
			var l = d[h],
				m = l.name,
				n = k[m];
			if (void 0 === n) {
				n = f[h];
				if (void 0 !== n) {
					null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, g, m));
					continue
				}
				n = b && b._propertyBindings[h].binding.parsedPath;
				n = new THREE.PropertyMixer(THREE.PropertyBinding.create(c,
					m, n), l.ValueTypeName, l.getValueSize());
				++n.referenceCount;
				this._addInactiveBinding(n, g, m)
			}
			f[h] = n;
			a[h].resultBuffer = n.buffer
		}
	},
	_activateAction: function(a) {
		if (!this._isActiveAction(a)) {
			if (null === a._cacheIndex) {
				var b = (a._localRoot || this._root).uuid,
					c = a._clip.uuid,
					d = this._actionsByClip[c];
				this._bindAction(a, d && d.knownActions[0]);
				this._addInactiveAction(a, c, b)
			}
			b = a._propertyBindings;
			c = 0;
			for (d = b.length; c !== d; ++c) {
				var e = b[c];
				0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
			}
			this._lendAction(a)
		}
	},
	_deactivateAction: function(a) {
		if (this._isActiveAction(a)) {
			for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
				var e = b[c];
				0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
			}
			this._takeBackAction(a)
		}
	},
	_initMemoryManager: function() {
		this._actions = [];
		this._nActiveActions = 0;
		this._actionsByClip = {};
		this._bindings = [];
		this._nActiveBindings = 0;
		this._bindingsByRootAndName = {};
		this._controlInterpolants = [];
		this._nActiveControlInterpolants = 0;
		var a = this;
		this.stats = {
			actions: {get total() {
					return a._actions.length
				},
				get inUse() {
					return a._nActiveActions
				}
			},
			bindings: {get total() {
					return a._bindings.length
				},
				get inUse() {
					return a._nActiveBindings
				}
			},
			controlInterpolants: {get total() {
					return a._controlInterpolants.length
				},
				get inUse() {
					return a._nActiveControlInterpolants
				}
			}
		}
	},
	_isActiveAction: function(a) {
		a = a._cacheIndex;
		return null !== a && a < this._nActiveActions
	},
	_addInactiveAction: function(a, b, c) {
		var d = this._actions,
			e = this._actionsByClip,
			f = e[b];
		void 0 === f ? (f = {
			knownActions: [a],
			actionByRoot: {}
		}, a._byClipCacheIndex = 0, e[b] = f) : (b =
			f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
		a._cacheIndex = d.length;
		d.push(a);
		f.actionByRoot[c] = a
	},
	_removeInactiveAction: function(a) {
		var b = this._actions,
			c = b[b.length - 1],
			d = a._cacheIndex;
		c._cacheIndex = d;
		b[d] = c;
		b.pop();
		a._cacheIndex = null;
		var c = a._clip.uuid,
			d = this._actionsByClip,
			e = d[c],
			f = e.knownActions,
			g = f[f.length - 1],
			h = a._byClipCacheIndex;
		g._byClipCacheIndex = h;
		f[h] = g;
		f.pop();
		a._byClipCacheIndex = null;
		e = e.actionByRoot;
		b = (b._localRoot || this._root).uuid;
		delete e[b];
		0 === f.length && delete d[c];
		this._removeInactiveBindingsForAction(a)
	},
	_removeInactiveBindingsForAction: function(a) {
		a = a._propertyBindings;
		for (var b = 0, c = a.length; b !== c; ++b) {
			var d = a[b];
			0 === --d.referenceCount && this._removeInactiveBinding(d)
		}
	},
	_lendAction: function(a) {
		var b = this._actions,
			c = a._cacheIndex,
			d = this._nActiveActions++,
			e = b[d];
		a._cacheIndex = d;
		b[d] = a;
		e._cacheIndex = c;
		b[c] = e
	},
	_takeBackAction: function(a) {
		var b = this._actions,
			c = a._cacheIndex,
			d = --this._nActiveActions,
			e = b[d];
		a._cacheIndex = d;
		b[d] = a;
		e._cacheIndex = c;
		b[c] = e
	},
	_addInactiveBinding: function(a, b, c) {
		var d = this._bindingsByRootAndName,
			e = d[b],
			f = this._bindings;
		void 0 === e && (e = {}, d[b] = e);
		e[c] = a;
		a._cacheIndex = f.length;
		f.push(a)
	},
	_removeInactiveBinding: function(a) {
		var b = this._bindings,
			c = a.binding,
			d = c.rootNode.uuid,
			c = c.path,
			e = this._bindingsByRootAndName,
			f = e[d],
			g = b[b.length - 1];
		a = a._cacheIndex;
		g._cacheIndex = a;
		b[a] = g;
		b.pop();
		delete f[c];
		a: {
			for (var h in f) break a;delete e[d]
		}
	},
	_lendBinding: function(a) {
		var b = this._bindings,
			c = a._cacheIndex,
			d = this._nActiveBindings++,
			e = b[d];
		a._cacheIndex = d;
		b[d] = a;
		e._cacheIndex = c;
		b[c] = e
	},
	_takeBackBinding: function(a) {
		var b =
			this._bindings,
			c = a._cacheIndex,
			d = --this._nActiveBindings,
			e = b[d];
		a._cacheIndex = d;
		b[d] = a;
		e._cacheIndex = c;
		b[c] = e
	},
	_lendControlInterpolant: function() {
		var a = this._controlInterpolants,
			b = this._nActiveControlInterpolants++,
			c = a[b];
		void 0 === c && (c = new THREE.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), c.__cacheIndex = b, a[b] = c);
		return c
	},
	_takeBackControlInterpolant: function(a) {
		var b = this._controlInterpolants,
			c = a.__cacheIndex,
			d = --this._nActiveControlInterpolants,
			e = b[d];
		a.__cacheIndex = d;
		b[d] = a;
		e.__cacheIndex = c;
		b[c] = e
	},
	_controlInterpolantsResultBuffer: new Float32Array(1)
});
THREE.AnimationObjectGroup = function(a) {
	this.uuid = THREE.Math.generateUUID();
	this._objects = Array.prototype.slice.call(arguments);
	this.nCachedObjects_ = 0;
	var b = {};
	this._indicesByUUID = b;
	for (var c = 0, d = arguments.length; c !== d; ++c) b[arguments[c].uuid] = c;
	this._paths = [];
	this._parsedPaths = [];
	this._bindings = [];
	this._bindingsIndicesByPath = {};
	var e = this;
	this.stats = {
		objects: {get total() {
				return e._objects.length
			},
			get inUse() {
				return this.total - e.nCachedObjects_
			}
		},
		get bindingsPerObject() {
			return e._bindings.length
		}
	}
};
THREE.AnimationObjectGroup.prototype = {
	constructor: THREE.AnimationObjectGroup,
	add: function(a) {
		for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._paths, g = this._parsedPaths, h = this._bindings, k = h.length, l = 0, m = arguments.length; l !== m; ++l) {
			var n = arguments[l],
				r = n.uuid,
				t = e[r];
			if (void 0 === t) {
				t = c++;
				e[r] = t;
				b.push(n);
				for (var r = 0, u = k; r !== u; ++r) h[r].push(new THREE.PropertyBinding(n, f[r], g[r]))
			} else if (t < d) {
				var w = b[t],
					v = --d,
					u = b[v];
				e[u.uuid] = t;
				b[t] = u;
				e[r] = v;
				b[v] = n;
				r = 0;
				for (u = k; r !==
					u; ++r) {
					var x = h[r],
						y = x[v],
						D = x[t];
					x[t] = y;
					void 0 === D && (D = new THREE.PropertyBinding(n, f[r], g[r]));
					x[v] = D
				}
			} else b[t] !== w && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
		}
		this.nCachedObjects_ = d
	},
	remove: function(a) {
		for (var b = this._objects, c = b.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings, f = e.length, g = 0, h = arguments.length; g !== h; ++g) {
			var k = arguments[g],
				l = k.uuid,
				m = d[l];
			if (void 0 !== m && m >= c) {
				var n =
					c++,
					r = b[n];
				d[r.uuid] = m;
				b[m] = r;
				d[l] = n;
				b[n] = k;
				k = 0;
				for (l = f; k !== l; ++k) {
					var r = e[k],
						t = r[n],
						u = r[m];
					r[m] = t;
					r[n] = u
				}
			}
		}
		this.nCachedObjects_ = c
	},
	uncache: function(a) {
		for (var b = this._objects, c = b.length, d = this.nCachedObjects_, e = this._indicesByUUID, f = this._bindings, g = f.length, h = 0, k = arguments.length; h !== k; ++h) {
			var l = arguments[h],
				m = l.uuid,
				l = e[m];
			if (void 0 !== l)
				if (delete e[m], l < d) {
					var m = --d,
						n = b[m],
						r = --c,
						t = b[r];
					e[n.uuid] = l;
					b[l] = n;
					e[t.uuid] = m;
					b[m] = t;
					b.pop();
					n = 0;
					for (t = g; n !== t; ++n) {
						var u = f[n],
							w = u[m],
							v = u[r];
						u[l] = w;
						u[m] = v;
						u.pop()
					}
				} else
					for (r = --c, t = b[r], e[t.uuid] = l, b[l] = t, b.pop(), n = 0, t = g; n !== t; ++n) u = f[n], u[l] = u[r], u.pop()
		}
		this.nCachedObjects_ = d
	},
	subscribe_: function(a, b) {
		var c = this._bindingsIndicesByPath,
			d = c[a],
			e = this._bindings;
		if (void 0 !== d) return e[d];
		var f = this._paths,
			g = this._parsedPaths,
			h = this._objects,
			k = h.length,
			l = this.nCachedObjects_,
			k = Array(k),
			d = e.length;
		c[a] = d;
		f.push(a);
		g.push(b);
		e.push(k);
		c = l;
		for (e = h.length; c !== e; ++c) f = h[c], k[c] = new THREE.PropertyBinding(f, a, b);
		return k
	},
	unsubscribe_: function(a) {
		var b = this._bindingsIndicesByPath,
			c = b[a];
		if (void 0 !== c) {
			var d = this._paths,
				e = this._parsedPaths,
				f = this._bindings,
				g = f.length - 1,
				h = f[g];
			a = a[g];
			b[a] = c;
			f[c] = h;
			f.pop();
			e[c] = e[g];
			e.pop();
			d[c] = d[g];
			d.pop()
		}
	}
};
THREE.AnimationUtils = {
	arraySlice: function(a, b, c) {
		return THREE.AnimationUtils.isTypedArray(a) ? new a.constructor(a.subarray(b, c)) : a.slice(b, c)
	},
	convertArray: function(a, b, c) {
		return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(a)
	},
	isTypedArray: function(a) {
		return ArrayBuffer.isView(a) && !(a instanceof DataView)
	},
	getKeyframeOrder: function(a) {
		function b(b, c) {
			return a[b] - a[c]
		}
		for (var c = a.length, d = Array(c), e = 0; e !== c; ++e) d[e] = e;
		d.sort(b);
		return d
	},
	sortedArray: function(a,
		b, c) {
		for (var d = a.length, e = new a.constructor(d), f = 0, g = 0; g !== d; ++f)
			for (var h = c[f] * b, k = 0; k !== b; ++k) e[g++] = a[h + k];
		return e
	},
	flattenJSON: function(a, b, c, d) {
		for (var e = 1, f = a[0]; void 0 !== f && void 0 === f[d];) f = a[e++];
		if (void 0 !== f) {
			var g = f[d];
			if (void 0 !== g)
				if (Array.isArray(g)) {
					do g = f[d], void 0 !== g && (b.push(f.time), c.push.apply(c, g)), f = a[e++]; while (void 0 !== f)
				} else if (void 0 !== g.toArray) {
				do g = f[d], void 0 !== g && (b.push(f.time), g.toArray(c, c.length)), f = a[e++]; while (void 0 !== f)
			} else {
				do g = f[d], void 0 !== g && (b.push(f.time),
					c.push(g)), f = a[e++]; while (void 0 !== f)
			}
		}
	}
};
THREE.KeyframeTrack = function(a, b, c, d) {
	if (void 0 === a) throw Error("track name is undefined");
	if (void 0 === b || 0 === b.length) throw Error("no keyframes in track named " + a);
	this.name = a;
	this.times = THREE.AnimationUtils.convertArray(b, this.TimeBufferType);
	this.values = THREE.AnimationUtils.convertArray(c, this.ValueBufferType);
	this.setInterpolation(d || this.DefaultInterpolation);
	this.validate();
	this.optimize()
};
THREE.KeyframeTrack.prototype = {
	constructor: THREE.KeyframeTrack,
	TimeBufferType: Float32Array,
	ValueBufferType: Float32Array,
	DefaultInterpolation: THREE.InterpolateLinear,
	InterpolantFactoryMethodDiscrete: function(a) {
		return new THREE.DiscreteInterpolant(this.times, this.values, this.getValueSize(), a)
	},
	InterpolantFactoryMethodLinear: function(a) {
		return new THREE.LinearInterpolant(this.times, this.values, this.getValueSize(), a)
	},
	InterpolantFactoryMethodSmooth: function(a) {
		return new THREE.CubicInterpolant(this.times,
			this.values, this.getValueSize(), a)
	},
	setInterpolation: function(a) {
		var b;
		switch (a) {
			case THREE.InterpolateDiscrete:
				b = this.InterpolantFactoryMethodDiscrete;
				break;
			case THREE.InterpolateLinear:
				b = this.InterpolantFactoryMethodLinear;
				break;
			case THREE.InterpolateSmooth:
				b = this.InterpolantFactoryMethodSmooth
		}
		if (void 0 === b) {
			b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
			if (void 0 === this.createInterpolant)
				if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
				else throw Error(b);
			console.warn(b)
		} else this.createInterpolant = b
	},
	getInterpolation: function() {
		switch (this.createInterpolant) {
			case this.InterpolantFactoryMethodDiscrete:
				return THREE.InterpolateDiscrete;
			case this.InterpolantFactoryMethodLinear:
				return THREE.InterpolateLinear;
			case this.InterpolantFactoryMethodSmooth:
				return THREE.InterpolateSmooth
		}
	},
	getValueSize: function() {
		return this.values.length / this.times.length
	},
	shift: function(a) {
		if (0 !== a)
			for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
		return this
	},
	scale: function(a) {
		if (1 !== a)
			for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
		return this
	},
	trim: function(a, b) {
		for (var c = this.times, d = c.length, e = 0, f = d - 1; e !== d && c[e] < a;) ++e;
		for (; - 1 !== f && c[f] > b;) --f;
		++f;
		if (0 !== e || f !== d) e >= f && (f = Math.max(f, 1), e = f - 1), a = this.getValueSize(), this.times = THREE.AnimationUtils.arraySlice(c, e, f), this.values = THREE.AnimationUtils.arraySlice(this.values, e * a, f * a);
		return this
	},
	validate: function() {
		var a = !0,
			b = this.getValueSize();
		0 !== b - Math.floor(b) && (console.error("invalid value size in track",
			this), a = !1);
		var c = this.times,
			b = this.values,
			d = c.length;
		0 === d && (console.error("track is empty", this), a = !1);
		for (var e = null, f = 0; f !== d; f++) {
			var g = c[f];
			if ("number" === typeof g && isNaN(g)) {
				console.error("time is not a valid number", this, f, g);
				a = !1;
				break
			}
			if (null !== e && e > g) {
				console.error("out of order keys", this, f, g, e);
				a = !1;
				break
			}
			e = g
		}
		if (void 0 !== b && THREE.AnimationUtils.isTypedArray(b))
			for (f = 0, c = b.length; f !== c; ++f)
				if (d = b[f], isNaN(d)) {
					console.error("value is not a valid number", this, f, d);
					a = !1;
					break
				}
		return a
	},
	optimize: function() {
		for (var a =
				this.times, b = this.values, c = this.getValueSize(), d = 1, e = 1, f = a.length - 1; e <= f; ++e) {
			var g = !1,
				h = a[e],
				k = a[e + 1];
			if (h !== k && (1 !== e || h !== h[0]))
				for (var k = e * c, l = k - c, m = k + c, h = 0; h !== c; ++h) {
					var n = b[k + h];
					if (n !== b[l + h] || n !== b[m + h]) {
						g = !0;
						break
					}
				}
			if (g) {
				if (e !== d)
					for (a[d] = a[e], g = e * c, k = d * c, h = 0; h !== c; ++h) b[k + h] = b[g + h];
				++d
			}
		}
		d !== a.length && (this.times = THREE.AnimationUtils.arraySlice(a, 0, d), this.values = THREE.AnimationUtils.arraySlice(b, 0, d * c));
		return this
	}
};
Object.assign(THREE.KeyframeTrack, {
	parse: function(a) {
		if (void 0 === a.type) throw Error("track type undefined, can not parse");
		var b = THREE.KeyframeTrack._getTrackTypeForValueTypeName(a.type);
		if (void 0 === a.times) {
			var c = [],
				d = [];
			THREE.AnimationUtils.flattenJSON(a.keys, c, d, "value");
			a.times = c;
			a.values = d
		}
		return void 0 !== b.parse ? b.parse(a) : new b(a.name, a.times, a.values, a.interpolation)
	},
	toJSON: function(a) {
		var b = a.constructor;
		if (void 0 !== b.toJSON) b = b.toJSON(a);
		else {
			var b = {
					name: a.name,
					times: THREE.AnimationUtils.convertArray(a.times,
						Array),
					values: THREE.AnimationUtils.convertArray(a.values, Array)
				},
				c = a.getInterpolation();
			c !== a.DefaultInterpolation && (b.interpolation = c)
		}
		b.type = a.ValueTypeName;
		return b
	},
	_getTrackTypeForValueTypeName: function(a) {
		switch (a.toLowerCase()) {
			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":
				return THREE.NumberKeyframeTrack;
			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":
				return THREE.VectorKeyframeTrack;
			case "color":
				return THREE.ColorKeyframeTrack;
			case "quaternion":
				return THREE.QuaternionKeyframeTrack;
			case "bool":
			case "boolean":
				return THREE.BooleanKeyframeTrack;
			case "string":
				return THREE.StringKeyframeTrack
		}
		throw Error("Unsupported typeName: " + a);
	}
});
THREE.PropertyBinding = function(a, b, c) {
	this.path = b;
	this.parsedPath = c || THREE.PropertyBinding.parseTrackName(b);
	this.node = THREE.PropertyBinding.findNode(a, this.parsedPath.nodeName) || a;
	this.rootNode = a
};
THREE.PropertyBinding.prototype = {
	constructor: THREE.PropertyBinding,
	getValue: function vm(b, c) {
		this.bind();
		this.getValue(b, c)
	},
	setValue: function wm(b, c) {
		this.bind();
		this.setValue(b, c)
	},
	bind: function() {
		var a = this.node,
			b = this.parsedPath,
			c = b.objectName,
			d = b.propertyName,
			e = b.propertyIndex;
		a || (this.node = a = THREE.PropertyBinding.findNode(this.rootNode, b.nodeName) || this.rootNode);
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;
		if (a) {
			if (c) {
				var f = b.objectIndex;
				switch (c) {
					case "materials":
						if (!a.material) {
							console.error("  can not bind to material as node does not have a material",
								this);
							return
						}
						if (!a.material.materials) {
							console.error("  can not bind to material.materials as node.material does not have a materials array", this);
							return
						}
						a = a.material.materials;
						break;
					case "bones":
						if (!a.skeleton) {
							console.error("  can not bind to bones as node does not have a skeleton", this);
							return
						}
						a = a.skeleton.bones;
						for (c = 0; c < a.length; c++)
							if (a[c].name === f) {
								f = c;
								break
							}
						break;
					default:
						if (void 0 === a[c]) {
							console.error("  can not bind to objectName of node, undefined", this);
							return
						}
						a = a[c]
				}
				if (void 0 !== f) {
					if (void 0 ===
						a[f]) {
						console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, a);
						return
					}
					a = a[f]
				}
			}
			if (f = a[d]) {
				b = this.Versioning.None;
				void 0 !== a.needsUpdate ? (b = this.Versioning.NeedsUpdate, this.targetObject = a) : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = a);
				c = this.BindingType.Direct;
				if (void 0 !== e) {
					if ("morphTargetInfluences" === d) {
						if (!a.geometry) {
							console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry",
								this);
							return
						}
						if (!a.geometry.morphTargets) {
							console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
							return
						}
						for (c = 0; c < this.node.geometry.morphTargets.length; c++)
							if (a.geometry.morphTargets[c].name === e) {
								e = c;
								break
							}
					}
					c = this.BindingType.ArrayElement;
					this.resolvedProperty = f;
					this.propertyIndex = e
				} else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = f) : void 0 !== f.length ? (c = this.BindingType.EntireArray, this.resolvedProperty =
					f) : this.propertyName = d;
				this.getValue = this.GetterByBindingType[c];
				this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
			} else e = b.nodeName, console.error("  trying to update property for track: " + e + "." + d + " but it wasn't found.", a)
		} else console.error("  trying to update node for track: " + this.path + " but it wasn't found.")
	},
	unbind: function() {
		this.node = null;
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound
	}
};
Object.assign(THREE.PropertyBinding.prototype, {
	_getValue_unavailable: function() {},
	_setValue_unavailable: function() {},
	_getValue_unbound: THREE.PropertyBinding.prototype.getValue,
	_setValue_unbound: THREE.PropertyBinding.prototype.setValue,
	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},
	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},
	GetterByBindingType: [function xm(b, c) {
		b[c] = this.node[this.propertyName]
	}, function ym(b, c) {
		for (var d = this.resolvedProperty, e = 0, f = d.length; e !==
			f; ++e) b[c++] = d[e]
	}, function zm(b, c) {
		b[c] = this.resolvedProperty[this.propertyIndex]
	}, function Am(b, c) {
		this.resolvedProperty.toArray(b, c)
	}],
	SetterByBindingTypeAndVersioning: [
		[function Bm(b, c) {
			this.node[this.propertyName] = b[c]
		}, function Cm(b, c) {
			this.node[this.propertyName] = b[c];
			this.targetObject.needsUpdate = !0
		}, function Dm(b, c) {
			this.node[this.propertyName] = b[c];
			this.targetObject.matrixWorldNeedsUpdate = !0
		}],
		[function Em(b, c) {
			for (var d = this.resolvedProperty, e = 0, f = d.length; e !== f; ++e) d[e] = b[c++]
		}, function Fm(b,
			c) {
			for (var d = this.resolvedProperty, e = 0, f = d.length; e !== f; ++e) d[e] = b[c++];
			this.targetObject.needsUpdate = !0
		}, function Gm(b, c) {
			for (var d = this.resolvedProperty, e = 0, f = d.length; e !== f; ++e) d[e] = b[c++];
			this.targetObject.matrixWorldNeedsUpdate = !0
		}],
		[function Hm(b, c) {
			this.resolvedProperty[this.propertyIndex] = b[c]
		}, function Im(b, c) {
			this.resolvedProperty[this.propertyIndex] = b[c];
			this.targetObject.needsUpdate = !0
		}, function Jm(b, c) {
			this.resolvedProperty[this.propertyIndex] = b[c];
			this.targetObject.matrixWorldNeedsUpdate = !0
		}],
		[function Km(b, c) {
			this.resolvedProperty.fromArray(b, c)
		}, function Lm(b, c) {
			this.resolvedProperty.fromArray(b, c);
			this.targetObject.needsUpdate = !0
		}, function Mm(b, c) {
			this.resolvedProperty.fromArray(b, c);
			this.targetObject.matrixWorldNeedsUpdate = !0
		}]
	]
});
THREE.PropertyBinding.Composite = function(a, b, c) {
	c = c || THREE.PropertyBinding.parseTrackName(b);
	this._targetGroup = a;
	this._bindings = a.subscribe_(b, c)
};
THREE.PropertyBinding.Composite.prototype = {
	constructor: THREE.PropertyBinding.Composite,
	getValue: function(a, b) {
		this.bind();
		var c = this._targetGroup.nCachedObjects_,
			c = this._bindings[c];
		void 0 !== c && c.getValue(a, b)
	},
	setValue: function(a, b) {
		for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a, b)
	},
	bind: function() {
		for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
	},
	unbind: function() {
		for (var a = this._bindings, b = this._targetGroup.nCachedObjects_,
				c = a.length; b !== c; ++b) a[b].unbind()
	}
};
THREE.PropertyBinding.create = function(a, b, c) {
	return a instanceof THREE.AnimationObjectGroup ? new THREE.PropertyBinding.Composite(a, b, c) : new THREE.PropertyBinding(a, b, c)
};
THREE.PropertyBinding.parseTrackName = function(a) {
	var b = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,
		c = b.exec(a);
	if (!c) throw Error("cannot parse trackName at all: " + a);
	c.index === b.lastIndex && b.lastIndex++;
	b = {
		nodeName: c[3],
		objectName: c[5],
		objectIndex: c[7],
		propertyName: c[9],
		propertyIndex: c[11]
	};
	if (null === b.propertyName || 0 === b.propertyName.length) throw Error("can not parse propertyName from trackName: " + a);
	return b
};
THREE.PropertyBinding.findNode = function(a, b) {
	if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
	if (a.skeleton) {
		var c = function(a) {
			for (var c = 0; c < a.bones.length; c++) {
				var d = a.bones[c];
				if (d.name === b) return d
			}
			return null
		};
		if (c = c(a.skeleton)) return c
	}
	if (a.children) {
		var d = function(a) {
			for (var c = 0; c < a.length; c++) {
				var e = a[c];
				if (e.name === b || e.uuid === b || (e = d(e.children))) return e
			}
			return null
		};
		if (a = d(a.children)) return a
	}
	return null
};
THREE.PropertyMixer = function(a, b, c) {
	this.binding = a;
	this.valueSize = c;
	a = Float64Array;
	switch (b) {
		case "quaternion":
			b = this._slerp;
			break;
		case "string":
		case "bool":
			a = Array;
			b = this._select;
			break;
		default:
			b = this._lerp
	}
	this.buffer = new a(4 * c);
	this._mixBufferRegion = b;
	this.referenceCount = this.useCount = this.cumulativeWeight = 0
};
THREE.PropertyMixer.prototype = {
	constructor: THREE.PropertyMixer,
	accumulate: function(a, b) {
		var c = this.buffer,
			d = this.valueSize;
		a = a * d + d;
		var e = this.cumulativeWeight;
		if (0 === e) {
			for (e = 0; e !== d; ++e) c[a + e] = c[e];
			e = b
		} else e += b, b /= e, this._mixBufferRegion(c, a, 0, b, d);
		this.cumulativeWeight = e
	},
	apply: function(a) {
		var b = this.valueSize,
			c = this.buffer;
		a = a * b + b;
		var d = this.cumulativeWeight,
			e = this.binding;
		this.cumulativeWeight = 0;
		if (1 > d) {
			var f = 3 * b;
			this._mixBufferRegion(c, a, f, 1 - d, b)
		}
		d = b;
		for (f = b + b; d !== f; ++d)
			if (c[d] !== c[d + b]) {
				e.setValue(c,
					a);
				break
			}
	},
	saveOriginalState: function() {
		var a = this.binding,
			b = this.buffer,
			c = this.valueSize,
			d = 3 * c;
		a.getValue(b, d);
		for (var a = c, e = d; a !== e; ++a) b[a] = b[d + a % c];
		this.cumulativeWeight = 0
	},
	restoreOriginalState: function() {
		var a = 3 * this.valueSize;
		this.binding.setValue(this.buffer, a)
	},
	_select: function(a, b, c, d, e) {
		if (.5 <= d)
			for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
	},
	_slerp: function(a, b, c, d, e) {
		THREE.Quaternion.slerpFlat(a, b, a, b, a, c, d)
	},
	_lerp: function(a, b, c, d, e) {
		for (var f = 1 - d, g = 0; g !== e; ++g) {
			var h = b + g;
			a[h] = a[h] * f + a[c + g] * d
		}
	}
};
THREE.BooleanKeyframeTrack = function(a, b, c) {
	THREE.KeyframeTrack.call(this, a, b, c)
};
THREE.BooleanKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
	constructor: THREE.BooleanKeyframeTrack,
	ValueTypeName: "bool",
	ValueBufferType: Array,
	DefaultInterpolation: THREE.InterpolateDiscrete,
	InterpolantFactoryMethodLinear: void 0,
	InterpolantFactoryMethodSmooth: void 0
});
THREE.ColorKeyframeTrack = function(a, b, c, d) {
	THREE.KeyframeTrack.call(this, a, b, c, d)
};
THREE.ColorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
	constructor: THREE.ColorKeyframeTrack,
	ValueTypeName: "color"
});
THREE.NumberKeyframeTrack = function(a, b, c, d) {
	THREE.KeyframeTrack.call(this, a, b, c, d)
};
THREE.NumberKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
	constructor: THREE.NumberKeyframeTrack,
	ValueTypeName: "number"
});
THREE.QuaternionKeyframeTrack = function(a, b, c, d) {
	THREE.KeyframeTrack.call(this, a, b, c, d)
};
THREE.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
	constructor: THREE.QuaternionKeyframeTrack,
	ValueTypeName: "quaternion",
	DefaultInterpolation: THREE.InterpolateLinear,
	InterpolantFactoryMethodLinear: function(a) {
		return new THREE.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), a)
	},
	InterpolantFactoryMethodSmooth: void 0
});
THREE.StringKeyframeTrack = function(a, b, c, d) {
	THREE.KeyframeTrack.call(this, a, b, c, d)
};
THREE.StringKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
	constructor: THREE.StringKeyframeTrack,
	ValueTypeName: "string",
	ValueBufferType: Array,
	DefaultInterpolation: THREE.InterpolateDiscrete,
	InterpolantFactoryMethodLinear: void 0,
	InterpolantFactoryMethodSmooth: void 0
});
THREE.VectorKeyframeTrack = function(a, b, c, d) {
	THREE.KeyframeTrack.call(this, a, b, c, d)
};
THREE.VectorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
	constructor: THREE.VectorKeyframeTrack,
	ValueTypeName: "vector"
});
THREE.Audio = function(a) {
	THREE.Object3D.call(this);
	this.type = "Audio";
	this.context = a.context;
	this.source = this.context.createBufferSource();
	this.source.onended = this.onEnded.bind(this);
	this.gain = this.context.createGain();
	this.gain.connect(a.getInput());
	this.autoplay = !1;
	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = !1;
	this.hasPlaybackControl = !0;
	this.sourceType = "empty";
	this.filters = []
};
THREE.Audio.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Audio,
	getOutput: function() {
		return this.gain
	},
	setNodeSource: function(a) {
		this.hasPlaybackControl = !1;
		this.sourceType = "audioNode";
		this.source = a;
		this.connect();
		return this
	},
	setBuffer: function(a) {
		this.source.buffer = a;
		this.sourceType = "buffer";
		this.autoplay && this.play();
		return this
	},
	play: function() {
		if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
		else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
		else {
			var a = this.context.createBufferSource();
			a.buffer = this.source.buffer;
			a.loop = this.source.loop;
			a.onended = this.source.onended;
			a.start(0, this.startTime);
			a.playbackRate.value = this.playbackRate;
			this.isPlaying = !0;
			this.source = a;
			return this.connect()
		}
	},
	pause: function() {
		if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
		else return this.source.stop(), this.startTime = this.context.currentTime, this
	},
	stop: function() {
		if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
		else return this.source.stop(), this.startTime = 0, this
	},
	connect: function() {
		if (0 < this.filters.length) {
			this.source.connect(this.filters[0]);
			for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
			this.filters[this.filters.length - 1].connect(this.getOutput())
		} else this.source.connect(this.getOutput());
		return this
	},
	disconnect: function() {
		if (0 < this.filters.length) {
			this.source.disconnect(this.filters[0]);
			for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].disconnect(this.filters[a]);
			this.filters[this.filters.length - 1].disconnect(this.getOutput())
		} else this.source.disconnect(this.getOutput());
		return this
	},
	getFilters: function() {
		return this.filters
	},
	setFilters: function(a) {
		a || (a = []);
		!0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
		return this
	},
	getFilter: function() {
		return this.getFilters()[0]
	},
	setFilter: function(a) {
		return this.setFilters(a ? [a] : [])
	},
	setPlaybackRate: function(a) {
		if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
		else return this.playbackRate = a, !0 === this.isPlaying && (this.source.playbackRate.value = this.playbackRate), this
	},
	getPlaybackRate: function() {
		return this.playbackRate
	},
	onEnded: function() {
		this.isPlaying = !1
	},
	getLoop: function() {
		return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.source.loop
	},
	setLoop: function(a) {
		!1 === this.hasPlaybackControl ? console.warn("THREE.Audio: this Audio has no playback control.") : this.source.loop = a
	},
	getVolume: function() {
		return this.gain.gain.value
	},
	setVolume: function(a) {
		this.gain.gain.value = a;
		return this
	}
});
THREE.AudioAnalyser = function(a, b) {
	this.analyser = a.context.createAnalyser();
	this.analyser.fftSize = void 0 !== b ? b : 2048;
	this.data = new Uint8Array(this.analyser.frequencyBinCount);
	a.getOutput().connect(this.analyser)
};
Object.assign(THREE.AudioAnalyser.prototype, {
	getFrequencyData: function() {
		this.analyser.getByteFrequencyData(this.data);
		return this.data
	},
	getAverageFrequency: function() {
		for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
		return a / b.length
	}
});
Object.defineProperty(THREE, "AudioContext", {
	get: function() {
		var a;
		return function() {
			void 0 === a && (a = new(window.AudioContext || window.webkitAudioContext));
			return a
		}
	}()
});
THREE.PositionalAudio = function(a) {
	THREE.Audio.call(this, a);
	this.panner = this.context.createPanner();
	this.panner.connect(this.gain)
};
THREE.PositionalAudio.prototype = Object.assign(Object.create(THREE.Audio.prototype), {
	constructor: THREE.PositionalAudio,
	getOutput: function() {
		return this.panner
	},
	getRefDistance: function() {
		return this.panner.refDistance
	},
	setRefDistance: function(a) {
		this.panner.refDistance = a
	},
	getRolloffFactor: function() {
		return this.panner.rolloffFactor
	},
	setRolloffFactor: function(a) {
		this.panner.rolloffFactor = a
	},
	getDistanceModel: function() {
		return this.panner.distanceModel
	},
	setDistanceModel: function(a) {
		this.panner.distanceModel =
			a
	},
	getMaxDistance: function() {
		return this.panner.maxDistance
	},
	setMaxDistance: function(a) {
		this.panner.maxDistance = a
	},
	updateMatrixWorld: function() {
		var a = new THREE.Vector3;
		return function c(d) {
			THREE.Object3D.prototype.updateMatrixWorld.call(this, d);
			a.setFromMatrixPosition(this.matrixWorld);
			this.panner.setPosition(a.x, a.y, a.z)
		}
	}()
});
THREE.AudioListener = function() {
	THREE.Object3D.call(this);
	this.type = "AudioListener";
	this.context = THREE.AudioContext;
	this.gain = this.context.createGain();
	this.gain.connect(this.context.destination);
	this.filter = null
};
THREE.AudioListener.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.AudioListener,
	getInput: function() {
		return this.gain
	},
	removeFilter: function() {
		null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
	},
	getFilter: function() {
		return this.filter
	},
	setFilter: function(a) {
		null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) :
			this.gain.disconnect(this.context.destination);
		this.filter = a;
		this.gain.connect(this.filter);
		this.filter.connect(this.context.destination)
	},
	getMasterVolume: function() {
		return this.gain.gain.value
	},
	setMasterVolume: function(a) {
		this.gain.gain.value = a
	},
	updateMatrixWorld: function() {
		var a = new THREE.Vector3,
			b = new THREE.Quaternion,
			c = new THREE.Vector3,
			d = new THREE.Vector3;
		return function f(g) {
			THREE.Object3D.prototype.updateMatrixWorld.call(this, g);
			g = this.context.listener;
			var h = this.up;
			this.matrixWorld.decompose(a,
				b, c);
			d.set(0, 0, -1).applyQuaternion(b);
			g.setPosition(a.x, a.y, a.z);
			g.setOrientation(d.x, d.y, d.z, h.x, h.y, h.z)
		}
	}()
});
THREE.Camera = function() {
	THREE.Object3D.call(this);
	this.type = "Camera";
	this.matrixWorldInverse = new THREE.Matrix4;
	this.projectionMatrix = new THREE.Matrix4
};
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
q = THREE.Camera.prototype;
q.constructor = THREE.Camera;
q.getWorldDirection = function() {
	var a = new THREE.Quaternion;
	return function(b) {
		b = b || new THREE.Vector3;
		this.getWorldQuaternion(a);
		return b.set(0, 0, -1).applyQuaternion(a)
	}
}();
q.lookAt = function() {
	var a = new THREE.Matrix4;
	return function(b) {
		a.lookAt(this.position, b, this.up);
		this.quaternion.setFromRotationMatrix(a)
	}
}();
q.clone = function() {
	return (new this.constructor).copy(this)
};
q.copy = function(a) {
	THREE.Object3D.prototype.copy.call(this, a);
	this.matrixWorldInverse.copy(a.matrixWorldInverse);
	this.projectionMatrix.copy(a.projectionMatrix);
	return this
};
THREE.CubeCamera = function(a, b, c) {
	THREE.Object3D.call(this);
	this.type = "CubeCamera";
	var d = new THREE.PerspectiveCamera(90, 1, a, b);
	d.up.set(0, -1, 0);
	d.lookAt(new THREE.Vector3(1, 0, 0));
	this.add(d);
	var e = new THREE.PerspectiveCamera(90, 1, a, b);
	e.up.set(0, -1, 0);
	e.lookAt(new THREE.Vector3(-1, 0, 0));
	this.add(e);
	var f = new THREE.PerspectiveCamera(90, 1, a, b);
	f.up.set(0, 0, 1);
	f.lookAt(new THREE.Vector3(0, 1, 0));
	this.add(f);
	var g = new THREE.PerspectiveCamera(90, 1, a, b);
	g.up.set(0, 0, -1);
	g.lookAt(new THREE.Vector3(0, -1, 0));
	this.add(g);
	var h = new THREE.PerspectiveCamera(90, 1, a, b);
	h.up.set(0, -1, 0);
	h.lookAt(new THREE.Vector3(0, 0, 1));
	this.add(h);
	var k = new THREE.PerspectiveCamera(90, 1, a, b);
	k.up.set(0, -1, 0);
	k.lookAt(new THREE.Vector3(0, 0, -1));
	this.add(k);
	a = {
		format: THREE.RGBFormat,
		magFilter: THREE.LinearFilter,
		minFilter: THREE.LinearFilter
	};
	this.renderTarget = new THREE.WebGLRenderTargetCube(c, c, a);
	this.updateCubeMap = function(a, b) {
		null === this.parent && this.updateMatrixWorld();
		var c = this.renderTarget,
			l = c.texture.generateMipmaps;
		c.texture.generateMipmaps = !1;
		c.activeCubeFace = 0;
		a.render(b, d, c);
		c.activeCubeFace = 1;
		a.render(b, e, c);
		c.activeCubeFace = 2;
		a.render(b, f, c);
		c.activeCubeFace = 3;
		a.render(b, g, c);
		c.activeCubeFace = 4;
		a.render(b, h, c);
		c.texture.generateMipmaps = l;
		c.activeCubeFace = 5;
		a.render(b, k, c);
		a.setRenderTarget(null)
	}
};
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;
THREE.OrthographicCamera = function(a, b, c, d, e, f) {
	THREE.Camera.call(this);
	this.type = "OrthographicCamera";
	this.zoom = 1;
	this.left = a;
	this.right = b;
	this.top = c;
	this.bottom = d;
	this.near = void 0 !== e ? e : .1;
	this.far = void 0 !== f ? f : 2E3;
	this.updateProjectionMatrix()
};
THREE.OrthographicCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {
	constructor: THREE.OrthographicCamera,
	copy: function(a) {
		THREE.Camera.prototype.copy.call(this, a);
		this.left = a.left;
		this.right = a.right;
		this.top = a.top;
		this.bottom = a.bottom;
		this.near = a.near;
		this.far = a.far;
		this.zoom = a.zoom;
		return this
	},
	updateProjectionMatrix: function() {
		var a = (this.right - this.left) / (2 * this.zoom),
			b = (this.top - this.bottom) / (2 * this.zoom),
			c = (this.right + this.left) / 2,
			d = (this.top + this.bottom) / 2;
		this.projectionMatrix.makeOrthographic(c -
			a, c + a, d + b, d - b, this.near, this.far)
	},
	toJSON: function(a) {
		a = THREE.Object3D.prototype.toJSON.call(this, a);
		a.object.zoom = this.zoom;
		a.object.left = this.left;
		a.object.right = this.right;
		a.object.top = this.top;
		a.object.bottom = this.bottom;
		a.object.near = this.near;
		a.object.far = this.far;
		return a
	}
});
THREE.PerspectiveCamera = function(a, b, c, d) {
	THREE.Camera.call(this);
	this.type = "PerspectiveCamera";
	this.fov = void 0 !== a ? a : 50;
	this.zoom = 1;
	this.near = void 0 !== c ? c : .1;
	this.far = void 0 !== d ? d : 2E3;
	this.focus = 10;
	this.aspect = void 0 !== b ? b : 1;
	this.view = null;
	this.filmGauge = 35;
	this.filmOffset = 0;
	this.updateProjectionMatrix()
};
THREE.PerspectiveCamera.prototype = Object.assign(Object.create(THREE.Camera.prototype), {
	constructor: THREE.PerspectiveCamera,
	copy: function(a) {
		THREE.Camera.prototype.copy.call(this, a);
		this.fov = a.fov;
		this.zoom = a.zoom;
		this.near = a.near;
		this.far = a.far;
		this.focus = a.focus;
		this.aspect = a.aspect;
		this.view = null === a.view ? null : Object.assign({}, a.view);
		this.filmGauge = a.filmGauge;
		this.filmOffset = a.filmOffset;
		return this
	},
	setFocalLength: function(a) {
		a = .5 * this.getFilmHeight() / a;
		this.fov = 2 * THREE.Math.RAD2DEG * Math.atan(a);
		this.updateProjectionMatrix()
	},
	getFocalLength: function() {
		var a = Math.tan(.5 * THREE.Math.DEG2RAD * this.fov);
		return .5 * this.getFilmHeight() / a
	},
	getEffectiveFOV: function() {
		return 2 * THREE.Math.RAD2DEG * Math.atan(Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom)
	},
	getFilmWidth: function() {
		return this.filmGauge * Math.min(this.aspect, 1)
	},
	getFilmHeight: function() {
		return this.filmGauge / Math.max(this.aspect, 1)
	},
	setViewOffset: function(a, b, c, d, e, f) {
		this.aspect = a / b;
		this.view = {
			fullWidth: a,
			fullHeight: b,
			offsetX: c,
			offsetY: d,
			width: e,
			height: f
		};
		this.updateProjectionMatrix()
	},
	clearViewOffset: function() {
		this.view = null;
		this.updateProjectionMatrix()
	},
	updateProjectionMatrix: function() {
		var a = this.near,
			b = a * Math.tan(.5 * THREE.Math.DEG2RAD * this.fov) / this.zoom,
			c = 2 * b,
			d = this.aspect * c,
			e = -.5 * d,
			f = this.view;
		if (null !== f) var g = f.fullWidth,
			h = f.fullHeight,
			e = e + f.offsetX * d / g,
			b = b - f.offsetY * c / h,
			d = f.width / g * d,
			c = f.height / h * c;
		f = this.filmOffset;
		0 !== f && (e += a * f / this.getFilmWidth());
		this.projectionMatrix.makeFrustum(e, e + d, b - c, b, a, this.far)
	},
	toJSON: function(a) {
		a =
			THREE.Object3D.prototype.toJSON.call(this, a);
		a.object.fov = this.fov;
		a.object.zoom = this.zoom;
		a.object.near = this.near;
		a.object.far = this.far;
		a.object.focus = this.focus;
		a.object.aspect = this.aspect;
		null !== this.view && (a.object.view = Object.assign({}, this.view));
		a.object.filmGauge = this.filmGauge;
		a.object.filmOffset = this.filmOffset;
		return a
	}
});
THREE.StereoCamera = function() {
	this.type = "StereoCamera";
	this.aspect = 1;
	this.cameraL = new THREE.PerspectiveCamera;
	this.cameraL.layers.enable(1);
	this.cameraL.matrixAutoUpdate = !1;
	this.cameraR = new THREE.PerspectiveCamera;
	this.cameraR.layers.enable(2);
	this.cameraR.matrixAutoUpdate = !1
};
Object.assign(THREE.StereoCamera.prototype, {
	update: function() {
		var a, b, c, d, e, f = new THREE.Matrix4,
			g = new THREE.Matrix4;
		return function k(l) {
			var m = a !== l.focus || b !== l.fov || c !== l.aspect * this.aspect || d !== l.near || e !== l.far;
			if (m) {
				a = l.focus;
				b = l.fov;
				c = l.aspect * this.aspect;
				d = l.near;
				e = l.far;
				var m = l.projectionMatrix.clone(),
					n = .032,
					r = n * d / a,
					t = d * Math.tan(THREE.Math.DEG2RAD * b * .5),
					u;
				g.elements[12] = -n;
				f.elements[12] = n;
				n = -t * c + r;
				u = t * c + r;
				m.elements[0] = 2 * d / (u - n);
				m.elements[8] = (u + n) / (u - n);
				this.cameraL.projectionMatrix.copy(m);
				n = -t * c - r;
				u = t * c - r;
				m.elements[0] = 2 * d / (u - n);
				m.elements[8] = (u + n) / (u - n);
				this.cameraR.projectionMatrix.copy(m)
			}
			this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(g);
			this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(f)
		}
	}()
});
THREE.Light = function(a, b) {
	THREE.Object3D.call(this);
	this.type = "Light";
	this.color = new THREE.Color(a);
	this.intensity = void 0 !== b ? b : 1;
	this.receiveShadow = void 0
};
THREE.Light.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Light,
	copy: function(a) {
		THREE.Object3D.prototype.copy.call(this, a);
		this.color.copy(a.color);
		this.intensity = a.intensity;
		return this
	},
	toJSON: function(a) {
		a = THREE.Object3D.prototype.toJSON.call(this, a);
		a.object.color = this.color.getHex();
		a.object.intensity = this.intensity;
		void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
		void 0 !== this.distance && (a.object.distance = this.distance);
		void 0 !==
			this.angle && (a.object.angle = this.angle);
		void 0 !== this.decay && (a.object.decay = this.decay);
		void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
		return a
	}
});
THREE.LightShadow = function(a) {
	this.camera = a;
	this.bias = 0;
	this.radius = 1;
	this.mapSize = new THREE.Vector2(512, 512);
	this.map = null;
	this.matrix = new THREE.Matrix4
};
Object.assign(THREE.LightShadow.prototype, {
	copy: function(a) {
		this.camera = a.camera.clone();
		this.bias = a.bias;
		this.radius = a.radius;
		this.mapSize.copy(a.mapSize);
		return this
	},
	clone: function() {
		return (new this.constructor).copy(this)
	}
});
THREE.AmbientLight = function(a, b) {
	THREE.Light.call(this, a, b);
	this.type = "AmbientLight";
	this.castShadow = void 0
};
THREE.AmbientLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
	constructor: THREE.AmbientLight
});
THREE.DirectionalLight = function(a, b) {
	THREE.Light.call(this, a, b);
	this.type = "DirectionalLight";
	this.position.set(0, 1, 0);
	this.updateMatrix();
	this.target = new THREE.Object3D;
	this.shadow = new THREE.DirectionalLightShadow
};
THREE.DirectionalLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
	constructor: THREE.DirectionalLight,
	copy: function(a) {
		THREE.Light.prototype.copy.call(this, a);
		this.target = a.target.clone();
		this.shadow = a.shadow.clone();
		return this
	}
});
THREE.DirectionalLightShadow = function(a) {
	THREE.LightShadow.call(this, new THREE.OrthographicCamera(-5, 5, 5, -5, .5, 500))
};
THREE.DirectionalLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {
	constructor: THREE.DirectionalLightShadow
});
THREE.HemisphereLight = function(a, b, c) {
	THREE.Light.call(this, a, c);
	this.type = "HemisphereLight";
	this.castShadow = void 0;
	this.position.set(0, 1, 0);
	this.updateMatrix();
	this.groundColor = new THREE.Color(b)
};
THREE.HemisphereLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
	constructor: THREE.HemisphereLight,
	copy: function(a) {
		THREE.Light.prototype.copy.call(this, a);
		this.groundColor.copy(a.groundColor);
		return this
	}
});
THREE.PointLight = function(a, b, c, d) {
	THREE.Light.call(this, a, b);
	this.type = "PointLight";
	Object.defineProperty(this, "power", {
		get: function() {
			return 4 * this.intensity * Math.PI
		},
		set: function(a) {
			this.intensity = a / (4 * Math.PI)
		}
	});
	this.distance = void 0 !== c ? c : 0;
	this.decay = void 0 !== d ? d : 1;
	this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, .5, 500))
};
THREE.PointLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
	constructor: THREE.PointLight,
	copy: function(a) {
		THREE.Light.prototype.copy.call(this, a);
		this.distance = a.distance;
		this.decay = a.decay;
		this.shadow = a.shadow.clone();
		return this
	}
});
THREE.SpotLight = function(a, b, c, d, e, f) {
	THREE.Light.call(this, a, b);
	this.type = "SpotLight";
	this.position.set(0, 1, 0);
	this.updateMatrix();
	this.target = new THREE.Object3D;
	Object.defineProperty(this, "power", {
		get: function() {
			return this.intensity * Math.PI
		},
		set: function(a) {
			this.intensity = a / Math.PI
		}
	});
	this.distance = void 0 !== c ? c : 0;
	this.angle = void 0 !== d ? d : Math.PI / 3;
	this.penumbra = void 0 !== e ? e : 0;
	this.decay = void 0 !== f ? f : 1;
	this.shadow = new THREE.SpotLightShadow
};
THREE.SpotLight.prototype = Object.assign(Object.create(THREE.Light.prototype), {
	constructor: THREE.SpotLight,
	copy: function(a) {
		THREE.Light.prototype.copy.call(this, a);
		this.distance = a.distance;
		this.angle = a.angle;
		this.penumbra = a.penumbra;
		this.decay = a.decay;
		this.target = a.target.clone();
		this.shadow = a.shadow.clone();
		return this
	}
});
THREE.SpotLightShadow = function() {
	THREE.LightShadow.call(this, new THREE.PerspectiveCamera(50, 1, .5, 500))
};
THREE.SpotLightShadow.prototype = Object.assign(Object.create(THREE.LightShadow.prototype), {
	constructor: THREE.SpotLightShadow,
	update: function(a) {
		var b = 2 * THREE.Math.RAD2DEG * a.angle,
			c = this.mapSize.width / this.mapSize.height;
		a = a.distance || 500;
		var d = this.camera;
		if (b !== d.fov || c !== d.aspect || a !== d.far) d.fov = b, d.aspect = c, d.far = a, d.updateProjectionMatrix()
	}
});
THREE.AudioLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.AudioLoader.prototype = {
	constructor: THREE.AudioLoader,
	load: function(a, b, c, d) {
		var e = new THREE.XHRLoader(this.manager);
		e.setResponseType("arraybuffer");
		e.load(a, function(a) {
			var c = THREE.AudioContext;
			c.decodeAudioData(a, function(a) {
				b(a)
			})
		}, c, d)
	}
};
THREE.Cache = {
	enabled: !1,
	files: {},
	add: function(a, b) {
		!1 !== this.enabled && (this.files[a] = b)
	},
	get: function(a) {
		if (!1 !== this.enabled) return this.files[a]
	},
	remove: function(a) {
		delete this.files[a]
	},
	clear: function() {
		this.files = {}
	}
};
THREE.Loader = function() {
	this.onLoadStart = function() {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function() {}
};
THREE.Loader.prototype = {
	constructor: THREE.Loader,
	crossOrigin: void 0,
	extractUrlBase: function(a) {
		a = a.split("/");
		if (1 === a.length) return "./";
		a.pop();
		return a.join("/") + "/"
	},
	initMaterials: function(a, b, c) {
		for (var d = [], e = 0; e < a.length; ++e) d[e] = this.createMaterial(a[e], b, c);
		return d
	},
	createMaterial: function() {
		var a, b, c;
		return function(d, e, f) {
			function g(a, c, d, g, k) {
				a = e + a;
				var l = THREE.Loader.Handlers.get(a);
				null !== l ? a = l.load(a) : (b.setCrossOrigin(f), a = b.load(a));
				void 0 !== c && (a.repeat.fromArray(c), 1 !== c[0] && (a.wrapS =
					THREE.RepeatWrapping), 1 !== c[1] && (a.wrapT = THREE.RepeatWrapping));
				void 0 !== d && a.offset.fromArray(d);
				void 0 !== g && ("repeat" === g[0] && (a.wrapS = THREE.RepeatWrapping), "mirror" === g[0] && (a.wrapS = THREE.MirroredRepeatWrapping), "repeat" === g[1] && (a.wrapT = THREE.RepeatWrapping), "mirror" === g[1] && (a.wrapT = THREE.MirroredRepeatWrapping));
				void 0 !== k && (a.anisotropy = k);
				c = THREE.Math.generateUUID();
				h[c] = a;
				return c
			}
			void 0 === a && (a = new THREE.Color);
			void 0 === b && (b = new THREE.TextureLoader);
			void 0 === c && (c = new THREE.MaterialLoader);
			var h = {},
				k = {
					uuid: THREE.Math.generateUUID(),
					type: "MeshLambertMaterial"
				},
				l;
			for (l in d) {
				var m = d[l];
				switch (l) {
					case "DbgColor":
					case "DbgIndex":
					case "opticalDensity":
					case "illumination":
						break;
					case "DbgName":
						k.name = m;
						break;
					case "blending":
						k.blending = THREE[m];
						break;
					case "colorAmbient":
					case "mapAmbient":
						console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
						break;
					case "colorDiffuse":
						k.color = a.fromArray(m).getHex();
						break;
					case "colorSpecular":
						k.specular = a.fromArray(m).getHex();
						break;
					case "colorEmissive":
						k.emissive =
							a.fromArray(m).getHex();
						break;
					case "specularCoef":
						k.shininess = m;
						break;
					case "shading":
						"basic" === m.toLowerCase() && (k.type = "MeshBasicMaterial");
						"phong" === m.toLowerCase() && (k.type = "MeshPhongMaterial");
						break;
					case "mapDiffuse":
						k.map = g(m, d.mapDiffuseRepeat, d.mapDiffuseOffset, d.mapDiffuseWrap, d.mapDiffuseAnisotropy);
						break;
					case "mapDiffuseRepeat":
					case "mapDiffuseOffset":
					case "mapDiffuseWrap":
					case "mapDiffuseAnisotropy":
						break;
					case "mapLight":
						k.lightMap = g(m, d.mapLightRepeat, d.mapLightOffset, d.mapLightWrap, d.mapLightAnisotropy);
						break;
					case "mapLightRepeat":
					case "mapLightOffset":
					case "mapLightWrap":
					case "mapLightAnisotropy":
						break;
					case "mapAO":
						k.aoMap = g(m, d.mapAORepeat, d.mapAOOffset, d.mapAOWrap, d.mapAOAnisotropy);
						break;
					case "mapAORepeat":
					case "mapAOOffset":
					case "mapAOWrap":
					case "mapAOAnisotropy":
						break;
					case "mapBump":
						k.bumpMap = g(m, d.mapBumpRepeat, d.mapBumpOffset, d.mapBumpWrap, d.mapBumpAnisotropy);
						break;
					case "mapBumpScale":
						k.bumpScale = m;
						break;
					case "mapBumpRepeat":
					case "mapBumpOffset":
					case "mapBumpWrap":
					case "mapBumpAnisotropy":
						break;
					case "mapNormal":
						k.normalMap = g(m, d.mapNormalRepeat, d.mapNormalOffset, d.mapNormalWrap, d.mapNormalAnisotropy);
						break;
					case "mapNormalFactor":
						k.normalScale = [m, m];
						break;
					case "mapNormalRepeat":
					case "mapNormalOffset":
					case "mapNormalWrap":
					case "mapNormalAnisotropy":
						break;
					case "mapSpecular":
						k.specularMap = g(m, d.mapSpecularRepeat, d.mapSpecularOffset, d.mapSpecularWrap, d.mapSpecularAnisotropy);
						break;
					case "mapSpecularRepeat":
					case "mapSpecularOffset":
					case "mapSpecularWrap":
					case "mapSpecularAnisotropy":
						break;
					case "mapAlpha":
						k.alphaMap =
							g(m, d.mapAlphaRepeat, d.mapAlphaOffset, d.mapAlphaWrap, d.mapAlphaAnisotropy);
						break;
					case "mapAlphaRepeat":
					case "mapAlphaOffset":
					case "mapAlphaWrap":
					case "mapAlphaAnisotropy":
						break;
					case "flipSided":
						k.side = THREE.BackSide;
						break;
					case "doubleSided":
						k.side = THREE.DoubleSide;
						break;
					case "transparency":
						console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
						k.opacity = m;
						break;
					case "depthTest":
					case "depthWrite":
					case "colorWrite":
					case "opacity":
					case "reflectivity":
					case "transparent":
					case "visible":
					case "wireframe":
						k[l] =
							m;
						break;
					case "vertexColors":
						!0 === m && (k.vertexColors = THREE.VertexColors);
						"face" === m && (k.vertexColors = THREE.FaceColors);
						break;
					default:
						console.error("THREE.Loader.createMaterial: Unsupported", l, m)
				}
			}
			"MeshBasicMaterial" === k.type && delete k.emissive;
			"MeshPhongMaterial" !== k.type && delete k.specular;
			1 > k.opacity && (k.transparent = !0);
			c.setTextures(h);
			return c.parse(k)
		}
	}()
};
THREE.Loader.Handlers = {
	handlers: [],
	add: function(a, b) {
		this.handlers.push(a, b)
	},
	get: function(a) {
		for (var b = this.handlers, c = 0, d = b.length; c < d; c += 2) {
			var e = b[c],
				f = b[c + 1];
			if (e.test(a)) return f
		}
		return null
	}
};
THREE.XHRLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.XHRLoader.prototype = {
	constructor: THREE.XHRLoader,
	load: function(a, b, c, d) {
		void 0 !== this.path && (a = this.path + a);
		var e = this,
			f = THREE.Cache.get(a);
		if (void 0 !== f) return b && setTimeout(function() {
			b(f)
		}, 0), f;
		var g = new XMLHttpRequest;
		g.overrideMimeType("text/plain");
		g.open("GET", a, !0);
		g.addEventListener("load", function(c) {
			var f = c.target.response;
			THREE.Cache.add(a, f);
			200 === this.status ? (b && b(f), e.manager.itemEnd(a)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."), b && b(f), e.manager.itemEnd(a)) :
				(d && d(c), e.manager.itemError(a))
		}, !1);
		void 0 !== c && g.addEventListener("progress", function(a) {
			c(a)
		}, !1);
		g.addEventListener("error", function(b) {
			d && d(b);
			e.manager.itemError(a)
		}, !1);
		void 0 !== this.responseType && (g.responseType = this.responseType);
		void 0 !== this.withCredentials && (g.withCredentials = this.withCredentials);
		g.send(null);
		e.manager.itemStart(a);
		return g
	},
	setPath: function(a) {
		this.path = a
	},
	setResponseType: function(a) {
		this.responseType = a
	},
	setWithCredentials: function(a) {
		this.withCredentials = a
	}
};
THREE.FontLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.FontLoader.prototype = {
	constructor: THREE.FontLoader,
	load: function(a, b, c, d) {
		var e = this,
			f = new THREE.XHRLoader(this.manager);
		f.load(a, function(a) {
			var c;
			try {
				c = JSON.parse(a)
			} catch (k) {
				console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c = JSON.parse(a.substring(65, a.length - 2))
			}
			a = e.parse(c);
			b && b(a)
		}, c, d)
	},
	parse: function(a) {
		return new THREE.Font(a)
	}
};
THREE.ImageLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.ImageLoader.prototype = {
	constructor: THREE.ImageLoader,
	load: function(a, b, c, d) {
		void 0 !== this.path && (a = this.path + a);
		var e = this,
			f = THREE.Cache.get(a);
		if (void 0 !== f) return e.manager.itemStart(a), b ? setTimeout(function() {
			b(f);
			e.manager.itemEnd(a)
		}, 0) : e.manager.itemEnd(a), f;
		var g = document.createElement("img");
		g.addEventListener("load", function(c) {
			THREE.Cache.add(a, this);
			b && b(this);
			e.manager.itemEnd(a)
		}, !1);
		void 0 !== c && g.addEventListener("progress", function(a) {
			c(a)
		}, !1);
		g.addEventListener("error", function(b) {
			d &&
				d(b);
			e.manager.itemError(a)
		}, !1);
		void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin);
		e.manager.itemStart(a);
		g.src = a;
		return g
	},
	setCrossOrigin: function(a) {
		this.crossOrigin = a
	},
	setPath: function(a) {
		this.path = a
	}
};
THREE.JSONLoader = function(a) {
	"boolean" === typeof a && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), a = void 0);
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this.withCredentials = !1
};
THREE.JSONLoader.prototype = {
	constructor: THREE.JSONLoader,
	get statusDomElement() {
		void 0 === this._statusDomElement && (this._statusDomElement = document.createElement("div"));
		console.warn("THREE.JSONLoader: .statusDomElement has been removed.");
		return this._statusDomElement
	},
	load: function(a, b, c, d) {
		var e = this,
			f = this.texturePath && "string" === typeof this.texturePath ? this.texturePath : THREE.Loader.prototype.extractUrlBase(a),
			g = new THREE.XHRLoader(this.manager);
		g.setWithCredentials(this.withCredentials);
		g.load(a,
			function(c) {
				c = JSON.parse(c);
				var d = c.metadata;
				if (void 0 !== d && (d = d.type, void 0 !== d)) {
					if ("object" === d.toLowerCase()) {
						console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.ObjectLoader instead.");
						return
					}
					if ("scene" === d.toLowerCase()) {
						console.error("THREE.JSONLoader: " + a + " should be loaded with THREE.SceneLoader instead.");
						return
					}
				}
				c = e.parse(c, f);
				b(c.geometry, c.materials)
			}, c, d)
	},
	setTexturePath: function(a) {
		this.texturePath = a
	},
	parse: function(a, b) {
		function c(b) {
			var c, d, e, f, h, k, w, v, x, y, D, z, G, A =
				a.faces;
			k = a.vertices;
			var H = a.normals,
				O = a.colors,
				M = 0;
			if (void 0 !== a.uvs) {
				for (c = 0; c < a.uvs.length; c++) a.uvs[c].length && M++;
				for (c = 0; c < M; c++) g.faceVertexUvs[c] = []
			}
			f = 0;
			for (h = k.length; f < h;) c = new THREE.Vector3, c.x = k[f++] * b, c.y = k[f++] * b, c.z = k[f++] * b, g.vertices.push(c);
			f = 0;
			for (h = A.length; f < h;)
				if (b = A[f++], x = b & 1, e = b & 2, c = b & 8, w = b & 16, y = b & 32, k = b & 64, b &= 128, x) {
					x = new THREE.Face3;
					x.a = A[f];
					x.b = A[f + 1];
					x.c = A[f + 3];
					D = new THREE.Face3;
					D.a = A[f + 1];
					D.b = A[f + 2];
					D.c = A[f + 3];
					f += 4;
					e && (e = A[f++], x.materialIndex = e, D.materialIndex = e);
					e =
						g.faces.length;
					if (c)
						for (c = 0; c < M; c++)
							for (z = a.uvs[c], g.faceVertexUvs[c][e] = [], g.faceVertexUvs[c][e + 1] = [], d = 0; 4 > d; d++) v = A[f++], G = z[2 * v], v = z[2 * v + 1], G = new THREE.Vector2(G, v), 2 !== d && g.faceVertexUvs[c][e].push(G), 0 !== d && g.faceVertexUvs[c][e + 1].push(G);
					w && (w = 3 * A[f++], x.normal.set(H[w++], H[w++], H[w]), D.normal.copy(x.normal));
					if (y)
						for (c = 0; 4 > c; c++) w = 3 * A[f++], y = new THREE.Vector3(H[w++], H[w++], H[w]), 2 !== c && x.vertexNormals.push(y), 0 !== c && D.vertexNormals.push(y);
					k && (k = A[f++], k = O[k], x.color.setHex(k), D.color.setHex(k));
					if (b)
						for (c = 0; 4 > c; c++) k = A[f++], k = O[k], 2 !== c && x.vertexColors.push(new THREE.Color(k)), 0 !== c && D.vertexColors.push(new THREE.Color(k));
					g.faces.push(x);
					g.faces.push(D)
				} else {
					x = new THREE.Face3;
					x.a = A[f++];
					x.b = A[f++];
					x.c = A[f++];
					e && (e = A[f++], x.materialIndex = e);
					e = g.faces.length;
					if (c)
						for (c = 0; c < M; c++)
							for (z = a.uvs[c], g.faceVertexUvs[c][e] = [], d = 0; 3 > d; d++) v = A[f++], G = z[2 * v], v = z[2 * v + 1], G = new THREE.Vector2(G, v), g.faceVertexUvs[c][e].push(G);
					w && (w = 3 * A[f++], x.normal.set(H[w++], H[w++], H[w]));
					if (y)
						for (c = 0; 3 > c; c++) w = 3 * A[f++],
							y = new THREE.Vector3(H[w++], H[w++], H[w]), x.vertexNormals.push(y);
					k && (k = A[f++], x.color.setHex(O[k]));
					if (b)
						for (c = 0; 3 > c; c++) k = A[f++], x.vertexColors.push(new THREE.Color(O[k]));
					g.faces.push(x)
				}
		}

		function d() {
			var b = void 0 !== a.influencesPerVertex ? a.influencesPerVertex : 2;
			if (a.skinWeights)
				for (var c = 0, d = a.skinWeights.length; c < d; c += b) {
					var e = a.skinWeights[c],
						f = 1 < b ? a.skinWeights[c + 1] : 0,
						h = 2 < b ? a.skinWeights[c + 2] : 0,
						u = 3 < b ? a.skinWeights[c + 3] : 0;
					g.skinWeights.push(new THREE.Vector4(e, f, h, u))
				}
			if (a.skinIndices)
				for (c = 0,
					d = a.skinIndices.length; c < d; c += b) e = a.skinIndices[c], f = 1 < b ? a.skinIndices[c + 1] : 0, h = 2 < b ? a.skinIndices[c + 2] : 0, u = 3 < b ? a.skinIndices[c + 3] : 0, g.skinIndices.push(new THREE.Vector4(e, f, h, u));
			g.bones = a.bones;
			g.bones && 0 < g.bones.length && (g.skinWeights.length !== g.skinIndices.length || g.skinIndices.length !== g.vertices.length) && console.warn("When skinning, number of vertices (" + g.vertices.length + "), skinIndices (" + g.skinIndices.length + "), and skinWeights (" + g.skinWeights.length + ") should match.")
		}

		function e(b) {
			if (void 0 !==
				a.morphTargets)
				for (var c = 0, d = a.morphTargets.length; c < d; c++) {
					g.morphTargets[c] = {};
					g.morphTargets[c].name = a.morphTargets[c].name;
					g.morphTargets[c].vertices = [];
					for (var e = g.morphTargets[c].vertices, f = a.morphTargets[c].vertices, h = 0, k = f.length; h < k; h += 3) {
						var w = new THREE.Vector3;
						w.x = f[h] * b;
						w.y = f[h + 1] * b;
						w.z = f[h + 2] * b;
						e.push(w)
					}
				}
			if (void 0 !== a.morphColors && 0 < a.morphColors.length)
				for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), b = g.faces, e = a.morphColors[0].colors,
					c = 0, d = b.length; c < d; c++) b[c].color.fromArray(e, 3 * c)
		}

		function f() {
			var b = [],
				c = [];
			void 0 !== a.animation && c.push(a.animation);
			void 0 !== a.animations && (a.animations.length ? c = c.concat(a.animations) : c.push(a.animations));
			for (var d = 0; d < c.length; d++) {
				var e = THREE.AnimationClip.parseAnimation(c[d], g.bones);
				e && b.push(e)
			}
			g.morphTargets && (c = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(g.morphTargets, 10), b = b.concat(c));
			0 < b.length && (g.animations = b)
		}
		var g = new THREE.Geometry,
			h = void 0 !== a.scale ? 1 / a.scale : 1;
		c(h);
		d();
		e(h);
		f();
		g.computeFaceNormals();
		g.computeBoundingSphere();
		if (void 0 === a.materials || 0 === a.materials.length) return {
			geometry: g
		};
		b = THREE.Loader.prototype.initMaterials(a.materials, b, this.crossOrigin);
		return {
			geometry: g,
			materials: b
		}
	}
};
THREE.LoadingManager = function(a, b, c) {
	var d = this,
		e = !1,
		f = 0,
		g = 0;
	this.onStart = void 0;
	this.onLoad = a;
	this.onProgress = b;
	this.onError = c;
	this.itemStart = function(a) {
		g++;
		if (!1 === e && void 0 !== d.onStart) d.onStart(a, f, g);
		e = !0
	};
	this.itemEnd = function(a) {
		f++;
		if (void 0 !== d.onProgress) d.onProgress(a, f, g);
		if (f === g && (e = !1, void 0 !== d.onLoad)) d.onLoad()
	};
	this.itemError = function(a) {
		if (void 0 !== d.onError) d.onError(a)
	}
};
THREE.DefaultLoadingManager = new THREE.LoadingManager;
THREE.BufferGeometryLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.BufferGeometryLoader.prototype = {
	constructor: THREE.BufferGeometryLoader,
	load: function(a, b, c, d) {
		var e = this,
			f = new THREE.XHRLoader(e.manager);
		f.load(a, function(a) {
			b(e.parse(JSON.parse(a)))
		}, c, d)
	},
	parse: function(a) {
		var b = new THREE.BufferGeometry,
			c = a.data.index,
			d = {
				Int8Array: Int8Array,
				Uint8Array: Uint8Array,
				Uint8ClampedArray: Uint8ClampedArray,
				Int16Array: Int16Array,
				Uint16Array: Uint16Array,
				Int32Array: Int32Array,
				Uint32Array: Uint32Array,
				Float32Array: Float32Array,
				Float64Array: Float64Array
			};
		void 0 !== c && (c =
			new d[c.type](c.array), b.setIndex(new THREE.BufferAttribute(c, 1)));
		var e = a.data.attributes,
			f;
		for (f in e) {
			var g = e[f],
				c = new d[g.type](g.array);
			b.addAttribute(f, new THREE.BufferAttribute(c, g.itemSize, g.normalized))
		}
		d = a.data.groups || a.data.drawcalls || a.data.offsets;
		if (void 0 !== d)
			for (f = 0, c = d.length; f !== c; ++f) e = d[f], b.addGroup(e.start, e.count, e.materialIndex);
		a = a.data.boundingSphere;
		void 0 !== a && (d = new THREE.Vector3, void 0 !== a.center && d.fromArray(a.center), b.boundingSphere = new THREE.Sphere(d, a.radius));
		return b
	}
};
THREE.MaterialLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this.textures = {}
};
THREE.MaterialLoader.prototype = {
	constructor: THREE.MaterialLoader,
	load: function(a, b, c, d) {
		var e = this,
			f = new THREE.XHRLoader(e.manager);
		f.load(a, function(a) {
			b(e.parse(JSON.parse(a)))
		}, c, d)
	},
	setTextures: function(a) {
		this.textures = a
	},
	getTexture: function(a) {
		var b = this.textures;
		void 0 === b[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
		return b[a]
	},
	parse: function(a) {
		var b = new THREE[a.type];
		void 0 !== a.uuid && (b.uuid = a.uuid);
		void 0 !== a.name && (b.name = a.name);
		void 0 !== a.color && b.color.setHex(a.color);
		void 0 !== a.roughness && (b.roughness = a.roughness);
		void 0 !== a.metalness && (b.metalness = a.metalness);
		void 0 !== a.emissive && b.emissive.setHex(a.emissive);
		void 0 !== a.specular && b.specular.setHex(a.specular);
		void 0 !== a.shininess && (b.shininess = a.shininess);
		void 0 !== a.uniforms && (b.uniforms = a.uniforms);
		void 0 !== a.vertexShader && (b.vertexShader = a.vertexShader);
		void 0 !== a.fragmentShader && (b.fragmentShader = a.fragmentShader);
		void 0 !== a.vertexColors && (b.vertexColors = a.vertexColors);
		void 0 !== a.shading && (b.shading = a.shading);
		void 0 !== a.blending && (b.blending = a.blending);
		void 0 !== a.side && (b.side = a.side);
		void 0 !== a.opacity && (b.opacity = a.opacity);
		void 0 !== a.transparent && (b.transparent = a.transparent);
		void 0 !== a.alphaTest && (b.alphaTest = a.alphaTest);
		void 0 !== a.depthTest && (b.depthTest = a.depthTest);
		void 0 !== a.depthWrite && (b.depthWrite = a.depthWrite);
		void 0 !== a.colorWrite && (b.colorWrite = a.colorWrite);
		void 0 !== a.wireframe && (b.wireframe = a.wireframe);
		void 0 !== a.wireframeLinewidth && (b.wireframeLinewidth = a.wireframeLinewidth);
		void 0 !==
			a.size && (b.size = a.size);
		void 0 !== a.sizeAttenuation && (b.sizeAttenuation = a.sizeAttenuation);
		void 0 !== a.map && (b.map = this.getTexture(a.map));
		void 0 !== a.alphaMap && (b.alphaMap = this.getTexture(a.alphaMap), b.transparent = !0);
		void 0 !== a.bumpMap && (b.bumpMap = this.getTexture(a.bumpMap));
		void 0 !== a.bumpScale && (b.bumpScale = a.bumpScale);
		void 0 !== a.normalMap && (b.normalMap = this.getTexture(a.normalMap));
		if (void 0 !== a.normalScale) {
			var c = a.normalScale;
			!1 === Array.isArray(c) && (c = [c, c]);
			b.normalScale = (new THREE.Vector2).fromArray(c)
		}
		void 0 !==
			a.displacementMap && (b.displacementMap = this.getTexture(a.displacementMap));
		void 0 !== a.displacementScale && (b.displacementScale = a.displacementScale);
		void 0 !== a.displacementBias && (b.displacementBias = a.displacementBias);
		void 0 !== a.roughnessMap && (b.roughnessMap = this.getTexture(a.roughnessMap));
		void 0 !== a.metalnessMap && (b.metalnessMap = this.getTexture(a.metalnessMap));
		void 0 !== a.emissiveMap && (b.emissiveMap = this.getTexture(a.emissiveMap));
		void 0 !== a.emissiveIntensity && (b.emissiveIntensity = a.emissiveIntensity);
		void 0 !== a.specularMap && (b.specularMap = this.getTexture(a.specularMap));
		void 0 !== a.envMap && (b.envMap = this.getTexture(a.envMap), b.combine = THREE.MultiplyOperation);
		a.reflectivity && (b.reflectivity = a.reflectivity);
		void 0 !== a.lightMap && (b.lightMap = this.getTexture(a.lightMap));
		void 0 !== a.lightMapIntensity && (b.lightMapIntensity = a.lightMapIntensity);
		void 0 !== a.aoMap && (b.aoMap = this.getTexture(a.aoMap));
		void 0 !== a.aoMapIntensity && (b.aoMapIntensity = a.aoMapIntensity);
		if (void 0 !== a.materials)
			for (var c = 0, d = a.materials.length; c <
				d; c++) b.materials.push(this.parse(a.materials[c]));
		return b
	}
};
THREE.ObjectLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this.texturePath = ""
};
THREE.ObjectLoader.prototype = {
	constructor: THREE.ObjectLoader,
	load: function(a, b, c, d) {
		"" === this.texturePath && (this.texturePath = a.substring(0, a.lastIndexOf("/") + 1));
		var e = this,
			f = new THREE.XHRLoader(e.manager);
		f.load(a, function(a) {
			e.parse(JSON.parse(a), b)
		}, c, d)
	},
	setTexturePath: function(a) {
		this.texturePath = a
	},
	setCrossOrigin: function(a) {
		this.crossOrigin = a
	},
	parse: function(a, b) {
		var c = this.parseGeometries(a.geometries),
			d = this.parseImages(a.images, function() {
				void 0 !== b && b(e)
			}),
			d = this.parseTextures(a.textures,
				d),
			d = this.parseMaterials(a.materials, d),
			e = this.parseObject(a.object, c, d);
		a.animations && (e.animations = this.parseAnimations(a.animations));
		void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
		return e
	},
	parseGeometries: function(a) {
		var b = {};
		if (void 0 !== a)
			for (var c = new THREE.JSONLoader, d = new THREE.BufferGeometryLoader, e = 0, f = a.length; e < f; e++) {
				var g, h = a[e];
				switch (h.type) {
					case "PlaneGeometry":
					case "PlaneBufferGeometry":
						g = new THREE[h.type](h.width, h.height, h.widthSegments, h.heightSegments);
						break;
					case "BoxGeometry":
					case "BoxBufferGeometry":
					case "CubeGeometry":
						g =
							new THREE[h.type](h.width, h.height, h.depth, h.widthSegments, h.heightSegments, h.depthSegments);
						break;
					case "CircleGeometry":
					case "CircleBufferGeometry":
						g = new THREE[h.type](h.radius, h.segments, h.thetaStart, h.thetaLength);
						break;
					case "CylinderGeometry":
					case "CylinderBufferGeometry":
						g = new THREE[h.type](h.radiusTop, h.radiusBottom, h.height, h.radialSegments, h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
						break;
					case "ConeGeometry":
					case "ConeBufferGeometry":
						g = new THREE[h.type](h.radius, h.height, h.radialSegments,
							h.heightSegments, h.openEnded, h.thetaStart, h.thetaLength);
						break;
					case "SphereGeometry":
					case "SphereBufferGeometry":
						g = new THREE[h.type](h.radius, h.widthSegments, h.heightSegments, h.phiStart, h.phiLength, h.thetaStart, h.thetaLength);
						break;
					case "DodecahedronGeometry":
					case "IcosahedronGeometry":
					case "OctahedronGeometry":
					case "TetrahedronGeometry":
						g = new THREE[h.type](h.radius, h.detail);
						break;
					case "RingGeometry":
					case "RingBufferGeometry":
						g = new THREE[h.type](h.innerRadius, h.outerRadius, h.thetaSegments, h.phiSegments,
							h.thetaStart, h.thetaLength);
						break;
					case "TorusGeometry":
					case "TorusBufferGeometry":
						g = new THREE[h.type](h.radius, h.tube, h.radialSegments, h.tubularSegments, h.arc);
						break;
					case "TorusKnotGeometry":
					case "TorusKnotBufferGeometry":
						g = new THREE[h.type](h.radius, h.tube, h.tubularSegments, h.radialSegments, h.p, h.q);
						break;
					case "LatheGeometry":
					case "LatheBufferGeometry":
						g = new THREE[h.type](h.points, h.segments, h.phiStart, h.phiLength);
						break;
					case "BufferGeometry":
						g = d.parse(h);
						break;
					case "Geometry":
						g = c.parse(h.data, this.texturePath).geometry;
						break;
					default:
						console.warn('THREE.ObjectLoader: Unsupported geometry type "' + h.type + '"');
						continue
				}
				g.uuid = h.uuid;
				void 0 !== h.name && (g.name = h.name);
				b[h.uuid] = g
			}
		return b
	},
	parseMaterials: function(a, b) {
		var c = {};
		if (void 0 !== a) {
			var d = new THREE.MaterialLoader;
			d.setTextures(b);
			b = 0;
			for (var e = a.length; b < e; b++) {
				var f = d.parse(a[b]);
				c[f.uuid] = f
			}
		}
		return c
	},
	parseAnimations: function(a) {
		for (var b = [], c = 0; c < a.length; c++) {
			var d = THREE.AnimationClip.parse(a[c]);
			b.push(d)
		}
		return b
	},
	parseImages: function(a, b) {
		function c(a) {
			d.manager.itemStart(a);
			return f.load(a, function() {
				d.manager.itemEnd(a)
			})
		}
		var d = this,
			e = {};
		if (void 0 !== a && 0 < a.length) {
			b = new THREE.LoadingManager(b);
			var f = new THREE.ImageLoader(b);
			f.setCrossOrigin(this.crossOrigin);
			b = 0;
			for (var g = a.length; b < g; b++) {
				var h = a[b],
					k = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h.url) ? h.url : d.texturePath + h.url;
				e[h.uuid] = c(k)
			}
		}
		return e
	},
	parseTextures: function(a, b) {
		function c(a) {
			if ("number" === typeof a) return a;
			console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
			return THREE[a]
		}
		var d = {};
		if (void 0 !== a)
			for (var e = 0, f = a.length; e < f; e++) {
				var g = a[e];
				void 0 === g.image && console.warn('THREE.ObjectLoader: No "image" specified for', g.uuid);
				void 0 === b[g.image] && console.warn("THREE.ObjectLoader: Undefined image", g.image);
				var h = new THREE.Texture(b[g.image]);
				h.needsUpdate = !0;
				h.uuid = g.uuid;
				void 0 !== g.name && (h.name = g.name);
				void 0 !== g.mapping && (h.mapping = c(g.mapping));
				void 0 !== g.offset && (h.offset = new THREE.Vector2(g.offset[0], g.offset[1]));
				void 0 !== g.repeat && (h.repeat = new THREE.Vector2(g.repeat[0],
					g.repeat[1]));
				void 0 !== g.minFilter && (h.minFilter = c(g.minFilter));
				void 0 !== g.magFilter && (h.magFilter = c(g.magFilter));
				void 0 !== g.anisotropy && (h.anisotropy = g.anisotropy);
				Array.isArray(g.wrap) && (h.wrapS = c(g.wrap[0]), h.wrapT = c(g.wrap[1]));
				d[g.uuid] = h
			}
		return d
	},
	parseObject: function() {
		var a = new THREE.Matrix4;
		return function(b, c, d) {
			function e(a) {
				void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
				return c[a]
			}

			function f(a) {
				if (void 0 !== a) return void 0 === d[a] && console.warn("THREE.ObjectLoader: Undefined material",
					a), d[a]
			}
			var g;
			switch (b.type) {
				case "Scene":
					g = new THREE.Scene;
					break;
				case "PerspectiveCamera":
					g = new THREE.PerspectiveCamera(b.fov, b.aspect, b.near, b.far);
					void 0 !== b.focus && (g.focus = b.focus);
					void 0 !== b.zoom && (g.zoom = b.zoom);
					void 0 !== b.filmGauge && (g.filmGauge = b.filmGauge);
					void 0 !== b.filmOffset && (g.filmOffset = b.filmOffset);
					void 0 !== b.view && (g.view = Object.assign({}, b.view));
					break;
				case "OrthographicCamera":
					g = new THREE.OrthographicCamera(b.left, b.right, b.top, b.bottom, b.near, b.far);
					break;
				case "AmbientLight":
					g =
						new THREE.AmbientLight(b.color, b.intensity);
					break;
				case "DirectionalLight":
					g = new THREE.DirectionalLight(b.color, b.intensity);
					break;
				case "PointLight":
					g = new THREE.PointLight(b.color, b.intensity, b.distance, b.decay);
					break;
				case "SpotLight":
					g = new THREE.SpotLight(b.color, b.intensity, b.distance, b.angle, b.penumbra, b.decay);
					break;
				case "HemisphereLight":
					g = new THREE.HemisphereLight(b.color, b.groundColor, b.intensity);
					break;
				case "Mesh":
					g = e(b.geometry);
					var h = f(b.material);
					g = g.bones && 0 < g.bones.length ? new THREE.SkinnedMesh(g,
						h) : new THREE.Mesh(g, h);
					break;
				case "LOD":
					g = new THREE.LOD;
					break;
				case "Line":
					g = new THREE.Line(e(b.geometry), f(b.material), b.mode);
					break;
				case "PointCloud":
				case "Points":
					g = new THREE.Points(e(b.geometry), f(b.material));
					break;
				case "Sprite":
					g = new THREE.Sprite(f(b.material));
					break;
				case "Group":
					g = new THREE.Group;
					break;
				default:
					g = new THREE.Object3D
			}
			g.uuid = b.uuid;
			void 0 !== b.name && (g.name = b.name);
			void 0 !== b.matrix ? (a.fromArray(b.matrix), a.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== b.position && g.position.fromArray(b.position),
				void 0 !== b.rotation && g.rotation.fromArray(b.rotation), void 0 !== b.scale && g.scale.fromArray(b.scale));
			void 0 !== b.castShadow && (g.castShadow = b.castShadow);
			void 0 !== b.receiveShadow && (g.receiveShadow = b.receiveShadow);
			void 0 !== b.visible && (g.visible = b.visible);
			void 0 !== b.userData && (g.userData = b.userData);
			if (void 0 !== b.children)
				for (var k in b.children) g.add(this.parseObject(b.children[k], c, d));
			if ("LOD" === b.type)
				for (b = b.levels, h = 0; h < b.length; h++) {
					var l = b[h];
					k = g.getObjectByProperty("uuid", l.object);
					void 0 !==
						k && g.addLevel(k, l.distance)
				}
			return g
		}
	}()
};
THREE.TextureLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.TextureLoader.prototype = {
	constructor: THREE.TextureLoader,
	load: function(a, b, c, d) {
		var e = new THREE.Texture,
			f = new THREE.ImageLoader(this.manager);
		f.setCrossOrigin(this.crossOrigin);
		f.setPath(this.path);
		f.load(a, function(a) {
			e.image = a;
			e.needsUpdate = !0;
			void 0 !== b && b(e)
		}, c, d);
		return e
	},
	setCrossOrigin: function(a) {
		this.crossOrigin = a
	},
	setPath: function(a) {
		this.path = a
	}
};
THREE.CubeTextureLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
};
THREE.CubeTextureLoader.prototype = {
	constructor: THREE.CubeTextureLoader,
	load: function(a, b, c, d) {
		function e(c) {
			g.load(a[c], function(a) {
				f.images[c] = a;
				h++;
				6 === h && (f.needsUpdate = !0, b && b(f))
			}, void 0, d)
		}
		var f = new THREE.CubeTexture,
			g = new THREE.ImageLoader(this.manager);
		g.setCrossOrigin(this.crossOrigin);
		g.setPath(this.path);
		var h = 0;
		for (c = 0; c < a.length; ++c) e(c);
		return f
	},
	setCrossOrigin: function(a) {
		this.crossOrigin = a
	},
	setPath: function(a) {
		this.path = a
	}
};
THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this._parser = null
};
THREE.BinaryTextureLoader.prototype = {
	constructor: THREE.BinaryTextureLoader,
	load: function(a, b, c, d) {
		var e = this,
			f = new THREE.DataTexture,
			g = new THREE.XHRLoader(this.manager);
		g.setResponseType("arraybuffer");
		g.load(a, function(a) {
			if (a = e._parser(a)) void 0 !== a.image ? f.image = a.image : void 0 !== a.data && (f.image.width = a.width, f.image.height = a.height, f.image.data = a.data), f.wrapS = void 0 !== a.wrapS ? a.wrapS : THREE.ClampToEdgeWrapping, f.wrapT = void 0 !== a.wrapT ? a.wrapT : THREE.ClampToEdgeWrapping, f.magFilter = void 0 !== a.magFilter ?
				a.magFilter : THREE.LinearFilter, f.minFilter = void 0 !== a.minFilter ? a.minFilter : THREE.LinearMipMapLinearFilter, f.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !== a.format && (f.format = a.format), void 0 !== a.type && (f.type = a.type), void 0 !== a.mipmaps && (f.mipmaps = a.mipmaps), 1 === a.mipmapCount && (f.minFilter = THREE.LinearFilter), f.needsUpdate = !0, b && b(f, a)
		}, c, d);
		return f
	}
};
THREE.CompressedTextureLoader = function(a) {
	this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager;
	this._parser = null
};
THREE.CompressedTextureLoader.prototype = {
	constructor: THREE.CompressedTextureLoader,
	load: function(a, b, c, d) {
		function e(e) {
			k.load(a[e], function(a) {
				a = f._parser(a, !0);
				g[e] = {
					width: a.width,
					height: a.height,
					format: a.format,
					mipmaps: a.mipmaps
				};
				l += 1;
				6 === l && (1 === a.mipmapCount && (h.minFilter = THREE.LinearFilter), h.format = a.format, h.needsUpdate = !0, b && b(h))
			}, c, d)
		}
		var f = this,
			g = [],
			h = new THREE.CompressedTexture;
		h.image = g;
		var k = new THREE.XHRLoader(this.manager);
		k.setPath(this.path);
		k.setResponseType("arraybuffer");
		if (Array.isArray(a))
			for (var l =
					0, m = 0, n = a.length; m < n; ++m) e(m);
		else k.load(a, function(a) {
			a = f._parser(a, !0);
			if (a.isCubemap)
				for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
					g[d] = {
						mipmaps: []
					};
					for (var e = 0; e < a.mipmapCount; e++) g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), g[d].format = a.format, g[d].width = a.width, g[d].height = a.height
				} else h.image.width = a.width, h.image.height = a.height, h.mipmaps = a.mipmaps;
			1 === a.mipmapCount && (h.minFilter = THREE.LinearFilter);
			h.format = a.format;
			h.needsUpdate = !0;
			b && b(h)
		}, c, d);
		return h
	},
	setPath: function(a) {
		this.path =
			a
	}
};
THREE.Material = function() {
	Object.defineProperty(this, "id", {
		value: THREE.MaterialIdCount++
	});
	this.uuid = THREE.Math.generateUUID();
	this.name = "";
	this.type = "Material";
	this.lights = this.fog = !0;
	this.blending = THREE.NormalBlending;
	this.side = THREE.FrontSide;
	this.shading = THREE.SmoothShading;
	this.vertexColors = THREE.NoColors;
	this.opacity = 1;
	this.transparent = !1;
	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;
	this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha =
		null;
	this.depthFunc = THREE.LessEqualDepth;
	this.depthWrite = this.depthTest = !0;
	this.clippingPlanes = null;
	this.clipShadows = !1;
	this.colorWrite = !0;
	this.precision = null;
	this.polygonOffset = !1;
	this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
	this.premultipliedAlpha = !1;
	this.overdraw = 0;
	this._needsUpdate = this.visible = !0
};
THREE.Material.prototype = {
	constructor: THREE.Material,
	get needsUpdate() {
		return this._needsUpdate
	},
	set needsUpdate(a) {
		!0 === a && this.update();
		this._needsUpdate = a
	},
	setValues: function(a) {
		if (void 0 !== a)
			for (var b in a) {
				var c = a[b];
				if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
				else {
					var d = this[b];
					void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d instanceof THREE.Color ? d.set(c) : d instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? d.copy(c) :
						this[b] = "overdraw" === b ? Number(c) : c
				}
			}
	},
	toJSON: function(a) {
		function b(a) {
			var b = [],
				c;
			for (c in a) {
				var d = a[c];
				delete d.metadata;
				b.push(d)
			}
			return b
		}
		var c = void 0 === a;
		c && (a = {
			textures: {},
			images: {}
		});
		var d = {
			metadata: {
				version: 4.4,
				type: "Material",
				generator: "Material.toJSON"
			}
		};
		d.uuid = this.uuid;
		d.type = this.type;
		"" !== this.name && (d.name = this.name);
		this.color instanceof THREE.Color && (d.color = this.color.getHex());
		.5 !== this.roughness && (d.roughness = this.roughness);
		.5 !== this.metalness && (d.metalness = this.metalness);
		this.emissive instanceof
		THREE.Color && (d.emissive = this.emissive.getHex());
		this.specular instanceof THREE.Color && (d.specular = this.specular.getHex());
		void 0 !== this.shininess && (d.shininess = this.shininess);
		this.map instanceof THREE.Texture && (d.map = this.map.toJSON(a).uuid);
		this.alphaMap instanceof THREE.Texture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
		this.lightMap instanceof THREE.Texture && (d.lightMap = this.lightMap.toJSON(a).uuid);
		this.bumpMap instanceof THREE.Texture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
		this.normalMap instanceof THREE.Texture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalScale = this.normalScale.toArray());
		this.displacementMap instanceof THREE.Texture && (d.displacementMap = this.displacementMap.toJSON(a).uuid, d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
		this.roughnessMap instanceof THREE.Texture && (d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
		this.metalnessMap instanceof THREE.Texture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
		this.emissiveMap instanceof THREE.Texture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
		this.specularMap instanceof THREE.Texture && (d.specularMap = this.specularMap.toJSON(a).uuid);
		this.envMap instanceof THREE.Texture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity);
		void 0 !== this.size && (d.size = this.size);
		void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
		this.blending !== THREE.NormalBlending && (d.blending = this.blending);
		this.shading !== THREE.SmoothShading &&
			(d.shading = this.shading);
		this.side !== THREE.FrontSide && (d.side = this.side);
		this.vertexColors !== THREE.NoColors && (d.vertexColors = this.vertexColors);
		1 > this.opacity && (d.opacity = this.opacity);
		!0 === this.transparent && (d.transparent = this.transparent);
		0 < this.alphaTest && (d.alphaTest = this.alphaTest);
		!0 === this.premultipliedAlpha && (d.premultipliedAlpha = this.premultipliedAlpha);
		!0 === this.wireframe && (d.wireframe = this.wireframe);
		1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
		c && (c = b(a.textures),
			a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
		return d
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.name = a.name;
		this.fog = a.fog;
		this.lights = a.lights;
		this.blending = a.blending;
		this.side = a.side;
		this.vertexColors = a.vertexColors;
		this.opacity = a.opacity;
		this.transparent = a.transparent;
		this.blendSrc = a.blendSrc;
		this.blendDst = a.blendDst;
		this.blendEquation = a.blendEquation;
		this.blendSrcAlpha = a.blendSrcAlpha;
		this.blendDstAlpha = a.blendDstAlpha;
		this.blendEquationAlpha =
			a.blendEquationAlpha;
		this.depthFunc = a.depthFunc;
		this.depthTest = a.depthTest;
		this.depthWrite = a.depthWrite;
		this.colorWrite = a.colorWrite;
		this.precision = a.precision;
		this.polygonOffset = a.polygonOffset;
		this.polygonOffsetFactor = a.polygonOffsetFactor;
		this.polygonOffsetUnits = a.polygonOffsetUnits;
		this.alphaTest = a.alphaTest;
		this.premultipliedAlpha = a.premultipliedAlpha;
		this.overdraw = a.overdraw;
		this.visible = a.visible;
		this.clipShadows = a.clipShadows;
		a = a.clippingPlanes;
		var b = null;
		if (null !== a)
			for (var c = a.length, b =
					Array(c), d = 0; d !== c; ++d) b[d] = a[d].clone();
		this.clippingPlanes = b;
		return this
	},
	update: function() {
		this.dispatchEvent({
			type: "update"
		})
	},
	dispose: function() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
};
Object.assign(THREE.Material.prototype, THREE.EventDispatcher.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "LineBasicMaterial";
	this.color = new THREE.Color(16777215);
	this.linewidth = 1;
	this.linejoin = this.linecap = "round";
	this.lights = !1;
	this.setValues(a)
};
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;
THREE.LineBasicMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.color.copy(a.color);
	this.linewidth = a.linewidth;
	this.linecap = a.linecap;
	this.linejoin = a.linejoin;
	return this
};
THREE.LineDashedMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "LineDashedMaterial";
	this.color = new THREE.Color(16777215);
	this.scale = this.linewidth = 1;
	this.dashSize = 3;
	this.gapSize = 1;
	this.lights = !1;
	this.setValues(a)
};
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;
THREE.LineDashedMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.color.copy(a.color);
	this.linewidth = a.linewidth;
	this.scale = a.scale;
	this.dashSize = a.dashSize;
	this.gapSize = a.gapSize;
	return this
};
THREE.MeshBasicMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "MeshBasicMaterial";
	this.color = new THREE.Color(16777215);
	this.aoMap = this.map = null;
	this.aoMapIntensity = 1;
	this.envMap = this.alphaMap = this.specularMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = .98;
	this.wireframe = !1;
	this.wireframeLinewidth = 1;
	this.wireframeLinejoin = this.wireframeLinecap = "round";
	this.lights = this.morphTargets = this.skinning = !1;
	this.setValues(a)
};
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;
THREE.MeshBasicMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.color.copy(a.color);
	this.map = a.map;
	this.aoMap = a.aoMap;
	this.aoMapIntensity = a.aoMapIntensity;
	this.specularMap = a.specularMap;
	this.alphaMap = a.alphaMap;
	this.envMap = a.envMap;
	this.combine = a.combine;
	this.reflectivity = a.reflectivity;
	this.refractionRatio = a.refractionRatio;
	this.wireframe = a.wireframe;
	this.wireframeLinewidth = a.wireframeLinewidth;
	this.wireframeLinecap = a.wireframeLinecap;
	this.wireframeLinejoin = a.wireframeLinejoin;
	this.skinning = a.skinning;
	this.morphTargets = a.morphTargets;
	return this
};
THREE.MeshDepthMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "MeshDepthMaterial";
	this.depthPacking = THREE.BasicDepthPacking;
	this.morphTargets = this.skinning = !1;
	this.displacementMap = this.alphaMap = this.map = null;
	this.displacementScale = 1;
	this.displacementBias = 0;
	this.wireframe = !1;
	this.wireframeLinewidth = 1;
	this.lights = this.fog = !1;
	this.setValues(a)
};
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;
THREE.MeshDepthMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.depthPacking = a.depthPacking;
	this.skinning = a.skinning;
	this.morphTargets = a.morphTargets;
	this.map = a.map;
	this.alphaMap = a.alphaMap;
	this.displacementMap = a.displacementMap;
	this.displacementScale = a.displacementScale;
	this.displacementBias = a.displacementBias;
	this.wireframe = a.wireframe;
	this.wireframeLinewidth = a.wireframeLinewidth;
	return this
};
THREE.MeshLambertMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "MeshLambertMaterial";
	this.color = new THREE.Color(16777215);
	this.lightMap = this.map = null;
	this.lightMapIntensity = 1;
	this.aoMap = null;
	this.aoMapIntensity = 1;
	this.emissive = new THREE.Color(0);
	this.emissiveIntensity = 1;
	this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = .98;
	this.wireframe = !1;
	this.wireframeLinewidth = 1;
	this.wireframeLinejoin = this.wireframeLinecap =
		"round";
	this.morphNormals = this.morphTargets = this.skinning = !1;
	this.setValues(a)
};
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;
THREE.MeshLambertMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.color.copy(a.color);
	this.map = a.map;
	this.lightMap = a.lightMap;
	this.lightMapIntensity = a.lightMapIntensity;
	this.aoMap = a.aoMap;
	this.aoMapIntensity = a.aoMapIntensity;
	this.emissive.copy(a.emissive);
	this.emissiveMap = a.emissiveMap;
	this.emissiveIntensity = a.emissiveIntensity;
	this.specularMap = a.specularMap;
	this.alphaMap = a.alphaMap;
	this.envMap = a.envMap;
	this.combine = a.combine;
	this.reflectivity = a.reflectivity;
	this.refractionRatio =
		a.refractionRatio;
	this.wireframe = a.wireframe;
	this.wireframeLinewidth = a.wireframeLinewidth;
	this.wireframeLinecap = a.wireframeLinecap;
	this.wireframeLinejoin = a.wireframeLinejoin;
	this.skinning = a.skinning;
	this.morphTargets = a.morphTargets;
	this.morphNormals = a.morphNormals;
	return this
};
THREE.MeshNormalMaterial = function(a) {
	THREE.Material.call(this, a);
	this.type = "MeshNormalMaterial";
	this.wireframe = !1;
	this.wireframeLinewidth = 1;
	this.morphTargets = this.lights = this.fog = !1;
	this.setValues(a)
};
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;
THREE.MeshNormalMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.wireframe = a.wireframe;
	this.wireframeLinewidth = a.wireframeLinewidth;
	return this
};
THREE.MeshPhongMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "MeshPhongMaterial";
	this.color = new THREE.Color(16777215);
	this.specular = new THREE.Color(1118481);
	this.shininess = 30;
	this.lightMap = this.map = null;
	this.lightMapIntensity = 1;
	this.aoMap = null;
	this.aoMapIntensity = 1;
	this.emissive = new THREE.Color(0);
	this.emissiveIntensity = 1;
	this.bumpMap = this.emissiveMap = null;
	this.bumpScale = 1;
	this.normalMap = null;
	this.normalScale = new THREE.Vector2(1, 1);
	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias =
		0;
	this.envMap = this.alphaMap = this.specularMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = .98;
	this.wireframe = !1;
	this.wireframeLinewidth = 1;
	this.wireframeLinejoin = this.wireframeLinecap = "round";
	this.morphNormals = this.morphTargets = this.skinning = !1;
	this.setValues(a)
};
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;
THREE.MeshPhongMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.color.copy(a.color);
	this.specular.copy(a.specular);
	this.shininess = a.shininess;
	this.map = a.map;
	this.lightMap = a.lightMap;
	this.lightMapIntensity = a.lightMapIntensity;
	this.aoMap = a.aoMap;
	this.aoMapIntensity = a.aoMapIntensity;
	this.emissive.copy(a.emissive);
	this.emissiveMap = a.emissiveMap;
	this.emissiveIntensity = a.emissiveIntensity;
	this.bumpMap = a.bumpMap;
	this.bumpScale = a.bumpScale;
	this.normalMap = a.normalMap;
	this.normalScale.copy(a.normalScale);
	this.displacementMap = a.displacementMap;
	this.displacementScale = a.displacementScale;
	this.displacementBias = a.displacementBias;
	this.specularMap = a.specularMap;
	this.alphaMap = a.alphaMap;
	this.envMap = a.envMap;
	this.combine = a.combine;
	this.reflectivity = a.reflectivity;
	this.refractionRatio = a.refractionRatio;
	this.wireframe = a.wireframe;
	this.wireframeLinewidth = a.wireframeLinewidth;
	this.wireframeLinecap = a.wireframeLinecap;
	this.wireframeLinejoin = a.wireframeLinejoin;
	this.skinning = a.skinning;
	this.morphTargets = a.morphTargets;
	this.morphNormals = a.morphNormals;
	return this
};
THREE.MeshStandardMaterial = function(a) {
	THREE.Material.call(this);
	this.defines = {
		STANDARD: ""
	};
	this.type = "MeshStandardMaterial";
	this.color = new THREE.Color(16777215);
	this.metalness = this.roughness = .5;
	this.lightMap = this.map = null;
	this.lightMapIntensity = 1;
	this.aoMap = null;
	this.aoMapIntensity = 1;
	this.emissive = new THREE.Color(0);
	this.emissiveIntensity = 1;
	this.bumpMap = this.emissiveMap = null;
	this.bumpScale = 1;
	this.normalMap = null;
	this.normalScale = new THREE.Vector2(1, 1);
	this.displacementMap = null;
	this.displacementScale =
		1;
	this.displacementBias = 0;
	this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
	this.envMapIntensity = 1;
	this.refractionRatio = .98;
	this.wireframe = !1;
	this.wireframeLinewidth = 1;
	this.wireframeLinejoin = this.wireframeLinecap = "round";
	this.morphNormals = this.morphTargets = this.skinning = !1;
	this.setValues(a)
};
THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;
THREE.MeshStandardMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.defines = {
		STANDARD: ""
	};
	this.color.copy(a.color);
	this.roughness = a.roughness;
	this.metalness = a.metalness;
	this.map = a.map;
	this.lightMap = a.lightMap;
	this.lightMapIntensity = a.lightMapIntensity;
	this.aoMap = a.aoMap;
	this.aoMapIntensity = a.aoMapIntensity;
	this.emissive.copy(a.emissive);
	this.emissiveMap = a.emissiveMap;
	this.emissiveIntensity = a.emissiveIntensity;
	this.bumpMap = a.bumpMap;
	this.bumpScale = a.bumpScale;
	this.normalMap =
		a.normalMap;
	this.normalScale.copy(a.normalScale);
	this.displacementMap = a.displacementMap;
	this.displacementScale = a.displacementScale;
	this.displacementBias = a.displacementBias;
	this.roughnessMap = a.roughnessMap;
	this.metalnessMap = a.metalnessMap;
	this.alphaMap = a.alphaMap;
	this.envMap = a.envMap;
	this.envMapIntensity = a.envMapIntensity;
	this.refractionRatio = a.refractionRatio;
	this.wireframe = a.wireframe;
	this.wireframeLinewidth = a.wireframeLinewidth;
	this.wireframeLinecap = a.wireframeLinecap;
	this.wireframeLinejoin = a.wireframeLinejoin;
	this.skinning = a.skinning;
	this.morphTargets = a.morphTargets;
	this.morphNormals = a.morphNormals;
	return this
};
THREE.MeshPhysicalMaterial = function(a) {
	THREE.MeshStandardMaterial.call(this);
	this.defines = {
		PHYSICAL: ""
	};
	this.type = "MeshPhysicalMaterial";
	this.reflectivity = .5;
	this.setValues(a)
};
THREE.MeshPhysicalMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype);
THREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;
THREE.MeshPhysicalMaterial.prototype.copy = function(a) {
	THREE.MeshStandardMaterial.prototype.copy.call(this, a);
	this.defines = {
		PHYSICAL: ""
	};
	this.reflectivity = a.reflectivity;
	return this
};
THREE.MultiMaterial = function(a) {
	this.uuid = THREE.Math.generateUUID();
	this.type = "MultiMaterial";
	this.materials = a instanceof Array ? a : [];
	this.visible = !0
};
THREE.MultiMaterial.prototype = {
	constructor: THREE.MultiMaterial,
	toJSON: function(a) {
		for (var b = {
				metadata: {
					version: 4.2,
					type: "material",
					generator: "MaterialExporter"
				},
				uuid: this.uuid,
				type: this.type,
				materials: []
			}, c = this.materials, d = 0, e = c.length; d < e; d++) {
			var f = c[d].toJSON(a);
			delete f.metadata;
			b.materials.push(f)
		}
		b.visible = this.visible;
		return b
	},
	clone: function() {
		for (var a = new this.constructor, b = 0; b < this.materials.length; b++) a.materials.push(this.materials[b].clone());
		a.visible = this.visible;
		return a
	}
};
THREE.PointsMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "PointsMaterial";
	this.color = new THREE.Color(16777215);
	this.map = null;
	this.size = 1;
	this.sizeAttenuation = !0;
	this.lights = !1;
	this.setValues(a)
};
THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;
THREE.PointsMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.color.copy(a.color);
	this.map = a.map;
	this.size = a.size;
	this.sizeAttenuation = a.sizeAttenuation;
	return this
};
THREE.ShaderMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "ShaderMaterial";
	this.defines = {};
	this.uniforms = {};
	this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
	this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
	this.linewidth = 1;
	this.wireframe = !1;
	this.wireframeLinewidth = 1;
	this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
	this.extensions = {
		derivatives: !1,
		fragDepth: !1,
		drawBuffers: !1,
		shaderTextureLOD: !1
	};
	this.defaultAttributeValues = {
		color: [1, 1, 1],
		uv: [0, 0],
		uv2: [0, 0]
	};
	this.index0AttributeName = void 0;
	void 0 !== a && (void 0 !== a.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
};
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;
THREE.ShaderMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.fragmentShader = a.fragmentShader;
	this.vertexShader = a.vertexShader;
	this.uniforms = THREE.UniformsUtils.clone(a.uniforms);
	this.defines = a.defines;
	this.wireframe = a.wireframe;
	this.wireframeLinewidth = a.wireframeLinewidth;
	this.lights = a.lights;
	this.clipping = a.clipping;
	this.skinning = a.skinning;
	this.morphTargets = a.morphTargets;
	this.morphNormals = a.morphNormals;
	this.extensions = a.extensions;
	return this
};
THREE.ShaderMaterial.prototype.toJSON = function(a) {
	a = THREE.Material.prototype.toJSON.call(this, a);
	a.uniforms = this.uniforms;
	a.vertexShader = this.vertexShader;
	a.fragmentShader = this.fragmentShader;
	return a
};
THREE.RawShaderMaterial = function(a) {
	THREE.ShaderMaterial.call(this, a);
	this.type = "RawShaderMaterial"
};
THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;
THREE.SpriteMaterial = function(a) {
	THREE.Material.call(this);
	this.type = "SpriteMaterial";
	this.color = new THREE.Color(16777215);
	this.map = null;
	this.rotation = 0;
	this.lights = this.fog = !1;
	this.setValues(a)
};
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;
THREE.SpriteMaterial.prototype.copy = function(a) {
	THREE.Material.prototype.copy.call(this, a);
	this.color.copy(a.color);
	this.map = a.map;
	this.rotation = a.rotation;
	return this
};
THREE.ShadowMaterial = function() {
	THREE.ShaderMaterial.call(this, {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.lights, {
			opacity: {
				value: 1
			}
		}]),
		vertexShader: THREE.ShaderChunk.shadow_vert,
		fragmentShader: THREE.ShaderChunk.shadow_frag
	});
	this.transparent = this.lights = !0;
	Object.defineProperties(this, {
		opacity: {
			enumerable: !0,
			get: function() {
				return this.uniforms.opacity.value
			},
			set: function(a) {
				this.uniforms.opacity.value = a
			}
		}
	})
};
THREE.ShadowMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype);
THREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;
THREE.Texture = function(a, b, c, d, e, f, g, h, k, l) {
	Object.defineProperty(this, "id", {
		value: THREE.TextureIdCount++
	});
	this.uuid = THREE.Math.generateUUID();
	this.sourceFile = this.name = "";
	this.image = void 0 !== a ? a : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];
	this.mapping = void 0 !== b ? b : THREE.Texture.DEFAULT_MAPPING;
	this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
	this.wrapT = void 0 !== d ? d : THREE.ClampToEdgeWrapping;
	this.magFilter = void 0 !== e ? e : THREE.LinearFilter;
	this.minFilter = void 0 !== f ? f : THREE.LinearMipMapLinearFilter;
	this.anisotropy = void 0 !== k ? k : 1;
	this.format = void 0 !== g ? g : THREE.RGBAFormat;
	this.type = void 0 !== h ? h : THREE.UnsignedByteType;
	this.offset = new THREE.Vector2(0, 0);
	this.repeat = new THREE.Vector2(1, 1);
	this.generateMipmaps = !0;
	this.premultiplyAlpha = !1;
	this.flipY = !0;
	this.unpackAlignment = 4;
	this.encoding = void 0 !== l ? l : THREE.LinearEncoding;
	this.version = 0;
	this.onUpdate = null
};
THREE.Texture.DEFAULT_IMAGE = void 0;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;
THREE.Texture.prototype = {
	constructor: THREE.Texture,
	set needsUpdate(a) {
		!0 === a && this.version++
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.image = a.image;
		this.mipmaps = a.mipmaps.slice(0);
		this.mapping = a.mapping;
		this.wrapS = a.wrapS;
		this.wrapT = a.wrapT;
		this.magFilter = a.magFilter;
		this.minFilter = a.minFilter;
		this.anisotropy = a.anisotropy;
		this.format = a.format;
		this.type = a.type;
		this.offset.copy(a.offset);
		this.repeat.copy(a.repeat);
		this.generateMipmaps = a.generateMipmaps;
		this.premultiplyAlpha =
			a.premultiplyAlpha;
		this.flipY = a.flipY;
		this.unpackAlignment = a.unpackAlignment;
		this.encoding = a.encoding;
		return this
	},
	toJSON: function(a) {
		if (void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
		var b = {
			metadata: {
				version: 4.4,
				type: "Texture",
				generator: "Texture.toJSON"
			},
			uuid: this.uuid,
			name: this.name,
			mapping: this.mapping,
			repeat: [this.repeat.x, this.repeat.y],
			offset: [this.offset.x, this.offset.y],
			wrap: [this.wrapS, this.wrapT],
			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy
		};
		if (void 0 !== this.image) {
			var c = this.image;
			void 0 === c.uuid && (c.uuid = THREE.Math.generateUUID());
			if (void 0 === a.images[c.uuid]) {
				var d = a.images,
					e = c.uuid,
					f = c.uuid,
					g;
				a: {
					g = c;
					var h;void 0 !== g.toDataURL ? h = g : (h = document.createElement("canvas"), h.width = g.width, h.height = g.height, h.getContext("2d").drawImage(g, 0, 0, g.width, g.height));g = 2048 < h.width || 2048 < h.height ? h.toDataURL("image/jpeg", .6) : h.toDataURL("image/png");
					break a;g = void 0
				}
				d[e] = {
					uuid: f,
					url: g
				}
			}
			b.image = c.uuid
		}
		return a.textures[this.uuid] = b
	},
	dispose: function() {
		this.dispatchEvent({
			type: "dispose"
		})
	},
	transformUv: function(a) {
		if (this.mapping === THREE.UVMapping) {
			a.multiply(this.repeat);
			a.add(this.offset);
			if (0 > a.x || 1 < a.x) switch (this.wrapS) {
				case THREE.RepeatWrapping:
					a.x -= Math.floor(a.x);
					break;
				case THREE.ClampToEdgeWrapping:
					a.x = 0 > a.x ? 0 : 1;
					break;
				case THREE.MirroredRepeatWrapping:
					a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
			}
			if (0 > a.y || 1 < a.y) switch (this.wrapT) {
				case THREE.RepeatWrapping:
					a.y -= Math.floor(a.y);
					break;
				case THREE.ClampToEdgeWrapping:
					a.y = 0 > a.y ? 0 : 1;
					break;
				case THREE.MirroredRepeatWrapping:
					a.y =
						1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
			}
			this.flipY && (a.y = 1 - a.y)
		}
	}
};
Object.assign(THREE.Texture.prototype, THREE.EventDispatcher.prototype);
THREE.TextureIdCount = 0;
THREE.DepthTexture = function(a, b, c, d, e, f, g, h, k) {
	THREE.Texture.call(this, null, d, e, f, g, h, THREE.DepthFormat, c, k);
	this.image = {
		width: a,
		height: b
	};
	this.type = void 0 !== c ? c : THREE.UnsignedShortType;
	this.magFilter = void 0 !== g ? g : THREE.NearestFilter;
	this.minFilter = void 0 !== h ? h : THREE.NearestFilter;
	this.generateMipmaps = this.flipY = !1
};
THREE.DepthTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DepthTexture.prototype.constructor = THREE.DepthTexture;
THREE.CanvasTexture = function(a, b, c, d, e, f, g, h, k) {
	THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
	this.needsUpdate = !0
};
THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;
THREE.CubeTexture = function(a, b, c, d, e, f, g, h, k, l) {
	a = void 0 !== a ? a : [];
	b = void 0 !== b ? b : THREE.CubeReflectionMapping;
	THREE.Texture.call(this, a, b, c, d, e, f, g, h, k, l);
	this.flipY = !1
};
THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;
Object.defineProperty(THREE.CubeTexture.prototype, "images", {
	get: function() {
		return this.image
	},
	set: function(a) {
		this.image = a
	}
});
THREE.CompressedTexture = function(a, b, c, d, e, f, g, h, k, l, m, n) {
	THREE.Texture.call(this, null, f, g, h, k, l, d, e, m, n);
	this.image = {
		width: b,
		height: c
	};
	this.mipmaps = a;
	this.generateMipmaps = this.flipY = !1
};
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;
THREE.DataTexture = function(a, b, c, d, e, f, g, h, k, l, m, n) {
	THREE.Texture.call(this, null, f, g, h, k, l, d, e, m, n);
	this.image = {
		data: a,
		width: b,
		height: c
	};
	this.magFilter = void 0 !== k ? k : THREE.NearestFilter;
	this.minFilter = void 0 !== l ? l : THREE.NearestFilter;
	this.generateMipmaps = this.flipY = !1
};
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.constructor = THREE.DataTexture;
THREE.VideoTexture = function(a, b, c, d, e, f, g, h, k) {
	function l() {
		requestAnimationFrame(l);
		a.readyState >= a.HAVE_CURRENT_DATA && (m.needsUpdate = !0)
	}
	THREE.Texture.call(this, a, b, c, d, e, f, g, h, k);
	this.generateMipmaps = !1;
	var m = this;
	l()
};
THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;
THREE.Group = function() {
	THREE.Object3D.call(this);
	this.type = "Group"
};
THREE.Group.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Group
});
THREE.Points = function(a, b) {
	THREE.Object3D.call(this);
	this.type = "Points";
	this.geometry = void 0 !== a ? a : new THREE.BufferGeometry;
	this.material = void 0 !== b ? b : new THREE.PointsMaterial({
		color: 16777215 * Math.random()
	})
};
THREE.Points.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Points,
	raycast: function() {
		var a = new THREE.Matrix4,
			b = new THREE.Ray,
			c = new THREE.Sphere;
		return function e(f, g) {
			function h(a, c) {
				var e = b.distanceSqToPoint(a);
				if (e < r) {
					a = b.closestPointToPoint(a);
					a.applyMatrix4(m);
					var h = f.ray.origin.distanceTo(a);
					h < f.near || h > f.far || g.push({
						distance: h,
						distanceToRay: Math.sqrt(e),
						point: a.clone(),
						index: c,
						face: null,
						object: k
					})
				}
			}
			var k = this,
				l = this.geometry,
				m = this.matrixWorld,
				n = f.params.Points.threshold;
			null === l.boundingSphere && l.computeBoundingSphere();
			c.copy(l.boundingSphere);
			c.applyMatrix4(m);
			if (!1 !== f.ray.intersectsSphere(c)) {
				a.getInverse(m);
				b.copy(f.ray).applyMatrix4(a);
				var n = n / ((this.scale.x + this.scale.y + this.scale.z) / 3),
					r = n * n,
					n = new THREE.Vector3;
				if (l instanceof THREE.BufferGeometry) {
					var t = l.index,
						l = l.attributes,
						l = l.position.array;
					if (null !== t)
						for (var u = t.array, t = 0, w = u.length; t < w; t++) {
							var v = u[t];
							n.fromArray(l, 3 * v);
							h(n, v)
						} else
							for (t = 0, u = l.length / 3; t < u; t++) n.fromArray(l, 3 * t), h(n, t)
				} else
					for (n =
						l.vertices, t = 0, u = n.length; t < u; t++) h(n[t], t)
			}
		}
	}(),
	clone: function() {
		return (new this.constructor(this.geometry, this.material)).copy(this)
	}
});
THREE.Line = function(a, b, c) {
	if (1 === c) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."), new THREE.LineSegments(a, b);
	THREE.Object3D.call(this);
	this.type = "Line";
	this.geometry = void 0 !== a ? a : new THREE.BufferGeometry;
	this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
		color: 16777215 * Math.random()
	})
};
THREE.Line.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Line,
	raycast: function() {
		var a = new THREE.Matrix4,
			b = new THREE.Ray,
			c = new THREE.Sphere;
		return function e(f, g) {
			var h = f.linePrecision,
				h = h * h,
				k = this.geometry,
				l = this.matrixWorld;
			null === k.boundingSphere && k.computeBoundingSphere();
			c.copy(k.boundingSphere);
			c.applyMatrix4(l);
			if (!1 !== f.ray.intersectsSphere(c)) {
				a.getInverse(l);
				b.copy(f.ray).applyMatrix4(a);
				var m = new THREE.Vector3,
					n = new THREE.Vector3,
					l = new THREE.Vector3,
					r = new THREE.Vector3,
					t = this instanceof THREE.LineSegments ? 2 : 1;
				if (k instanceof THREE.BufferGeometry) {
					var u = k.index,
						k = k.attributes,
						k = k.position.array;
					if (null !== u)
						for (var w = u.array, u = 0, v = w.length - 1; u < v; u += t) {
							var x = w[u],
								y = w[u + 1];
							m.fromArray(k, 3 * x);
							n.fromArray(k, 3 * y);
							x = b.distanceSqToSegment(m, n, r, l);
							x > h || (r.applyMatrix4(this.matrixWorld), x = f.ray.origin.distanceTo(r), x < f.near || x > f.far || g.push({
								distance: x,
								point: l.clone().applyMatrix4(this.matrixWorld),
								index: u,
								face: null,
								faceIndex: null,
								object: this
							}))
						} else
							for (u =
								0, v = k.length / 3 - 1; u < v; u += t) m.fromArray(k, 3 * u), n.fromArray(k, 3 * u + 3), x = b.distanceSqToSegment(m, n, r, l), x > h || (r.applyMatrix4(this.matrixWorld), x = f.ray.origin.distanceTo(r), x < f.near || x > f.far || g.push({
								distance: x,
								point: l.clone().applyMatrix4(this.matrixWorld),
								index: u,
								face: null,
								faceIndex: null,
								object: this
							}))
				} else if (k instanceof THREE.Geometry)
					for (m = k.vertices, n = m.length, u = 0; u < n - 1; u += t) x = b.distanceSqToSegment(m[u], m[u + 1], r, l), x > h || (r.applyMatrix4(this.matrixWorld), x = f.ray.origin.distanceTo(r), x < f.near || x > f.far ||
						g.push({
							distance: x,
							point: l.clone().applyMatrix4(this.matrixWorld),
							index: u,
							face: null,
							faceIndex: null,
							object: this
						}))
			}
		}
	}(),
	clone: function() {
		return (new this.constructor(this.geometry, this.material)).copy(this)
	}
});
THREE.LineSegments = function(a, b) {
	THREE.Line.call(this, a, b);
	this.type = "LineSegments"
};
THREE.LineSegments.prototype = Object.assign(Object.create(THREE.Line.prototype), {
	constructor: THREE.LineSegments
});
THREE.Mesh = function(a, b) {
	THREE.Object3D.call(this);
	this.type = "Mesh";
	this.geometry = void 0 !== a ? a : new THREE.BufferGeometry;
	this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
		color: 16777215 * Math.random()
	});
	this.drawMode = THREE.TrianglesDrawMode;
	this.updateMorphTargets()
};
THREE.Mesh.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Mesh,
	setDrawMode: function(a) {
		this.drawMode = a
	},
	updateMorphTargets: function() {
		if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
			this.morphTargetBase = -1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};
			for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++) this.morphTargetInfluences.push(0), this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
		}
	},
	getMorphTargetIndexByName: function(a) {
		if (void 0 !==
			this.morphTargetDictionary[a]) return this.morphTargetDictionary[a];
		console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
		return 0
	},
	raycast: function() {
		function a(a, b, c, d, e, f, g) {
			THREE.Triangle.barycoordFromPoint(a, b, c, d, w);
			e.multiplyScalar(w.x);
			f.multiplyScalar(w.y);
			g.multiplyScalar(w.z);
			e.add(f).add(g);
			return e.clone()
		}

		function b(a, b, c, d, e, f, g) {
			var h = a.material;
			c = h.side === THREE.BackSide ? c.intersectTriangle(f, e, d, !0, g) : c.intersectTriangle(d, e, f, h.side !==
				THREE.DoubleSide, g);
			if (null === c) return null;
			x.copy(g);
			x.applyMatrix4(a.matrixWorld);
			g = b.ray.origin.distanceTo(x);
			return g < b.near || g > b.far ? null : {
				distance: g,
				point: x.clone(),
				object: a
			}
		}

		function c(c, d, e, f, l, m, n, w) {
			g.fromArray(f, 3 * m);
			h.fromArray(f, 3 * n);
			k.fromArray(f, 3 * w);
			if (c = b(c, d, e, g, h, k, v)) l && (r.fromArray(l, 2 * m), t.fromArray(l, 2 * n), u.fromArray(l, 2 * w), c.uv = a(v, g, h, k, r, t, u)), c.face = new THREE.Face3(m, n, w, THREE.Triangle.normal(g, h, k)), c.faceIndex = m;
			return c
		}
		var d = new THREE.Matrix4,
			e = new THREE.Ray,
			f = new THREE.Sphere,
			g = new THREE.Vector3,
			h = new THREE.Vector3,
			k = new THREE.Vector3,
			l = new THREE.Vector3,
			m = new THREE.Vector3,
			n = new THREE.Vector3,
			r = new THREE.Vector2,
			t = new THREE.Vector2,
			u = new THREE.Vector2,
			w = new THREE.Vector3,
			v = new THREE.Vector3,
			x = new THREE.Vector3;
		return function D(w, x) {
			var z = this.geometry,
				G = this.material,
				O = this.matrixWorld;
			if (void 0 !== G && (null === z.boundingSphere && z.computeBoundingSphere(), f.copy(z.boundingSphere), f.applyMatrix4(O), !1 !== w.ray.intersectsSphere(f) && (d.getInverse(O), e.copy(w.ray).applyMatrix4(d),
					null === z.boundingBox || !1 !== e.intersectsBox(z.boundingBox)))) {
				var M, J;
				if (z instanceof THREE.BufferGeometry) {
					var P, L, G = z.index,
						O = z.attributes,
						z = O.position.array;
					void 0 !== O.uv && (M = O.uv.array);
					if (null !== G)
						for (var O = G.array, Q = 0, S = O.length; Q < S; Q += 3) {
							if (G = O[Q], P = O[Q + 1], L = O[Q + 2], J = c(this, w, e, z, M, G, P, L)) J.faceIndex = Math.floor(Q / 3), x.push(J)
						} else
							for (Q = 0, S = z.length; Q < S; Q += 9)
								if (G = Q / 3, P = G + 1, L = G + 2, J = c(this, w, e, z, M, G, P, L)) J.index = G, x.push(J)
				} else if (z instanceof THREE.Geometry) {
					var K, X, O = G instanceof THREE.MultiMaterial,
						Q = !0 === O ? G.materials : null,
						S = z.vertices;
					P = z.faces;
					L = z.faceVertexUvs[0];
					0 < L.length && (M = L);
					for (var ba = 0, ca = P.length; ba < ca; ba++) {
						var ia = P[ba];
						J = !0 === O ? Q[ia.materialIndex] : G;
						if (void 0 !== J) {
							L = S[ia.a];
							K = S[ia.b];
							X = S[ia.c];
							if (!0 === J.morphTargets) {
								J = z.morphTargets;
								var Y = this.morphTargetInfluences;
								g.set(0, 0, 0);
								h.set(0, 0, 0);
								k.set(0, 0, 0);
								for (var ha = 0, Z = J.length; ha < Z; ha++) {
									var aa = Y[ha];
									if (0 !== aa) {
										var I = J[ha].vertices;
										g.addScaledVector(l.subVectors(I[ia.a], L), aa);
										h.addScaledVector(m.subVectors(I[ia.b], K), aa);
										k.addScaledVector(n.subVectors(I[ia.c],
											X), aa)
									}
								}
								g.add(L);
								h.add(K);
								k.add(X);
								L = g;
								K = h;
								X = k
							}
							if (J = b(this, w, e, L, K, X, v)) M && (Y = M[ba], r.copy(Y[0]), t.copy(Y[1]), u.copy(Y[2]), J.uv = a(v, L, K, X, r, t, u)), J.face = ia, J.faceIndex = ba, x.push(J)
						}
					}
				}
			}
		}
	}(),
	clone: function() {
		return (new this.constructor(this.geometry, this.material)).copy(this)
	}
});
THREE.Bone = function(a) {
	THREE.Object3D.call(this);
	this.type = "Bone";
	this.skin = a
};
THREE.Bone.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Bone,
	copy: function(a) {
		THREE.Object3D.prototype.copy.call(this, a);
		this.skin = a.skin;
		return this
	}
});
THREE.Skeleton = function(a, b, c) {
	this.useVertexTexture = void 0 !== c ? c : !0;
	this.identityMatrix = new THREE.Matrix4;
	a = a || [];
	this.bones = a.slice(0);
	this.useVertexTexture ? (a = Math.sqrt(4 * this.bones.length), a = THREE.Math.nextPowerOfTwo(Math.ceil(a)), this.boneTextureHeight = this.boneTextureWidth = a = Math.max(a, 4), this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType)) :
		this.boneMatrices = new Float32Array(16 * this.bones.length);
	if (void 0 === b) this.calculateInverses();
	else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
	else
		for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], b = 0, a = this.bones.length; b < a; b++) this.boneInverses.push(new THREE.Matrix4)
};
Object.assign(THREE.Skeleton.prototype, {
	calculateInverses: function() {
		this.boneInverses = [];
		for (var a = 0, b = this.bones.length; a < b; a++) {
			var c = new THREE.Matrix4;
			this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
			this.boneInverses.push(c)
		}
	},
	pose: function() {
		for (var a, b = 0, c = this.bones.length; b < c; b++)(a = this.bones[b]) && a.matrixWorld.getInverse(this.boneInverses[b]);
		b = 0;
		for (c = this.bones.length; b < c; b++)
			if (a = this.bones[b]) a.parent ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(a.matrixWorld)) :
				a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
	},
	update: function() {
		var a = new THREE.Matrix4;
		return function c() {
			for (var d = 0, e = this.bones.length; d < e; d++) {
				var f = this.bones[d] ? this.bones[d].matrixWorld : this.identityMatrix;
				a.multiplyMatrices(f, this.boneInverses[d]);
				a.toArray(this.boneMatrices, 16 * d)
			}
			this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
		}
	}(),
	clone: function() {
		return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture)
	}
});
THREE.SkinnedMesh = function(a, b, c) {
	THREE.Mesh.call(this, a, b);
	this.type = "SkinnedMesh";
	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4;
	this.bindMatrixInverse = new THREE.Matrix4;
	a = [];
	if (this.geometry && void 0 !== this.geometry.bones) {
		for (var d, e = 0, f = this.geometry.bones.length; e < f; ++e) d = this.geometry.bones[e], b = new THREE.Bone(this), a.push(b), b.name = d.name, b.position.fromArray(d.pos), b.quaternion.fromArray(d.rotq), void 0 !== d.scl && b.scale.fromArray(d.scl);
		e = 0;
		for (f = this.geometry.bones.length; e < f; ++e) d =
			this.geometry.bones[e], -1 !== d.parent && null !== d.parent && void 0 !== a[d.parent] ? a[d.parent].add(a[e]) : this.add(a[e])
	}
	this.normalizeSkinWeights();
	this.updateMatrixWorld(!0);
	this.bind(new THREE.Skeleton(a, void 0, c), this.matrixWorld)
};
THREE.SkinnedMesh.prototype = Object.assign(Object.create(THREE.Mesh.prototype), {
	constructor: THREE.SkinnedMesh,
	bind: function(a, b) {
		this.skeleton = a;
		void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld);
		this.bindMatrix.copy(b);
		this.bindMatrixInverse.getInverse(b)
	},
	pose: function() {
		this.skeleton.pose()
	},
	normalizeSkinWeights: function() {
		if (this.geometry instanceof THREE.Geometry)
			for (var a = 0; a < this.geometry.skinWeights.length; a++) {
				var b = this.geometry.skinWeights[a],
					c =
					1 / b.lengthManhattan();
				Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0)
			} else if (this.geometry instanceof THREE.BufferGeometry)
				for (var b = new THREE.Vector4, d = this.geometry.attributes.skinWeight, a = 0; a < d.count; a++) b.x = d.getX(a), b.y = d.getY(a), b.z = d.getZ(a), b.w = d.getW(a), c = 1 / b.lengthManhattan(), Infinity !== c ? b.multiplyScalar(c) : b.set(1, 0, 0, 0), d.setXYZW(a, b.x, b.y, b.z, b.w)
	},
	updateMatrixWorld: function(a) {
		THREE.Mesh.prototype.updateMatrixWorld.call(this, !0);
		"attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) :
			"detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
	},
	clone: function() {
		return (new this.constructor(this.geometry, this.material, this.useVertexTexture)).copy(this)
	}
});
THREE.LOD = function() {
	THREE.Object3D.call(this);
	this.type = "LOD";
	Object.defineProperties(this, {
		levels: {
			enumerable: !0,
			value: []
		}
	})
};
THREE.LOD.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.LOD,
	copy: function(a) {
		THREE.Object3D.prototype.copy.call(this, a, !1);
		a = a.levels;
		for (var b = 0, c = a.length; b < c; b++) {
			var d = a[b];
			this.addLevel(d.object.clone(), d.distance)
		}
		return this
	},
	addLevel: function(a, b) {
		void 0 === b && (b = 0);
		b = Math.abs(b);
		for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
		c.splice(d, 0, {
			distance: b,
			object: a
		});
		this.add(a)
	},
	getObjectForDistance: function(a) {
		for (var b = this.levels, c = 1, d = b.length; c <
			d && !(a < b[c].distance); c++);
		return b[c - 1].object
	},
	raycast: function() {
		var a = new THREE.Vector3;
		return function c(d, e) {
			a.setFromMatrixPosition(this.matrixWorld);
			var f = d.ray.origin.distanceTo(a);
			this.getObjectForDistance(f).raycast(d, e)
		}
	}(),
	update: function() {
		var a = new THREE.Vector3,
			b = new THREE.Vector3;
		return function d(e) {
			var f = this.levels;
			if (1 < f.length) {
				a.setFromMatrixPosition(e.matrixWorld);
				b.setFromMatrixPosition(this.matrixWorld);
				e = a.distanceTo(b);
				f[0].object.visible = !0;
				for (var g = 1, h = f.length; g < h; g++)
					if (e >=
						f[g].distance) f[g - 1].object.visible = !1, f[g].object.visible = !0;
					else break;
				for (; g < h; g++) f[g].object.visible = !1
			}
		}
	}(),
	toJSON: function(a) {
		a = THREE.Object3D.prototype.toJSON.call(this, a);
		a.object.levels = [];
		for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
			var e = b[c];
			a.object.levels.push({
				object: e.object.uuid,
				distance: e.distance
			})
		}
		return a
	}
});
THREE.Sprite = function(a) {
	THREE.Object3D.call(this);
	this.type = "Sprite";
	this.material = void 0 !== a ? a : new THREE.SpriteMaterial
};
THREE.Sprite.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.Sprite,
	raycast: function() {
		var a = new THREE.Vector3;
		return function c(d, e) {
			a.setFromMatrixPosition(this.matrixWorld);
			d = d.ray.distanceSqToPoint(a);
			var f = this.scale.x * this.scale.y / 4;
			d > f || e.push({
				distance: Math.sqrt(d),
				point: this.position,
				face: null,
				object: this
			})
		}
	}(),
	clone: function() {
		return (new this.constructor(this.material)).copy(this)
	}
});
THREE.LensFlare = function(a, b, c, d, e) {
	THREE.Object3D.call(this);
	this.lensFlares = [];
	this.positionScreen = new THREE.Vector3;
	this.customUpdateCallback = void 0;
	void 0 !== a && this.add(a, b, c, d, e)
};
THREE.LensFlare.prototype = Object.assign(Object.create(THREE.Object3D.prototype), {
	constructor: THREE.LensFlare,
	copy: function(a) {
		THREE.Object3D.prototype.copy.call(this, a);
		this.positionScreen.copy(a.positionScreen);
		this.customUpdateCallback = a.customUpdateCallback;
		for (var b = 0, c = a.lensFlares.length; b < c; b++) this.lensFlares.push(a.lensFlares[b]);
		return this
	},
	add: function(a, b, c, d, e, f) {
		void 0 === b && (b = -1);
		void 0 === c && (c = 0);
		void 0 === f && (f = 1);
		void 0 === e && (e = new THREE.Color(16777215));
		void 0 === d && (d = THREE.NormalBlending);
		c = Math.min(c, Math.max(0, c));
		this.lensFlares.push({
			texture: a,
			size: b,
			distance: c,
			x: 0,
			y: 0,
			z: 0,
			scale: 1,
			rotation: 0,
			opacity: f,
			color: e,
			blending: d
		})
	},
	updateLensFlares: function() {
		var a, b = this.lensFlares.length,
			c, d = 2 * -this.positionScreen.x,
			e = 2 * -this.positionScreen.y;
		for (a = 0; a < b; a++) c = this.lensFlares[a], c.x = this.positionScreen.x + d * c.distance, c.y = this.positionScreen.y + e * c.distance, c.wantedRotation = c.x * Math.PI * .25, c.rotation += .25 * (c.wantedRotation - c.rotation)
	}
});
THREE.Scene = function() {
	THREE.Object3D.call(this);
	this.type = "Scene";
	this.overrideMaterial = this.fog = null;
	this.autoUpdate = !0
};
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.constructor = THREE.Scene;
THREE.Scene.prototype.copy = function(a, b) {
	THREE.Object3D.prototype.copy.call(this, a, b);
	null !== a.fog && (this.fog = a.fog.clone());
	null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
	this.autoUpdate = a.autoUpdate;
	this.matrixAutoUpdate = a.matrixAutoUpdate;
	return this
};
THREE.Fog = function(a, b, c) {
	this.name = "";
	this.color = new THREE.Color(a);
	this.near = void 0 !== b ? b : 1;
	this.far = void 0 !== c ? c : 1E3
};
THREE.Fog.prototype.clone = function() {
	return new THREE.Fog(this.color.getHex(), this.near, this.far)
};
THREE.FogExp2 = function(a, b) {
	this.name = "";
	this.color = new THREE.Color(a);
	this.density = void 0 !== b ? b : 2.5E-4
};
THREE.FogExp2.prototype.clone = function() {
	return new THREE.FogExp2(this.color.getHex(), this.density)
};
THREE.ShaderChunk = {};
THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
THREE.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
THREE.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
THREE.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n";
THREE.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
THREE.ShaderChunk.bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
THREE.ShaderChunk.clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n#endif\n";
THREE.ShaderChunk.clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
THREE.ShaderChunk.clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
THREE.ShaderChunk.clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
THREE.ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";
THREE.ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
THREE.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
THREE.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
THREE.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
THREE.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
THREE.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
THREE.ShaderChunk.encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
THREE.ShaderChunk.encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#else\n\t\tfloat flipNormal = 1.0;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
THREE.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
THREE.ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
THREE.ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
THREE.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
THREE.ShaderChunk.lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\n\t\t\tdirectLight.color = pointLight.color;\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tfloat flipNormal = 1.0;\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
THREE.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
THREE.ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
THREE.ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#endif\n";
THREE.ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t#endif\n};\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
THREE.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n";
THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";
THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
THREE.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";
THREE.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";
THREE.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
THREE.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t#endif\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
THREE.ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
THREE.ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
THREE.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
THREE.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
THREE.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
THREE.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";
THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
THREE.ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
THREE.ShaderChunk.tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
THREE.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
THREE.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
THREE.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
THREE.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
THREE.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
THREE.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";
THREE.UniformsUtils = {
	merge: function(a) {
		for (var b = {}, c = 0; c < a.length; c++) {
			var d = this.clone(a[c]),
				e;
			for (e in d) b[e] = d[e]
		}
		return b
	},
	clone: function(a) {
		var b = {},
			c;
		for (c in a) {
			b[c] = {};
			for (var d in a[c]) {
				var e = a[c][d];
				e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix3 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? b[c][d] = e.clone() : Array.isArray(e) ? b[c][d] = e.slice() : b[c][d] = e
			}
		}
		return b
	}
};
THREE.UniformsLib = {
	common: {
		diffuse: {
			type: "c",
			value: new THREE.Color(15658734)
		},
		opacity: {
			type: "1f",
			value: 1
		},
		map: {
			type: "t",
			value: null
		},
		offsetRepeat: {
			type: "v4",
			value: new THREE.Vector4(0, 0, 1, 1)
		},
		specularMap: {
			type: "t",
			value: null
		},
		alphaMap: {
			type: "t",
			value: null
		},
		envMap: {
			type: "t",
			value: null
		},
		flipEnvMap: {
			type: "1f",
			value: -1
		},
		reflectivity: {
			type: "1f",
			value: 1
		},
		refractionRatio: {
			type: "1f",
			value: .98
		}
	},
	aomap: {
		aoMap: {
			type: "t",
			value: null
		},
		aoMapIntensity: {
			type: "1f",
			value: 1
		}
	},
	lightmap: {
		lightMap: {
			type: "t",
			value: null
		},
		lightMapIntensity: {
			type: "1f",
			value: 1
		}
	},
	emissivemap: {
		emissiveMap: {
			type: "t",
			value: null
		}
	},
	bumpmap: {
		bumpMap: {
			type: "t",
			value: null
		},
		bumpScale: {
			type: "1f",
			value: 1
		}
	},
	normalmap: {
		normalMap: {
			type: "t",
			value: null
		},
		normalScale: {
			type: "v2",
			value: new THREE.Vector2(1, 1)
		}
	},
	displacementmap: {
		displacementMap: {
			type: "t",
			value: null
		},
		displacementScale: {
			type: "1f",
			value: 1
		},
		displacementBias: {
			type: "1f",
			value: 0
		}
	},
	roughnessmap: {
		roughnessMap: {
			type: "t",
			value: null
		}
	},
	metalnessmap: {
		metalnessMap: {
			type: "t",
			value: null
		}
	},
	fog: {
		fogDensity: {
			type: "1f",
			value: 2.5E-4
		},
		fogNear: {
			type: "1f",
			value: 1
		},
		fogFar: {
			type: "1f",
			value: 2E3
		},
		fogColor: {
			type: "c",
			value: new THREE.Color(16777215)
		}
	},
	lights: {
		ambientLightColor: {
			type: "3fv",
			value: []
		},
		directionalLights: {
			type: "sa",
			value: [],
			properties: {
				direction: {
					type: "v3"
				},
				color: {
					type: "c"
				},
				shadow: {
					type: "1i"
				},
				shadowBias: {
					type: "1f"
				},
				shadowRadius: {
					type: "1f"
				},
				shadowMapSize: {
					type: "v2"
				}
			}
		},
		directionalShadowMap: {
			type: "tv",
			value: []
		},
		directionalShadowMatrix: {
			type: "m4v",
			value: []
		},
		spotLights: {
			type: "sa",
			value: [],
			properties: {
				color: {
					type: "c"
				},
				position: {
					type: "v3"
				},
				direction: {
					type: "v3"
				},
				distance: {
					type: "1f"
				},
				coneCos: {
					type: "1f"
				},
				penumbraCos: {
					type: "1f"
				},
				decay: {
					type: "1f"
				},
				shadow: {
					type: "1i"
				},
				shadowBias: {
					type: "1f"
				},
				shadowRadius: {
					type: "1f"
				},
				shadowMapSize: {
					type: "v2"
				}
			}
		},
		spotShadowMap: {
			type: "tv",
			value: []
		},
		spotShadowMatrix: {
			type: "m4v",
			value: []
		},
		pointLights: {
			type: "sa",
			value: [],
			properties: {
				color: {
					type: "c"
				},
				position: {
					type: "v3"
				},
				decay: {
					type: "1f"
				},
				distance: {
					type: "1f"
				},
				shadow: {
					type: "1i"
				},
				shadowBias: {
					type: "1f"
				},
				shadowRadius: {
					type: "1f"
				},
				shadowMapSize: {
					type: "v2"
				}
			}
		},
		pointShadowMap: {
			type: "tv",
			value: []
		},
		pointShadowMatrix: {
			type: "m4v",
			value: []
		},
		hemisphereLights: {
			type: "sa",
			value: [],
			properties: {
				direction: {
					type: "v3"
				},
				skyColor: {
					type: "c"
				},
				groundColor: {
					type: "c"
				}
			}
		}
	},
	points: {
		diffuse: {
			type: "c",
			value: new THREE.Color(15658734)
		},
		opacity: {
			type: "1f",
			value: 1
		},
		size: {
			type: "1f",
			value: 1
		},
		scale: {
			type: "1f",
			value: 1
		},
		map: {
			type: "t",
			value: null
		},
		offsetRepeat: {
			type: "v4",
			value: new THREE.Vector4(0, 0, 1, 1)
		}
	}
};
THREE.ShaderChunk.cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\t#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk.cube_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
THREE.ShaderChunk.depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
THREE.ShaderChunk.distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";
THREE.ShaderChunk.equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk.equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight;\n\treflectedLight.directDiffuse = vec3( 0.0 );\n\treflectedLight.directSpecular = vec3( 0.0 );\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\n\treflectedLight.indirectSpecular = vec3( 0.0 );\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";
THREE.ShaderChunk.meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n\t#include <logdepthbuf_fragment>\n}\n";
THREE.ShaderChunk.normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
THREE.ShaderChunk.points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
THREE.ShaderChunk.points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderChunk.shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";
THREE.ShaderChunk.shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
THREE.ShaderLib = {
	basic: {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.fog]),
		vertexShader: THREE.ShaderChunk.meshbasic_vert,
		fragmentShader: THREE.ShaderChunk.meshbasic_frag
	},
	lambert: {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
			emissive: {
				type: "c",
				value: new THREE.Color(0)
			}
		}]),
		vertexShader: THREE.ShaderChunk.meshlambert_vert,
		fragmentShader: THREE.ShaderChunk.meshlambert_frag
	},
	phong: {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
			emissive: {
				type: "c",
				value: new THREE.Color(0)
			},
			specular: {
				type: "c",
				value: new THREE.Color(1118481)
			},
			shininess: {
				type: "1f",
				value: 30
			}
		}]),
		vertexShader: THREE.ShaderChunk.meshphong_vert,
		fragmentShader: THREE.ShaderChunk.meshphong_frag
	},
	standard: {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.roughnessmap, THREE.UniformsLib.metalnessmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
			emissive: {
				type: "c",
				value: new THREE.Color(0)
			},
			roughness: {
				type: "1f",
				value: .5
			},
			metalness: {
				type: "1f",
				value: 0
			},
			envMapIntensity: {
				type: "1f",
				value: 1
			}
		}]),
		vertexShader: THREE.ShaderChunk.meshphysical_vert,
		fragmentShader: THREE.ShaderChunk.meshphysical_frag
	},
	points: {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.points, THREE.UniformsLib.fog]),
		vertexShader: THREE.ShaderChunk.points_vert,
		fragmentShader: THREE.ShaderChunk.points_frag
	},
	dashed: {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
			scale: {
				type: "1f",
				value: 1
			},
			dashSize: {
				type: "1f",
				value: 1
			},
			totalSize: {
				type: "1f",
				value: 2
			}
		}]),
		vertexShader: THREE.ShaderChunk.linedashed_vert,
		fragmentShader: THREE.ShaderChunk.linedashed_frag
	},
	depth: {
		uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.displacementmap]),
		vertexShader: THREE.ShaderChunk.depth_vert,
		fragmentShader: THREE.ShaderChunk.depth_frag
	},
	normal: {
		uniforms: {
			opacity: {
				type: "1f",
				value: 1
			}
		},
		vertexShader: THREE.ShaderChunk.normal_vert,
		fragmentShader: THREE.ShaderChunk.normal_frag
	},
	cube: {
		uniforms: {
			tCube: {
				type: "t",
				value: null
			},
			tFlip: {
				type: "1f",
				value: -1
			}
		},
		vertexShader: THREE.ShaderChunk.cube_vert,
		fragmentShader: THREE.ShaderChunk.cube_frag
	},
	equirect: {
		uniforms: {
			tEquirect: {
				type: "t",
				value: null
			},
			tFlip: {
				type: "1f",
				value: -1
			}
		},
		vertexShader: THREE.ShaderChunk.equirect_vert,
		fragmentShader: THREE.ShaderChunk.equirect_frag
	},
	distanceRGBA: {
		uniforms: {
			lightPos: {
				type: "v3",
				value: new THREE.Vector3
			}
		},
		vertexShader: THREE.ShaderChunk.distanceRGBA_vert,
		fragmentShader: THREE.ShaderChunk.distanceRGBA_frag
	}
};
THREE.ShaderLib.physical = {
	uniforms: THREE.UniformsUtils.merge([THREE.ShaderLib.standard.uniforms, {}]),
	vertexShader: THREE.ShaderChunk.meshphysical_vert,
	fragmentShader: THREE.ShaderChunk.meshphysical_frag
};
THREE.WebGLRenderer = function(a) {
	function b(a, b, c, d) {
		!0 === ba && (a *= d, b *= d, c *= d);
		W.clearColor(a, b, c, d)
	}

	function c() {
		W.init();
		W.scissor(Ua.copy(bc).multiplyScalar(Sa));
		W.viewport(Za.copy(vb).multiplyScalar(Sa));
		b(La.r, La.g, La.b, Ia)
	}

	function d() {
		Ja = Fa = null;
		Qa = "";
		Ba = -1;
		W.reset()
	}

	function e(a) {
		a.preventDefault();
		d();
		c();
		ra.clear()
	}

	function f(a) {
		a = a.target;
		a.removeEventListener("dispose", f);
		a: {
			var b = ra.get(a);
			if (a.image && b.__image__webglTextureCube) E.deleteTexture(b.__image__webglTextureCube);
			else {
				if (void 0 ===
					b.__webglInit) break a;
				E.deleteTexture(b.__webglTexture)
			}
			ra.delete(a)
		}
		nb.textures--
	}

	function g(a) {
		a = a.target;
		a.removeEventListener("dispose", g);
		var b = ra.get(a),
			c = ra.get(a.texture);
		if (a) {
			void 0 !== c.__webglTexture && E.deleteTexture(c.__webglTexture);
			a.depthTexture && a.depthTexture.dispose();
			if (a instanceof THREE.WebGLRenderTargetCube)
				for (c = 0; 6 > c; c++) E.deleteFramebuffer(b.__webglFramebuffer[c]), b.__webglDepthbuffer && E.deleteRenderbuffer(b.__webglDepthbuffer[c]);
			else E.deleteFramebuffer(b.__webglFramebuffer),
				b.__webglDepthbuffer && E.deleteRenderbuffer(b.__webglDepthbuffer);
			ra.delete(a.texture);
			ra.delete(a)
		}
		nb.textures--
	}

	function h(a) {
		a = a.target;
		a.removeEventListener("dispose", h);
		k(a);
		ra.delete(a)
	}

	function k(a) {
		var b = ra.get(a).program;
		a.program = void 0;
		void 0 !== b && Pb.releaseProgram(b)
	}

	function l(a, b) {
		return Math.abs(b[0]) - Math.abs(a[0])
	}

	function m(a, b) {
		return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !==
			b.z ? a.z - b.z : a.id - b.id
	}

	function n(a, b) {
		return a.object.renderOrder !== b.object.renderOrder ? a.object.renderOrder - b.object.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
	}

	function r(a, b, c, d, e) {
		var f;
		c.transparent ? (d = Z, f = ++aa) : (d = Y, f = ++ha);
		f = d[f];
		void 0 !== f ? (f.id = a.id, f.object = a, f.geometry = b, f.material = c, f.z = Ka.z, f.group = e) : (f = {
			id: a.id,
			object: a,
			geometry: b,
			material: c,
			z: Ka.z,
			group: e
		}, d.push(f))
	}

	function t(a) {
		if (!dc.intersectsSphere(a)) return !1;
		var b = Ca.numPlanes;
		if (0 === b) return !0;
		var c = oa.clippingPlanes,
			d = a.center;
		a = -a.radius;
		var e = 0;
		do
			if (c[e].distanceToPoint(d) < a) return !1;
		while (++e !== b);
		return !0
	}

	function u(a, b) {
		if (!1 !== a.visible) {
			if (a.layers.test(b.layers))
				if (a instanceof THREE.Light) ia.push(a);
				else if (a instanceof THREE.Sprite) {
				var c;
				(c = !1 === a.frustumCulled) || (c = a, tb.center.set(0, 0, 0), tb.radius = .7071067811865476, tb.applyMatrix4(c.matrixWorld), c = t(tb), c = !0 === c);
				c && ma.push(a)
			} else if (a instanceof THREE.LensFlare) ka.push(a);
			else if (a instanceof THREE.ImmediateRenderObject) !0 === oa.sortObjects && (Ka.setFromMatrixPosition(a.matrixWorld),
				Ka.applyProjection(Nb)), r(a, null, a.material, Ka.z, null);
			else if (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Points) {
				a instanceof THREE.SkinnedMesh && a.skeleton.update();
				if (!(c = !1 === a.frustumCulled)) {
					c = a;
					var d = c.geometry;
					null === d.boundingSphere && d.computeBoundingSphere();
					tb.copy(d.boundingSphere).applyMatrix4(c.matrixWorld);
					c = t(tb);
					c = !0 === c
				}
				if (c) {
					var e = a.material;
					if (!0 === e.visible)
						if (!0 === oa.sortObjects && (Ka.setFromMatrixPosition(a.matrixWorld), Ka.applyProjection(Nb)), c = xb.update(a),
							e instanceof THREE.MultiMaterial)
							for (var d = c.groups, f = e.materials, e = 0, g = d.length; e < g; e++) {
								var h = d[e],
									k = f[h.materialIndex];
								!0 === k.visible && r(a, c, k, Ka.z, h)
							} else r(a, c, e, Ka.z, null)
				}
			}
			a = a.children;
			e = 0;
			for (g = a.length; e < g; e++) u(a[e], b)
		}
	}

	function w(a, b, c, d) {
		for (var e = 0, f = a.length; e < f; e++) {
			var g = a[e],
				h = g.object,
				k = g.geometry,
				l = void 0 === d ? g.material : d,
				g = g.group;
			h.modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, h.matrixWorld);
			h.normalMatrix.getNormalMatrix(h.modelViewMatrix);
			if (h instanceof THREE.ImmediateRenderObject) {
				v(l);
				var m = x(b, c, l, h);
				Qa = "";
				h.render(function(a) {
					oa.renderBufferImmediate(a, m, l)
				})
			} else oa.renderBufferDirect(b, c, k, l, h, g)
		}
	}

	function v(a) {
		a.side !== THREE.DoubleSide ? W.enable(E.CULL_FACE) : W.disable(E.CULL_FACE);
		W.setFlipSided(a.side === THREE.BackSide);
		!0 === a.transparent ? W.setBlending(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha, a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha) : W.setBlending(THREE.NoBlending);
		W.setDepthFunc(a.depthFunc);
		W.setDepthTest(a.depthTest);
		W.setDepthWrite(a.depthWrite);
		W.setColorWrite(a.colorWrite);
		W.setPolygonOffset(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
	}

	function x(a, b, c, d) {
		Ya = 0;
		var e = ra.get(c);
		if (wb) {
			if (mb || a !== Ja) {
				var f = a === Ja && c.id === Ba;
				Ca.setState(c.clippingPlanes, c.clipShadows, a, e, f)
			}
			void 0 !== e.numClippingPlanes && e.numClippingPlanes !== Ca.numPlanes && (c.needsUpdate = !0)
		}
		void 0 === e.program && (c.needsUpdate = !0);
		void 0 !== e.lightsHash && e.lightsHash !== la.hash && (c.needsUpdate = !0);
		if (c.needsUpdate) {
			a: {
				var g = c,
					l = b,
					m = d,
					f = ra.get(g),
					l = Pb.getParameters(g,
						la, l, Ca.numPlanes, m),
					m = Pb.getProgramCode(g, l),
					n = f.program,
					r = !0;
				if (void 0 === n) g.addEventListener("dispose", h);
				else if (n.code !== m) k(g);
				else if (void 0 !== l.shaderID) break a;
				else r = !1;r && (l.shaderID ? (n = THREE.ShaderLib[l.shaderID], f.__webglShader = {
						name: g.type,
						uniforms: THREE.UniformsUtils.clone(n.uniforms),
						vertexShader: n.vertexShader,
						fragmentShader: n.fragmentShader
					}) : f.__webglShader = {
						name: g.type,
						uniforms: g.uniforms,
						vertexShader: g.vertexShader,
						fragmentShader: g.fragmentShader
					}, g.__webglShader = f.__webglShader,
					n = Pb.acquireProgram(g, l, m), f.program = n, g.program = n);l = n.getAttributes();
				if (g.morphTargets)
					for (m = g.numSupportedMorphTargets = 0; m < oa.maxMorphTargets; m++) 0 <= l["morphTarget" + m] && g.numSupportedMorphTargets++;
				if (g.morphNormals)
					for (m = g.numSupportedMorphNormals = 0; m < oa.maxMorphNormals; m++) 0 <= l["morphNormal" + m] && g.numSupportedMorphNormals++;l = f.__webglShader.uniforms;
				(g instanceof THREE.ShaderMaterial || g instanceof THREE.RawShaderMaterial) && !0 !== g.clipping || (f.numClippingPlanes = Ca.numPlanes, l.clippingPlanes =
					Ca.uniform);g.lights && (f.lightsHash = la.hash, l.ambientLightColor.value = la.ambient, l.directionalLights.value = la.directional, l.spotLights.value = la.spot, l.pointLights.value = la.point, l.hemisphereLights.value = la.hemi, l.directionalShadowMap.value = la.directionalShadowMap, l.directionalShadowMatrix.value = la.directionalShadowMatrix, l.spotShadowMap.value = la.spotShadowMap, l.spotShadowMatrix.value = la.spotShadowMatrix, l.pointShadowMap.value = la.pointShadowMap, l.pointShadowMatrix.value = la.pointShadowMatrix);g = f.program.getUniforms();
				g = THREE.WebGLUniforms.seqWithValue(g.seq, l);f.uniformsList = g;f.dynamicUniforms = THREE.WebGLUniforms.splitDynamic(g, l)
			}
			c.needsUpdate = !1
		}
		m = n = r = !1;
		f = e.program;
		l = f.getUniforms();
		g = e.__webglShader.uniforms;
		f.id !== Fa && (E.useProgram(f.program), Fa = f.id, m = n = r = !0);
		c.id !== Ba && (Ba = c.id, n = !0);
		if (r || a !== Ja) {
			l.set(E, a, "projectionMatrix");
			$a.logarithmicDepthBuffer && l.setValue(E, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
			a !== Ja && (Ja = a, m = n = !0);
			if (c instanceof THREE.ShaderMaterial || c instanceof THREE.MeshPhongMaterial ||
				c instanceof THREE.MeshStandardMaterial || c.envMap) r = l.map.cameraPosition, void 0 !== r && r.setValue(E, Ka.setFromMatrixPosition(a.matrixWorld));
			(c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshLambertMaterial || c instanceof THREE.MeshBasicMaterial || c instanceof THREE.MeshStandardMaterial || c instanceof THREE.ShaderMaterial || c.skinning) && l.setValue(E, "viewMatrix", a.matrixWorldInverse);
			l.set(E, oa, "toneMappingExposure");
			l.set(E, oa, "toneMappingWhitePoint")
		}
		c.skinning && (l.setOptional(E, d, "bindMatrix"),
			l.setOptional(E, d, "bindMatrixInverse"), r = d.skeleton) && ($a.floatVertexTextures && r.useVertexTexture ? (l.set(E, r, "boneTexture"), l.set(E, r, "boneTextureWidth"), l.set(E, r, "boneTextureHeight")) : l.setOptional(E, r, "boneMatrices"));
		if (n) {
			c.lights && (n = g, n.ambientLightColor.needsUpdate = m, n.directionalLights.needsUpdate = m, n.pointLights.needsUpdate = m, n.spotLights.needsUpdate = m, n.hemisphereLights.needsUpdate = m);
			b && c.fog && (m = g, m.fogColor.value = b.color, b instanceof THREE.Fog ? (m.fogNear.value = b.near, m.fogFar.value =
				b.far) : b instanceof THREE.FogExp2 && (m.fogDensity.value = b.density));
			if (c instanceof THREE.MeshBasicMaterial || c instanceof THREE.MeshLambertMaterial || c instanceof THREE.MeshPhongMaterial || c instanceof THREE.MeshStandardMaterial || c instanceof THREE.MeshDepthMaterial) {
				b = g;
				m = c;
				b.opacity.value = m.opacity;
				b.diffuse.value = m.color;
				m.emissive && b.emissive.value.copy(m.emissive).multiplyScalar(m.emissiveIntensity);
				b.map.value = m.map;
				b.specularMap.value = m.specularMap;
				b.alphaMap.value = m.alphaMap;
				m.aoMap && (b.aoMap.value =
					m.aoMap, b.aoMapIntensity.value = m.aoMapIntensity);
				var t;
				m.map ? t = m.map : m.specularMap ? t = m.specularMap : m.displacementMap ? t = m.displacementMap : m.normalMap ? t = m.normalMap : m.bumpMap ? t = m.bumpMap : m.roughnessMap ? t = m.roughnessMap : m.metalnessMap ? t = m.metalnessMap : m.alphaMap ? t = m.alphaMap : m.emissiveMap && (t = m.emissiveMap);
				void 0 !== t && (t instanceof THREE.WebGLRenderTarget && (t = t.texture), n = t.offset, t = t.repeat, b.offsetRepeat.value.set(n.x, n.y, t.x, t.y));
				b.envMap.value = m.envMap;
				b.flipEnvMap.value = m.envMap instanceof THREE.CubeTexture ?
					-1 : 1;
				b.reflectivity.value = m.reflectivity;
				b.refractionRatio.value = m.refractionRatio
			}
			c instanceof THREE.LineBasicMaterial ? (t = g, t.diffuse.value = c.color, t.opacity.value = c.opacity) : c instanceof THREE.LineDashedMaterial ? (t = g, b = c, t.diffuse.value = b.color, t.opacity.value = b.opacity, t = g, t.dashSize.value = c.dashSize, t.totalSize.value = c.dashSize + c.gapSize, t.scale.value = c.scale) : c instanceof THREE.PointsMaterial ? (t = g, b = c, t.diffuse.value = b.color, t.opacity.value = b.opacity, t.size.value = b.size * Sa, t.scale.value = .5 * P.clientHeight,
				t.map.value = b.map, null !== b.map && (c = b.map.offset, b = b.map.repeat, t.offsetRepeat.value.set(c.x, c.y, b.x, b.y))) : c instanceof THREE.MeshLambertMaterial ? (t = g, c.lightMap && (t.lightMap.value = c.lightMap, t.lightMapIntensity.value = c.lightMapIntensity), c.emissiveMap && (t.emissiveMap.value = c.emissiveMap)) : c instanceof THREE.MeshPhongMaterial ? (t = g, t.specular.value = c.specular, t.shininess.value = Math.max(c.shininess, 1E-4), c.lightMap && (t.lightMap.value = c.lightMap, t.lightMapIntensity.value = c.lightMapIntensity), c.emissiveMap &&
				(t.emissiveMap.value = c.emissiveMap), c.bumpMap && (t.bumpMap.value = c.bumpMap, t.bumpScale.value = c.bumpScale), c.normalMap && (t.normalMap.value = c.normalMap, t.normalScale.value.copy(c.normalScale)), c.displacementMap && (t.displacementMap.value = c.displacementMap, t.displacementScale.value = c.displacementScale, t.displacementBias.value = c.displacementBias)) : c instanceof THREE.MeshPhysicalMaterial ? y(g, c) : c instanceof THREE.MeshStandardMaterial ? y(g, c) : c instanceof THREE.MeshDepthMaterial ? c.displacementMap && (g.displacementMap.value =
				c.displacementMap, g.displacementScale.value = c.displacementScale, g.displacementBias.value = c.displacementBias) : c instanceof THREE.MeshNormalMaterial && (g.opacity.value = c.opacity);
			THREE.WebGLUniforms.upload(E, e.uniformsList, g, oa)
		}
		l.set(E, d, "modelViewMatrix");
		l.set(E, d, "normalMatrix");
		l.setValue(E, "modelMatrix", d.matrixWorld);
		e = e.dynamicUniforms;
		null !== e && (THREE.WebGLUniforms.evalDynamic(e, g, d, a), THREE.WebGLUniforms.upload(E, e, g, oa));
		return f
	}

	function y(a, b) {
		a.roughness.value = b.roughness;
		a.metalness.value =
			b.metalness;
		b.roughnessMap && (a.roughnessMap.value = b.roughnessMap);
		b.metalnessMap && (a.metalnessMap.value = b.metalnessMap);
		b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity);
		b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
		b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale);
		b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale));
		b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value =
			b.displacementScale, a.displacementBias.value = b.displacementBias);
		b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
	}

	function D() {
		var a = Ya;
		a >= $a.maxTextures && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + $a.maxTextures);
		Ya += 1;
		return a
	}

	function z(a, b, c) {
		c ? (E.texParameteri(a, E.TEXTURE_WRAP_S, J(b.wrapS)), E.texParameteri(a, E.TEXTURE_WRAP_T, J(b.wrapT)), E.texParameteri(a, E.TEXTURE_MAG_FILTER, J(b.magFilter)), E.texParameteri(a, E.TEXTURE_MIN_FILTER, J(b.minFilter))) :
			(E.texParameteri(a, E.TEXTURE_WRAP_S, E.CLAMP_TO_EDGE), E.texParameteri(a, E.TEXTURE_WRAP_T, E.CLAMP_TO_EDGE), b.wrapS === THREE.ClampToEdgeWrapping && b.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", b), E.texParameteri(a, E.TEXTURE_MAG_FILTER, M(b.magFilter)), E.texParameteri(a, E.TEXTURE_MIN_FILTER, M(b.minFilter)), b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter &&
				console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", b));
		!(c = ua.get("EXT_texture_filter_anisotropic")) || b.type === THREE.FloatType && null === ua.get("OES_texture_float_linear") || b.type === THREE.HalfFloatType && null === ua.get("OES_texture_half_float_linear") || !(1 < b.anisotropy || ra.get(b).__currentAnisotropy) || (E.texParameterf(a, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, oa.getMaxAnisotropy())), ra.get(b).__currentAnisotropy =
			b.anisotropy)
	}

	function G(a, b) {
		if (a.width > b || a.height > b) {
			var c = b / Math.max(a.width, a.height);
			b = document.createElement("canvas");
			b.width = Math.floor(a.width * c);
			b.height = Math.floor(a.height * c);
			c = b.getContext("2d");
			c.drawImage(a, 0, 0, a.width, a.height, 0, 0, b.width, b.height);
			console.warn("THREE.WebGLRenderer: image is too big (" + a.width + "x" + a.height + "). Resized to " + b.width + "x" + b.height, a);
			return b
		}
		return a
	}

	function A(a) {
		return THREE.Math.isPowerOfTwo(a.width) && THREE.Math.isPowerOfTwo(a.height)
	}

	function H(a,
		b, c, d) {
		var e = J(b.texture.format),
			f = J(b.texture.type);
		W.texImage2D(d, 0, e, b.width, b.height, 0, e, f, null);
		E.bindFramebuffer(E.FRAMEBUFFER, a);
		E.framebufferTexture2D(E.FRAMEBUFFER, c, d, ra.get(b.texture).__webglTexture, 0);
		E.bindFramebuffer(E.FRAMEBUFFER, null)
	}

	function O(a, b) {
		E.bindRenderbuffer(E.RENDERBUFFER, a);
		b.depthBuffer && !b.stencilBuffer ? (E.renderbufferStorage(E.RENDERBUFFER, E.DEPTH_COMPONENT16, b.width, b.height), E.framebufferRenderbuffer(E.FRAMEBUFFER, E.DEPTH_ATTACHMENT, E.RENDERBUFFER, a)) : b.depthBuffer &&
			b.stencilBuffer ? (E.renderbufferStorage(E.RENDERBUFFER, E.DEPTH_STENCIL, b.width, b.height), E.framebufferRenderbuffer(E.FRAMEBUFFER, E.DEPTH_STENCIL_ATTACHMENT, E.RENDERBUFFER, a)) : E.renderbufferStorage(E.RENDERBUFFER, E.RGBA4, b.width, b.height);
		E.bindRenderbuffer(E.RENDERBUFFER, null)
	}

	function M(a) {
		return a === THREE.NearestFilter || a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? E.NEAREST : E.LINEAR
	}

	function J(a) {
		var b;
		if (a === THREE.RepeatWrapping) return E.REPEAT;
		if (a === THREE.ClampToEdgeWrapping) return E.CLAMP_TO_EDGE;
		if (a === THREE.MirroredRepeatWrapping) return E.MIRRORED_REPEAT;
		if (a === THREE.NearestFilter) return E.NEAREST;
		if (a === THREE.NearestMipMapNearestFilter) return E.NEAREST_MIPMAP_NEAREST;
		if (a === THREE.NearestMipMapLinearFilter) return E.NEAREST_MIPMAP_LINEAR;
		if (a === THREE.LinearFilter) return E.LINEAR;
		if (a === THREE.LinearMipMapNearestFilter) return E.LINEAR_MIPMAP_NEAREST;
		if (a === THREE.LinearMipMapLinearFilter) return E.LINEAR_MIPMAP_LINEAR;
		if (a === THREE.UnsignedByteType) return E.UNSIGNED_BYTE;
		if (a === THREE.UnsignedShort4444Type) return E.UNSIGNED_SHORT_4_4_4_4;
		if (a === THREE.UnsignedShort5551Type) return E.UNSIGNED_SHORT_5_5_5_1;
		if (a === THREE.UnsignedShort565Type) return E.UNSIGNED_SHORT_5_6_5;
		if (a === THREE.ByteType) return E.BYTE;
		if (a === THREE.ShortType) return E.SHORT;
		if (a === THREE.UnsignedShortType) return E.UNSIGNED_SHORT;
		if (a === THREE.IntType) return E.INT;
		if (a === THREE.UnsignedIntType) return E.UNSIGNED_INT;
		if (a === THREE.FloatType) return E.FLOAT;
		b = ua.get("OES_texture_half_float");
		if (null !== b && a === THREE.HalfFloatType) return b.HALF_FLOAT_OES;
		if (a === THREE.AlphaFormat) return E.ALPHA;
		if (a === THREE.RGBFormat) return E.RGB;
		if (a === THREE.RGBAFormat) return E.RGBA;
		if (a === THREE.LuminanceFormat) return E.LUMINANCE;
		if (a === THREE.LuminanceAlphaFormat) return E.LUMINANCE_ALPHA;
		if (a === THREE.DepthFormat) return E.DEPTH_COMPONENT;
		if (a === THREE.AddEquation) return E.FUNC_ADD;
		if (a === THREE.SubtractEquation) return E.FUNC_SUBTRACT;
		if (a === THREE.ReverseSubtractEquation) return E.FUNC_REVERSE_SUBTRACT;
		if (a === THREE.ZeroFactor) return E.ZERO;
		if (a === THREE.OneFactor) return E.ONE;
		if (a === THREE.SrcColorFactor) return E.SRC_COLOR;
		if (a === THREE.OneMinusSrcColorFactor) return E.ONE_MINUS_SRC_COLOR;
		if (a === THREE.SrcAlphaFactor) return E.SRC_ALPHA;
		if (a === THREE.OneMinusSrcAlphaFactor) return E.ONE_MINUS_SRC_ALPHA;
		if (a === THREE.DstAlphaFactor) return E.DST_ALPHA;
		if (a === THREE.OneMinusDstAlphaFactor) return E.ONE_MINUS_DST_ALPHA;
		if (a === THREE.DstColorFactor) return E.DST_COLOR;
		if (a === THREE.OneMinusDstColorFactor) return E.ONE_MINUS_DST_COLOR;
		if (a === THREE.SrcAlphaSaturateFactor) return E.SRC_ALPHA_SATURATE;
		b = ua.get("WEBGL_compressed_texture_s3tc");
		if (null !== b) {
			if (a === THREE.RGB_S3TC_DXT1_Format) return b.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if (a === THREE.RGBA_S3TC_DXT1_Format) return b.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if (a === THREE.RGBA_S3TC_DXT3_Format) return b.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if (a === THREE.RGBA_S3TC_DXT5_Format) return b.COMPRESSED_RGBA_S3TC_DXT5_EXT
		}
		b = ua.get("WEBGL_compressed_texture_pvrtc");
		if (null !== b) {
			if (a === THREE.RGB_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if (a === THREE.RGB_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if (a === THREE.RGBA_PVRTC_4BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if (a === THREE.RGBA_PVRTC_2BPPV1_Format) return b.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
		}
		b = ua.get("WEBGL_compressed_texture_etc1");
		if (null !== b && a === THREE.RGB_ETC1_Format) return b.COMPRESSED_RGB_ETC1_WEBGL;
		b = ua.get("EXT_blend_minmax");
		if (null !== b) {
			if (a === THREE.MinEquation) return b.MIN_EXT;
			if (a === THREE.MaxEquation) return b.MAX_EXT
		}
		return 0
	}
	console.log("THREE.WebGLRenderer", THREE.REVISION);
	a = a || {};
	var P = void 0 !== a.canvas ? a.canvas :
		document.createElement("canvas"),
		L = void 0 !== a.context ? a.context : null,
		Q = void 0 !== a.alpha ? a.alpha : !1,
		S = void 0 !== a.depth ? a.depth : !0,
		K = void 0 !== a.stencil ? a.stencil : !0,
		X = void 0 !== a.antialias ? a.antialias : !1,
		ba = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
		ca = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
		ia = [],
		Y = [],
		ha = -1,
		Z = [],
		aa = -1,
		I = new Float32Array(8),
		ma = [],
		ka = [];
	this.domElement = P;
	this.context = null;
	this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
	this.clippingPlanes = [];
	this.localClippingEnabled = !1;
	this.gammaFactor = 2;
	this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
	this.toneMapping = THREE.LinearToneMapping;
	this.toneMappingWhitePoint = this.toneMappingExposure = 1;
	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;
	this.autoScaleCubemaps = !0;
	var oa = this,
		Fa = null,
		Pa = null,
		Xa = null,
		Ba = -1,
		Qa = "",
		Ja = null,
		Ua = new THREE.Vector4,
		ac = null,
		Za = new THREE.Vector4,
		Ya = 0,
		La = new THREE.Color(0),
		Ia = 0,
		ub = P.width,
		Ra = P.height,
		Sa = 1,
		bc = new THREE.Vector4(0, 0, ub, Ra),
		cc = !1,
		vb = new THREE.Vector4(0, 0, ub, Ra),
		dc = new THREE.Frustum,
		Ca = new THREE.WebGLClipping,
		wb = !1,
		mb = !1,
		tb = new THREE.Sphere,
		Nb = new THREE.Matrix4,
		Ka = new THREE.Vector3,
		la = {
			hash: "",
			ambient: [0, 0, 0],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: [],
			shadows: []
		},
		nb = {
			geometries: 0,
			textures: 0
		},
		pa = {
			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0
		};
	this.info = {
		render: pa,
		memory: nb,
		programs: null
	};
	var E;
	try {
		var Ob = {
			alpha: Q,
			depth: S,
			stencil: K,
			antialias: X,
			premultipliedAlpha: ba,
			preserveDrawingBuffer: ca
		};
		E = L || P.getContext("webgl", Ob) || P.getContext("experimental-webgl", Ob);
		if (null === E) {
			if (null !== P.getContext("webgl")) throw "Error creating WebGL context with your selected attributes.";
			throw "Error creating WebGL context.";
		}
		void 0 === E.getShaderPrecisionFormat && (E.getShaderPrecisionFormat = function() {
			return {
				rangeMin: 1,
				rangeMax: 1,
				precision: 1
			}
		});
		P.addEventListener("webglcontextlost", e, !1)
	} catch (na) {
		console.error("THREE.WebGLRenderer: " +
			na)
	}
	var $c = "undefined" !== typeof WebGL2RenderingContext && E instanceof WebGL2RenderingContext,
		ua = new THREE.WebGLExtensions(E);
	ua.get("WEBGL_depth_texture");
	ua.get("OES_texture_float");
	ua.get("OES_texture_float_linear");
	ua.get("OES_texture_half_float");
	ua.get("OES_texture_half_float_linear");
	ua.get("OES_standard_derivatives");
	ua.get("ANGLE_instanced_arrays");
	ua.get("OES_element_index_uint") && (THREE.BufferGeometry.MaxIndex = 4294967296);
	var $a = new THREE.WebGLCapabilities(E, ua, a),
		W = new THREE.WebGLState(E,
			ua, J),
		ra = new THREE.WebGLProperties,
		xb = new THREE.WebGLObjects(E, ra, this.info),
		Pb = new THREE.WebGLPrograms(this, $a),
		ec = new THREE.WebGLLights;
	this.info.programs = Pb.programs;
	var Ge = new THREE.WebGLBufferRenderer(E, ua, pa),
		hb = new THREE.WebGLIndexedBufferRenderer(E, ua, pa);
	c();
	this.context = E;
	this.capabilities = $a;
	this.extensions = ua;
	this.properties = ra;
	this.state = W;
	var ob = new THREE.WebGLShadowMap(this, la, xb);
	this.shadowMap = ob;
	var fc = new THREE.SpritePlugin(this, ma),
		He = new THREE.LensFlarePlugin(this, ka);
	this.getContext =
		function() {
			return E
		};
	this.getContextAttributes = function() {
		return E.getContextAttributes()
	};
	this.forceContextLoss = function() {
		ua.get("WEBGL_lose_context").loseContext()
	};
	this.getMaxAnisotropy = function() {
		var a;
		return function uc() {
			if (void 0 !== a) return a;
			var b = ua.get("EXT_texture_filter_anisotropic");
			return a = null !== b ? E.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
		}
	}();
	this.getPrecision = function() {
		return $a.precision
	};
	this.getPixelRatio = function() {
		return Sa
	};
	this.setPixelRatio = function(a) {
		void 0 !==
			a && (Sa = a, this.setSize(vb.z, vb.w, !1))
	};
	this.getSize = function() {
		return {
			width: ub,
			height: Ra
		}
	};
	this.setSize = function(a, b, c) {
		ub = a;
		Ra = b;
		P.width = a * Sa;
		P.height = b * Sa;
		!1 !== c && (P.style.width = a + "px", P.style.height = b + "px");
		this.setViewport(0, 0, a, b)
	};
	this.setViewport = function(a, b, c, d) {
		W.viewport(vb.set(a, b, c, d))
	};
	this.setScissor = function(a, b, c, d) {
		W.scissor(bc.set(a, b, c, d))
	};
	this.setScissorTest = function(a) {
		W.setScissorTest(cc = a)
	};
	this.getClearColor = function() {
		return La
	};
	this.setClearColor = function(a, c) {
		La.set(a);
		Ia = void 0 !== c ? c : 1;
		b(La.r, La.g, La.b, Ia)
	};
	this.getClearAlpha = function() {
		return Ia
	};
	this.setClearAlpha = function(a) {
		Ia = a;
		b(La.r, La.g, La.b, Ia)
	};
	this.clear = function(a, b, c) {
		var d = 0;
		if (void 0 === a || a) d |= E.COLOR_BUFFER_BIT;
		if (void 0 === b || b) d |= E.DEPTH_BUFFER_BIT;
		if (void 0 === c || c) d |= E.STENCIL_BUFFER_BIT;
		E.clear(d)
	};
	this.clearColor = function() {
		this.clear(!0, !1, !1)
	};
	this.clearDepth = function() {
		this.clear(!1, !0, !1)
	};
	this.clearStencil = function() {
		this.clear(!1, !1, !0)
	};
	this.clearTarget = function(a, b, c, d) {
		this.setRenderTarget(a);
		this.clear(b, c, d)
	};
	this.resetGLState = d;
	this.dispose = function() {
		P.removeEventListener("webglcontextlost", e, !1)
	};
	this.renderBufferImmediate = function(a, b, c) {
		W.initAttributes();
		var d = ra.get(a);
		a.hasPositions && !d.position && (d.position = E.createBuffer());
		a.hasNormals && !d.normal && (d.normal = E.createBuffer());
		a.hasUvs && !d.uv && (d.uv = E.createBuffer());
		a.hasColors && !d.color && (d.color = E.createBuffer());
		b = b.getAttributes();
		a.hasPositions && (E.bindBuffer(E.ARRAY_BUFFER, d.position), E.bufferData(E.ARRAY_BUFFER, a.positionArray,
			E.DYNAMIC_DRAW), W.enableAttribute(b.position), E.vertexAttribPointer(b.position, 3, E.FLOAT, !1, 0, 0));
		if (a.hasNormals) {
			E.bindBuffer(E.ARRAY_BUFFER, d.normal);
			if ("MeshPhongMaterial" !== c.type && "MeshStandardMaterial" !== c.type && "MeshPhysicalMaterial" !== c.type && c.shading === THREE.FlatShading)
				for (var e = 0, f = 3 * a.count; e < f; e += 9) {
					var g = a.normalArray,
						h = (g[e + 0] + g[e + 3] + g[e + 6]) / 3,
						k = (g[e + 1] + g[e + 4] + g[e + 7]) / 3,
						l = (g[e + 2] + g[e + 5] + g[e + 8]) / 3;
					g[e + 0] = h;
					g[e + 1] = k;
					g[e + 2] = l;
					g[e + 3] = h;
					g[e + 4] = k;
					g[e + 5] = l;
					g[e + 6] = h;
					g[e + 7] = k;
					g[e + 8] = l
				}
			E.bufferData(E.ARRAY_BUFFER,
				a.normalArray, E.DYNAMIC_DRAW);
			W.enableAttribute(b.normal);
			E.vertexAttribPointer(b.normal, 3, E.FLOAT, !1, 0, 0)
		}
		a.hasUvs && c.map && (E.bindBuffer(E.ARRAY_BUFFER, d.uv), E.bufferData(E.ARRAY_BUFFER, a.uvArray, E.DYNAMIC_DRAW), W.enableAttribute(b.uv), E.vertexAttribPointer(b.uv, 2, E.FLOAT, !1, 0, 0));
		a.hasColors && c.vertexColors !== THREE.NoColors && (E.bindBuffer(E.ARRAY_BUFFER, d.color), E.bufferData(E.ARRAY_BUFFER, a.colorArray, E.DYNAMIC_DRAW), W.enableAttribute(b.color), E.vertexAttribPointer(b.color, 3, E.FLOAT, !1, 0, 0));
		W.disableUnusedAttributes();
		E.drawArrays(E.TRIANGLES, 0, a.count);
		a.count = 0
	};
	this.renderBufferDirect = function(a, b, c, d, e, f) {
		v(d);
		var g = x(a, b, d, e),
			h = !1;
		a = c.id + "_" + g.id + "_" + d.wireframe;
		a !== Qa && (Qa = a, h = !0);
		b = e.morphTargetInfluences;
		if (void 0 !== b) {
			a = [];
			for (var k = 0, h = b.length; k < h; k++) {
				var m = b[k];
				a.push([m, k])
			}
			a.sort(l);
			8 < a.length && (a.length = 8);
			for (var n = c.morphAttributes, k = 0, h = a.length; k < h; k++) m = a[k], I[k] = m[0], 0 !== m[0] ? (b = m[1], !0 === d.morphTargets && n.position && c.addAttribute("morphTarget" + k, n.position[b]), !0 === d.morphNormals && n.normal &&
				c.addAttribute("morphNormal" + k, n.normal[b])) : (!0 === d.morphTargets && c.removeAttribute("morphTarget" + k), !0 === d.morphNormals && c.removeAttribute("morphNormal" + k));
			g.getUniforms().setValue(E, "morphTargetInfluences", I);
			h = !0
		}
		b = c.index;
		k = c.attributes.position;
		!0 === d.wireframe && (b = xb.getWireframeAttribute(c));
		null !== b ? (a = hb, a.setIndex(b)) : a = Ge;
		if (h) {
			a: {
				var r = d,
					n = g,
					g = c,
					h = void 0,
					t;
				if (g instanceof THREE.InstancedBufferGeometry && (t = ua.get("ANGLE_instanced_arrays"), null === t)) {
					console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
					break a
				}
				void 0 === h && (h = 0);W.initAttributes();
				var m = g.attributes,
					n = n.getAttributes(),
					r = r.defaultAttributeValues,
					u;
				for (u in n) {
					var w = n[u];
					if (0 <= w) {
						var y = m[u];
						if (void 0 !== y) {
							var z = E.FLOAT,
								A = y.array,
								K = y.normalized;
							A instanceof Float32Array ? z = E.FLOAT : A instanceof Float64Array ? console.warn("Unsupported data buffer format: Float64Array") : A instanceof Uint16Array ? z = E.UNSIGNED_SHORT : A instanceof Int16Array ? z = E.SHORT : A instanceof Uint32Array ? z = E.UNSIGNED_INT : A instanceof Int32Array ? z = E.INT : A instanceof Int8Array ?
								z = E.BYTE : A instanceof Uint8Array && (z = E.UNSIGNED_BYTE);
							var A = y.itemSize,
								D = xb.getAttributeBuffer(y);
							if (y instanceof THREE.InterleavedBufferAttribute) {
								var G = y.data,
									J = G.stride,
									y = y.offset;
								G instanceof THREE.InstancedInterleavedBuffer ? (W.enableAttributeAndDivisor(w, G.meshPerAttribute, t), void 0 === g.maxInstancedCount && (g.maxInstancedCount = G.meshPerAttribute * G.count)) : W.enableAttribute(w);
								E.bindBuffer(E.ARRAY_BUFFER, D);
								E.vertexAttribPointer(w, A, z, K, J * G.array.BYTES_PER_ELEMENT, (h * J + y) * G.array.BYTES_PER_ELEMENT)
							} else y instanceof
							THREE.InstancedBufferAttribute ? (W.enableAttributeAndDivisor(w, y.meshPerAttribute, t), void 0 === g.maxInstancedCount && (g.maxInstancedCount = y.meshPerAttribute * y.count)) : W.enableAttribute(w), E.bindBuffer(E.ARRAY_BUFFER, D), E.vertexAttribPointer(w, A, z, K, 0, h * A * y.array.BYTES_PER_ELEMENT)
						} else if (void 0 !== r && (z = r[u], void 0 !== z)) switch (z.length) {
							case 2:
								E.vertexAttrib2fv(w, z);
								break;
							case 3:
								E.vertexAttrib3fv(w, z);
								break;
							case 4:
								E.vertexAttrib4fv(w, z);
								break;
							default:
								E.vertexAttrib1fv(w, z)
						}
					}
				}
				W.disableUnusedAttributes()
			}
			null !==
			b && E.bindBuffer(E.ELEMENT_ARRAY_BUFFER, xb.getAttributeBuffer(b))
		}
		t = Infinity;
		null !== b ? t = b.count : void 0 !== k && (t = k.count);
		u = c.drawRange.start;
		b = c.drawRange.count;
		k = null !== f ? f.start : 0;
		g = null !== f ? f.count : Infinity;
		f = Math.max(0, u, k);
		t = Math.min(0 + t, u + b, k + g) - 1;
		t = Math.max(0, t - f + 1);
		if (e instanceof THREE.Mesh)
			if (!0 === d.wireframe) W.setLineWidth(d.wireframeLinewidth * (null === Pa ? Sa : 1)), a.setMode(E.LINES);
			else switch (e.drawMode) {
				case THREE.TrianglesDrawMode:
					a.setMode(E.TRIANGLES);
					break;
				case THREE.TriangleStripDrawMode:
					a.setMode(E.TRIANGLE_STRIP);
					break;
				case THREE.TriangleFanDrawMode:
					a.setMode(E.TRIANGLE_FAN)
			} else e instanceof THREE.Line ? (d = d.linewidth, void 0 === d && (d = 1), W.setLineWidth(d * (null === Pa ? Sa : 1)), e instanceof THREE.LineSegments ? a.setMode(E.LINES) : a.setMode(E.LINE_STRIP)) : e instanceof THREE.Points && a.setMode(E.POINTS);
		c instanceof THREE.InstancedBufferGeometry ? 0 < c.maxInstancedCount && a.renderInstances(c, f, t) : a.render(f, t)
	};
	this.render = function(a, b, c, d) {
		if (!1 === b instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
		else {
			var e = a.fog;
			Qa = "";
			Ba = -1;
			Ja = null;
			!0 === a.autoUpdate && a.updateMatrixWorld();
			null === b.parent && b.updateMatrixWorld();
			b.matrixWorldInverse.getInverse(b.matrixWorld);
			Nb.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
			dc.setFromMatrix(Nb);
			ia.length = 0;
			aa = ha = -1;
			ma.length = 0;
			ka.length = 0;
			mb = this.localClippingEnabled;
			wb = Ca.init(this.clippingPlanes, mb, b);
			u(a, b);
			Y.length = ha + 1;
			Z.length = aa + 1;
			!0 === oa.sortObjects && (Y.sort(m), Z.sort(n));
			wb && Ca.beginShadows();
			for (var f = ia, g = 0, h = 0, k = f.length; h < k; h++) {
				var l =
					f[h];
				l.castShadow && (la.shadows[g++] = l)
			}
			la.shadows.length = g;
			ob.render(a, b);
			for (var f = ia, r = l = 0, t = 0, v, x, y, z, K = b.matrixWorldInverse, D = 0, G = 0, J = 0, I = 0, g = 0, h = f.length; g < h; g++)
				if (k = f[g], v = k.color, x = k.intensity, y = k.distance, z = k.shadow && k.shadow.map ? k.shadow.map.texture : null, k instanceof THREE.AmbientLight) l += v.r * x, r += v.g * x, t += v.b * x;
				else if (k instanceof THREE.DirectionalLight) {
				var H = ec.get(k);
				H.color.copy(k.color).multiplyScalar(k.intensity);
				H.direction.setFromMatrixPosition(k.matrixWorld);
				Ka.setFromMatrixPosition(k.target.matrixWorld);
				H.direction.sub(Ka);
				H.direction.transformDirection(K);
				if (H.shadow = k.castShadow) H.shadowBias = k.shadow.bias, H.shadowRadius = k.shadow.radius, H.shadowMapSize = k.shadow.mapSize;
				la.directionalShadowMap[D] = z;
				la.directionalShadowMatrix[D] = k.shadow.matrix;
				la.directional[D++] = H
			} else if (k instanceof THREE.SpotLight) {
				H = ec.get(k);
				H.position.setFromMatrixPosition(k.matrixWorld);
				H.position.applyMatrix4(K);
				H.color.copy(v).multiplyScalar(x);
				H.distance = y;
				H.direction.setFromMatrixPosition(k.matrixWorld);
				Ka.setFromMatrixPosition(k.target.matrixWorld);
				H.direction.sub(Ka);
				H.direction.transformDirection(K);
				H.coneCos = Math.cos(k.angle);
				H.penumbraCos = Math.cos(k.angle * (1 - k.penumbra));
				H.decay = 0 === k.distance ? 0 : k.decay;
				if (H.shadow = k.castShadow) H.shadowBias = k.shadow.bias, H.shadowRadius = k.shadow.radius, H.shadowMapSize = k.shadow.mapSize;
				la.spotShadowMap[J] = z;
				la.spotShadowMatrix[J] = k.shadow.matrix;
				la.spot[J++] = H
			} else if (k instanceof THREE.PointLight) {
				H = ec.get(k);
				H.position.setFromMatrixPosition(k.matrixWorld);
				H.position.applyMatrix4(K);
				H.color.copy(k.color).multiplyScalar(k.intensity);
				H.distance = k.distance;
				H.decay = 0 === k.distance ? 0 : k.decay;
				if (H.shadow = k.castShadow) H.shadowBias = k.shadow.bias, H.shadowRadius = k.shadow.radius, H.shadowMapSize = k.shadow.mapSize;
				la.pointShadowMap[G] = z;
				void 0 === la.pointShadowMatrix[G] && (la.pointShadowMatrix[G] = new THREE.Matrix4);
				Ka.setFromMatrixPosition(k.matrixWorld).negate();
				la.pointShadowMatrix[G].identity().setPosition(Ka);
				la.point[G++] = H
			} else k instanceof THREE.HemisphereLight && (H = ec.get(k), H.direction.setFromMatrixPosition(k.matrixWorld), H.direction.transformDirection(K),
				H.direction.normalize(), H.skyColor.copy(k.color).multiplyScalar(x), H.groundColor.copy(k.groundColor).multiplyScalar(x), la.hemi[I++] = H);
			la.ambient[0] = l;
			la.ambient[1] = r;
			la.ambient[2] = t;
			la.directional.length = D;
			la.spot.length = J;
			la.point.length = G;
			la.hemi.length = I;
			la.hash = D + "," + G + "," + J + "," + I + "," + la.shadows.length;
			wb && Ca.endShadows();
			pa.calls = 0;
			pa.vertices = 0;
			pa.faces = 0;
			pa.points = 0;
			void 0 === c && (c = null);
			this.setRenderTarget(c);
			(this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
			a.overrideMaterial ? (d = a.overrideMaterial, w(Y, b, e, d), w(Z, b, e, d)) : (W.setBlending(THREE.NoBlending), w(Y, b, e), w(Z, b, e));
			fc.render(a, b);
			He.render(a, b, Za);
			c && (a = c.texture, a.generateMipmaps && A(c) && a.minFilter !== THREE.NearestFilter && a.minFilter !== THREE.LinearFilter && (a = c instanceof THREE.WebGLRenderTargetCube ? E.TEXTURE_CUBE_MAP : E.TEXTURE_2D, c = ra.get(c.texture).__webglTexture, W.bindTexture(a, c), E.generateMipmap(a), W.bindTexture(a, null)));
			W.setDepthTest(!0);
			W.setDepthWrite(!0);
			W.setColorWrite(!0)
		}
	};
	this.setFaceCulling =
		function(a, b) {
			W.setCullFace(a);
			W.setFlipSided(b === THREE.FrontFaceDirectionCW)
		};
	this.allocTextureUnit = D;
	this.setTexture2D = function() {
		var a = !1;
		return function(b, c) {
			b instanceof THREE.WebGLRenderTarget && (a || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
			var d = c;
			c = ra.get(b);
			if (0 < b.version && c.__version !== b.version) {
				var e = b.image;
				if (void 0 === e) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined",
					b);
				else if (!1 === e.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", b);
				else {
					void 0 === c.__webglInit && (c.__webglInit = !0, b.addEventListener("dispose", f), c.__webglTexture = E.createTexture(), nb.textures++);
					W.activeTexture(E.TEXTURE0 + d);
					W.bindTexture(E.TEXTURE_2D, c.__webglTexture);
					E.pixelStorei(E.UNPACK_FLIP_Y_WEBGL, b.flipY);
					E.pixelStorei(E.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
					E.pixelStorei(E.UNPACK_ALIGNMENT, b.unpackAlignment);
					var g = G(b.image, $a.maxTextureSize);
					if ((b.wrapS !== THREE.ClampToEdgeWrapping || b.wrapT !== THREE.ClampToEdgeWrapping || b.minFilter !== THREE.NearestFilter && b.minFilter !== THREE.LinearFilter) && !1 === A(g))
						if (d = g, d instanceof HTMLImageElement || d instanceof HTMLCanvasElement) {
							e = document.createElement("canvas");
							e.width = THREE.Math.nearestPowerOfTwo(d.width);
							e.height = THREE.Math.nearestPowerOfTwo(d.height);
							var h = e.getContext("2d");
							h.drawImage(d, 0, 0, e.width, e.height);
							console.warn("THREE.WebGLRenderer: image is not power of two (" + d.width + "x" + d.height +
								"). Resized to " + e.width + "x" + e.height, d);
							g = e
						} else g = d;
					d = A(g);
					e = J(b.format);
					h = J(b.type);
					z(E.TEXTURE_2D, b, d);
					var k = b.mipmaps;
					if (b instanceof THREE.DepthTexture) {
						k = E.DEPTH_COMPONENT;
						if (b.type === THREE.FloatType) {
							if (!$c) throw Error("Float Depth Texture only supported in WebGL2.0");
							k = E.DEPTH_COMPONENT32F
						} else $c && (k = E.DEPTH_COMPONENT16);
						W.texImage2D(E.TEXTURE_2D, 0, k, g.width, g.height, 0, e, h, null)
					} else if (b instanceof THREE.DataTexture)
						if (0 < k.length && d) {
							for (var l = 0, m = k.length; l < m; l++) g = k[l], W.texImage2D(E.TEXTURE_2D,
								l, e, g.width, g.height, 0, e, h, g.data);
							b.generateMipmaps = !1
						} else W.texImage2D(E.TEXTURE_2D, 0, e, g.width, g.height, 0, e, h, g.data);
					else if (b instanceof THREE.CompressedTexture)
						for (l = 0, m = k.length; l < m; l++) g = k[l], b.format !== THREE.RGBAFormat && b.format !== THREE.RGBFormat ? -1 < W.getCompressedTextureFormats().indexOf(e) ? W.compressedTexImage2D(E.TEXTURE_2D, l, e, g.width, g.height, 0, g.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : W.texImage2D(E.TEXTURE_2D,
							l, e, g.width, g.height, 0, e, h, g.data);
					else if (0 < k.length && d) {
						l = 0;
						for (m = k.length; l < m; l++) g = k[l], W.texImage2D(E.TEXTURE_2D, l, e, e, h, g);
						b.generateMipmaps = !1
					} else W.texImage2D(E.TEXTURE_2D, 0, e, e, h, g);
					b.generateMipmaps && d && E.generateMipmap(E.TEXTURE_2D);
					c.__version = b.version;
					if (b.onUpdate) b.onUpdate(b)
				}
			} else W.activeTexture(E.TEXTURE0 + d), W.bindTexture(E.TEXTURE_2D, c.__webglTexture)
		}
	}();
	this.setTexture = function() {
		var a = !1;
		return function(b, c) {
			a || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."),
				a = !0);
			oa.setTexture2D(b, c)
		}
	}();
	this.setTextureCube = function() {
		var a = !1;
		return function(b, c) {
			b instanceof THREE.WebGLRenderTargetCube && (a || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), a = !0), b = b.texture);
			if (b instanceof THREE.CubeTexture || Array.isArray(b.image) && 6 === b.image.length) {
				var d = c;
				c = ra.get(b);
				if (6 === b.image.length)
					if (0 < b.version && c.__version !== b.version) {
						c.__image__webglTextureCube || (b.addEventListener("dispose",
							f), c.__image__webglTextureCube = E.createTexture(), nb.textures++);
						W.activeTexture(E.TEXTURE0 + d);
						W.bindTexture(E.TEXTURE_CUBE_MAP, c.__image__webglTextureCube);
						E.pixelStorei(E.UNPACK_FLIP_Y_WEBGL, b.flipY);
						for (var d = b instanceof THREE.CompressedTexture, e = b.image[0] instanceof THREE.DataTexture, g = [], h = 0; 6 > h; h++) g[h] = !oa.autoScaleCubemaps || d || e ? e ? b.image[h].image : b.image[h] : G(b.image[h], $a.maxCubemapSize);
						var h = g[0],
							k = A(h),
							l = J(b.format),
							m = J(b.type);
						z(E.TEXTURE_CUBE_MAP, b, k);
						for (h = 0; 6 > h; h++)
							if (d)
								for (var n,
										r = g[h].mipmaps, t = 0, u = r.length; t < u; t++) n = r[t], b.format !== THREE.RGBAFormat && b.format !== THREE.RGBFormat ? -1 < W.getCompressedTextureFormats().indexOf(l) ? W.compressedTexImage2D(E.TEXTURE_CUBE_MAP_POSITIVE_X + h, t, l, n.width, n.height, 0, n.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : W.texImage2D(E.TEXTURE_CUBE_MAP_POSITIVE_X + h, t, l, n.width, n.height, 0, l, m, n.data);
							else e ? W.texImage2D(E.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, l, g[h].width, g[h].height,
								0, l, m, g[h].data) : W.texImage2D(E.TEXTURE_CUBE_MAP_POSITIVE_X + h, 0, l, l, m, g[h]);
						b.generateMipmaps && k && E.generateMipmap(E.TEXTURE_CUBE_MAP);
						c.__version = b.version;
						if (b.onUpdate) b.onUpdate(b)
					} else W.activeTexture(E.TEXTURE0 + d), W.bindTexture(E.TEXTURE_CUBE_MAP, c.__image__webglTextureCube)
			} else W.activeTexture(E.TEXTURE0 + c), W.bindTexture(E.TEXTURE_CUBE_MAP, ra.get(b).__webglTexture)
		}
	}();
	this.getCurrentRenderTarget = function() {
		return Pa
	};
	this.setRenderTarget = function(a) {
		if ((Pa = a) && void 0 === ra.get(a).__webglFramebuffer) {
			var b =
				a,
				c = ra.get(b),
				d = ra.get(b.texture);
			b.addEventListener("dispose", g);
			d.__webglTexture = E.createTexture();
			nb.textures++;
			var e = b instanceof THREE.WebGLRenderTargetCube,
				f = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height);
			if (e) {
				c.__webglFramebuffer = [];
				for (var h = 0; 6 > h; h++) c.__webglFramebuffer[h] = E.createFramebuffer()
			} else c.__webglFramebuffer = E.createFramebuffer();
			if (e) {
				W.bindTexture(E.TEXTURE_CUBE_MAP, d.__webglTexture);
				z(E.TEXTURE_CUBE_MAP, b.texture, f);
				for (h = 0; 6 > h; h++) H(c.__webglFramebuffer[h],
					b, E.COLOR_ATTACHMENT0, E.TEXTURE_CUBE_MAP_POSITIVE_X + h);
				b.texture.generateMipmaps && f && E.generateMipmap(E.TEXTURE_CUBE_MAP);
				W.bindTexture(E.TEXTURE_CUBE_MAP, null)
			} else W.bindTexture(E.TEXTURE_2D, d.__webglTexture), z(E.TEXTURE_2D, b.texture, f), H(c.__webglFramebuffer, b, E.COLOR_ATTACHMENT0, E.TEXTURE_2D), b.texture.generateMipmaps && f && E.generateMipmap(E.TEXTURE_2D), W.bindTexture(E.TEXTURE_2D, null);
			if (b.depthBuffer) {
				c = b;
				b = ra.get(c);
				d = c instanceof THREE.WebGLRenderTargetCube;
				if (c.depthTexture) {
					if (d) throw Error("target.depthTexture not supported in Cube render targets");
					if (d = c instanceof THREE.WebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported!");
					E.bindFramebuffer(E.FRAMEBUFFER, b.__webglFramebuffer);
					if (!(c.depthTexture instanceof THREE.DepthTexture)) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
					ra.get(c.depthTexture).__webglTexture && c.depthTexture.image.width === c.width && c.depthTexture.image.height === c.height || (c.depthTexture.image.width = c.width, c.depthTexture.image.height = c.height, c.depthTexture.needsUpdate = !0);
					oa.setTexture2D(c.depthTexture, 0);
					b = ra.get(c.depthTexture).__webglTexture;
					E.framebufferTexture2D(E.FRAMEBUFFER, E.DEPTH_ATTACHMENT, E.TEXTURE_2D, b, 0)
				} else if (d)
					for (b.__webglDepthbuffer = [], d = 0; 6 > d; d++) E.bindFramebuffer(E.FRAMEBUFFER, b.__webglFramebuffer[d]), b.__webglDepthbuffer[d] = E.createRenderbuffer(), O(b.__webglDepthbuffer[d], c);
				else E.bindFramebuffer(E.FRAMEBUFFER, b.__webglFramebuffer), b.__webglDepthbuffer = E.createRenderbuffer(), O(b.__webglDepthbuffer, c);
				E.bindFramebuffer(E.FRAMEBUFFER, null)
			}
		}
		b =
			a instanceof THREE.WebGLRenderTargetCube;
		a ? (c = ra.get(a), c = b ? c.__webglFramebuffer[a.activeCubeFace] : c.__webglFramebuffer, Ua.copy(a.scissor), ac = a.scissorTest, Za.copy(a.viewport)) : (c = null, Ua.copy(bc).multiplyScalar(Sa), ac = cc, Za.copy(vb).multiplyScalar(Sa));
		Xa !== c && (E.bindFramebuffer(E.FRAMEBUFFER, c), Xa = c);
		W.scissor(Ua);
		W.setScissorTest(ac);
		W.viewport(Za);
		b && (b = ra.get(a.texture), E.framebufferTexture2D(E.FRAMEBUFFER, E.COLOR_ATTACHMENT0, E.TEXTURE_CUBE_MAP_POSITIVE_X + a.activeCubeFace, b.__webglTexture, a.activeMipMapLevel))
	};
	this.readRenderTargetPixels = function(a, b, c, d, e, f) {
		if (!1 === a instanceof THREE.WebGLRenderTarget) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
		else {
			var g = ra.get(a).__webglFramebuffer;
			if (g) {
				var h = !1;
				g !== Xa && (E.bindFramebuffer(E.FRAMEBUFFER, g), h = !0);
				try {
					var k = a.texture;
					k.format !== THREE.RGBAFormat && J(k.format) !== E.getParameter(E.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") :
						k.type === THREE.UnsignedByteType || J(k.type) === E.getParameter(E.IMPLEMENTATION_COLOR_READ_TYPE) || k.type === THREE.FloatType && ua.get("WEBGL_color_buffer_float") || k.type === THREE.HalfFloatType && ua.get("EXT_color_buffer_half_float") ? E.checkFramebufferStatus(E.FRAMEBUFFER) === E.FRAMEBUFFER_COMPLETE ? 0 <= b && b <= a.width - d && 0 <= c && c <= a.height - e && E.readPixels(b, c, d, e, J(k.format), J(k.type), f) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") :
						console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
				} finally {
					h && E.bindFramebuffer(E.FRAMEBUFFER, Xa)
				}
			}
		}
	}
};
THREE.WebGLRenderTarget = function(a, b, c) {
	this.uuid = THREE.Math.generateUUID();
	this.width = a;
	this.height = b;
	this.scissor = new THREE.Vector4(0, 0, a, b);
	this.scissorTest = !1;
	this.viewport = new THREE.Vector4(0, 0, a, b);
	c = c || {};
	void 0 === c.minFilter && (c.minFilter = THREE.LinearFilter);
	this.texture = new THREE.Texture(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy, c.encoding);
	this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
	this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer :
		!0;
	this.depthTexture = null
};
Object.assign(THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {
	setSize: function(a, b) {
		if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.dispose();
		this.viewport.set(0, 0, a, b);
		this.scissor.set(0, 0, a, b)
	},
	clone: function() {
		return (new this.constructor).copy(this)
	},
	copy: function(a) {
		this.width = a.width;
		this.height = a.height;
		this.viewport.copy(a.viewport);
		this.texture = a.texture.clone();
		this.depthBuffer = a.depthBuffer;
		this.stencilBuffer = a.stencilBuffer;
		this.depthTexture = a.depthTexture;
		return this
	},
	dispose: function() {
		this.dispatchEvent({
			type: "dispose"
		})
	}
});
THREE.WebGLRenderTargetCube = function(a, b, c) {
	THREE.WebGLRenderTarget.call(this, a, b, c);
	this.activeMipMapLevel = this.activeCubeFace = 0
};
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype);
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;
THREE.WebGLBufferRenderer = function(a, b, c) {
	function d(a) {
		g = a
	}

	function e(b, d) {
		a.drawArrays(g, b, d);
		c.calls++;
		c.vertices += d;
		g === a.TRIANGLES && (c.faces += d / 3)
	}

	function f(d) {
		var e = b.get("ANGLE_instanced_arrays");
		if (null === e) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
		else {
			var f = d.attributes.position,
				h = 0,
				h = f instanceof THREE.InterleavedBufferAttribute ? f.data.count : f.count;
			e.drawArraysInstancedANGLE(g, 0, h, d.maxInstancedCount);
			c.calls++;
			c.vertices += h * d.maxInstancedCount;
			g === a.TRIANGLES && (c.faces += d.maxInstancedCount * h / 3)
		}
	}
	var g;
	this.setMode = d;
	this.render = e;
	this.renderInstances = f
};
THREE.WebGLClipping = function() {
	function a() {
		l.value !== d && (l.value = d, l.needsUpdate = 0 < e);
		c.numPlanes = e
	}

	function b(a, b, d, e) {
		var f = null !== a ? a.length : 0,
			g = null;
		if (0 !== f) {
			g = l.value;
			if (!0 !== e || null === g) {
				e = d + 4 * f;
				b = b.matrixWorldInverse;
				k.getNormalMatrix(b);
				if (null === g || g.length < e) g = new Float32Array(e);
				for (e = 0; e !== f; ++e, d += 4) h.copy(a[e]).applyMatrix4(b, k), h.normal.toArray(g, d), g[d + 3] = h.constant
			}
			l.value = g;
			l.needsUpdate = !0
		}
		c.numPlanes = f;
		return g
	}
	var c = this,
		d = null,
		e = 0,
		f = !1,
		g = !1,
		h = new THREE.Plane,
		k = new THREE.Matrix3,
		l = {
			value: null,
			needsUpdate: !1
		};
	this.uniform = l;
	this.numPlanes = 0;
	this.init = function(a, c, g) {
		var h = 0 !== a.length || c || 0 !== e || f;
		f = c;
		d = b(a, g, 0);
		e = a.length;
		return h
	};
	this.beginShadows = function() {
		g = !0;
		b(null)
	};
	this.endShadows = function() {
		g = !1;
		a()
	};
	this.setState = function(c, h, k, t, u) {
		if (!f || null === c || 0 === c.length || g && !h) g ? b(null) : a();
		else {
			h = g ? 0 : e;
			var m = 4 * h,
				n = t.clippingState || null;
			l.value = n;
			n = b(c, k, m, u);
			for (c = 0; c !== m; ++c) n[c] = d[c];
			t.clippingState = n;
			this.numPlanes += h
		}
	}
};
THREE.WebGLIndexedBufferRenderer = function(a, b, c) {
	function d(a) {
		h = a
	}

	function e(c) {
		c.array instanceof Uint32Array && b.get("OES_element_index_uint") ? (k = a.UNSIGNED_INT, l = 4) : (k = a.UNSIGNED_SHORT, l = 2)
	}

	function f(b, d) {
		a.drawElements(h, d, k, b * l);
		c.calls++;
		c.vertices += d;
		h === a.TRIANGLES && (c.faces += d / 3)
	}

	function g(d, e, f) {
		var g = b.get("ANGLE_instanced_arrays");
		null === g ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (g.drawElementsInstancedANGLE(h,
			f, k, e * l, d.maxInstancedCount), c.calls++, c.vertices += f * d.maxInstancedCount, h === a.TRIANGLES && (c.faces += d.maxInstancedCount * f / 3))
	}
	var h, k, l;
	this.setMode = d;
	this.setIndex = e;
	this.render = f;
	this.renderInstances = g
};
THREE.WebGLExtensions = function(a) {
	var b = {};
	this.get = function(c) {
		if (void 0 !== b[c]) return b[c];
		var d;
		switch (c) {
			case "WEBGL_depth_texture":
				d = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension("WEBKIT_WEBGL_depth_texture");
				break;
			case "EXT_texture_filter_anisotropic":
				d = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
				break;
			case "WEBGL_compressed_texture_s3tc":
				d =
					a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
				break;
			case "WEBGL_compressed_texture_pvrtc":
				d = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
				break;
			case "WEBGL_compressed_texture_etc1":
				d = a.getExtension("WEBGL_compressed_texture_etc1");
				break;
			default:
				d = a.getExtension(c)
		}
		null === d && console.warn("THREE.WebGLRenderer: " + c + " extension not supported.");
		return b[c] = d
	}
};
THREE.WebGLCapabilities = function(a, b, c) {
	function d(b) {
		if ("highp" === b) {
			if (0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT).precision) return "highp";
			b = "mediump"
		}
		return "mediump" === b && 0 < a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.MEDIUM_FLOAT).precision && 0 < a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.MEDIUM_FLOAT).precision ? "mediump" : "lowp"
	}
	this.getMaxPrecision = d;
	this.precision = void 0 !== c.precision ? c.precision : "highp";
	this.logarithmicDepthBuffer = void 0 !== c.logarithmicDepthBuffer ? c.logarithmicDepthBuffer : !1;
	this.maxTextures = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS);
	this.maxVertexTextures = a.getParameter(a.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
	this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
	this.maxCubemapSize = a.getParameter(a.MAX_CUBE_MAP_TEXTURE_SIZE);
	this.maxAttributes = a.getParameter(a.MAX_VERTEX_ATTRIBS);
	this.maxVertexUniforms = a.getParameter(a.MAX_VERTEX_UNIFORM_VECTORS);
	this.maxVaryings = a.getParameter(a.MAX_VARYING_VECTORS);
	this.maxFragmentUniforms = a.getParameter(a.MAX_FRAGMENT_UNIFORM_VECTORS);
	this.vertexTextures = 0 < this.maxVertexTextures;
	this.floatFragmentTextures = !!b.get("OES_texture_float");
	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;
	var e = d(this.precision);
	e !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", e, "instead."), this.precision = e);
	this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!b.get("EXT_frag_depth"))
};
THREE.WebGLGeometries = function(a, b, c) {
	function d(a) {
		var b = a.geometry;
		if (void 0 !== g[b.id]) return g[b.id];
		b.addEventListener("dispose", e);
		var d;
		b instanceof THREE.BufferGeometry ? d = b : b instanceof THREE.Geometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new THREE.BufferGeometry).setFromObject(a)), d = b._bufferGeometry);
		g[b.id] = d;
		c.memory.geometries++;
		return d
	}

	function e(a) {
		var d = a.target;
		a = g[d.id];
		null !== a.index && f(a.index);
		var h = a.attributes,
			m;
		for (m in h) f(h[m]);
		d.removeEventListener("dispose",
			e);
		delete g[d.id];
		m = b.get(d);
		m.wireframe && f(m.wireframe);
		b.delete(d);
		d = b.get(a);
		d.wireframe && f(d.wireframe);
		b.delete(a);
		c.memory.geometries--
	}

	function f(c) {
		var d;
		d = c;
		d = d instanceof THREE.InterleavedBufferAttribute ? b.get(d.data).__webglBuffer : b.get(d).__webglBuffer;
		void 0 !== d && (a.deleteBuffer(d), c instanceof THREE.InterleavedBufferAttribute ? b.delete(c.data) : b.delete(c))
	}
	var g = {};
	this.get = d
};
THREE.WebGLLights = function() {
	var a = {};
	this.get = function(b) {
		if (void 0 !== a[b.id]) return a[b.id];
		var c;
		switch (b.type) {
			case "DirectionalLight":
				c = {
					direction: new THREE.Vector3,
					color: new THREE.Color,
					shadow: !1,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new THREE.Vector2
				};
				break;
			case "SpotLight":
				c = {
					position: new THREE.Vector3,
					direction: new THREE.Vector3,
					color: new THREE.Color,
					distance: 0,
					coneCos: 0,
					penumbraCos: 0,
					decay: 0,
					shadow: !1,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new THREE.Vector2
				};
				break;
			case "PointLight":
				c = {
					position: new THREE.Vector3,
					color: new THREE.Color,
					distance: 0,
					decay: 0,
					shadow: !1,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new THREE.Vector2
				};
				break;
			case "HemisphereLight":
				c = {
					direction: new THREE.Vector3,
					skyColor: new THREE.Color,
					groundColor: new THREE.Color
				}
		}
		return a[b.id] = c
	}
};
THREE.WebGLObjects = function(a, b, c) {
	function d(b) {
		var c = k.get(b);
		b.geometry instanceof THREE.Geometry && c.updateFromObject(b);
		b = c.index;
		var d = c.attributes;
		null !== b && e(b, a.ELEMENT_ARRAY_BUFFER);
		for (var f in d) e(d[f], a.ARRAY_BUFFER);
		b = c.morphAttributes;
		for (f in b)
			for (var d = b[f], g = 0, h = d.length; g < h; g++) e(d[g], a.ARRAY_BUFFER);
		return c
	}

	function e(c, d) {
		var e = c instanceof THREE.InterleavedBufferAttribute ? c.data : c;
		c = b.get(e);
		if (void 0 === c.__webglBuffer) {
			c.__webglBuffer = a.createBuffer();
			a.bindBuffer(d, c.__webglBuffer);
			var f = e.dynamic ? a.DYNAMIC_DRAW : a.STATIC_DRAW;
			a.bufferData(d, e.array, f);
			c.version = e.version
		} else c.version !== e.version && (a.bindBuffer(d, c.__webglBuffer), !1 === e.dynamic || -1 === e.updateRange.count ? a.bufferSubData(d, 0, e.array) : 0 === e.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (a.bufferSubData(d, e.updateRange.offset * e.array.BYTES_PER_ELEMENT, e.array.subarray(e.updateRange.offset,
			e.updateRange.offset + e.updateRange.count)), e.updateRange.count = 0), c.version = e.version)
	}

	function f(a) {
		return a instanceof THREE.InterleavedBufferAttribute ? b.get(a.data).__webglBuffer : b.get(a).__webglBuffer
	}

	function g(c) {
		var d = b.get(c);
		if (void 0 !== d.wireframe) return d.wireframe;
		var f = [],
			g = c.index,
			k = c.attributes;
		c = k.position;
		if (null !== g)
			for (var k = {}, g = g.array, l = 0, w = g.length; l < w; l += 3) {
				var v = g[l + 0],
					x = g[l + 1],
					y = g[l + 2];
				h(k, v, x) && f.push(v, x);
				h(k, x, y) && f.push(x, y);
				h(k, y, v) && f.push(y, v)
			} else
				for (g = k.position.array,
					l = 0, w = g.length / 3 - 1; l < w; l += 3) v = l + 0, x = l + 1, y = l + 2, f.push(v, x, x, y, y, v);
		c = 65535 < c.count ? Uint32Array : Uint16Array;
		f = new THREE.BufferAttribute(new c(f), 1);
		e(f, a.ELEMENT_ARRAY_BUFFER);
		return d.wireframe = f
	}

	function h(a, b, c) {
		if (b > c) {
			var d = b;
			b = c;
			c = d
		}
		d = a[b];
		return void 0 === d ? (a[b] = [c], !0) : -1 === d.indexOf(c) ? (d.push(c), !0) : !1
	}
	var k = new THREE.WebGLGeometries(a, b, c);
	this.getAttributeBuffer = f;
	this.getWireframeAttribute = g;
	this.update = d
};
THREE.WebGLProgram = function() {
	function a(a) {
		switch (a) {
			case THREE.LinearEncoding:
				return ["Linear", "( value )"];
			case THREE.sRGBEncoding:
				return ["sRGB", "( value )"];
			case THREE.RGBEEncoding:
				return ["RGBE", "( value )"];
			case THREE.RGBM7Encoding:
				return ["RGBM", "( value, 7.0 )"];
			case THREE.RGBM16Encoding:
				return ["RGBM", "( value, 16.0 )"];
			case THREE.RGBDEncoding:
				return ["RGBD", "( value, 256.0 )"];
			case THREE.GammaEncoding:
				return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
			default:
				throw Error("unsupported encoding: " +
					a);
		}
	}

	function b(b, c) {
		c = a(c);
		return "vec4 " + b + "( vec4 value ) { return " + c[0] + "ToLinear" + c[1] + "; }"
	}

	function c(b, c) {
		c = a(c);
		return "vec4 " + b + "( vec4 value ) { return LinearTo" + c[0] + c[1] + "; }"
	}

	function d(a, b) {
		switch (b) {
			case THREE.LinearToneMapping:
				b = "Linear";
				break;
			case THREE.ReinhardToneMapping:
				b = "Reinhard";
				break;
			case THREE.Uncharted2ToneMapping:
				b = "Uncharted2";
				break;
			case THREE.CineonToneMapping:
				b = "OptimizedCineon";
				break;
			default:
				throw Error("unsupported toneMapping: " + b);
		}
		return "vec3 " + a + "( vec3 color ) { return " +
			b + "ToneMapping( color ); }"
	}

	function e(a, b, c) {
		a = a || {};
		a = [a.derivatives || b.envMapCubeUV || b.bumpMap || b.normalMap || b.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
		return a.filter(g).join("\n")
	}

	function f(a) {
		var b = [],
			c;
		for (c in a) {
			var d = a[c];
			!1 !== d && b.push("#define " + c + " " + d)
		}
		return b.join("\n")
	}

	function g(a) {
		return "" !== a
	}

	function h(a, b) {
		return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(/NUM_HEMI_LIGHTS/g, b.numHemiLights)
	}

	function k(a) {
		function b(a, b) {
			a = THREE.ShaderChunk[b];
			if (void 0 === a) throw Error("Can not resolve #include <" + b + ">");
			return k(a)
		}
		var c = /#include +<([\w\d.]+)>/g;
		return a.replace(c,
			b)
	}

	function l(a) {
		function b(a, b, c, d) {
			a = "";
			for (b = parseInt(b); b < parseInt(c); b++) a += d.replace(/\[ i \]/g, "[ " + b + " ]");
			return a
		}
		var c = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
		return a.replace(c, b)
	}
	var m = 0;
	return function r(a, u, w, v) {
		var t = a.context,
			y = w.extensions,
			D = w.defines,
			z = w.__webglShader.vertexShader,
			G = w.__webglShader.fragmentShader,
			A = "SHADOWMAP_TYPE_BASIC";
		v.shadowMapType === THREE.PCFShadowMap ? A = "SHADOWMAP_TYPE_PCF" : v.shadowMapType === THREE.PCFSoftShadowMap && (A = "SHADOWMAP_TYPE_PCF_SOFT");
		var H = "ENVMAP_TYPE_CUBE",
			O = "ENVMAP_MODE_REFLECTION",
			M = "ENVMAP_BLENDING_MULTIPLY";
		if (v.envMap) {
			switch (w.envMap.mapping) {
				case THREE.CubeReflectionMapping:
				case THREE.CubeRefractionMapping:
					H = "ENVMAP_TYPE_CUBE";
					break;
				case THREE.CubeUVReflectionMapping:
				case THREE.CubeUVRefractionMapping:
					H = "ENVMAP_TYPE_CUBE_UV";
					break;
				case THREE.EquirectangularReflectionMapping:
				case THREE.EquirectangularRefractionMapping:
					H = "ENVMAP_TYPE_EQUIREC";
					break;
				case THREE.SphericalReflectionMapping:
					H = "ENVMAP_TYPE_SPHERE"
			}
			switch (w.envMap.mapping) {
				case THREE.CubeRefractionMapping:
				case THREE.EquirectangularRefractionMapping:
					O =
						"ENVMAP_MODE_REFRACTION"
			}
			switch (w.combine) {
				case THREE.MultiplyOperation:
					M = "ENVMAP_BLENDING_MULTIPLY";
					break;
				case THREE.MixOperation:
					M = "ENVMAP_BLENDING_MIX";
					break;
				case THREE.AddOperation:
					M = "ENVMAP_BLENDING_ADD"
			}
		}
		var J = 0 < a.gammaFactor ? a.gammaFactor : 1,
			y = e(y, v, a.extensions),
			P = f(D),
			L = t.createProgram();
		w instanceof THREE.RawShaderMaterial ? A = D = "" : (D = ["precision " + v.precision + " float;", "precision " + v.precision + " int;", "#define SHADER_NAME " + w.__webglShader.name, P, v.supportsVertexTextures ? "#define VERTEX_TEXTURES" :
			"", "#define GAMMA_FACTOR " + J, "#define MAX_BONES " + v.maxBones, v.map ? "#define USE_MAP" : "", v.envMap ? "#define USE_ENVMAP" : "", v.envMap ? "#define " + O : "", v.lightMap ? "#define USE_LIGHTMAP" : "", v.aoMap ? "#define USE_AOMAP" : "", v.emissiveMap ? "#define USE_EMISSIVEMAP" : "", v.bumpMap ? "#define USE_BUMPMAP" : "", v.normalMap ? "#define USE_NORMALMAP" : "", v.displacementMap && v.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", v.specularMap ? "#define USE_SPECULARMAP" : "", v.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", v.metalnessMap ?
			"#define USE_METALNESSMAP" : "", v.alphaMap ? "#define USE_ALPHAMAP" : "", v.vertexColors ? "#define USE_COLOR" : "", v.flatShading ? "#define FLAT_SHADED" : "", v.skinning ? "#define USE_SKINNING" : "", v.useVertexTexture ? "#define BONE_TEXTURE" : "", v.morphTargets ? "#define USE_MORPHTARGETS" : "", v.morphNormals && !1 === v.flatShading ? "#define USE_MORPHNORMALS" : "", v.doubleSided ? "#define DOUBLE_SIDED" : "", v.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + v.numClippingPlanes, v.shadowMapEnabled ? "#define USE_SHADOWMAP" :
			"", v.shadowMapEnabled ? "#define " + A : "", v.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", v.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", v.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR",
			"\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;",
			"\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"
		].filter(g).join("\n"), A = [y, "precision " + v.precision + " float;", "precision " + v.precision + " int;", "#define SHADER_NAME " + w.__webglShader.name, P, v.alphaTest ? "#define ALPHATEST " + v.alphaTest : "", "#define GAMMA_FACTOR " + J, v.useFog && v.fog ? "#define USE_FOG" : "", v.useFog && v.fogExp ? "#define FOG_EXP2" : "", v.map ? "#define USE_MAP" : "", v.envMap ? "#define USE_ENVMAP" : "", v.envMap ? "#define " + H : "", v.envMap ?
			"#define " + O : "", v.envMap ? "#define " + M : "", v.lightMap ? "#define USE_LIGHTMAP" : "", v.aoMap ? "#define USE_AOMAP" : "", v.emissiveMap ? "#define USE_EMISSIVEMAP" : "", v.bumpMap ? "#define USE_BUMPMAP" : "", v.normalMap ? "#define USE_NORMALMAP" : "", v.specularMap ? "#define USE_SPECULARMAP" : "", v.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", v.metalnessMap ? "#define USE_METALNESSMAP" : "", v.alphaMap ? "#define USE_ALPHAMAP" : "", v.vertexColors ? "#define USE_COLOR" : "", v.flatShading ? "#define FLAT_SHADED" : "", v.doubleSided ? "#define DOUBLE_SIDED" :
			"", v.flipSided ? "#define FLIP_SIDED" : "", "#define NUM_CLIPPING_PLANES " + v.numClippingPlanes, v.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", v.shadowMapEnabled ? "#define " + A : "", v.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", v.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", v.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", v.logarithmicDepthBuffer && a.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT" : "", v.envMap && a.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT" :
			"", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", v.toneMapping !== THREE.NoToneMapping ? "#define TONE_MAPPING" : "", v.toneMapping !== THREE.NoToneMapping ? THREE.ShaderChunk.tonemapping_pars_fragment : "", v.toneMapping !== THREE.NoToneMapping ? d("toneMapping", v.toneMapping) : "", v.outputEncoding || v.mapEncoding || v.envMapEncoding || v.emissiveMapEncoding ? THREE.ShaderChunk.encodings_pars_fragment : "", v.mapEncoding ? b("mapTexelToLinear", v.mapEncoding) : "", v.envMapEncoding ? b("envMapTexelToLinear", v.envMapEncoding) :
			"", v.emissiveMapEncoding ? b("emissiveMapTexelToLinear", v.emissiveMapEncoding) : "", v.outputEncoding ? c("linearToOutputTexel", v.outputEncoding) : "", v.depthPacking ? "#define DEPTH_PACKING " + w.depthPacking : "", "\n"
		].filter(g).join("\n"));
		z = k(z, v);
		z = h(z, v);
		G = k(G, v);
		G = h(G, v);
		!1 === w instanceof THREE.ShaderMaterial && (z = l(z), G = l(G));
		z = D + z;
		H = A + G;
		G = THREE.WebGLShader(t, t.VERTEX_SHADER, z);
		z = THREE.WebGLShader(t, t.FRAGMENT_SHADER, H);
		t.attachShader(L, G);
		t.attachShader(L, z);
		void 0 !== w.index0AttributeName ? t.bindAttribLocation(L,
			0, w.index0AttributeName) : !0 === v.morphTargets && t.bindAttribLocation(L, 0, "position");
		t.linkProgram(L);
		v = t.getProgramInfoLog(L);
		H = t.getShaderInfoLog(G);
		O = t.getShaderInfoLog(z);
		J = M = !0;
		if (!1 === t.getProgramParameter(L, t.LINK_STATUS)) M = !1, console.error("THREE.WebGLProgram: shader error: ", t.getError(), "gl.VALIDATE_STATUS", t.getProgramParameter(L, t.VALIDATE_STATUS), "gl.getProgramInfoLog", v, H, O);
		else if ("" !== v) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", v);
		else if ("" === H || "" === O) J = !1;
		J && (this.diagnostics = {
			runnable: M,
			material: w,
			programLog: v,
			vertexShader: {
				log: H,
				prefix: D
			},
			fragmentShader: {
				log: O,
				prefix: A
			}
		});
		t.deleteShader(G);
		t.deleteShader(z);
		var Q;
		this.getUniforms = function() {
			void 0 === Q && (Q = new THREE.WebGLUniforms(t, L, a));
			return Q
		};
		var S;
		this.getAttributes = function() {
			if (void 0 === S) {
				for (var a = t, b = L, c = {}, d = a.getProgramParameter(b, a.ACTIVE_ATTRIBUTES), e = 0; e < d; e++) {
					var f = a.getActiveAttrib(b, e),
						f = f.name;
					c[f] = a.getAttribLocation(b, f)
				}
				S = c
			}
			return S
		};
		this.destroy = function() {
			t.deleteProgram(L);
			this.program = void 0
		};
		Object.defineProperties(this, {
			uniforms: {
				get: function() {
					console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
					return this.getUniforms()
				}
			},
			attributes: {
				get: function() {
					console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
					return this.getAttributes()
				}
			}
		});
		this.id = m++;
		this.code = u;
		this.usedTimes = 1;
		this.program = L;
		this.vertexShader = G;
		this.fragmentShader = z;
		return this
	}
}();
THREE.WebGLPrograms = function(a, b) {
	function c(a, b) {
		var c;
		a ? a instanceof THREE.Texture ? c = a.encoding : a instanceof THREE.WebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), c = a.texture.encoding) : c = THREE.LinearEncoding;
		c === THREE.LinearEncoding && b && (c = THREE.GammaEncoding);
		return c
	}
	var d = [],
		e = {
			MeshDepthMaterial: "depth",
			MeshNormalMaterial: "normal",
			MeshBasicMaterial: "basic",
			MeshLambertMaterial: "lambert",
			MeshPhongMaterial: "phong",
			MeshStandardMaterial: "physical",
			MeshPhysicalMaterial: "physical",
			LineBasicMaterial: "basic",
			LineDashedMaterial: "dashed",
			PointsMaterial: "points"
		},
		f = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes depthPacking".split(" ");
	this.getParameters = function(d, f, k, l, m) {
		var g = e[d.type],
			h;
		a: {
			b.floatVertexTextures && m && m.skeleton && m.skeleton.useVertexTexture ? h = 1024 : (h = b.maxVertexUniforms, h = Math.floor((h - 20) / 4), void 0 !== m && m instanceof THREE.SkinnedMesh && (h = Math.min(m.skeleton.bones.length, h), h < m.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + m.skeleton.bones.length + ", this GPU supports just " + h + " (try OpenGL instead of ANGLE)")));
			break a;h = void 0
		}
		var t = a.getPrecision();
		null !== d.precision && (t = b.getMaxPrecision(d.precision),
			t !== d.precision && console.warn("THREE.WebGLProgram.getParameters:", d.precision, "not supported, using", t, "instead."));
		var u = a.getCurrentRenderTarget();
		return d = {
			shaderID: g,
			precision: t,
			supportsVertexTextures: b.vertexTextures,
			outputEncoding: c(u ? u.texture : null, a.gammaOutput),
			map: !!d.map,
			mapEncoding: c(d.map, a.gammaInput),
			envMap: !!d.envMap,
			envMapMode: d.envMap && d.envMap.mapping,
			envMapEncoding: c(d.envMap, a.gammaInput),
			envMapCubeUV: !!d.envMap && (d.envMap.mapping === THREE.CubeUVReflectionMapping || d.envMap.mapping ===
				THREE.CubeUVRefractionMapping),
			lightMap: !!d.lightMap,
			aoMap: !!d.aoMap,
			emissiveMap: !!d.emissiveMap,
			emissiveMapEncoding: c(d.emissiveMap, a.gammaInput),
			bumpMap: !!d.bumpMap,
			normalMap: !!d.normalMap,
			displacementMap: !!d.displacementMap,
			roughnessMap: !!d.roughnessMap,
			metalnessMap: !!d.metalnessMap,
			specularMap: !!d.specularMap,
			alphaMap: !!d.alphaMap,
			combine: d.combine,
			vertexColors: d.vertexColors,
			fog: k,
			useFog: d.fog,
			fogExp: k instanceof THREE.FogExp2,
			flatShading: d.shading === THREE.FlatShading,
			sizeAttenuation: d.sizeAttenuation,
			logarithmicDepthBuffer: b.logarithmicDepthBuffer,
			skinning: d.skinning,
			maxBones: h,
			useVertexTexture: b.floatVertexTextures && m && m.skeleton && m.skeleton.useVertexTexture,
			morphTargets: d.morphTargets,
			morphNormals: d.morphNormals,
			maxMorphTargets: a.maxMorphTargets,
			maxMorphNormals: a.maxMorphNormals,
			numDirLights: f.directional.length,
			numPointLights: f.point.length,
			numSpotLights: f.spot.length,
			numHemiLights: f.hemi.length,
			numClippingPlanes: l,
			shadowMapEnabled: a.shadowMap.enabled && m.receiveShadow && 0 < f.shadows.length,
			shadowMapType: a.shadowMap.type,
			toneMapping: a.toneMapping,
			physicallyCorrectLights: a.physicallyCorrectLights,
			premultipliedAlpha: d.premultipliedAlpha,
			alphaTest: d.alphaTest,
			doubleSided: d.side === THREE.DoubleSide,
			flipSided: d.side === THREE.BackSide,
			depthPacking: void 0 !== d.depthPacking ? d.depthPacking : !1
		}
	};
	this.getProgramCode = function(a, b) {
		var c = [];
		b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader));
		if (void 0 !== a.defines)
			for (var d in a.defines) c.push(d), c.push(a.defines[d]);
		for (a = 0; a < f.length; a++) c.push(b[f[a]]);
		return c.join()
	};
	this.acquireProgram = function(b, c, e) {
		for (var f, g = 0, h = d.length; g < h; g++) {
			var k = d[g];
			if (k.code === e) {
				f = k;
				++f.usedTimes;
				break
			}
		}
		void 0 === f && (f = new THREE.WebGLProgram(a, e, b, c), d.push(f));
		return f
	};
	this.releaseProgram = function(a) {
		if (0 === --a.usedTimes) {
			var b = d.indexOf(a);
			d[b] = d[d.length - 1];
			d.pop();
			a.destroy()
		}
	};
	this.programs = d
};
THREE.WebGLProperties = function() {
	var a = {};
	this.get = function(b) {
		b = b.uuid;
		var c = a[b];
		void 0 === c && (c = {}, a[b] = c);
		return c
	};
	this.delete = function(b) {
		delete a[b.uuid]
	};
	this.clear = function() {
		a = {}
	}
};
THREE.WebGLShader = function() {
	function a(a) {
		a = a.split("\n");
		for (var b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
		return a.join("\n")
	}
	return function c(d, e, f) {
		var g = d.createShader(e);
		d.shaderSource(g, f);
		d.compileShader(g);
		!1 === d.getShaderParameter(g, d.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile.");
		"" !== d.getShaderInfoLog(g) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", e === d.VERTEX_SHADER ? "vertex" : "fragment", d.getShaderInfoLog(g), a(f));
		return g
	}
}();
THREE.WebGLShadowMap = function(a, b, c) {
	function d(b, c, d, e) {
		var f = b.geometry,
			g = null,
			g = x,
			h = b.customDepthMaterial;
		d && (g = y, h = b.customDistanceMaterial);
		h ? g = h : (f = void 0 !== f.morphTargets && 0 < f.morphTargets.length && c.morphTargets, b = b instanceof THREE.SkinnedMesh && c.skinning, h = 0, f && (h |= u), b && (h |= w), g = g[h]);
		a.localClippingEnabled && !0 === c.clipShadows && 0 !== c.clippingPlanes.length && (h = g.uuid, b = c.uuid, f = D[h], void 0 === f && (f = {}, D[h] = f), h = f[b], void 0 === h && (h = g.clone(), f[b] = h), g = h);
		g.visible = c.visible;
		g.wireframe = c.wireframe;
		b = c.side;
		S.renderSingleSided && b == THREE.DoubleSide && (b = THREE.FrontSide);
		S.renderReverseSided && (b === THREE.FrontSide ? b = THREE.BackSide : b === THREE.BackSide && (b = THREE.FrontSide));
		g.side = b;
		g.clipShadows = c.clipShadows;
		g.clippingPlanes = c.clippingPlanes;
		g.wireframeLinewidth = c.wireframeLinewidth;
		g.linewidth = c.linewidth;
		d && void 0 !== g.uniforms.lightPos && g.uniforms.lightPos.value.copy(e);
		return g
	}

	function e(a, b, c) {
		if (!1 !== a.visible) {
			if (a.layers.test(b.layers) && (a instanceof THREE.Mesh || a instanceof THREE.Line ||
					a instanceof THREE.Points) && a.castShadow && (!1 === a.frustumCulled || !0 === h.intersectsObject(a))) {
				var d = a.material;
				!0 === d.visible && (a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse, a.matrixWorld), t.push(a))
			}
			a = a.children;
			for (var d = 0, f = a.length; d < f; d++) e(a[d], b, c)
		}
	}
	var f = a.context,
		g = a.state,
		h = new THREE.Frustum,
		k = new THREE.Matrix4,
		l = b.shadows,
		m = new THREE.Vector2,
		n = new THREE.Vector3,
		r = new THREE.Vector3,
		t = [],
		u = 1,
		w = 2,
		v = (u | w) + 1,
		x = Array(v),
		y = Array(v),
		D = {},
		z = [new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1,
			0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)],
		G = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)],
		A = [new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4],
		H = new THREE.MeshDepthMaterial;
	H.depthPacking = THREE.RGBADepthPacking;
	H.clipping = !0;
	for (var O = THREE.ShaderLib.distanceRGBA, M = THREE.UniformsUtils.clone(O.uniforms),
			J = 0; J !== v; ++J) {
		var P = 0 !== (J & u),
			L = 0 !== (J & w),
			Q = H.clone();
		Q.morphTargets = P;
		Q.skinning = L;
		x[J] = Q;
		P = new THREE.ShaderMaterial({
			defines: {
				USE_SHADOWMAP: ""
			},
			uniforms: M,
			vertexShader: O.vertexShader,
			fragmentShader: O.fragmentShader,
			morphTargets: P,
			skinning: L,
			clipping: !0
		});
		y[J] = P
	}
	var S = this;
	this.enabled = !1;
	this.autoUpdate = !0;
	this.needsUpdate = !1;
	this.type = THREE.PCFShadowMap;
	this.renderSingleSided = this.renderReverseSided = !0;
	this.render = function(b, u) {
		if (!1 !== S.enabled && (!1 !== S.autoUpdate || !1 !== S.needsUpdate) && 0 !== l.length) {
			g.clearColor(1,
				1, 1, 1);
			g.disable(f.BLEND);
			g.setDepthTest(!0);
			g.setScissorTest(!1);
			for (var v, w, x = 0, y = l.length; x < y; x++) {
				var D = l[x],
					K = D.shadow;
				if (void 0 === K) console.warn("THREE.WebGLShadowMap:", D, "has no shadow.");
				else {
					var J = K.camera;
					m.copy(K.mapSize);
					if (D instanceof THREE.PointLight) {
						v = 6;
						w = !0;
						var H = m.x,
							L = m.y;
						A[0].set(2 * H, L, H, L);
						A[1].set(0, L, H, L);
						A[2].set(3 * H, L, H, L);
						A[3].set(H, L, H, L);
						A[4].set(3 * H, 0, H, L);
						A[5].set(H, 0, H, L);
						m.x *= 4;
						m.y *= 2
					} else v = 1, w = !1;
					null === K.map && (H = {
						minFilter: THREE.NearestFilter,
						magFilter: THREE.NearestFilter,
						format: THREE.RGBAFormat
					}, K.map = new THREE.WebGLRenderTarget(m.x, m.y, H), J.updateProjectionMatrix());
					K instanceof THREE.SpotLightShadow && K.update(D);
					H = K.map;
					K = K.matrix;
					r.setFromMatrixPosition(D.matrixWorld);
					J.position.copy(r);
					a.setRenderTarget(H);
					a.clear();
					for (H = 0; H < v; H++) {
						w ? (n.copy(J.position), n.add(z[H]), J.up.copy(G[H]), J.lookAt(n), L = A[H], g.viewport(L)) : (n.setFromMatrixPosition(D.target.matrixWorld), J.lookAt(n));
						J.updateMatrixWorld();
						J.matrixWorldInverse.getInverse(J.matrixWorld);
						K.set(.5, 0, 0, .5, 0,
							.5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
						K.multiply(J.projectionMatrix);
						K.multiply(J.matrixWorldInverse);
						k.multiplyMatrices(J.projectionMatrix, J.matrixWorldInverse);
						h.setFromMatrix(k);
						t.length = 0;
						e(b, u, J);
						for (var L = 0, P = t.length; L < P; L++) {
							var M = t[L],
								O = c.update(M),
								Q = M.material;
							if (Q instanceof THREE.MultiMaterial)
								for (var X = O.groups, Q = Q.materials, Ba = 0, Qa = X.length; Ba < Qa; Ba++) {
									var Ja = X[Ba],
										Ua = Q[Ja.materialIndex];
									!0 === Ua.visible && (Ua = d(M, Ua, w, r), a.renderBufferDirect(J, null, O, Ua, M, Ja))
								} else Ua = d(M, Q, w, r), a.renderBufferDirect(J,
									null, O, Ua, M, null)
						}
					}
				}
			}
			b = a.getClearColor();
			u = a.getClearAlpha();
			a.setClearColor(b, u);
			S.needsUpdate = !1
		}
	}
};
THREE.WebGLState = function(a, b, c) {
	function d(b, c, d) {
		var e = new Uint8Array(3),
			f = a.createTexture();
		a.bindTexture(b, f);
		a.texParameteri(b, a.TEXTURE_MIN_FILTER, a.NEAREST);
		a.texParameteri(b, a.TEXTURE_MAG_FILTER, a.NEAREST);
		for (b = 0; b < d; b++) a.texImage2D(c + b, 0, a.RGB, 1, 1, 0, a.RGB, a.UNSIGNED_BYTE, e);
		return f
	}
	var e = this;
	this.buffers = {
		color: new THREE.WebGLColorBuffer(a, this),
		depth: new THREE.WebGLDepthBuffer(a, this),
		stencil: new THREE.WebGLStencilBuffer(a, this)
	};
	var f = a.getParameter(a.MAX_VERTEX_ATTRIBS),
		g = new Uint8Array(f),
		h = new Uint8Array(f),
		k = new Uint8Array(f),
		l = {},
		m = null,
		n = null,
		r = null,
		t = null,
		u = null,
		w = null,
		v = null,
		x = null,
		y = !1,
		D = null,
		z = null,
		G = null,
		A = null,
		H = null,
		O = null,
		M = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS),
		J = null,
		P = {},
		L = new THREE.Vector4,
		Q = new THREE.Vector4,
		S = {};
	S[a.TEXTURE_2D] = d(a.TEXTURE_2D, a.TEXTURE_2D, 1);
	S[a.TEXTURE_CUBE_MAP] = d(a.TEXTURE_CUBE_MAP, a.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
	this.init = function() {
		this.clearColor(0, 0, 0, 1);
		this.clearDepth(1);
		this.clearStencil(0);
		this.enable(a.DEPTH_TEST);
		this.setDepthFunc(THREE.LessEqualDepth);
		this.setFlipSided(!1);
		this.setCullFace(THREE.CullFaceBack);
		this.enable(a.CULL_FACE);
		this.enable(a.BLEND);
		this.setBlending(THREE.NormalBlending)
	};
	this.initAttributes = function() {
		for (var a = 0, b = g.length; a < b; a++) g[a] = 0
	};
	this.enableAttribute = function(c) {
		g[c] = 1;
		0 === h[c] && (a.enableVertexAttribArray(c), h[c] = 1);
		if (0 !== k[c]) {
			var d = b.get("ANGLE_instanced_arrays");
			d.vertexAttribDivisorANGLE(c, 0);
			k[c] = 0
		}
	};
	this.enableAttributeAndDivisor = function(b, c, d) {
		g[b] = 1;
		0 === h[b] && (a.enableVertexAttribArray(b), h[b] = 1);
		k[b] !==
			c && (d.vertexAttribDivisorANGLE(b, c), k[b] = c)
	};
	this.disableUnusedAttributes = function() {
		for (var b = 0, c = h.length; b !== c; ++b) h[b] !== g[b] && (a.disableVertexAttribArray(b), h[b] = 0)
	};
	this.enable = function(b) {
		!0 !== l[b] && (a.enable(b), l[b] = !0)
	};
	this.disable = function(b) {
		!1 !== l[b] && (a.disable(b), l[b] = !1)
	};
	this.getCompressedTextureFormats = function() {
		if (null === m && (m = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") || b.get("WEBGL_compressed_texture_etc1")))
			for (var c = a.getParameter(a.COMPRESSED_TEXTURE_FORMATS),
					d = 0; d < c.length; d++) m.push(c[d]);
		return m
	};
	this.setBlending = function(b, d, e, f, g, h, k, l) {
		if (b !== THREE.NoBlending) {
			this.enable(a.BLEND);
			if (b !== n || l !== y) b === THREE.AdditiveBlending ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE, a.ONE, a.ONE)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.SRC_ALPHA, a.ONE)) : b === THREE.SubtractiveBlending ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.ZERO, a.ONE_MINUS_SRC_COLOR, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD),
					a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR)) : b === THREE.MultiplyBlending ? l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ZERO, a.SRC_COLOR, a.ZERO, a.SRC_ALPHA)) : (a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR)) : l ? (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.ONE, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)) : (a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD), a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)),
				n = b, y = l;
			if (b === THREE.CustomBlending) {
				g = g || d;
				h = h || e;
				k = k || f;
				if (d !== r || g !== w) a.blendEquationSeparate(c(d), c(g)), r = d, w = g;
				if (e !== t || f !== u || h !== v || k !== x) a.blendFuncSeparate(c(e), c(f), c(h), c(k)), t = e, u = f, v = h, x = k
			} else x = v = w = u = t = r = null
		} else this.disable(a.BLEND), n = b
	};
	this.setColorWrite = function(a) {
		this.buffers.color.setMask(a)
	};
	this.setDepthTest = function(a) {
		this.buffers.depth.setTest(a)
	};
	this.setDepthWrite = function(a) {
		this.buffers.depth.setMask(a)
	};
	this.setDepthFunc = function(a) {
		this.buffers.depth.setFunc(a)
	};
	this.setStencilTest = function(a) {
		this.buffers.stencil.setTest(a)
	};
	this.setStencilWrite = function(a) {
		this.buffers.stencil.setMask(a)
	};
	this.setStencilFunc = function(a, b, c) {
		this.buffers.stencil.setFunc(a, b, c)
	};
	this.setStencilOp = function(a, b, c) {
		this.buffers.stencil.setOp(a, b, c)
	};
	this.setFlipSided = function(b) {
		D !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), D = b)
	};
	this.setCullFace = function(b) {
		b !== THREE.CullFaceNone ? (this.enable(a.CULL_FACE), b !== z && (b === THREE.CullFaceBack ? a.cullFace(a.BACK) : b === THREE.CullFaceFront ?
			a.cullFace(a.FRONT) : a.cullFace(a.FRONT_AND_BACK))) : this.disable(a.CULL_FACE);
		z = b
	};
	this.setLineWidth = function(b) {
		b !== G && (a.lineWidth(b), G = b)
	};
	this.setPolygonOffset = function(b, c, d) {
		if (b) {
			if (this.enable(a.POLYGON_OFFSET_FILL), A !== c || H !== d) a.polygonOffset(c, d), A = c, H = d
		} else this.disable(a.POLYGON_OFFSET_FILL)
	};
	this.getScissorTest = function() {
		return O
	};
	this.setScissorTest = function(b) {
		(O = b) ? this.enable(a.SCISSOR_TEST): this.disable(a.SCISSOR_TEST)
	};
	this.activeTexture = function(b) {
		void 0 === b && (b = a.TEXTURE0 +
			M - 1);
		J !== b && (a.activeTexture(b), J = b)
	};
	this.bindTexture = function(b, c) {
		null === J && e.activeTexture();
		var d = P[J];
		void 0 === d && (d = {
			type: void 0,
			texture: void 0
		}, P[J] = d);
		if (d.type !== b || d.texture !== c) a.bindTexture(b, c || S[b]), d.type = b, d.texture = c
	};
	this.compressedTexImage2D = function() {
		try {
			a.compressedTexImage2D.apply(a, arguments)
		} catch (K) {
			console.error(K)
		}
	};
	this.texImage2D = function() {
		try {
			a.texImage2D.apply(a, arguments)
		} catch (K) {
			console.error(K)
		}
	};
	this.clearColor = function(a, b, c, d) {
		this.buffers.color.setClear(a,
			b, c, d)
	};
	this.clearDepth = function(a) {
		this.buffers.depth.setClear(a)
	};
	this.clearStencil = function(a) {
		this.buffers.stencil.setClear(a)
	};
	this.scissor = function(b) {
		!1 === L.equals(b) && (a.scissor(b.x, b.y, b.z, b.w), L.copy(b))
	};
	this.viewport = function(b) {
		!1 === Q.equals(b) && (a.viewport(b.x, b.y, b.z, b.w), Q.copy(b))
	};
	this.reset = function() {
		for (var b = 0; b < h.length; b++) 1 === h[b] && (a.disableVertexAttribArray(b), h[b] = 0);
		l = {};
		J = m = null;
		P = {};
		z = D = n = null;
		this.buffers.color.reset();
		this.buffers.depth.reset();
		this.buffers.stencil.reset()
	}
};
THREE.WebGLColorBuffer = function(a, b) {
	var c = !1,
		d = new THREE.Vector4,
		e = null,
		f = new THREE.Vector4;
	this.setMask = function(b) {
		e === b || c || (a.colorMask(b, b, b, b), e = b)
	};
	this.setLocked = function(a) {
		c = a
	};
	this.setClear = function(b, c, e, l) {
		d.set(b, c, e, l);
		!1 === f.equals(d) && (a.clearColor(b, c, e, l), f.copy(d))
	};
	this.reset = function() {
		c = !1;
		e = null;
		f = new THREE.Vector4
	}
};
THREE.WebGLDepthBuffer = function(a, b) {
	var c = !1,
		d = null,
		e = null,
		f = null;
	this.setTest = function(c) {
		c ? b.enable(a.DEPTH_TEST) : b.disable(a.DEPTH_TEST)
	};
	this.setMask = function(b) {
		d === b || c || (a.depthMask(b), d = b)
	};
	this.setFunc = function(b) {
		if (e !== b) {
			if (b) switch (b) {
				case THREE.NeverDepth:
					a.depthFunc(a.NEVER);
					break;
				case THREE.AlwaysDepth:
					a.depthFunc(a.ALWAYS);
					break;
				case THREE.LessDepth:
					a.depthFunc(a.LESS);
					break;
				case THREE.LessEqualDepth:
					a.depthFunc(a.LEQUAL);
					break;
				case THREE.EqualDepth:
					a.depthFunc(a.EQUAL);
					break;
				case THREE.GreaterEqualDepth:
					a.depthFunc(a.GEQUAL);
					break;
				case THREE.GreaterDepth:
					a.depthFunc(a.GREATER);
					break;
				case THREE.NotEqualDepth:
					a.depthFunc(a.NOTEQUAL);
					break;
				default:
					a.depthFunc(a.LEQUAL)
			} else a.depthFunc(a.LEQUAL);
			e = b
		}
	};
	this.setLocked = function(a) {
		c = a
	};
	this.setClear = function(b) {
		f !== b && (a.clearDepth(b), f = b)
	};
	this.reset = function() {
		c = !1;
		f = e = d = null
	}
};
THREE.WebGLStencilBuffer = function(a, b) {
	var c = !1,
		d = null,
		e = null,
		f = null,
		g = null,
		h = null,
		k = null,
		l = null,
		m = null;
	this.setTest = function(c) {
		c ? b.enable(a.STENCIL_TEST) : b.disable(a.STENCIL_TEST)
	};
	this.setMask = function(b) {
		d === b || c || (a.stencilMask(b), d = b)
	};
	this.setFunc = function(b, c, d) {
		if (e !== b || f !== c || g !== d) a.stencilFunc(b, c, d), e = b, f = c, g = d
	};
	this.setOp = function(b, c, d) {
		if (h !== b || k !== c || l !== d) a.stencilOp(b, c, d), h = b, k = c, l = d
	};
	this.setLocked = function(a) {
		c = a
	};
	this.setClear = function(b) {
		m !== b && (a.clearStencil(b), m = b)
	};
	this.reset =
		function() {
			c = !1;
			m = l = k = h = g = f = e = d = null
		}
};
THREE.WebGLUniforms = function() {
	var a = [],
		b = [],
		c = function(b, c, d) {
			var e = b[0];
			if (0 >= e || 0 < e) return b;
			var f = c * d,
				g = a[f];
			void 0 === g && (g = new Float32Array(f), a[f] = g);
			if (0 !== c)
				for (e.toArray(g, 0), e = 1, f = 0; e !== c; ++e) f += d, b[e].toArray(g, f);
			return g
		},
		d = function(a, c) {
			var d = b[c];
			void 0 === d && (d = new Int32Array(c), b[c] = d);
			for (var e = 0; e !== c; ++e) d[e] = a.allocTextureUnit();
			return d
		},
		e = function(a, b) {
			a.uniform1f(this.addr, b)
		},
		f = function(a, b) {
			a.uniform1i(this.addr, b)
		},
		g = function(a, b) {
			void 0 === b.x ? a.uniform2fv(this.addr, b) : a.uniform2f(this.addr,
				b.x, b.y)
		},
		h = function(a, b) {
			void 0 !== b.x ? a.uniform3f(this.addr, b.x, b.y, b.z) : void 0 !== b.r ? a.uniform3f(this.addr, b.r, b.g, b.b) : a.uniform3fv(this.addr, b)
		},
		k = function(a, b) {
			void 0 === b.x ? a.uniform4fv(this.addr, b) : a.uniform4f(this.addr, b.x, b.y, b.z, b.w)
		},
		l = function(a, b) {
			a.uniformMatrix2fv(this.addr, !1, b.elements || b)
		},
		m = function(a, b) {
			a.uniformMatrix3fv(this.addr, !1, b.elements || b)
		},
		n = function(a, b) {
			a.uniformMatrix4fv(this.addr, !1, b.elements || b)
		},
		r = function(a, b, c) {
			var d = c.allocTextureUnit();
			a.uniform1i(this.addr,
				d);
			b && c.setTexture2D(b, d)
		},
		t = function(a, b, c) {
			var d = c.allocTextureUnit();
			a.uniform1i(this.addr, d);
			b && c.setTextureCube(b, d)
		},
		u = function(a, b) {
			a.uniform2iv(this.addr, b)
		},
		w = function(a, b) {
			a.uniform3iv(this.addr, b)
		},
		v = function(a, b) {
			a.uniform4iv(this.addr, b)
		},
		x = function(a) {
			switch (a) {
				case 5126:
					return e;
				case 35664:
					return g;
				case 35665:
					return h;
				case 35666:
					return k;
				case 35674:
					return l;
				case 35675:
					return m;
				case 35676:
					return n;
				case 35678:
					return r;
				case 35680:
					return t;
				case 5124:
				case 35670:
					return f;
				case 35667:
				case 35671:
					return u;
				case 35668:
				case 35672:
					return w;
				case 35669:
				case 35673:
					return v
			}
		},
		y = function(a, b) {
			a.uniform1fv(this.addr, b)
		},
		D = function(a, b) {
			a.uniform1iv(this.addr, b)
		},
		z = function(a, b) {
			a.uniform2fv(this.addr, c(b, this.size, 2))
		},
		G = function(a, b) {
			a.uniform3fv(this.addr, c(b, this.size, 3))
		},
		A = function(a, b) {
			a.uniform4fv(this.addr, c(b, this.size, 4))
		},
		H = function(a, b) {
			a.uniformMatrix2fv(this.addr, !1, c(b, this.size, 4))
		},
		O = function(a, b) {
			a.uniformMatrix3fv(this.addr, !1, c(b, this.size, 9))
		},
		M = function(a, b) {
			a.uniformMatrix4fv(this.addr, !1, c(b, this.size, 16))
		},
		J = function(a, b, c) {
			var e = b.length,
				f = d(c, e);
			a.uniform1iv(this.addr, f);
			for (a = 0; a !== e; ++a) {
				var g = b[a];
				g && c.setTexture2D(g, f[a])
			}
		},
		P = function(a, b, c) {
			var e = b.length,
				f = d(c, e);
			a.uniform1iv(this.addr, f);
			for (a = 0; a !== e; ++a) {
				var g = b[a];
				g && c.setTextureCube(g, f[a])
			}
		},
		L = function(a) {
			switch (a) {
				case 5126:
					return y;
				case 35664:
					return z;
				case 35665:
					return G;
				case 35666:
					return A;
				case 35674:
					return H;
				case 35675:
					return O;
				case 35676:
					return M;
				case 35678:
					return J;
				case 35680:
					return P;
				case 5124:
				case 35670:
					return D;
				case 35667:
				case 35671:
					return u;
				case 35668:
				case 35672:
					return w;
				case 35669:
				case 35673:
					return v
			}
		},
		Q = function ia(a, b, c) {
			this.id = a;
			this.addr = c;
			this.setValue = x(b.type)
		},
		S = function(a, b, c) {
			this.id = a;
			this.addr = c;
			this.size = b.size;
			this.setValue = L(b.type)
		},
		K = function(a) {
			this.id = a;
			this.seq = [];
			this.map = {}
		};
	K.prototype.setValue = function(a, b) {
		for (var c = this.seq, d = 0, e = c.length; d !== e; ++d) {
			var f = c[d];
			f.setValue(a, b[f.id])
		}
	};
	var X = /([\w\d_]+)(\])?(\[|\.)?/g,
		ba = function Y(a, b, c) {
			this.seq = [];
			this.map = {};
			this.renderer =
				c;
			c = a.getProgramParameter(b, a.ACTIVE_UNIFORMS);
			for (var d = 0; d !== c; ++d) {
				var e = a.getActiveUniform(b, d),
					f = e.name,
					f = a.getUniformLocation(b, f),
					g = this,
					h = e.name,
					k = h.length;
				for (X.lastIndex = 0;;) {
					var l = X.exec(h),
						m = X.lastIndex,
						n = l[1],
						r = "]" === l[2],
						l = l[3];
					r && (n |= 0);
					if (void 0 === l || "[" === l && m + 2 === k) {
						h = g;
						e = void 0 === l ? new Q(n, e, f) : new S(n, e, f);
						h.seq.push(e);
						h.map[e.id] = e;
						break
					} else m = g.map, m = m[n], void 0 === m && (m = new K(n), n = g, g = m, n.seq.push(g), n.map[g.id] = g), g = m
				}
			}
		};
	ba.prototype.setValue = function(a, b, c) {
		b = this.map[b];
		void 0 !== b && b.setValue(a, c, this.renderer)
	};
	ba.prototype.set = function(a, b, c) {
		var d = this.map[c];
		void 0 !== d && d.setValue(a, b[c], this.renderer)
	};
	ba.prototype.setOptional = function(a, b, c) {
		b = b[c];
		void 0 !== b && this.setValue(a, c, b)
	};
	ba.upload = function(a, b, c, d) {
		for (var e = 0, f = b.length; e !== f; ++e) {
			var g = b[e],
				h = c[g.id];
			!1 !== h.needsUpdate && g.setValue(a, h.value, d)
		}
	};
	ba.seqWithValue = function(a, b) {
		for (var c = [], d = 0, e = a.length; d !== e; ++d) {
			var f = a[d];
			f.id in b && c.push(f)
		}
		return c
	};
	ba.splitDynamic = function(a, b) {
		for (var c =
				null, d = a.length, e = 0, f = 0; f !== d; ++f) {
			var g = a[f],
				h = b[g.id];
			h && !0 === h.dynamic ? (null === c && (c = []), c.push(g)) : (e < f && (a[e] = g), ++e)
		}
		e < d && (a.length = e);
		return c
	};
	ba.evalDynamic = function(a, b, c, d) {
		for (var e = 0, f = a.length; e !== f; ++e) {
			var g = b[a[e].id],
				h = g.onUpdateCallback;
			void 0 !== h && h.call(g, c, d)
		}
	};
	return ba
}();
THREE.LensFlarePlugin = function(a, b) {
	var c = a.context,
		d = a.state,
		e, f, g, h, k, l, m, n;
	this.render = function(r, t, u) {
		if (0 !== b.length) {
			r = new THREE.Vector3;
			var w = u.w / u.z,
				v = .5 * u.z,
				x = .5 * u.w,
				y = 16 / u.w,
				D = new THREE.Vector2(y * w, y),
				z = new THREE.Vector3(1, 1, 0),
				G = new THREE.Vector2(1, 1),
				A = new THREE.Box2;
			A.min.set(0, 0);
			A.max.set(u.z - 16, u.w - 16);
			if (void 0 === h) {
				var y = new Float32Array([-1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
					H = new Uint16Array([0, 1, 2, 0, 2, 3]);
				e = c.createBuffer();
				f = c.createBuffer();
				c.bindBuffer(c.ARRAY_BUFFER, e);
				c.bufferData(c.ARRAY_BUFFER,
					y, c.STATIC_DRAW);
				c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, f);
				c.bufferData(c.ELEMENT_ARRAY_BUFFER, H, c.STATIC_DRAW);
				m = c.createTexture();
				n = c.createTexture();
				d.bindTexture(c.TEXTURE_2D, m);
				c.texImage2D(c.TEXTURE_2D, 0, c.RGB, 16, 16, 0, c.RGB, c.UNSIGNED_BYTE, null);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST);
				d.bindTexture(c.TEXTURE_2D,
					n);
				c.texImage2D(c.TEXTURE_2D, 0, c.RGBA, 16, 16, 0, c.RGBA, c.UNSIGNED_BYTE, null);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST);
				c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST);
				var y = g = {
						vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
						fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
					},
					H = c.createProgram(),
					O = c.createShader(c.FRAGMENT_SHADER),
					M = c.createShader(c.VERTEX_SHADER),
					J = "precision " + a.getPrecision() + " float;\n";
				c.shaderSource(O, J + y.fragmentShader);
				c.shaderSource(M, J + y.vertexShader);
				c.compileShader(O);
				c.compileShader(M);
				c.attachShader(H, O);
				c.attachShader(H, M);
				c.linkProgram(H);
				h = H;
				k = {
					vertex: c.getAttribLocation(h, "position"),
					uv: c.getAttribLocation(h, "uv")
				};
				l = {
					renderType: c.getUniformLocation(h, "renderType"),
					map: c.getUniformLocation(h, "map"),
					occlusionMap: c.getUniformLocation(h, "occlusionMap"),
					opacity: c.getUniformLocation(h, "opacity"),
					color: c.getUniformLocation(h, "color"),
					scale: c.getUniformLocation(h, "scale"),
					rotation: c.getUniformLocation(h, "rotation"),
					screenPosition: c.getUniformLocation(h, "screenPosition")
				}
			}
			c.useProgram(h);
			d.initAttributes();
			d.enableAttribute(k.vertex);
			d.enableAttribute(k.uv);
			d.disableUnusedAttributes();
			c.uniform1i(l.occlusionMap, 0);
			c.uniform1i(l.map, 1);
			c.bindBuffer(c.ARRAY_BUFFER, e);
			c.vertexAttribPointer(k.vertex, 2, c.FLOAT, !1, 16, 0);
			c.vertexAttribPointer(k.uv, 2, c.FLOAT, !1, 16, 8);
			c.bindBuffer(c.ELEMENT_ARRAY_BUFFER,
				f);
			d.disable(c.CULL_FACE);
			d.setDepthWrite(!1);
			H = 0;
			for (O = b.length; H < O; H++)
				if (y = 16 / u.w, D.set(y * w, y), M = b[H], r.set(M.matrixWorld.elements[12], M.matrixWorld.elements[13], M.matrixWorld.elements[14]), r.applyMatrix4(t.matrixWorldInverse), r.applyProjection(t.projectionMatrix), z.copy(r), G.x = u.x + z.x * v + v - 8, G.y = u.y + z.y * x + x - 8, !0 === A.containsPoint(G)) {
					d.activeTexture(c.TEXTURE0);
					d.bindTexture(c.TEXTURE_2D, null);
					d.activeTexture(c.TEXTURE1);
					d.bindTexture(c.TEXTURE_2D, m);
					c.copyTexImage2D(c.TEXTURE_2D, 0, c.RGB, G.x, G.y,
						16, 16, 0);
					c.uniform1i(l.renderType, 0);
					c.uniform2f(l.scale, D.x, D.y);
					c.uniform3f(l.screenPosition, z.x, z.y, z.z);
					d.disable(c.BLEND);
					d.enable(c.DEPTH_TEST);
					c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0);
					d.activeTexture(c.TEXTURE0);
					d.bindTexture(c.TEXTURE_2D, n);
					c.copyTexImage2D(c.TEXTURE_2D, 0, c.RGBA, G.x, G.y, 16, 16, 0);
					c.uniform1i(l.renderType, 1);
					d.disable(c.DEPTH_TEST);
					d.activeTexture(c.TEXTURE1);
					d.bindTexture(c.TEXTURE_2D, m);
					c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0);
					M.positionScreen.copy(z);
					M.customUpdateCallback ?
						M.customUpdateCallback(M) : M.updateLensFlares();
					c.uniform1i(l.renderType, 2);
					d.enable(c.BLEND);
					for (var J = 0, P = M.lensFlares.length; J < P; J++) {
						var L = M.lensFlares[J];
						.001 < L.opacity && .001 < L.scale && (z.x = L.x, z.y = L.y, z.z = L.z, y = L.size * L.scale / u.w, D.x = y * w, D.y = y, c.uniform3f(l.screenPosition, z.x, z.y, z.z), c.uniform2f(l.scale, D.x, D.y), c.uniform1f(l.rotation, L.rotation), c.uniform1f(l.opacity, L.opacity), c.uniform3f(l.color, L.color.r, L.color.g, L.color.b), d.setBlending(L.blending, L.blendEquation, L.blendSrc, L.blendDst),
							a.setTexture2D(L.texture, 1), c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0))
					}
				}
			d.enable(c.CULL_FACE);
			d.enable(c.DEPTH_TEST);
			d.setDepthWrite(!0);
			a.resetGLState()
		}
	}
};
THREE.SpritePlugin = function(a, b) {
	function c(a, b) {
		return a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : b.id - a.id
	}
	var d = a.context,
		e = a.state,
		f, g, h, k, l, m, n = new THREE.Vector3,
		r = new THREE.Quaternion,
		t = new THREE.Vector3;
	this.render = function(u, w) {
		if (0 !== b.length) {
			if (void 0 === h) {
				var v = new Float32Array([-.5, -.5, 0, 0, .5, -.5, 1, 0, .5, .5, 1, 1, -.5, .5, 0, 1]),
					x = new Uint16Array([0, 1, 2, 0, 2, 3]);
				f = d.createBuffer();
				g = d.createBuffer();
				d.bindBuffer(d.ARRAY_BUFFER, f);
				d.bufferData(d.ARRAY_BUFFER,
					v, d.STATIC_DRAW);
				d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, g);
				d.bufferData(d.ELEMENT_ARRAY_BUFFER, x, d.STATIC_DRAW);
				var v = d.createProgram(),
					x = d.createShader(d.VERTEX_SHADER),
					y = d.createShader(d.FRAGMENT_SHADER);
				d.shaderSource(x, ["precision " + a.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n"));
				d.shaderSource(y, ["precision " + a.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n"));
				d.compileShader(x);
				d.compileShader(y);
				d.attachShader(v, x);
				d.attachShader(v, y);
				d.linkProgram(v);
				h = v;
				k = {
					position: d.getAttribLocation(h, "position"),
					uv: d.getAttribLocation(h, "uv")
				};
				l = {
					uvOffset: d.getUniformLocation(h, "uvOffset"),
					uvScale: d.getUniformLocation(h, "uvScale"),
					rotation: d.getUniformLocation(h, "rotation"),
					scale: d.getUniformLocation(h, "scale"),
					color: d.getUniformLocation(h, "color"),
					map: d.getUniformLocation(h, "map"),
					opacity: d.getUniformLocation(h, "opacity"),
					modelViewMatrix: d.getUniformLocation(h,
						"modelViewMatrix"),
					projectionMatrix: d.getUniformLocation(h, "projectionMatrix"),
					fogType: d.getUniformLocation(h, "fogType"),
					fogDensity: d.getUniformLocation(h, "fogDensity"),
					fogNear: d.getUniformLocation(h, "fogNear"),
					fogFar: d.getUniformLocation(h, "fogFar"),
					fogColor: d.getUniformLocation(h, "fogColor"),
					alphaTest: d.getUniformLocation(h, "alphaTest")
				};
				v = document.createElement("canvas");
				v.width = 8;
				v.height = 8;
				x = v.getContext("2d");
				x.fillStyle = "white";
				x.fillRect(0, 0, 8, 8);
				m = new THREE.Texture(v);
				m.needsUpdate = !0
			}
			d.useProgram(h);
			e.initAttributes();
			e.enableAttribute(k.position);
			e.enableAttribute(k.uv);
			e.disableUnusedAttributes();
			e.disable(d.CULL_FACE);
			e.enable(d.BLEND);
			d.bindBuffer(d.ARRAY_BUFFER, f);
			d.vertexAttribPointer(k.position, 2, d.FLOAT, !1, 16, 0);
			d.vertexAttribPointer(k.uv, 2, d.FLOAT, !1, 16, 8);
			d.bindBuffer(d.ELEMENT_ARRAY_BUFFER, g);
			d.uniformMatrix4fv(l.projectionMatrix, !1, w.projectionMatrix.elements);
			e.activeTexture(d.TEXTURE0);
			d.uniform1i(l.map, 0);
			x = v = 0;
			(y = u.fog) ? (d.uniform3f(l.fogColor, y.color.r, y.color.g, y.color.b), y instanceof THREE.Fog ? (d.uniform1f(l.fogNear, y.near), d.uniform1f(l.fogFar, y.far), d.uniform1i(l.fogType, 1), x = v = 1) : y instanceof THREE.FogExp2 && (d.uniform1f(l.fogDensity, y.density), d.uniform1i(l.fogType, 2), x = v = 2)) : (d.uniform1i(l.fogType, 0), x = v = 0);
			for (var y = 0, D = b.length; y < D; y++) {
				var z = b[y];
				z.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, z.matrixWorld);
				z.z = -z.modelViewMatrix.elements[14]
			}
			b.sort(c);
			w = [];
			y = 0;
			for (D = b.length; y < D; y++) {
				var z = b[y],
					G = z.material;
				d.uniform1f(l.alphaTest, G.alphaTest);
				d.uniformMatrix4fv(l.modelViewMatrix, !1, z.modelViewMatrix.elements);
				z.matrixWorld.decompose(n, r, t);
				w[0] = t.x;
				w[1] = t.y;
				z = 0;
				u.fog && G.fog && (z = x);
				v !== z && (d.uniform1i(l.fogType, z), v = z);
				null !== G.map ? (d.uniform2f(l.uvOffset, G.map.offset.x, G.map.offset.y), d.uniform2f(l.uvScale, G.map.repeat.x, G.map.repeat.y)) : (d.uniform2f(l.uvOffset, 0, 0), d.uniform2f(l.uvScale, 1, 1));
				d.uniform1f(l.opacity, G.opacity);
				d.uniform3f(l.color, G.color.r, G.color.g, G.color.b);
				d.uniform1f(l.rotation, G.rotation);
				d.uniform2fv(l.scale, w);
				e.setBlending(G.blending, G.blendEquation,
					G.blendSrc, G.blendDst);
				e.setDepthTest(G.depthTest);
				e.setDepthWrite(G.depthWrite);
				G.map ? a.setTexture2D(G.map, 0) : a.setTexture2D(m, 0);
				d.drawElements(d.TRIANGLES, 6, d.UNSIGNED_SHORT, 0)
			}
			e.enable(d.CULL_FACE);
			a.resetGLState()
		}
	}
};
Object.assign(THREE, {
	Face4: function(a, b, c, d, e, f, g) {
		console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
		return new THREE.Face3(a, b, c, e, f, g)
	},
	LineStrip: 0,
	LinePieces: 1,
	MeshFaceMaterial: THREE.MultiMaterial,
	PointCloud: function(a, b) {
		console.warn("THREE.PointCloud has been renamed to THREE.Points.");
		return new THREE.Points(a, b)
	},
	Particle: THREE.Sprite,
	ParticleSystem: function(a, b) {
		console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
		return new THREE.Points(a,
			b)
	},
	PointCloudMaterial: function(a) {
		console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
		return new THREE.PointsMaterial(a)
	},
	ParticleBasicMaterial: function(a) {
		console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
		return new THREE.PointsMaterial(a)
	},
	ParticleSystemMaterial: function(a) {
		console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
		return new THREE.PointsMaterial(a)
	},
	Vertex: function(a, b, c) {
		console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
		return new THREE.Vector3(a, b, c)
	}
});
Object.assign(THREE.Box2.prototype, {
	empty: function() {
		console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
		return this.isEmpty()
	},
	isIntersectionBox: function(a) {
		console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
		return this.intersectsBox(a)
	}
});
Object.assign(THREE.Box3.prototype, {
	empty: function() {
		console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
		return this.isEmpty()
	},
	isIntersectionBox: function(a) {
		console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
		return this.intersectsBox(a)
	},
	isIntersectionSphere: function(a) {
		console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
		return this.intersectsSphere(a)
	}
});
Object.assign(THREE.Matrix3.prototype, {
	multiplyVector3: function(a) {
		console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
		return a.applyMatrix3(this)
	},
	multiplyVector3Array: function(a) {
		console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
		return this.applyToVector3Array(a)
	}
});
Object.assign(THREE.Matrix4.prototype, {
	extractPosition: function(a) {
		console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
		return this.copyPosition(a)
	},
	setRotationFromQuaternion: function(a) {
		console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
		return this.makeRotationFromQuaternion(a)
	},
	multiplyVector3: function(a) {
		console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
		return a.applyProjection(this)
	},
	multiplyVector4: function(a) {
		console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
		return a.applyMatrix4(this)
	},
	multiplyVector3Array: function(a) {
		console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");
		return this.applyToVector3Array(a)
	},
	rotateAxis: function(a) {
		console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
		a.transformDirection(this)
	},
	crossVector: function(a) {
		console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
		return a.applyMatrix4(this)
	},
	translate: function(a) {
		console.error("THREE.Matrix4: .translate() has been removed.")
	},
	rotateX: function(a) {
		console.error("THREE.Matrix4: .rotateX() has been removed.")
	},
	rotateY: function(a) {
		console.error("THREE.Matrix4: .rotateY() has been removed.")
	},
	rotateZ: function(a) {
		console.error("THREE.Matrix4: .rotateZ() has been removed.")
	},
	rotateByAxis: function(a, b) {
		console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
	}
});
Object.assign(THREE.Plane.prototype, {
	isIntersectionLine: function(a) {
		console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
		return this.intersectsLine(a)
	}
});
Object.assign(THREE.Quaternion.prototype, {
	multiplyVector3: function(a) {
		console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
		return a.applyQuaternion(this)
	}
});
Object.assign(THREE.Ray.prototype, {
	isIntersectionBox: function(a) {
		console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
		return this.intersectsBox(a)
	},
	isIntersectionPlane: function(a) {
		console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
		return this.intersectsPlane(a)
	},
	isIntersectionSphere: function(a) {
		console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
		return this.intersectsSphere(a)
	}
});
Object.assign(THREE.Vector3.prototype, {
	setEulerFromRotationMatrix: function() {
		console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
	},
	setEulerFromQuaternion: function() {
		console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
	},
	getPositionFromMatrix: function(a) {
		console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
		return this.setFromMatrixPosition(a)
	},
	getScaleFromMatrix: function(a) {
		console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
		return this.setFromMatrixScale(a)
	},
	getColumnFromMatrix: function(a, b) {
		console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
		return this.setFromMatrixColumn(b, a)
	}
});
Object.assign(THREE.Object3D.prototype, {
	getChildByName: function(a) {
		console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
		return this.getObjectByName(a)
	},
	renderDepth: function(a) {
		console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
	},
	translate: function(a, b) {
		console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
		return this.translateOnAxis(b, a)
	}
});
Object.defineProperties(THREE.Object3D.prototype, {
	eulerOrder: {
		get: function() {
			console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
			return this.rotation.order
		},
		set: function(a) {
			console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
			this.rotation.order = a
		}
	},
	useQuaternion: {
		get: function() {
			console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
		},
		set: function(a) {
			console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
		}
	}
});
Object.defineProperties(THREE.LOD.prototype, {
	objects: {
		get: function() {
			console.warn("THREE.LOD: .objects has been renamed to .levels.");
			return this.levels
		}
	}
});
THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
	console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
	void 0 !== b && (this.filmGauge = b);
	this.setFocalLength(a)
};
Object.defineProperties(THREE.Light.prototype, {
	onlyShadow: {
		set: function(a) {
			console.warn("THREE.Light: .onlyShadow has been removed.")
		}
	},
	shadowCameraFov: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
			this.shadow.camera.fov = a
		}
	},
	shadowCameraLeft: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
			this.shadow.camera.left = a
		}
	},
	shadowCameraRight: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
			this.shadow.camera.right = a
		}
	},
	shadowCameraTop: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
			this.shadow.camera.top = a
		}
	},
	shadowCameraBottom: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
			this.shadow.camera.bottom = a
		}
	},
	shadowCameraNear: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
			this.shadow.camera.near = a
		}
	},
	shadowCameraFar: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
			this.shadow.camera.far = a
		}
	},
	shadowCameraVisible: {
		set: function(a) {
			console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
		}
	},
	shadowBias: {
		set: function(a) {
			console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
			this.shadow.bias = a
		}
	},
	shadowDarkness: {
		set: function(a) {
			console.warn("THREE.Light: .shadowDarkness has been removed.")
		}
	},
	shadowMapWidth: {
		set: function(a) {
			console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
			this.shadow.mapSize.width = a
		}
	},
	shadowMapHeight: {
		set: function(a) {
			console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
			this.shadow.mapSize.height = a
		}
	}
});
Object.defineProperties(THREE.BufferAttribute.prototype, {
	length: {
		get: function() {
			console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count.");
			return this.array.length
		}
	}
});
Object.assign(THREE.BufferGeometry.prototype, {
	addIndex: function(a) {
		console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
		this.setIndex(a)
	},
	addDrawCall: function(a, b, c) {
		void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
		console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
		this.addGroup(a, b)
	},
	clearDrawCalls: function() {
		console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
		this.clearGroups()
	},
	computeTangents: function() {
		console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
	},
	computeOffsets: function() {
		console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
	}
});
Object.defineProperties(THREE.BufferGeometry.prototype, {
	drawcalls: {
		get: function() {
			console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
			return this.groups
		}
	},
	offsets: {
		get: function() {
			console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
			return this.groups
		}
	}
});
Object.defineProperties(THREE.Material.prototype, {
	wrapAround: {
		get: function() {
			console.warn("THREE." + this.type + ": .wrapAround has been removed.")
		},
		set: function(a) {
			console.warn("THREE." + this.type + ": .wrapAround has been removed.")
		}
	},
	wrapRGB: {
		get: function() {
			console.warn("THREE." + this.type + ": .wrapRGB has been removed.");
			return new THREE.Color
		}
	}
});
Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
	metal: {
		get: function() {
			console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
			return !1
		},
		set: function(a) {
			console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
		}
	}
});
Object.defineProperties(THREE.ShaderMaterial.prototype, {
	derivatives: {
		get: function() {
			console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
			return this.extensions.derivatives
		},
		set: function(a) {
			console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
			this.extensions.derivatives = a
		}
	}
});
THREE.EventDispatcher.prototype = Object.assign(Object.create({
	constructor: THREE.EventDispatcher,
	apply: function(a) {
		console.warn("THREE.EventDispatcher: .apply is deprecated, just inherit or Object.assign the prototype to mix-in.");
		Object.assign(a, this)
	}
}), THREE.EventDispatcher.prototype);
Object.assign(THREE.WebGLRenderer.prototype, {
	supportsFloatTextures: function() {
		console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
		return this.extensions.get("OES_texture_float")
	},
	supportsHalfFloatTextures: function() {
		console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
		return this.extensions.get("OES_texture_half_float")
	},
	supportsStandardDerivatives: function() {
		console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
		return this.extensions.get("OES_standard_derivatives")
	},
	supportsCompressedTextureS3TC: function() {
		console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
		return this.extensions.get("WEBGL_compressed_texture_s3tc")
	},
	supportsCompressedTexturePVRTC: function() {
		console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
		return this.extensions.get("WEBGL_compressed_texture_pvrtc")
	},
	supportsBlendMinMax: function() {
		console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
		return this.extensions.get("EXT_blend_minmax")
	},
	supportsVertexTextures: function() {
		return this.capabilities.vertexTextures
	},
	supportsInstancedArrays: function() {
		console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
		return this.extensions.get("ANGLE_instanced_arrays")
	},
	enableScissorTest: function(a) {
		console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
		this.setScissorTest(a)
	},
	initMaterial: function() {
		console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
	},
	addPrePlugin: function() {
		console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
	},
	addPostPlugin: function() {
		console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
	},
	updateShadowMap: function() {
		console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
	}
});
Object.defineProperties(THREE.WebGLRenderer.prototype, {
	shadowMapEnabled: {
		get: function() {
			return this.shadowMap.enabled
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
			this.shadowMap.enabled = a
		}
	},
	shadowMapType: {
		get: function() {
			return this.shadowMap.type
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
			this.shadowMap.type = a
		}
	},
	shadowMapCullFace: {
		get: function() {
			return this.shadowMap.cullFace
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.");
			this.shadowMap.cullFace = a
		}
	}
});
Object.defineProperties(THREE.WebGLShadowMap.prototype, {
	cullFace: {
		get: function() {
			return this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack
		},
		set: function(a) {
			a = a !== THREE.CullFaceBack;
			console.warn("WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + a + ".");
			this.renderReverseSided = a
		}
	}
});
Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
	wrapS: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
			return this.texture.wrapS
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
			this.texture.wrapS = a
		}
	},
	wrapT: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
			return this.texture.wrapT
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
			this.texture.wrapT =
				a
		}
	},
	magFilter: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
			return this.texture.magFilter
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
			this.texture.magFilter = a
		}
	},
	minFilter: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
			return this.texture.minFilter
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
			this.texture.minFilter =
				a
		}
	},
	anisotropy: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
			return this.texture.anisotropy
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
			this.texture.anisotropy = a
		}
	},
	offset: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
			return this.texture.offset
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
			this.texture.offset =
				a
		}
	},
	repeat: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
			return this.texture.repeat
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
			this.texture.repeat = a
		}
	},
	format: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
			return this.texture.format
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
			this.texture.format = a
		}
	},
	type: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
			return this.texture.type
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
			this.texture.type = a
		}
	},
	generateMipmaps: {
		get: function() {
			console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
			return this.texture.generateMipmaps
		},
		set: function(a) {
			console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
			this.texture.generateMipmaps = a
		}
	}
});
Object.assign(THREE.Audio.prototype, {
	load: function(a) {
		console.warn("THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.");
		var b = this,
			c = new THREE.AudioLoader;
		c.load(a, function(a) {
			b.setBuffer(a)
		});
		return this
	}
});
Object.assign(THREE.AudioAnalyser.prototype, {
	getData: function(a) {
		console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
		return this.getFrequencyData()
	}
});
THREE.GeometryUtils = {
	merge: function(a, b, c) {
		console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
		var d;
		b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(), d = b.matrix, b = b.geometry);
		a.merge(b, d, c)
	},
	center: function(a) {
		console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
		return a.center()
	}
};
THREE.ImageUtils = {
	crossOrigin: void 0,
	loadTexture: function(a, b, c, d) {
		console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
		var e = new THREE.TextureLoader;
		e.setCrossOrigin(this.crossOrigin);
		a = e.load(a, c, void 0, d);
		b && (a.mapping = b);
		return a
	},
	loadTextureCube: function(a, b, c, d) {
		console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
		var e = new THREE.CubeTextureLoader;
		e.setCrossOrigin(this.crossOrigin);
		a = e.load(a,
			c, void 0, d);
		b && (a.mapping = b);
		return a
	},
	loadCompressedTexture: function() {
		console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
	},
	loadCompressedTextureCube: function() {
		console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
	}
};
THREE.Projector = function() {
	console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js.");
	this.projectVector = function(a, b) {
		console.warn("THREE.Projector: .projectVector() is now vector.project().");
		a.project(b)
	};
	this.unprojectVector = function(a, b) {
		console.warn("THREE.Projector: .unprojectVector() is now vector.unproject().");
		a.unproject(b)
	};
	this.pickingRay = function(a, b) {
		console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
	}
};
THREE.CanvasRenderer = function() {
	console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js");
	this.domElement = document.createElement("canvas");
	this.clear = function() {};
	this.render = function() {};
	this.setClearColor = function() {};
	this.setSize = function() {}
};
THREE.CurveUtils = {
	tangentQuadraticBezier: function(a, b, c, d) {
		return 2 * (1 - a) * (c - b) + 2 * a * (d - c)
	},
	tangentCubicBezier: function(a, b, c, d, e) {
		return -3 * b * (1 - a) * (1 - a) + 3 * c * (1 - a) * (1 - a) - 6 * a * c * (1 - a) + 6 * a * d * (1 - a) - 3 * a * a * d + 3 * a * a * e
	},
	tangentSpline: function(a, b, c, d, e) {
		b = 6 * a * a - 6 * a;
		c = 3 * a * a - 4 * a + 1;
		d = -6 * a * a + 6 * a;
		a = 3 * a * a - 2 * a;
		return b + c + d + a
	},
	interpolate: function(a, b, c, d, e) {
		a = .5 * (c - a);
		d = .5 * (d - b);
		var f = e * e,
			g = e * f;
		return (2 * b - 2 * c + a + d) * g + (-3 * b + 3 * c - 2 * a - d) * f + a * e + b
	}
};
THREE.SceneUtils = {
	createMultiMaterialObject: function(a, b) {
		for (var c = new THREE.Group, d = 0, e = b.length; d < e; d++) c.add(new THREE.Mesh(a, b[d]));
		return c
	},
	detach: function(a, b, c) {
		a.applyMatrix(b.matrixWorld);
		b.remove(a);
		c.add(a)
	},
	attach: function(a, b, c) {
		var d = new THREE.Matrix4;
		d.getInverse(c.matrixWorld);
		a.applyMatrix(d);
		b.remove(a);
		c.add(a)
	}
};
THREE.ShapeUtils = {
	area: function(a) {
		for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
		return .5 * c
	},
	triangulate: function() {
		return function(a, b) {
			var c = a.length;
			if (3 > c) return null;
			var d = [],
				e = [],
				f = [],
				g, h, k;
			if (0 < THREE.ShapeUtils.area(a))
				for (h = 0; h < c; h++) e[h] = h;
			else
				for (h = 0; h < c; h++) e[h] = c - 1 - h;
			var l = 2 * c;
			for (h = c - 1; 2 < c;) {
				if (0 >= l--) {
					console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
					break
				}
				g = h;
				c <= g && (g = 0);
				h = g + 1;
				c <= h && (h = 0);
				k = h + 1;
				c <= k && (k = 0);
				var m;
				a: {
					var n =
						void 0,
						r = void 0,
						t = void 0,
						u = void 0,
						w = n = r = void 0,
						v = t = void 0,
						x = m = void 0,
						y = void 0,
						D = void 0,
						z = void 0,
						G = void 0,
						A = r = u = void 0,
						H = void 0,
						O = void 0,
						M = void 0,
						J = void 0,
						P = void 0,
						L = void 0,
						P = a[e[g]].x,
						J = a[e[g]].y,
						M = a[e[h]].x,
						O = a[e[h]].y,
						H = a[e[k]].x,
						A = a[e[k]].y;
					if (Number.EPSILON > (M - P) * (A - J) - (O - J) * (H - P)) m = !1;
					else {
						G = H - M;
						z = A - O;
						D = P - H;
						y = J - A;
						x = M - P;
						m = O - J;
						for (L = 0; L < c; L++)
							if (r = a[e[L]].x, u = a[e[L]].y, !(r === P && u === J || r === M && u === O || r === H && u === A) && (v = r - P, t = u - J, w = r - M, n = u - O, r -= H, u -= A, n = G * n - z * w, t = x * t - m * v, r = D * u - y * r, n >= -Number.EPSILON &&
									r >= -Number.EPSILON && t >= -Number.EPSILON)) {
								m = !1;
								break a
							}
						m = !0
					}
				}
				if (m) {
					l = e[g];
					m = e[h];
					x = e[k];
					d.push([a[l], a[m], a[x]]);
					f.push([e[g], e[h], e[k]]);
					g = h;
					for (k = h + 1; k < c; g++, k++) e[g] = e[k];
					c--;
					l = 2 * c
				}
			}
			return b ? f : d
		}
	}(),
	triangulateShape: function(a, b) {
		function c(a, b, c) {
			return a.x !== b.x ? a.x < b.x ? a.x <= c.x && c.x <= b.x : b.x <= c.x && c.x <= a.x : a.y < b.y ? a.y <= c.y && c.y <= b.y : b.y <= c.y && c.y <= a.y
		}

		function d(a, b, d, e, f) {
			var g = b.x - a.x,
				h = b.y - a.y,
				k = e.x - d.x,
				l = e.y - d.y,
				m = a.x - d.x,
				n = a.y - d.y,
				r = h * k - g * l,
				t = h * m - g * n;
			if (Math.abs(r) > Number.EPSILON) {
				if (0 <
					r) {
					if (0 > t || t > r) return [];
					k = l * m - k * n;
					if (0 > k || k > r) return []
				} else {
					if (0 < t || t < r) return [];
					k = l * m - k * n;
					if (0 < k || k < r) return []
				}
				if (0 === k) return !f || 0 !== t && t !== r ? [a] : [];
				if (k === r) return !f || 0 !== t && t !== r ? [b] : [];
				if (0 === t) return [d];
				if (t === r) return [e];
				f = k / r;
				return [{
					x: a.x + f * g,
					y: a.y + f * h
				}]
			}
			if (0 !== t || l * m !== k * n) return [];
			h = 0 === g && 0 === h;
			k = 0 === k && 0 === l;
			if (h && k) return a.x !== d.x || a.y !== d.y ? [] : [a];
			if (h) return c(d, e, a) ? [a] : [];
			if (k) return c(a, b, d) ? [d] : [];
			0 !== g ? (a.x < b.x ? (g = a, k = a.x, h = b, a = b.x) : (g = b, k = b.x, h = a, a = a.x), d.x < e.x ? (b = d, r = d.x, l =
				e, d = e.x) : (b = e, r = e.x, l = d, d = d.x)) : (a.y < b.y ? (g = a, k = a.y, h = b, a = b.y) : (g = b, k = b.y, h = a, a = a.y), d.y < e.y ? (b = d, r = d.y, l = e, d = e.y) : (b = e, r = e.y, l = d, d = d.y));
			return k <= r ? a < r ? [] : a === r ? f ? [] : [b] : a <= d ? [b, h] : [b, l] : k > d ? [] : k === d ? f ? [] : [g] : a <= d ? [g, h] : [g, l]
		}

		function e(a, b, c, d) {
			var e = b.x - a.x,
				f = b.y - a.y;
			b = c.x - a.x;
			c = c.y - a.y;
			var g = d.x - a.x;
			d = d.y - a.y;
			a = e * c - f * b;
			e = e * d - f * g;
			return Math.abs(a) > Number.EPSILON ? (b = g * c - d * b, 0 < a ? 0 <= e && 0 <= b : 0 <= e || 0 <= b) : 0 < e
		}

		function f(a, b) {
			function c(a, b) {
				var c = h.length - 1,
					d = a - 1;
				0 > d && (d = c);
				var f = a + 1;
				f > c && (f = 0);
				c =
					e(h[a], h[d], h[f], k[b]);
				if (!c) return !1;
				c = k.length - 1;
				d = b - 1;
				0 > d && (d = c);
				f = b + 1;
				f > c && (f = 0);
				return (c = e(k[b], k[d], k[f], h[a])) ? !0 : !1
			}

			function f(a, b) {
				var c, e;
				for (c = 0; c < h.length; c++)
					if (e = c + 1, e %= h.length, e = d(a, b, h[c], h[e], !0), 0 < e.length) return !0;
				return !1
			}

			function g(a, c) {
				var e, f, g, h;
				for (e = 0; e < l.length; e++)
					for (f = b[l[e]], g = 0; g < f.length; g++)
						if (h = g + 1, h %= f.length, h = d(a, c, f[g], f[h], !0), 0 < h.length) return !0;
				return !1
			}
			var h = a.concat(),
				k, l = [],
				m, n, r, A, H;
			a = [];
			var O, M, J, P = 0;
			for (m = b.length; P < m; P++) l.push(P);
			O = 0;
			for (var L = 2 *
					l.length; 0 < l.length;) {
				L--;
				if (0 > L) {
					console.log("Infinite Loop! Holes left:" + l.length + ", Probably Hole outside Shape!");
					break
				}
				for (n = O; n < h.length; n++) {
					r = h[n];
					m = -1;
					for (P = 0; P < l.length; P++)
						if (A = l[P], H = r.x + ":" + r.y + ":" + A, void 0 === a[H]) {
							k = b[A];
							for (M = 0; M < k.length; M++)
								if (A = k[M], c(n, M) && !f(r, A) && !g(r, A)) {
									m = M;
									l.splice(P, 1);
									O = h.slice(0, n + 1);
									A = h.slice(n);
									M = k.slice(m);
									J = k.slice(0, m + 1);
									h = O.concat(M).concat(J).concat(A);
									O = n;
									break
								}
							if (0 <= m) break;
							a[H] = !0
						}
					if (0 <= m) break
				}
			}
			return h
		}
		var g, h, k, l = {},
			m = a.concat();
		g = 0;
		for (h = b.length; g <
			h; g++) Array.prototype.push.apply(m, b[g]);
		g = 0;
		for (h = m.length; g < h; g++) k = m[g].x + ":" + m[g].y, void 0 !== l[k] && console.warn("THREE.Shape: Duplicate point", k), l[k] = g;
		g = f(a, b);
		m = THREE.ShapeUtils.triangulate(g, !1);
		g = 0;
		for (h = m.length; g < h; g++)
			for (b = m[g], a = 0; 3 > a; a++) k = b[a].x + ":" + b[a].y, k = l[k], void 0 !== k && (b[a] = k);
		return m.concat()
	},
	isClockWise: function(a) {
		return 0 > THREE.ShapeUtils.area(a)
	},
	b2: function() {
		return function(a, b, c, d) {
			var e = 1 - a;
			b *= e * e;
			return b + 2 * (1 - a) * a * c + a * a * d
		}
	}(),
	b3: function() {
		return function(a, b, c,
			d, e) {
			var f = 1 - a;
			b *= f * f * f;
			f = 1 - a;
			c *= 3 * f * f * a;
			c = b + c;
			b = 1 - a;
			d *= 3 * b * a * a;
			return c + d + a * a * a * e
		}
	}()
};
THREE.Curve = function() {};
THREE.Curve.prototype = {
	constructor: THREE.Curve,
	getPoint: function(a) {
		console.warn("THREE.Curve: Warning, getPoint() not implemented!");
		return null
	},
	getPointAt: function(a) {
		a = this.getUtoTmapping(a);
		return this.getPoint(a)
	},
	getPoints: function(a) {
		a || (a = 5);
		var b, c = [];
		for (b = 0; b <= a; b++) c.push(this.getPoint(b / a));
		return c
	},
	getSpacedPoints: function(a) {
		a || (a = 5);
		var b, c = [];
		for (b = 0; b <= a; b++) c.push(this.getPointAt(b / a));
		return c
	},
	getLength: function() {
		var a = this.getLengths();
		return a[a.length - 1]
	},
	getLengths: function(a) {
		a ||
			(a = this.__arcLengthDivisions ? this.__arcLengthDivisions : 200);
		if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
		this.needsUpdate = !1;
		var b = [],
			c, d = this.getPoint(0),
			e, f = 0;
		b.push(0);
		for (e = 1; e <= a; e++) c = this.getPoint(e / a), f += c.distanceTo(d), b.push(f), d = c;
		return this.cacheArcLengths = b
	},
	updateArcLengths: function() {
		this.needsUpdate = !0;
		this.getLengths()
	},
	getUtoTmapping: function(a, b) {
		var c = this.getLengths(),
			d = 0,
			e = c.length;
		a = b ? b : a * c[e - 1];
		b = 0;
		for (var f = e - 1,
				g; b <= f;)
			if (d = Math.floor(b + (f - b) / 2), g = c[d] - a, 0 > g) b = d + 1;
			else if (0 < g) f = d - 1;
		else {
			f = d;
			break
		}
		d = f;
		if (c[d] === a) return d /= e - 1;
		b = c[d];
		c = c[d + 1];
		c -= b;
		c = (a - b) / c;
		return d = (d + c) / (e - 1)
	},
	getTangent: function(a) {
		var b = a - 1E-4;
		a += 1E-4;
		0 > b && (b = 0);
		1 < a && (a = 1);
		b = this.getPoint(b);
		a = this.getPoint(a);
		b = a.clone().sub(b);
		return b.normalize()
	},
	getTangentAt: function(a) {
		a = this.getUtoTmapping(a);
		return this.getTangent(a)
	}
};
THREE.Curve.create = function(a, b) {
	a.prototype = Object.create(THREE.Curve.prototype);
	a.prototype.constructor = a;
	a.prototype.getPoint = b;
	return a
};
THREE.CurvePath = function() {
	this.curves = [];
	this.autoClose = !1
};
THREE.CurvePath.prototype = Object.assign(Object.create(THREE.Curve.prototype), {
	constructor: THREE.CurvePath,
	add: function(a) {
		this.curves.push(a)
	},
	closePath: function() {
		var a = this.curves[0].getPoint(0),
			b = this.curves[this.curves.length - 1].getPoint(1);
		a.equals(b) || this.curves.push(new THREE.LineCurve(b, a))
	},
	getPoint: function(a) {
		var b = a * this.getLength(),
			c = this.getCurveLengths();
		for (a = 0; a < c.length;) {
			if (c[a] >= b) return b = c[a] - b, a = this.curves[a], b = 1 - b / a.getLength(), a.getPointAt(b);
			a++
		}
		return null
	},
	getLength: function() {
		var a =
			this.getCurveLengths();
		return a[a.length - 1]
	},
	getCurveLengths: function() {
		if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
		for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
		return this.cacheLengths = a
	},
	createPointsGeometry: function(a) {
		a = this.getPoints(a);
		return this.createGeometry(a)
	},
	createSpacedPointsGeometry: function(a) {
		a = this.getSpacedPoints(a);
		return this.createGeometry(a)
	},
	createGeometry: function(a) {
		for (var b = new THREE.Geometry,
				c = 0, d = a.length; c < d; c++) {
			var e = a[c];
			b.vertices.push(new THREE.Vector3(e.x, e.y, e.z || 0))
		}
		return b
	}
});
THREE.Font = function(a) {
	this.data = a
};
Object.assign(THREE.Font.prototype, {
	generateShapes: function(a, b, c) {
		void 0 === b && (b = 100);
		void 0 === c && (c = 4);
		var d = this.data;
		a = String(a).split("");
		b /= d.resolution;
		for (var e = 0, f = [], g = 0; g < a.length; g++) {
			var h;
			var k = void 0,
				l = void 0,
				m = void 0,
				n = void 0,
				r = void 0,
				t = k = void 0,
				u = void 0,
				w = void 0,
				m = l = void 0;
			h = b;
			var v = e,
				x = d.glyphs[a[g]] || d.glyphs["?"];
			if (x) {
				var y = new THREE.Path,
					D = [],
					z = THREE.ShapeUtils.b2,
					G = THREE.ShapeUtils.b3;
				if (x.o)
					for (var A = x._cachedOutline || (x._cachedOutline = x.o.split(" ")), H = 0, O = A.length; H < O;) switch (l =
						A[H++], l) {
						case "m":
							m = A[H++] * h + v;
							l = A[H++] * h;
							y.moveTo(m, l);
							break;
						case "l":
							m = A[H++] * h + v;
							l = A[H++] * h;
							y.lineTo(m, l);
							break;
						case "q":
							w = A[H++] * h + v;
							u = A[H++] * h;
							r = A[H++] * h + v;
							n = A[H++] * h;
							y.quadraticCurveTo(r, n, w, u);
							if (k = D[D.length - 1])
								for (var t = k.x, k = k.y, M = 1; M <= c; M++) {
									var J = M / c;
									z(J, t, r, w);
									z(J, k, n, u)
								}
							break;
						case "b":
							if (w = A[H++] * h + v, u = A[H++] * h, r = A[H++] * h + v, n = A[H++] * h, m = A[H++] * h + v, l = A[H++] * h, y.bezierCurveTo(r, n, m, l, w, u), k = D[D.length - 1])
								for (t = k.x, k = k.y, M = 1; M <= c; M++) J = M / c, G(J, t, r, m, w), G(J, k, n, l, u)
					}
				h = {
					offset: x.ha * h,
					path: y
				}
			} else h =
				void 0;
			e += h.offset;
			f.push(h.path)
		}
		c = f;
		d = [];
		a = 0;
		for (b = c.length; a < b; a++) Array.prototype.push.apply(d, c[a].toShapes());
		return d
	}
});
THREE.Path = function(a) {
	THREE.CurvePath.call(this);
	this.actions = [];
	a && this.fromPoints(a)
};
THREE.Path.prototype = Object.assign(Object.create(THREE.CurvePath.prototype), {
	constructor: THREE.Path,
	fromPoints: function(a) {
		this.moveTo(a[0].x, a[0].y);
		for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
	},
	moveTo: function(a, b) {
		this.actions.push({
			action: "moveTo",
			args: [a, b]
		})
	},
	lineTo: function(a, b) {
		var c = this.actions[this.actions.length - 1].args,
			d = c[c.length - 2],
			c = c[c.length - 1],
			d = new THREE.LineCurve(new THREE.Vector2(d, c), new THREE.Vector2(a, b));
		this.curves.push(d);
		this.actions.push({
			action: "lineTo",
			args: [a, b]
		})
	},
	quadraticCurveTo: function(a, b, c, d) {
		var e = this.actions[this.actions.length - 1].args,
			f = e[e.length - 2],
			e = e[e.length - 1],
			f = new THREE.QuadraticBezierCurve(new THREE.Vector2(f, e), new THREE.Vector2(a, b), new THREE.Vector2(c, d));
		this.curves.push(f);
		this.actions.push({
			action: "quadraticCurveTo",
			args: [a, b, c, d]
		})
	},
	bezierCurveTo: function(a, b, c, d, e, f) {
		var g = this.actions[this.actions.length - 1].args,
			h = g[g.length - 2],
			g = g[g.length - 1],
			h = new THREE.CubicBezierCurve(new THREE.Vector2(h, g), new THREE.Vector2(a,
				b), new THREE.Vector2(c, d), new THREE.Vector2(e, f));
		this.curves.push(h);
		this.actions.push({
			action: "bezierCurveTo",
			args: [a, b, c, d, e, f]
		})
	},
	splineThru: function(a) {
		var b = Array.prototype.slice.call(arguments),
			c = this.actions[this.actions.length - 1].args,
			d = c[c.length - 2],
			c = c[c.length - 1],
			d = [new THREE.Vector2(d, c)];
		Array.prototype.push.apply(d, a);
		d = new THREE.SplineCurve(d);
		this.curves.push(d);
		this.actions.push({
			action: "splineThru",
			args: b
		})
	},
	arc: function(a, b, c, d, e, f) {
		var g = this.actions[this.actions.length - 1].args,
			h = g[g.length - 2],
			g = g[g.length - 1];
		this.absarc(a + h, b + g, c, d, e, f)
	},
	absarc: function(a, b, c, d, e, f) {
		this.absellipse(a, b, c, c, d, e, f)
	},
	ellipse: function(a, b, c, d, e, f, g, h) {
		var k = this.actions[this.actions.length - 1].args,
			l = k[k.length - 2],
			k = k[k.length - 1];
		this.absellipse(a + l, b + k, c, d, e, f, g, h)
	},
	absellipse: function(a, b, c, d, e, f, g, h) {
		var k = [a, b, c, d, e, f, g, h || 0];
		a = new THREE.EllipseCurve(a, b, c, d, e, f, g, h);
		this.curves.push(a);
		a = a.getPoint(1);
		k.push(a.x);
		k.push(a.y);
		this.actions.push({
			action: "ellipse",
			args: k
		})
	},
	getSpacedPoints: function(a) {
		a ||
			(a = 40);
		for (var b = [], c = 0; c < a; c++) b.push(this.getPoint(c / a));
		this.autoClose && b.push(b[0]);
		return b
	},
	getPoints: function(a) {
		a = a || 12;
		for (var b = THREE.ShapeUtils.b2, c = THREE.ShapeUtils.b3, d = [], e, f, g, h, k, l, m, n, r, t, u = 0, w = this.actions.length; u < w; u++) {
			var v = this.actions[u];
			r = v.action;
			v = v.args;
			switch (r) {
				case "moveTo":
					d.push(new THREE.Vector2(v[0], v[1]));
					break;
				case "lineTo":
					d.push(new THREE.Vector2(v[0], v[1]));
					break;
				case "quadraticCurveTo":
					e = v[2];
					f = v[3];
					k = v[0];
					l = v[1];
					0 < d.length ? (r = d[d.length - 1], m = r.x, n = r.y) : (r =
						this.actions[u - 1].args, m = r[r.length - 2], n = r[r.length - 1]);
					for (v = 1; v <= a; v++) t = v / a, r = b(t, m, k, e), t = b(t, n, l, f), d.push(new THREE.Vector2(r, t));
					break;
				case "bezierCurveTo":
					e = v[4];
					f = v[5];
					k = v[0];
					l = v[1];
					g = v[2];
					h = v[3];
					0 < d.length ? (r = d[d.length - 1], m = r.x, n = r.y) : (r = this.actions[u - 1].args, m = r[r.length - 2], n = r[r.length - 1]);
					for (v = 1; v <= a; v++) t = v / a, r = c(t, m, k, g, e), t = c(t, n, l, h, f), d.push(new THREE.Vector2(r, t));
					break;
				case "splineThru":
					r = this.actions[u - 1].args;
					r = new THREE.Vector2(r[r.length - 2], r[r.length - 1]);
					t = [r];
					r = a * v[0].length;
					t = t.concat(v[0]);
					t = new THREE.SplineCurve(t);
					for (v = 1; v <= r; v++) d.push(t.getPointAt(v / r));
					break;
				case "arc":
					e = v[0];
					f = v[1];
					l = v[2];
					g = v[3];
					r = v[4];
					k = !!v[5];
					m = r - g;
					n = 2 * a;
					for (v = 1; v <= n; v++) t = v / n, k || (t = 1 - t), t = g + t * m, r = e + l * Math.cos(t), t = f + l * Math.sin(t), d.push(new THREE.Vector2(r, t));
					break;
				case "ellipse":
					e = v[0];
					f = v[1];
					l = v[2];
					h = v[3];
					g = v[4];
					r = v[5];
					k = !!v[6];
					var x = v[7];
					m = r - g;
					n = 2 * a;
					var y, D;
					0 !== x && (y = Math.cos(x), D = Math.sin(x));
					for (v = 1; v <= n; v++) {
						t = v / n;
						k || (t = 1 - t);
						t = g + t * m;
						r = e + l * Math.cos(t);
						t = f + h * Math.sin(t);
						if (0 !== x) {
							var z =
								r;
							r = (z - e) * y - (t - f) * D + e;
							t = (z - e) * D + (t - f) * y + f
						}
						d.push(new THREE.Vector2(r, t))
					}
			}
		}
		a = d[d.length - 1];
		Math.abs(a.x - d[0].x) < Number.EPSILON && Math.abs(a.y - d[0].y) < Number.EPSILON && d.splice(d.length - 1, 1);
		this.autoClose && d.push(d[0]);
		return d
	},
	toShapes: function(a, b) {
		function c(a) {
			for (var b = [], c = new THREE.Path, d = 0, e = a.length; d < e; d++) {
				var f = a[d],
					g = f.args,
					f = f.action;
				"moveTo" === f && 0 !== c.actions.length && (b.push(c), c = new THREE.Path);
				c[f].apply(c, g)
			}
			0 !== c.actions.length && b.push(c);
			return b
		}

		function d(a) {
			for (var b = [], c = 0,
					d = a.length; c < d; c++) {
				var e = a[c],
					f = new THREE.Shape;
				f.actions = e.actions;
				f.curves = e.curves;
				b.push(f)
			}
			return b
		}

		function e(a, b) {
			for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
				var g = b[e],
					h = b[f],
					k = h.x - g.x,
					l = h.y - g.y;
				if (Math.abs(l) > Number.EPSILON) {
					if (0 > l && (g = b[f], k = -k, h = b[e], l = -l), !(a.y < g.y || a.y > h.y))
						if (a.y === g.y) {
							if (a.x === g.x) return !0
						} else {
							e = l * (a.x - g.x) - k * (a.y - g.y);
							if (0 === e) return !0;
							0 > e || (d = !d)
						}
				} else if (a.y === g.y && (h.x <= a.x && a.x <= g.x || g.x <= a.x && a.x <= h.x)) return !0
			}
			return d
		}
		var f = THREE.ShapeUtils.isClockWise,
			g = c(this.actions);
		if (0 === g.length) return [];
		if (!0 === b) return d(g);
		var h, k, l;
		b = [];
		if (1 === g.length) return k = g[0], l = new THREE.Shape, l.actions = k.actions, l.curves = k.curves, b.push(l), b;
		var m = !f(g[0].getPoints()),
			m = a ? !m : m;
		l = [];
		var n = [],
			r = [],
			t = 0,
			u;
		n[t] = void 0;
		r[t] = [];
		for (var w = 0, v = g.length; w < v; w++) k = g[w], u = k.getPoints(), h = f(u), (h = a ? !h : h) ? (!m && n[t] && t++, n[t] = {
			s: new THREE.Shape,
			p: u
		}, n[t].s.actions = k.actions, n[t].s.curves = k.curves, m && t++, r[t] = []) : r[t].push({
			h: k,
			p: u[0]
		});
		if (!n[0]) return d(g);
		if (1 < n.length) {
			w = !1;
			a = [];
			f = 0;
			for (g = n.length; f < g; f++) l[f] = [];
			f = 0;
			for (g = n.length; f < g; f++)
				for (k = r[f], h = 0; h < k.length; h++) {
					m = k[h];
					t = !0;
					for (u = 0; u < n.length; u++) e(m.p, n[u].p) && (f !== u && a.push({
						froms: f,
						tos: u,
						hole: h
					}), t ? (t = !1, l[u].push(m)) : w = !0);
					t && l[f].push(m)
				}
			0 < a.length && (w || (r = l))
		}
		w = 0;
		for (f = n.length; w < f; w++)
			for (l = n[w].s, b.push(l), a = r[w], g = 0, k = a.length; g < k; g++) l.holes.push(a[g].h);
		return b
	}
});
THREE.Shape = function() {
	THREE.Path.apply(this, arguments);
	this.holes = []
};
THREE.Shape.prototype = Object.assign(Object.create(THREE.Path.prototype), {
	constructor: THREE.Shape,
	extrude: function(a) {
		return new THREE.ExtrudeGeometry(this, a)
	},
	makeGeometry: function(a) {
		return new THREE.ShapeGeometry(this, a)
	},
	getPointsHoles: function(a) {
		for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
		return b
	},
	extractAllPoints: function(a) {
		return {
			shape: this.getPoints(a),
			holes: this.getPointsHoles(a)
		}
	},
	extractPoints: function(a) {
		return this.extractAllPoints(a)
	}
});
THREE.LineCurve = function(a, b) {
	this.v1 = a;
	this.v2 = b
};
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.LineCurve.prototype.constructor = THREE.LineCurve;
THREE.LineCurve.prototype.getPoint = function(a) {
	var b = this.v2.clone().sub(this.v1);
	b.multiplyScalar(a).add(this.v1);
	return b
};
THREE.LineCurve.prototype.getPointAt = function(a) {
	return this.getPoint(a)
};
THREE.LineCurve.prototype.getTangent = function(a) {
	a = this.v2.clone().sub(this.v1);
	return a.normalize()
};
THREE.QuadraticBezierCurve = function(a, b, c) {
	this.v0 = a;
	this.v1 = b;
	this.v2 = c
};
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;
THREE.QuadraticBezierCurve.prototype.getPoint = function(a) {
	var b = THREE.ShapeUtils.b2;
	return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y))
};
THREE.QuadraticBezierCurve.prototype.getTangent = function(a) {
	var b = THREE.CurveUtils.tangentQuadraticBezier;
	return (new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y))).normalize()
};
THREE.CubicBezierCurve = function(a, b, c, d) {
	this.v0 = a;
	this.v1 = b;
	this.v2 = c;
	this.v3 = d
};
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;
THREE.CubicBezierCurve.prototype.getPoint = function(a) {
	var b = THREE.ShapeUtils.b3;
	return new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
};
THREE.CubicBezierCurve.prototype.getTangent = function(a) {
	var b = THREE.CurveUtils.tangentCubicBezier;
	return (new THREE.Vector2(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y))).normalize()
};
THREE.SplineCurve = function(a) {
	this.points = void 0 == a ? [] : a
};
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;
THREE.SplineCurve.prototype.getPoint = function(a) {
	var b = this.points;
	a *= b.length - 1;
	var c = Math.floor(a);
	a -= c;
	var d = b[0 === c ? c : c - 1],
		e = b[c],
		f = b[c > b.length - 2 ? b.length - 1 : c + 1],
		b = b[c > b.length - 3 ? b.length - 1 : c + 2],
		c = THREE.CurveUtils.interpolate;
	return new THREE.Vector2(c(d.x, e.x, f.x, b.x, a), c(d.y, e.y, f.y, b.y, a))
};
THREE.EllipseCurve = function(a, b, c, d, e, f, g, h) {
	this.aX = a;
	this.aY = b;
	this.xRadius = c;
	this.yRadius = d;
	this.aStartAngle = e;
	this.aEndAngle = f;
	this.aClockwise = g;
	this.aRotation = h || 0
};
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype);
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;
THREE.EllipseCurve.prototype.getPoint = function(a) {
	var b = this.aEndAngle - this.aStartAngle;
	0 > b && (b += 2 * Math.PI);
	b > 2 * Math.PI && (b -= 2 * Math.PI);
	b = !0 === this.aClockwise ? this.aEndAngle + (1 - a) * (2 * Math.PI - b) : this.aStartAngle + a * b;
	a = this.aX + this.xRadius * Math.cos(b);
	var c = this.aY + this.yRadius * Math.sin(b);
	if (0 !== this.aRotation) {
		var b = Math.cos(this.aRotation),
			d = Math.sin(this.aRotation),
			e = a;
		a = (e - this.aX) * b - (c - this.aY) * d + this.aX;
		c = (e - this.aX) * d + (c - this.aY) * b + this.aY
	}
	return new THREE.Vector2(a, c)
};
THREE.ArcCurve = function(a, b, c, d, e, f) {
	THREE.EllipseCurve.call(this, a, b, c, c, d, e, f)
};
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype);
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;
THREE.LineCurve3 = THREE.Curve.create(function(a, b) {
	this.v1 = a;
	this.v2 = b
}, function(a) {
	var b = new THREE.Vector3;
	b.subVectors(this.v2, this.v1);
	b.multiplyScalar(a);
	b.add(this.v1);
	return b
});
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(a, b, c) {
	this.v0 = a;
	this.v1 = b;
	this.v2 = c
}, function(a) {
	var b = THREE.ShapeUtils.b2;
	return new THREE.Vector3(b(a, this.v0.x, this.v1.x, this.v2.x), b(a, this.v0.y, this.v1.y, this.v2.y), b(a, this.v0.z, this.v1.z, this.v2.z))
});
THREE.CubicBezierCurve3 = THREE.Curve.create(function(a, b, c, d) {
	this.v0 = a;
	this.v1 = b;
	this.v2 = c;
	this.v3 = d
}, function(a) {
	var b = THREE.ShapeUtils.b3;
	return new THREE.Vector3(b(a, this.v0.x, this.v1.x, this.v2.x, this.v3.x), b(a, this.v0.y, this.v1.y, this.v2.y, this.v3.y), b(a, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
});
THREE.SplineCurve3 = THREE.Curve.create(function(a) {
	console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3");
	this.points = void 0 == a ? [] : a
}, function(a) {
	var b = this.points;
	a *= b.length - 1;
	var c = Math.floor(a);
	a -= c;
	var d = b[0 == c ? c : c - 1],
		e = b[c],
		f = b[c > b.length - 2 ? b.length - 1 : c + 1],
		b = b[c > b.length - 3 ? b.length - 1 : c + 2],
		c = THREE.CurveUtils.interpolate;
	return new THREE.Vector3(c(d.x, e.x, f.x, b.x, a), c(d.y, e.y, f.y, b.y, a), c(d.z, e.z, f.z, b.z, a))
});
THREE.CatmullRomCurve3 = function() {
	function a() {}
	var b = new THREE.Vector3,
		c = new a,
		d = new a,
		e = new a;
	a.prototype.init = function(a, b, c, d) {
		this.c0 = a;
		this.c1 = c;
		this.c2 = -3 * a + 3 * b - 2 * c - d;
		this.c3 = 2 * a - 2 * b + c + d
	};
	a.prototype.initNonuniformCatmullRom = function(a, b, c, d, e, m, n) {
		a = (b - a) / e - (c - a) / (e + m) + (c - b) / m;
		d = (c - b) / m - (d - b) / (m + n) + (d - c) / n;
		a *= m;
		d *= m;
		this.init(b, c, a, d)
	};
	a.prototype.initCatmullRom = function(a, b, c, d, e) {
		this.init(b, c, e * (c - a), e * (d - b))
	};
	a.prototype.calc = function(a) {
		var b = a * a,
			c = b * a;
		return this.c0 + this.c1 * a + this.c2 *
			b + this.c3 * c
	};
	return THREE.Curve.create(function(a) {
		this.points = a || [];
		this.closed = !1
	}, function(a) {
		var f = this.points,
			h, k;
		k = f.length;
		2 > k && console.log("duh, you need at least 2 points");
		a *= k - (this.closed ? 0 : 1);
		h = Math.floor(a);
		a -= h;
		this.closed ? h += 0 < h ? 0 : (Math.floor(Math.abs(h) / f.length) + 1) * f.length : 0 === a && h === k - 1 && (h = k - 2, a = 1);
		var l, m, n;
		this.closed || 0 < h ? l = f[(h - 1) % k] : (b.subVectors(f[0], f[1]).add(f[0]), l = b);
		m = f[h % k];
		n = f[(h + 1) % k];
		this.closed || h + 2 < k ? f = f[(h + 2) % k] : (b.subVectors(f[k - 1], f[k - 2]).add(f[k - 1]), f = b);
		if (void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
			var r = "chordal" === this.type ? .5 : .25;
			k = Math.pow(l.distanceToSquared(m), r);
			h = Math.pow(m.distanceToSquared(n), r);
			r = Math.pow(n.distanceToSquared(f), r);
			1E-4 > h && (h = 1);
			1E-4 > k && (k = h);
			1E-4 > r && (r = h);
			c.initNonuniformCatmullRom(l.x, m.x, n.x, f.x, k, h, r);
			d.initNonuniformCatmullRom(l.y, m.y, n.y, f.y, k, h, r);
			e.initNonuniformCatmullRom(l.z, m.z, n.z, f.z, k, h, r)
		} else "catmullrom" === this.type && (k = void 0 !== this.tension ? this.tension : .5, c.initCatmullRom(l.x,
			m.x, n.x, f.x, k), d.initCatmullRom(l.y, m.y, n.y, f.y, k), e.initCatmullRom(l.z, m.z, n.z, f.z, k));
		return a = new THREE.Vector3(c.calc(a), d.calc(a), e.calc(a))
	})
}();
THREE.ClosedSplineCurve3 = function(a) {
	console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.");
	THREE.CatmullRomCurve3.call(this, a);
	this.type = "catmullrom";
	this.closed = !0
};
THREE.ClosedSplineCurve3.prototype = Object.create(THREE.CatmullRomCurve3.prototype);
THREE.BoxGeometry = function(a, b, c, d, e, f) {
	THREE.Geometry.call(this);
	this.type = "BoxGeometry";
	this.parameters = {
		width: a,
		height: b,
		depth: c,
		widthSegments: d,
		heightSegments: e,
		depthSegments: f
	};
	this.fromBufferGeometry(new THREE.BoxBufferGeometry(a, b, c, d, e, f));
	this.mergeVertices()
};
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;
THREE.CubeGeometry = THREE.BoxGeometry;
THREE.BoxBufferGeometry = function(a, b, c, d, e, f) {
	function g(a, b, c) {
		var d = 0,
			d = d + (a + 1) * (b + 1) * 2,
			d = d + (a + 1) * (c + 1) * 2;
		return d += (c + 1) * (b + 1) * 2
	}

	function h(a, b, c) {
		var d = 0,
			d = d + a * b * 2,
			d = d + a * c * 2,
			d = d + c * b * 2;
		return 6 * d
	}

	function k(a, b, c, d, e, f, g, h, k, m, n) {
		var A = f / k,
			J = g / m,
			G = f / 2,
			H = g / 2,
			K = h / 2;
		g = k + 1;
		for (var L = m + 1, P = f = 0, M = new THREE.Vector3, I = 0; I < L; I++)
			for (var Q = I * J - H, O = 0; O < g; O++) {
				var S = O * A - G;
				M[a] = S * d;
				M[b] = Q * e;
				M[c] = K;
				t[v] = M.x;
				t[v + 1] = M.y;
				t[v + 2] = M.z;
				M[a] = 0;
				M[b] = 0;
				M[c] = 0 < h ? 1 : -1;
				u[v] = M.x;
				u[v + 1] = M.y;
				u[v + 2] = M.z;
				w[x] = O / k;
				w[x + 1] = 1 - I /
					m;
				v += 3;
				x += 2;
				f += 1
			}
		for (I = 0; I < m; I++)
			for (O = 0; O < k; O++) a = D + O + g * I, b = D + O + g * (I + 1), c = D + (O + 1) + g * (I + 1), d = D + (O + 1) + g * I, r[y] = a, r[y + 1] = b, r[y + 2] = d, r[y + 3] = b, r[y + 4] = c, r[y + 5] = d, y += 6, P += 6;
		l.addGroup(z, P, n);
		z += P;
		D += f
	}
	THREE.BufferGeometry.call(this);
	this.type = "BoxBufferGeometry";
	this.parameters = {
		width: a,
		height: b,
		depth: c,
		widthSegments: d,
		heightSegments: e,
		depthSegments: f
	};
	var l = this;
	d = Math.floor(d) || 1;
	e = Math.floor(e) || 1;
	f = Math.floor(f) || 1;
	var m = g(d, e, f),
		n = h(d, e, f),
		r = new(65535 < n ? Uint32Array : Uint16Array)(n),
		t = new Float32Array(3 *
			m),
		u = new Float32Array(3 * m),
		w = new Float32Array(2 * m),
		v = 0,
		x = 0,
		y = 0,
		D = 0,
		z = 0;
	k("z", "y", "x", -1, -1, c, b, a, f, e, 0);
	k("z", "y", "x", 1, -1, c, b, -a, f, e, 1);
	k("x", "z", "y", 1, 1, a, c, b, d, f, 2);
	k("x", "z", "y", 1, -1, a, c, -b, d, f, 3);
	k("x", "y", "z", 1, -1, a, b, c, d, e, 4);
	k("x", "y", "z", -1, -1, a, b, -c, d, e, 5);
	this.setIndex(new THREE.BufferAttribute(r, 1));
	this.addAttribute("position", new THREE.BufferAttribute(t, 3));
	this.addAttribute("normal", new THREE.BufferAttribute(u, 3));
	this.addAttribute("uv", new THREE.BufferAttribute(w, 2))
};
THREE.BoxBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;
THREE.CircleGeometry = function(a, b, c, d) {
	THREE.Geometry.call(this);
	this.type = "CircleGeometry";
	this.parameters = {
		radius: a,
		segments: b,
		thetaStart: c,
		thetaLength: d
	};
	this.fromBufferGeometry(new THREE.CircleBufferGeometry(a, b, c, d))
};
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;
THREE.CircleBufferGeometry = function(a, b, c, d) {
	THREE.BufferGeometry.call(this);
	this.type = "CircleBufferGeometry";
	this.parameters = {
		radius: a,
		segments: b,
		thetaStart: c,
		thetaLength: d
	};
	a = a || 50;
	b = void 0 !== b ? Math.max(3, b) : 8;
	c = void 0 !== c ? c : 0;
	d = void 0 !== d ? d : 2 * Math.PI;
	var e = b + 2,
		f = new Float32Array(3 * e),
		g = new Float32Array(3 * e),
		e = new Float32Array(2 * e);
	g[2] = 1;
	e[0] = .5;
	e[1] = .5;
	for (var h = 0, k = 3, l = 2; h <= b; h++, k += 3, l += 2) {
		var m = c + h / b * d;
		f[k] = a * Math.cos(m);
		f[k + 1] = a * Math.sin(m);
		g[k + 2] = 1;
		e[l] = (f[k] / a + 1) / 2;
		e[l + 1] = (f[k + 1] / a + 1) / 2
	}
	c = [];
	for (k = 1; k <= b; k++) c.push(k, k + 1, 0);
	this.setIndex(new THREE.BufferAttribute(new Uint16Array(c), 1));
	this.addAttribute("position", new THREE.BufferAttribute(f, 3));
	this.addAttribute("normal", new THREE.BufferAttribute(g, 3));
	this.addAttribute("uv", new THREE.BufferAttribute(e, 2));
	this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;
THREE.CylinderBufferGeometry = function(a, b, c, d, e, f, g, h) {
	function k() {
		var a = (d + 1) * (e + 1);
		!1 === f && (a += (d + 1) * t + d * t);
		return a
	}

	function l() {
		var a = d * e * 6;
		!1 === f && (a += d * t * 3);
		return a
	}

	function m() {
		var f, k, l = new THREE.Vector3,
			m = new THREE.Vector3,
			n = 0,
			t = (b - a) / c;
		for (k = 0; k <= e; k++) {
			var u = [],
				w = k / e,
				ba = w * (b - a) + a;
			for (f = 0; f <= d; f++) {
				var ca = f / d;
				m.x = ba * Math.sin(ca * h + g);
				m.y = -w * c + H;
				m.z = ba * Math.cos(ca * h + g);
				x.setXYZ(z, m.x, m.y, m.z);
				l.copy(m);
				if (0 === a && 0 === k || 0 === b && k === e) l.x = Math.sin(ca * h + g), l.z = Math.cos(ca * h + g);
				l.setY(Math.sqrt(l.x *
					l.x + l.z * l.z) * t).normalize();
				y.setXYZ(z, l.x, l.y, l.z);
				D.setXY(z, ca, 1 - w);
				u.push(z);
				z++
			}
			A.push(u)
		}
		for (f = 0; f < d; f++)
			for (k = 0; k < e; k++) l = A[k][f], m = A[k + 1][f], t = A[k + 1][f + 1], u = A[k][f + 1], v.setX(G, l), G++, v.setX(G, m), G++, v.setX(G, u), G++, v.setX(G, m), G++, v.setX(G, t), G++, v.setX(G, u), G++, n += 6;
		r.addGroup(O, n, 0);
		O += n
	}

	function n(c) {
		var e, f, k, l = new THREE.Vector2,
			m = new THREE.Vector3,
			n = 0,
			t = !0 === c ? a : b,
			u = !0 === c ? 1 : -1;
		f = z;
		for (e = 1; e <= d; e++) x.setXYZ(z, 0, H * u, 0), y.setXYZ(z, 0, u, 0), l.x = .5, l.y = .5, D.setXY(z, l.x, l.y), z++;
		k = z;
		for (e = 0; e <=
			d; e++) {
			var w = e / d,
				A = w * h + g,
				w = Math.cos(A),
				A = Math.sin(A);
			m.x = t * A;
			m.y = H * u;
			m.z = t * w;
			x.setXYZ(z, m.x, m.y, m.z);
			y.setXYZ(z, 0, u, 0);
			l.x = .5 * w + .5;
			l.y = .5 * A * u + .5;
			D.setXY(z, l.x, l.y);
			z++
		}
		for (e = 0; e < d; e++) l = f + e, m = k + e, !0 === c ? (v.setX(G, m), G++, v.setX(G, m + 1)) : (v.setX(G, m + 1), G++, v.setX(G, m)), G++, v.setX(G, l), G++, n += 3;
		r.addGroup(O, n, !0 === c ? 1 : 2);
		O += n
	}
	THREE.BufferGeometry.call(this);
	this.type = "CylinderBufferGeometry";
	this.parameters = {
		radiusTop: a,
		radiusBottom: b,
		height: c,
		radialSegments: d,
		heightSegments: e,
		openEnded: f,
		thetaStart: g,
		thetaLength: h
	};
	var r = this;
	a = void 0 !== a ? a : 20;
	b = void 0 !== b ? b : 20;
	c = void 0 !== c ? c : 100;
	d = Math.floor(d) || 8;
	e = Math.floor(e) || 1;
	f = void 0 !== f ? f : !1;
	g = void 0 !== g ? g : 0;
	h = void 0 !== h ? h : 2 * Math.PI;
	var t = 0;
	!1 === f && (0 < a && t++, 0 < b && t++);
	var u = k(),
		w = l(),
		v = new THREE.BufferAttribute(new(65535 < w ? Uint32Array : Uint16Array)(w), 1),
		x = new THREE.BufferAttribute(new Float32Array(3 * u), 3),
		y = new THREE.BufferAttribute(new Float32Array(3 * u), 3),
		D = new THREE.BufferAttribute(new Float32Array(2 * u), 2),
		z = 0,
		G = 0,
		A = [],
		H = c / 2,
		O = 0;
	m();
	!1 === f && (0 < a &&
		n(!0), 0 < b && n(!1));
	this.setIndex(v);
	this.addAttribute("position", x);
	this.addAttribute("normal", y);
	this.addAttribute("uv", D)
};
THREE.CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;
THREE.CylinderGeometry = function(a, b, c, d, e, f, g, h) {
	THREE.Geometry.call(this);
	this.type = "CylinderGeometry";
	this.parameters = {
		radiusTop: a,
		radiusBottom: b,
		height: c,
		radialSegments: d,
		heightSegments: e,
		openEnded: f,
		thetaStart: g,
		thetaLength: h
	};
	this.fromBufferGeometry(new THREE.CylinderBufferGeometry(a, b, c, d, e, f, g, h));
	this.mergeVertices()
};
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;
THREE.ConeBufferGeometry = function(a, b, c, d, e, f, g) {
	THREE.CylinderBufferGeometry.call(this, 0, a, b, c, d, e, f, g);
	this.type = "ConeBufferGeometry";
	this.parameters = {
		radius: a,
		height: b,
		radialSegments: c,
		heightSegments: d,
		thetaStart: f,
		thetaLength: g
	}
};
THREE.ConeBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;
THREE.ConeGeometry = function(a, b, c, d, e, f, g) {
	THREE.CylinderGeometry.call(this, 0, a, b, c, d, e, f, g);
	this.type = "ConeGeometry";
	this.parameters = {
		radius: a,
		height: b,
		radialSegments: c,
		heightSegments: d,
		openEnded: e,
		thetaStart: f,
		thetaLength: g
	}
};
THREE.ConeGeometry.prototype = Object.create(THREE.CylinderGeometry.prototype);
THREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;
THREE.EdgesGeometry = function(a, b) {
	function c(a, b) {
		return a - b
	}
	THREE.BufferGeometry.call(this);
	b = void 0 !== b ? b : 1;
	b = Math.cos(THREE.Math.DEG2RAD * b);
	var d = [0, 0],
		e = {},
		f = ["a", "b", "c"],
		g;
	a instanceof THREE.BufferGeometry ? (g = new THREE.Geometry, g.fromBufferGeometry(a)) : g = a.clone();
	g.mergeVertices();
	g.computeFaceNormals();
	a = g.vertices;
	g = g.faces;
	for (var h = 0, k = g.length; h < k; h++)
		for (var l = g[h], m = 0; 3 > m; m++) {
			d[0] = l[f[m]];
			d[1] = l[f[(m + 1) % 3]];
			d.sort(c);
			var n = d.toString();
			void 0 === e[n] ? e[n] = {
				vert1: d[0],
				vert2: d[1],
				face1: h,
				face2: void 0
			} : e[n].face2 = h
		}
	d = [];
	for (n in e)
		if (f = e[n], void 0 === f.face2 || g[f.face1].normal.dot(g[f.face2].normal) <= b) h = a[f.vert1], d.push(h.x), d.push(h.y), d.push(h.z), h = a[f.vert2], d.push(h.x), d.push(h.y), d.push(h.z);
	this.addAttribute("position", new THREE.BufferAttribute(new Float32Array(d), 3))
};
THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;
THREE.ExtrudeGeometry = function(a, b) {
	"undefined" === typeof a ? a = [] : (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", a = Array.isArray(a) ? a : [a], this.addShapeList(a, b), this.computeFaceNormals())
};
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;
THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
	for (var c = a.length, d = 0; d < c; d++) {
		var e = a[d];
		this.addShape(e, b)
	}
};
THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
	function c(a, b, c) {
		b || console.error("THREE.ExtrudeGeometry: vec does not exist");
		return b.clone().multiplyScalar(c).add(a)
	}

	function d(a, b, c) {
		var d, e = 1,
			e = a.x - b.x,
			f = a.y - b.y;
		d = c.x - a.x;
		var g = c.y - a.y,
			h = e * e + f * f,
			k = e * g - f * d;
		if (Math.abs(k) > Number.EPSILON) {
			var l = Math.sqrt(h),
				k = Math.sqrt(d * d + g * g),
				h = b.x - f / l;
			b = b.y + e / l;
			l = c.x - g / k;
			c = c.y + d / k;
			g = ((l - h) * g - (c - b) * d) / (e * g - f * d);
			d = h + e * g - a.x;
			a = b + f * g - a.y;
			e = d * d + a * a;
			if (2 >= e) return new THREE.Vector2(d, a);
			e = Math.sqrt(e / 2)
		} else a = !1, e > Number.EPSILON ? d > Number.EPSILON && (a = !0) : e < -Number.EPSILON ? d < -Number.EPSILON && (a = !0) : Math.sign(f) === Math.sign(g) && (a = !0), a ? (d = -f, a = e, e = Math.sqrt(h)) : (d = e, a = f, e = Math.sqrt(h / 2));
		return new THREE.Vector2(d / e, a / e)
	}

	function e() {
		if (t) {
			var a = 0,
				a = ha * a;
			for (I = 0; I < aa; I++) Z = S[I], k(Z[2] + a, Z[1] + a, Z[0] + a);
			a = w + 2 * r;
			a *= ha;
			for (I = 0; I < aa; I++) Z = S[I], k(Z[0] + a, Z[1] + a, Z[2] + a)
		} else {
			for (I = 0; I < aa; I++) Z = S[I], k(Z[2], Z[1], Z[0]);
			for (I = 0; I < aa; I++) Z = S[I], k(Z[0] + ha * w, Z[1] + ha * w, Z[2] + ha * w)
		}
	}

	function f() {
		var a = 0;
		g(K, a);
		a += K.length;
		M = 0;
		for (J = Q.length; M < J; M++) O = Q[M], g(O, a), a += O.length
	}

	function g(a, b) {
		var c, d;
		for (I = a.length; 0 <= --I;) {
			c = I;
			d = I - 1;
			0 > d && (d = a.length - 1);
			for (var e = 0, f = w + 2 * r, e = 0; e < f; e++) {
				var g = ha * e,
					h = ha * (e + 1),
					k = b + c + g,
					l = b + d + g,
					g = b + d + h,
					h = b + c + h,
					k = k + L,
					l = l + L,
					g = g + L,
					h = h + L;
				P.faces.push(new THREE.Face3(k, l, h, null, null, 1));
				P.faces.push(new THREE.Face3(l, g, h, null, null, 1));
				g = D.generateSideWallUV(P, k, l, g, h);
				P.faceVertexUvs[0].push([g[0], g[1], g[3]]);
				P.faceVertexUvs[0].push([g[1], g[2], g[3]])
			}
		}
	}

	function h(a, b, c) {
		P.vertices.push(new THREE.Vector3(a,
			b, c))
	}

	function k(a, b, c) {
		a += L;
		b += L;
		c += L;
		P.faces.push(new THREE.Face3(a, b, c, null, null, 0));
		a = D.generateTopUV(P, a, b, c);
		P.faceVertexUvs[0].push(a)
	}
	var l = void 0 !== b.amount ? b.amount : 100,
		m = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
		n = void 0 !== b.bevelSize ? b.bevelSize : m - 2,
		r = void 0 !== b.bevelSegments ? b.bevelSegments : 3,
		t = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
		u = void 0 !== b.curveSegments ? b.curveSegments : 12,
		w = void 0 !== b.steps ? b.steps : 1,
		v = b.extrudePath,
		x, y = !1,
		D = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator,
		z, G, A, H;
	v && (x = v.getSpacedPoints(w), y = !0, t = !1, z = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(v, w, !1), G = new THREE.Vector3, A = new THREE.Vector3, H = new THREE.Vector3);
	t || (n = m = r = 0);
	var O, M, J, P = this,
		L = this.vertices.length;
	b = a.extractPoints(u);
	a = b.shape;
	var Q = b.holes;
	if (b = !THREE.ShapeUtils.isClockWise(a)) {
		a = a.reverse();
		M = 0;
		for (J = Q.length; M < J; M++) O = Q[M], THREE.ShapeUtils.isClockWise(O) && (Q[M] = O.reverse());
		b = !1
	}
	var S = THREE.ShapeUtils.triangulateShape(a, Q),
		K = a;
	M = 0;
	for (J = Q.length; M < J; M++) O = Q[M],
		a = a.concat(O);
	var X, ba, ca, ia, Y, ha = a.length,
		Z, aa = S.length;
	b = [];
	var I = 0;
	ca = K.length;
	X = ca - 1;
	for (ba = I + 1; I < ca; I++, X++, ba++) X === ca && (X = 0), ba === ca && (ba = 0), b[I] = d(K[I], K[X], K[ba]);
	var u = [],
		ma, v = b.concat();
	M = 0;
	for (J = Q.length; M < J; M++) {
		O = Q[M];
		ma = [];
		I = 0;
		ca = O.length;
		X = ca - 1;
		for (ba = I + 1; I < ca; I++, X++, ba++) X === ca && (X = 0), ba === ca && (ba = 0), ma[I] = d(O[I], O[X], O[ba]);
		u.push(ma);
		v = v.concat(ma)
	}
	for (X = 0; X < r; X++) {
		ca = X / r;
		ia = m * (1 - ca);
		ba = n * Math.sin(ca * Math.PI / 2);
		I = 0;
		for (ca = K.length; I < ca; I++) Y = c(K[I], b[I], ba), h(Y.x, Y.y, -ia);
		M = 0;
		for (J = Q.length; M < J; M++)
			for (O = Q[M], ma = u[M], I = 0, ca = O.length; I < ca; I++) Y = c(O[I], ma[I], ba), h(Y.x, Y.y, -ia)
	}
	ba = n;
	for (I = 0; I < ha; I++) Y = t ? c(a[I], v[I], ba) : a[I], y ? (A.copy(z.normals[0]).multiplyScalar(Y.x), G.copy(z.binormals[0]).multiplyScalar(Y.y), H.copy(x[0]).add(A).add(G), h(H.x, H.y, H.z)) : h(Y.x, Y.y, 0);
	for (ca = 1; ca <= w; ca++)
		for (I = 0; I < ha; I++) Y = t ? c(a[I], v[I], ba) : a[I], y ? (A.copy(z.normals[ca]).multiplyScalar(Y.x), G.copy(z.binormals[ca]).multiplyScalar(Y.y), H.copy(x[ca]).add(A).add(G), h(H.x, H.y, H.z)) : h(Y.x, Y.y, l / w * ca);
	for (X = r - 1; 0 <= X; X--) {
		ca = X / r;
		ia = m * (1 - ca);
		ba = n * Math.sin(ca * Math.PI / 2);
		I = 0;
		for (ca = K.length; I < ca; I++) Y = c(K[I], b[I], ba), h(Y.x, Y.y, l + ia);
		M = 0;
		for (J = Q.length; M < J; M++)
			for (O = Q[M], ma = u[M], I = 0, ca = O.length; I < ca; I++) Y = c(O[I], ma[I], ba), y ? h(Y.x, Y.y + x[w - 1].y, x[w - 1].x + ia) : h(Y.x, Y.y, l + ia)
	}
	e();
	f()
};
THREE.ExtrudeGeometry.WorldUVGenerator = {
	generateTopUV: function(a, b, c, d) {
		a = a.vertices;
		b = a[b];
		c = a[c];
		d = a[d];
		return [new THREE.Vector2(b.x, b.y), new THREE.Vector2(c.x, c.y), new THREE.Vector2(d.x, d.y)]
	},
	generateSideWallUV: function(a, b, c, d, e) {
		a = a.vertices;
		b = a[b];
		c = a[c];
		d = a[d];
		e = a[e];
		return .01 > Math.abs(b.y - c.y) ? [new THREE.Vector2(b.x, 1 - b.z), new THREE.Vector2(c.x, 1 - c.z), new THREE.Vector2(d.x, 1 - d.z), new THREE.Vector2(e.x, 1 - e.z)] : [new THREE.Vector2(b.y, 1 - b.z), new THREE.Vector2(c.y, 1 - c.z), new THREE.Vector2(d.y,
			1 - d.z), new THREE.Vector2(e.y, 1 - e.z)]
	}
};
THREE.ShapeGeometry = function(a, b) {
	THREE.Geometry.call(this);
	this.type = "ShapeGeometry";
	!1 === Array.isArray(a) && (a = [a]);
	this.addShapeList(a, b);
	this.computeFaceNormals()
};
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;
THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
	for (var c = 0, d = a.length; c < d; c++) this.addShape(a[c], b);
	return this
};
THREE.ShapeGeometry.prototype.addShape = function(a, b) {
	void 0 === b && (b = {});
	var c = void 0 !== b.curveSegments ? b.curveSegments : 12,
		d = b.material;
	b = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator;
	var e, f, g = this.vertices.length;
	a = a.extractPoints(c);
	var h = a.shape,
		k = a.holes;
	if (a = !THREE.ShapeUtils.isClockWise(h)) {
		h = h.reverse();
		a = 0;
		for (e = k.length; a < e; a++) f = k[a], THREE.ShapeUtils.isClockWise(f) && (k[a] = f.reverse());
		a = !1
	}
	c = THREE.ShapeUtils.triangulateShape(h, k);
	a = 0;
	for (e = k.length; a < e; a++) f =
		k[a], h = h.concat(f);
	f = h.length;
	k = c.length;
	for (a = 0; a < f; a++) e = h[a], this.vertices.push(new THREE.Vector3(e.x, e.y, 0));
	for (a = 0; a < k; a++) f = c[a], h = f[0] + g, e = f[1] + g, f = f[2] + g, this.faces.push(new THREE.Face3(h, e, f, null, null, d)), this.faceVertexUvs[0].push(b.generateTopUV(this, h, e, f))
};
THREE.LatheBufferGeometry = function(a, b, c, d) {
	THREE.BufferGeometry.call(this);
	this.type = "LatheBufferGeometry";
	this.parameters = {
		points: a,
		segments: b,
		phiStart: c,
		phiLength: d
	};
	b = Math.floor(b) || 12;
	c = c || 0;
	d = d || 2 * Math.PI;
	d = THREE.Math.clamp(d, 0, 2 * Math.PI);
	for (var e = (b + 1) * a.length, f = b * a.length * 6, g = new THREE.BufferAttribute(new(65535 < f ? Uint32Array : Uint16Array)(f), 1), h = new THREE.BufferAttribute(new Float32Array(3 * e), 3), k = new THREE.BufferAttribute(new Float32Array(2 * e), 2), l = 0, m = 0, e = 1 / (a.length - 1), n = 1 / b, r = new THREE.Vector3,
			t = new THREE.Vector2, e = 0; e <= b; e++)
		for (var f = c + e * n * d, u = Math.sin(f), w = Math.cos(f), f = 0; f <= a.length - 1; f++) r.x = a[f].x * u, r.y = a[f].y, r.z = a[f].x * w, h.setXYZ(l, r.x, r.y, r.z), t.x = e / b, t.y = f / (a.length - 1), k.setXY(l, t.x, t.y), l++;
	for (e = 0; e < b; e++)
		for (f = 0; f < a.length - 1; f++) l = c = f + e * a.length, n = c + a.length, r = c + a.length + 1, c += 1, g.setX(m, l), m++, g.setX(m, n), m++, g.setX(m, c), m++, g.setX(m, n), m++, g.setX(m, r), m++, g.setX(m, c), m++;
	this.setIndex(g);
	this.addAttribute("position", h);
	this.addAttribute("uv", k);
	this.computeVertexNormals();
	if (d === 2 * Math.PI)
		for (d = this.attributes.normal.array, g = new THREE.Vector3, h = new THREE.Vector3, k = new THREE.Vector3, c = b * a.length * 3, f = e = 0; e < a.length; e++, f += 3) g.x = d[f + 0], g.y = d[f + 1], g.z = d[f + 2], h.x = d[c + f + 0], h.y = d[c + f + 1], h.z = d[c + f + 2], k.addVectors(g, h).normalize(), d[f + 0] = d[c + f + 0] = k.x, d[f + 1] = d[c + f + 1] = k.y, d[f + 2] = d[c + f + 2] = k.z
};
THREE.LatheBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;
THREE.LatheGeometry = function(a, b, c, d) {
	THREE.Geometry.call(this);
	this.type = "LatheGeometry";
	this.parameters = {
		points: a,
		segments: b,
		phiStart: c,
		phiLength: d
	};
	this.fromBufferGeometry(new THREE.LatheBufferGeometry(a, b, c, d));
	this.mergeVertices()
};
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;
THREE.PlaneGeometry = function(a, b, c, d) {
	THREE.Geometry.call(this);
	this.type = "PlaneGeometry";
	this.parameters = {
		width: a,
		height: b,
		widthSegments: c,
		heightSegments: d
	};
	this.fromBufferGeometry(new THREE.PlaneBufferGeometry(a, b, c, d))
};
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;
THREE.PlaneBufferGeometry = function(a, b, c, d) {
	THREE.BufferGeometry.call(this);
	this.type = "PlaneBufferGeometry";
	this.parameters = {
		width: a,
		height: b,
		widthSegments: c,
		heightSegments: d
	};
	var e = a / 2,
		f = b / 2;
	c = Math.floor(c) || 1;
	d = Math.floor(d) || 1;
	var g = c + 1,
		h = d + 1,
		k = a / c,
		l = b / d;
	b = new Float32Array(g * h * 3);
	a = new Float32Array(g * h * 3);
	for (var m = new Float32Array(g * h * 2), n = 0, r = 0, t = 0; t < h; t++)
		for (var u = t * l - f, w = 0; w < g; w++) {
			var v = w * k - e;
			b[n] = v;
			b[n + 1] = -u;
			a[n + 2] = 1;
			m[r] = w / c;
			m[r + 1] = 1 - t / d;
			n += 3;
			r += 2
		}
	n = 0;
	e = new(65535 < b.length / 3 ? Uint32Array :
		Uint16Array)(c * d * 6);
	for (t = 0; t < d; t++)
		for (w = 0; w < c; w++) f = w + g * t, h = w + g * (t + 1), k = w + 1 + g * (t + 1), l = w + 1 + g * t, e[n] = f, e[n + 1] = h, e[n + 2] = l, e[n + 3] = h, e[n + 4] = k, e[n + 5] = l, n += 6;
	this.setIndex(new THREE.BufferAttribute(e, 1));
	this.addAttribute("position", new THREE.BufferAttribute(b, 3));
	this.addAttribute("normal", new THREE.BufferAttribute(a, 3));
	this.addAttribute("uv", new THREE.BufferAttribute(m, 2))
};
THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;
THREE.RingBufferGeometry = function(a, b, c, d, e, f) {
	THREE.BufferGeometry.call(this);
	this.type = "RingBufferGeometry";
	this.parameters = {
		innerRadius: a,
		outerRadius: b,
		thetaSegments: c,
		phiSegments: d,
		thetaStart: e,
		thetaLength: f
	};
	a = a || 20;
	b = b || 50;
	e = void 0 !== e ? e : 0;
	f = void 0 !== f ? f : 2 * Math.PI;
	c = void 0 !== c ? Math.max(3, c) : 8;
	d = void 0 !== d ? Math.max(1, d) : 1;
	var g = (c + 1) * (d + 1),
		h = c * d * 6,
		h = new THREE.BufferAttribute(new(65535 < h ? Uint32Array : Uint16Array)(h), 1),
		k = new THREE.BufferAttribute(new Float32Array(3 * g), 3),
		l = new THREE.BufferAttribute(new Float32Array(3 *
			g), 3),
		g = new THREE.BufferAttribute(new Float32Array(2 * g), 2),
		m = 0,
		n = 0,
		r, t = a,
		u = (b - a) / d,
		w = new THREE.Vector3,
		v = new THREE.Vector2,
		x;
	for (a = 0; a <= d; a++) {
		for (x = 0; x <= c; x++) r = e + x / c * f, w.x = t * Math.cos(r), w.y = t * Math.sin(r), k.setXYZ(m, w.x, w.y, w.z), l.setXYZ(m, 0, 0, 1), v.x = (w.x / b + 1) / 2, v.y = (w.y / b + 1) / 2, g.setXY(m, v.x, v.y), m++;
		t += u
	}
	for (a = 0; a < d; a++)
		for (b = a * (c + 1), x = 0; x < c; x++) e = r = x + b, f = r + c + 1, m = r + c + 2, r += 1, h.setX(n, e), n++, h.setX(n, f), n++, h.setX(n, m), n++, h.setX(n, e), n++, h.setX(n, m), n++, h.setX(n, r), n++;
	this.setIndex(h);
	this.addAttribute("position",
		k);
	this.addAttribute("normal", l);
	this.addAttribute("uv", g)
};
THREE.RingBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;
THREE.RingGeometry = function(a, b, c, d, e, f) {
	THREE.Geometry.call(this);
	this.type = "RingGeometry";
	this.parameters = {
		innerRadius: a,
		outerRadius: b,
		thetaSegments: c,
		phiSegments: d,
		thetaStart: e,
		thetaLength: f
	};
	this.fromBufferGeometry(new THREE.RingBufferGeometry(a, b, c, d, e, f))
};
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;
THREE.SphereGeometry = function(a, b, c, d, e, f, g) {
	THREE.Geometry.call(this);
	this.type = "SphereGeometry";
	this.parameters = {
		radius: a,
		widthSegments: b,
		heightSegments: c,
		phiStart: d,
		phiLength: e,
		thetaStart: f,
		thetaLength: g
	};
	this.fromBufferGeometry(new THREE.SphereBufferGeometry(a, b, c, d, e, f, g))
};
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;
THREE.SphereBufferGeometry = function(a, b, c, d, e, f, g) {
	THREE.BufferGeometry.call(this);
	this.type = "SphereBufferGeometry";
	this.parameters = {
		radius: a,
		widthSegments: b,
		heightSegments: c,
		phiStart: d,
		phiLength: e,
		thetaStart: f,
		thetaLength: g
	};
	a = a || 50;
	b = Math.max(3, Math.floor(b) || 8);
	c = Math.max(2, Math.floor(c) || 6);
	d = void 0 !== d ? d : 0;
	e = void 0 !== e ? e : 2 * Math.PI;
	f = void 0 !== f ? f : 0;
	g = void 0 !== g ? g : Math.PI;
	for (var h = f + g, k = (b + 1) * (c + 1), l = new THREE.BufferAttribute(new Float32Array(3 * k), 3), m = new THREE.BufferAttribute(new Float32Array(3 *
			k), 3), k = new THREE.BufferAttribute(new Float32Array(2 * k), 2), n = 0, r = [], t = new THREE.Vector3, u = 0; u <= c; u++) {
		for (var w = [], v = u / c, x = 0; x <= b; x++) {
			var y = x / b,
				D = -a * Math.cos(d + y * e) * Math.sin(f + v * g),
				z = a * Math.cos(f + v * g),
				G = a * Math.sin(d + y * e) * Math.sin(f + v * g);
			t.set(D, z, G).normalize();
			l.setXYZ(n, D, z, G);
			m.setXYZ(n, t.x, t.y, t.z);
			k.setXY(n, y, 1 - v);
			w.push(n);
			n++
		}
		r.push(w)
	}
	d = [];
	for (u = 0; u < c; u++)
		for (x = 0; x < b; x++) e = r[u][x + 1], g = r[u][x], n = r[u + 1][x], t = r[u + 1][x + 1], (0 !== u || 0 < f) && d.push(e, g, t), (u !== c - 1 || h < Math.PI) && d.push(g, n, t);
	this.setIndex(new(65535 <
		l.count ? THREE.Uint32Attribute : THREE.Uint16Attribute)(d, 1));
	this.addAttribute("position", l);
	this.addAttribute("normal", m);
	this.addAttribute("uv", k);
	this.boundingSphere = new THREE.Sphere(new THREE.Vector3, a)
};
THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;
THREE.TextGeometry = function(a, b) {
	b = b || {};
	var c = b.font;
	if (!1 === c instanceof THREE.Font) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new THREE.Geometry;
	a = c.generateShapes(a, b.size, b.curveSegments);
	b.amount = void 0 !== b.height ? b.height : 50;
	void 0 === b.bevelThickness && (b.bevelThickness = 10);
	void 0 === b.bevelSize && (b.bevelSize = 8);
	void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
	THREE.ExtrudeGeometry.call(this, a, b);
	this.type = "TextGeometry"
};
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;
THREE.TorusBufferGeometry = function(a, b, c, d, e) {
	THREE.BufferGeometry.call(this);
	this.type = "TorusBufferGeometry";
	this.parameters = {
		radius: a,
		tube: b,
		radialSegments: c,
		tubularSegments: d,
		arc: e
	};
	a = a || 100;
	b = b || 40;
	c = Math.floor(c) || 8;
	d = Math.floor(d) || 6;
	e = e || 2 * Math.PI;
	var f = (c + 1) * (d + 1),
		g = c * d * 6,
		g = new(65535 < g ? Uint32Array : Uint16Array)(g),
		h = new Float32Array(3 * f),
		k = new Float32Array(3 * f),
		f = new Float32Array(2 * f),
		l = 0,
		m = 0,
		n = 0,
		r = new THREE.Vector3,
		t = new THREE.Vector3,
		u = new THREE.Vector3,
		w, v;
	for (w = 0; w <= c; w++)
		for (v = 0; v <= d; v++) {
			var x =
				v / d * e,
				y = w / c * Math.PI * 2;
			t.x = (a + b * Math.cos(y)) * Math.cos(x);
			t.y = (a + b * Math.cos(y)) * Math.sin(x);
			t.z = b * Math.sin(y);
			h[l] = t.x;
			h[l + 1] = t.y;
			h[l + 2] = t.z;
			r.x = a * Math.cos(x);
			r.y = a * Math.sin(x);
			u.subVectors(t, r).normalize();
			k[l] = u.x;
			k[l + 1] = u.y;
			k[l + 2] = u.z;
			f[m] = v / d;
			f[m + 1] = w / c;
			l += 3;
			m += 2
		}
	for (w = 1; w <= c; w++)
		for (v = 1; v <= d; v++) a = (d + 1) * w + v - 1, b = (d + 1) * (w - 1) + v - 1, e = (d + 1) * (w - 1) + v, l = (d + 1) * w + v, g[n] = a, g[n + 1] = b, g[n + 2] = l, g[n + 3] = b, g[n + 4] = e, g[n + 5] = l, n += 6;
	this.setIndex(new THREE.BufferAttribute(g, 1));
	this.addAttribute("position", new THREE.BufferAttribute(h,
		3));
	this.addAttribute("normal", new THREE.BufferAttribute(k, 3));
	this.addAttribute("uv", new THREE.BufferAttribute(f, 2))
};
THREE.TorusBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;
THREE.TorusGeometry = function(a, b, c, d, e) {
	THREE.Geometry.call(this);
	this.type = "TorusGeometry";
	this.parameters = {
		radius: a,
		tube: b,
		radialSegments: c,
		tubularSegments: d,
		arc: e
	};
	this.fromBufferGeometry(new THREE.TorusBufferGeometry(a, b, c, d, e))
};
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;
THREE.TorusKnotBufferGeometry = function(a, b, c, d, e, f) {
	function g(a, b, c, d, e) {
		var f = Math.cos(a),
			g = Math.sin(a);
		a *= c / b;
		b = Math.cos(a);
		e.x = d * (2 + b) * .5 * f;
		e.y = d * (2 + b) * g * .5;
		e.z = d * Math.sin(a) * .5
	}
	THREE.BufferGeometry.call(this);
	this.type = "TorusKnotBufferGeometry";
	this.parameters = {
		radius: a,
		tube: b,
		tubularSegments: c,
		radialSegments: d,
		p: e,
		q: f
	};
	a = a || 100;
	b = b || 40;
	c = Math.floor(c) || 64;
	d = Math.floor(d) || 8;
	e = e || 2;
	f = f || 3;
	var h = (d + 1) * (c + 1),
		k = d * c * 6,
		k = new THREE.BufferAttribute(new(65535 < k ? Uint32Array : Uint16Array)(k), 1),
		l = new THREE.BufferAttribute(new Float32Array(3 *
			h), 3),
		m = new THREE.BufferAttribute(new Float32Array(3 * h), 3),
		h = new THREE.BufferAttribute(new Float32Array(2 * h), 2),
		n, r, t = 0,
		u = 0,
		w = new THREE.Vector3,
		v = new THREE.Vector3,
		x = new THREE.Vector2,
		y = new THREE.Vector3,
		D = new THREE.Vector3,
		z = new THREE.Vector3,
		G = new THREE.Vector3,
		A = new THREE.Vector3;
	for (n = 0; n <= c; ++n)
		for (r = n / c * e * Math.PI * 2, g(r, e, f, a, y), g(r + .01, e, f, a, D), G.subVectors(D, y), A.addVectors(D, y), z.crossVectors(G, A), A.crossVectors(z, G), z.normalize(), A.normalize(), r = 0; r <= d; ++r) {
			var H = r / d * Math.PI * 2,
				O = -b * Math.cos(H),
				H = b * Math.sin(H);
			w.x = y.x + (O * A.x + H * z.x);
			w.y = y.y + (O * A.y + H * z.y);
			w.z = y.z + (O * A.z + H * z.z);
			l.setXYZ(t, w.x, w.y, w.z);
			v.subVectors(w, y).normalize();
			m.setXYZ(t, v.x, v.y, v.z);
			x.x = n / c;
			x.y = r / d;
			h.setXY(t, x.x, x.y);
			t++
		}
	for (r = 1; r <= c; r++)
		for (n = 1; n <= d; n++) a = (d + 1) * (r - 1) + (n - 1), b = (d + 1) * r + (n - 1), e = (d + 1) * r + n, f = (d + 1) * (r - 1) + n, k.setX(u, a), u++, k.setX(u, b), u++, k.setX(u, f), u++, k.setX(u, b), u++, k.setX(u, e), u++, k.setX(u, f), u++;
	this.setIndex(k);
	this.addAttribute("position", l);
	this.addAttribute("normal", m);
	this.addAttribute("uv", h)
};
THREE.TorusKnotBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;
THREE.TorusKnotGeometry = function(a, b, c, d, e, f, g) {
	THREE.Geometry.call(this);
	this.type = "TorusKnotGeometry";
	this.parameters = {
		radius: a,
		tube: b,
		tubularSegments: c,
		radialSegments: d,
		p: e,
		q: f
	};
	void 0 !== g && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
	this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(a, b, c, d, e, f));
	this.mergeVertices()
};
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;
THREE.TubeGeometry = function(a, b, c, d, e, f) {
	THREE.Geometry.call(this);
	this.type = "TubeGeometry";
	this.parameters = {
		path: a,
		segments: b,
		radius: c,
		radialSegments: d,
		closed: e,
		taper: f
	};
	b = b || 64;
	c = c || 1;
	d = d || 8;
	e = e || !1;
	f = f || THREE.TubeGeometry.NoTaper;
	var g = [],
		h = this,
		k, l, m = b + 1,
		n, r, t, u, w, v = new THREE.Vector3,
		x, y, D;
	x = new THREE.TubeGeometry.FrenetFrames(a, b, e);
	y = x.tangents;
	D = x.normals;
	var z = x.binormals;
	this.tangents = y;
	this.normals = D;
	this.binormals = z;
	for (x = 0; x < m; x++)
		for (g[x] = [], n = x / (m - 1), w = a.getPointAt(n), k = y[x], k = D[x],
			l = z[x], t = c * f(n), n = 0; n < d; n++) r = n / d * 2 * Math.PI, u = -t * Math.cos(r), r = t * Math.sin(r), v.copy(w), v.x += u * k.x + r * l.x, v.y += u * k.y + r * l.y, v.z += u * k.z + r * l.z, g[x][n] = h.vertices.push(new THREE.Vector3(v.x, v.y, v.z)) - 1;
	for (x = 0; x < b; x++)
		for (n = 0; n < d; n++) f = e ? (x + 1) % b : x + 1, h = (n + 1) % d, a = g[x][n], c = g[f][n], f = g[f][h], h = g[x][h], m = new THREE.Vector2(x / b, n / d), v = new THREE.Vector2((x + 1) / b, n / d), y = new THREE.Vector2((x + 1) / b, (n + 1) / d), D = new THREE.Vector2(x / b, (n + 1) / d), this.faces.push(new THREE.Face3(a, c, h)), this.faceVertexUvs[0].push([m, v, D]),
			this.faces.push(new THREE.Face3(c, f, h)), this.faceVertexUvs[0].push([v.clone(), y, D.clone()]);
	this.computeFaceNormals();
	this.computeVertexNormals()
};
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;
THREE.TubeGeometry.NoTaper = function(a) {
	return 1
};
THREE.TubeGeometry.SinusoidalTaper = function(a) {
	return Math.sin(Math.PI * a)
};
THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
	var d = new THREE.Vector3,
		e = [],
		f = [],
		g = [],
		h = new THREE.Vector3,
		k = new THREE.Matrix4;
	b += 1;
	var l, m, n;
	this.tangents = e;
	this.normals = f;
	this.binormals = g;
	for (l = 0; l < b; l++) m = l / (b - 1), e[l] = a.getTangentAt(m), e[l].normalize();
	f[0] = new THREE.Vector3;
	g[0] = new THREE.Vector3;
	a = Number.MAX_VALUE;
	l = Math.abs(e[0].x);
	m = Math.abs(e[0].y);
	n = Math.abs(e[0].z);
	l <= a && (a = l, d.set(1, 0, 0));
	m <= a && (a = m, d.set(0, 1, 0));
	n <= a && d.set(0, 0, 1);
	h.crossVectors(e[0], d).normalize();
	f[0].crossVectors(e[0],
		h);
	g[0].crossVectors(e[0], f[0]);
	for (l = 1; l < b; l++) f[l] = f[l - 1].clone(), g[l] = g[l - 1].clone(), h.crossVectors(e[l - 1], e[l]), h.length() > Number.EPSILON && (h.normalize(), d = Math.acos(THREE.Math.clamp(e[l - 1].dot(e[l]), -1, 1)), f[l].applyMatrix4(k.makeRotationAxis(h, d))), g[l].crossVectors(e[l], f[l]);
	if (c)
		for (d = Math.acos(THREE.Math.clamp(f[0].dot(f[b - 1]), -1, 1)), d /= b - 1, 0 < e[0].dot(h.crossVectors(f[0], f[b - 1])) && (d = -d), l = 1; l < b; l++) f[l].applyMatrix4(k.makeRotationAxis(e[l], d * l)), g[l].crossVectors(e[l], f[l])
};
THREE.PolyhedronGeometry = function(a, b, c, d) {
	function e(a) {
		var b = a.normalize().clone();
		b.index = k.vertices.push(b) - 1;
		var c = Math.atan2(a.z, -a.x) / 2 / Math.PI + .5;
		a = Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5;
		b.uv = new THREE.Vector2(c, 1 - a);
		return b
	}

	function f(a, b, c, d) {
		d = new THREE.Face3(a.index, b.index, c.index, [a.clone(), b.clone(), c.clone()], void 0, d);
		k.faces.push(d);
		v.copy(a).add(b).add(c).divideScalar(3);
		d = Math.atan2(v.z, -v.x);
		k.faceVertexUvs[0].push([h(a.uv, a, d), h(b.uv, b, d), h(c.uv, c, d)])
	}

	function g(a,
		b) {
		b = Math.pow(2, b);
		var c = e(k.vertices[a.a]),
			d = e(k.vertices[a.b]),
			g = e(k.vertices[a.c]),
			h = [];
		a = a.materialIndex;
		for (var l = 0; l <= b; l++) {
			h[l] = [];
			for (var m = e(c.clone().lerp(g, l / b)), n = e(d.clone().lerp(g, l / b)), r = b - l, t = 0; t <= r; t++) h[l][t] = 0 === t && l === b ? m : e(m.clone().lerp(n, t / r))
		}
		for (l = 0; l < b; l++)
			for (t = 0; t < 2 * (b - l) - 1; t++) c = Math.floor(t / 2), 0 === t % 2 ? f(h[l][c + 1], h[l + 1][c], h[l][c], a) : f(h[l][c + 1], h[l + 1][c + 1], h[l + 1][c], a)
	}

	function h(a, b, c) {
		0 > c && 1 === a.x && (a = new THREE.Vector2(a.x - 1, a.y));
		0 === b.x && 0 === b.z && (a = new THREE.Vector2(c /
			2 / Math.PI + .5, a.y));
		return a.clone()
	}
	THREE.Geometry.call(this);
	this.type = "PolyhedronGeometry";
	this.parameters = {
		vertices: a,
		indices: b,
		radius: c,
		detail: d
	};
	c = c || 1;
	d = d || 0;
	for (var k = this, l = 0, m = a.length; l < m; l += 3) e(new THREE.Vector3(a[l], a[l + 1], a[l + 2]));
	a = this.vertices;
	for (var n = [], r = l = 0, m = b.length; l < m; l += 3, r++) {
		var t = a[b[l]],
			u = a[b[l + 1]],
			w = a[b[l + 2]];
		n[r] = new THREE.Face3(t.index, u.index, w.index, [t.clone(), u.clone(), w.clone()], void 0, r)
	}
	for (var v = new THREE.Vector3, l = 0, m = n.length; l < m; l++) g(n[l], d);
	l = 0;
	for (m = this.faceVertexUvs[0].length; l <
		m; l++) b = this.faceVertexUvs[0][l], d = b[0].x, a = b[1].x, n = b[2].x, r = Math.max(d, a, n), t = Math.min(d, a, n), .9 < r && .1 > t && (.2 > d && (b[0].x += 1), .2 > a && (b[1].x += 1), .2 > n && (b[2].x += 1));
	l = 0;
	for (m = this.vertices.length; l < m; l++) this.vertices[l].multiplyScalar(c);
	this.mergeVertices();
	this.computeFaceNormals();
	this.boundingSphere = new THREE.Sphere(new THREE.Vector3, c)
};
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;
THREE.DodecahedronGeometry = function(a, b) {
	var c = (1 + Math.sqrt(5)) / 2,
		d = 1 / c,
		c = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, -d, -c, 0, -d, c, 0, d, -c, 0, d, c, 0, -c, 0, -d, c, 0, -d, -c, 0, d, c, 0, d],
		d = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
	THREE.PolyhedronGeometry.call(this,
		c, d, a, b);
	this.type = "DodecahedronGeometry";
	this.parameters = {
		radius: a,
		detail: b
	}
};
THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;
THREE.IcosahedronGeometry = function(a, b) {
	var c = (1 + Math.sqrt(5)) / 2,
		c = [-1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, 0, 0, -1, c, 0, 1, c, 0, -1, -c, 0, 1, -c, c, 0, -1, c, 0, 1, -c, 0, -1, -c, 0, 1],
		d = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
	THREE.PolyhedronGeometry.call(this, c, d, a, b);
	this.type = "IcosahedronGeometry";
	this.parameters = {
		radius: a,
		detail: b
	}
};
THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;
THREE.OctahedronGeometry = function(a, b) {
	var c = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
		d = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
	THREE.PolyhedronGeometry.call(this, c, d, a, b);
	this.type = "OctahedronGeometry";
	this.parameters = {
		radius: a,
		detail: b
	}
};
THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;
THREE.TetrahedronGeometry = function(a, b) {
	var c = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
		d = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
	THREE.PolyhedronGeometry.call(this, c, d, a, b);
	this.type = "TetrahedronGeometry";
	this.parameters = {
		radius: a,
		detail: b
	}
};
THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype);
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;
THREE.ParametricGeometry = function(a, b, c) {
	THREE.Geometry.call(this);
	this.type = "ParametricGeometry";
	this.parameters = {
		func: a,
		slices: b,
		stacks: c
	};
	var d = this.vertices,
		e = this.faces,
		f = this.faceVertexUvs[0],
		g, h, k, l, m = b + 1;
	for (g = 0; g <= c; g++)
		for (l = g / c, h = 0; h <= b; h++) k = h / b, k = a(k, l), d.push(k);
	var n, r, t, u;
	for (g = 0; g < c; g++)
		for (h = 0; h < b; h++) a = g * m + h, d = g * m + h + 1, l = (g + 1) * m + h + 1, k = (g + 1) * m + h, n = new THREE.Vector2(h / b, g / c), r = new THREE.Vector2((h + 1) / b, g / c), t = new THREE.Vector2((h + 1) / b, (g + 1) / c), u = new THREE.Vector2(h / b, (g + 1) / c), e.push(new THREE.Face3(a,
			d, k)), f.push([n, r, u]), e.push(new THREE.Face3(d, l, k)), f.push([r.clone(), t, u.clone()]);
	this.computeFaceNormals();
	this.computeVertexNormals()
};
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;
THREE.WireframeGeometry = function(a) {
	function b(a, b) {
		return a - b
	}
	THREE.BufferGeometry.call(this);
	var c = [0, 0],
		d = {},
		e = ["a", "b", "c"];
	if (a instanceof THREE.Geometry) {
		var f = a.vertices,
			g = a.faces,
			h = 0,
			k = new Uint32Array(6 * g.length);
		a = 0;
		for (var l = g.length; a < l; a++)
			for (var m = g[a], n = 0; 3 > n; n++) {
				c[0] = m[e[n]];
				c[1] = m[e[(n + 1) % 3]];
				c.sort(b);
				var r = c.toString();
				void 0 === d[r] && (k[2 * h] = c[0], k[2 * h + 1] = c[1], d[r] = !0, h++)
			}
		c = new Float32Array(6 * h);
		a = 0;
		for (l = h; a < l; a++)
			for (n = 0; 2 > n; n++) d = f[k[2 * a + n]], h = 6 * a + 3 * n, c[h + 0] = d.x, c[h + 1] = d.y,
				c[h + 2] = d.z;
		this.addAttribute("position", new THREE.BufferAttribute(c, 3))
	} else if (a instanceof THREE.BufferGeometry) {
		if (null !== a.index) {
			l = a.index.array;
			f = a.attributes.position;
			e = a.groups;
			h = 0;
			0 === e.length && a.addGroup(0, l.length);
			k = new Uint32Array(2 * l.length);
			g = 0;
			for (m = e.length; g < m; ++g) {
				a = e[g];
				n = a.start;
				r = a.count;
				a = n;
				for (var t = n + r; a < t; a += 3)
					for (n = 0; 3 > n; n++) c[0] = l[a + n], c[1] = l[a + (n + 1) % 3], c.sort(b), r = c.toString(), void 0 === d[r] && (k[2 * h] = c[0], k[2 * h + 1] = c[1], d[r] = !0, h++)
			}
			c = new Float32Array(6 * h);
			a = 0;
			for (l = h; a <
				l; a++)
				for (n = 0; 2 > n; n++) h = 6 * a + 3 * n, d = k[2 * a + n], c[h + 0] = f.getX(d), c[h + 1] = f.getY(d), c[h + 2] = f.getZ(d)
		} else
			for (f = a.attributes.position.array, h = f.length / 3, k = h / 3, c = new Float32Array(6 * h), a = 0, l = k; a < l; a++)
				for (n = 0; 3 > n; n++) h = 18 * a + 6 * n, k = 9 * a + 3 * n, c[h + 0] = f[k], c[h + 1] = f[k + 1], c[h + 2] = f[k + 2], d = 9 * a + (n + 1) % 3 * 3, c[h + 3] = f[d], c[h + 4] = f[d + 1], c[h + 5] = f[d + 2];
		this.addAttribute("position", new THREE.BufferAttribute(c, 3))
	}
};
THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;
THREE.AxisHelper = function(a) {
	a = a || 1;
	var b = new Float32Array([0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a]),
		c = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
	a = new THREE.BufferGeometry;
	a.addAttribute("position", new THREE.BufferAttribute(b, 3));
	a.addAttribute("color", new THREE.BufferAttribute(c, 3));
	b = new THREE.LineBasicMaterial({
		vertexColors: THREE.VertexColors
	});
	THREE.LineSegments.call(this, a, b)
};
THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;
THREE.ArrowHelper = function() {
	var a = new THREE.BufferGeometry;
	a.addAttribute("position", new THREE.Float32Attribute([0, 0, 0, 0, 1, 0], 3));
	var b = new THREE.CylinderBufferGeometry(0, .5, 1, 5, 1);
	b.translate(0, -.5, 0);
	return function d(e, f, g, h, k, l) {
		THREE.Object3D.call(this);
		void 0 === h && (h = 16776960);
		void 0 === g && (g = 1);
		void 0 === k && (k = .2 * g);
		void 0 === l && (l = .2 * k);
		this.position.copy(f);
		this.line = new THREE.Line(a, new THREE.LineBasicMaterial({
			color: h
		}));
		this.line.matrixAutoUpdate = !1;
		this.add(this.line);
		this.cone = new THREE.Mesh(b,
			new THREE.MeshBasicMaterial({
				color: h
			}));
		this.cone.matrixAutoUpdate = !1;
		this.add(this.cone);
		this.setDirection(e);
		this.setLength(g, k, l)
	}
}();
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;
THREE.ArrowHelper.prototype.setDirection = function() {
	var a = new THREE.Vector3,
		b;
	return function d(e) {
		.99999 < e.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > e.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(e.z, 0, -e.x).normalize(), b = Math.acos(e.y), this.quaternion.setFromAxisAngle(a, b))
	}
}();
THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
	void 0 === b && (b = .2 * a);
	void 0 === c && (c = .2 * b);
	this.line.scale.set(1, Math.max(0, a - b), 1);
	this.line.updateMatrix();
	this.cone.scale.set(c, b, c);
	this.cone.position.y = a;
	this.cone.updateMatrix()
};
THREE.ArrowHelper.prototype.setColor = function(a) {
	this.line.material.color.copy(a);
	this.cone.material.color.copy(a)
};
THREE.BoxHelper = function(a) {
	var b = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
		c = new Float32Array(24),
		d = new THREE.BufferGeometry;
	d.setIndex(new THREE.BufferAttribute(b, 1));
	d.addAttribute("position", new THREE.BufferAttribute(c, 3));
	THREE.LineSegments.call(this, d, new THREE.LineBasicMaterial({
		color: 16776960
	}));
	void 0 !== a && this.update(a)
};
THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;
THREE.BoxHelper.prototype.update = function() {
	var a = new THREE.Box3;
	return function(b) {
		b instanceof THREE.Box3 ? a.copy(b) : a.setFromObject(b);
		if (!a.isEmpty()) {
			b = a.min;
			var c = a.max,
				d = this.geometry.attributes.position,
				e = d.array;
			e[0] = c.x;
			e[1] = c.y;
			e[2] = c.z;
			e[3] = b.x;
			e[4] = c.y;
			e[5] = c.z;
			e[6] = b.x;
			e[7] = b.y;
			e[8] = c.z;
			e[9] = c.x;
			e[10] = b.y;
			e[11] = c.z;
			e[12] = c.x;
			e[13] = c.y;
			e[14] = b.z;
			e[15] = b.x;
			e[16] = c.y;
			e[17] = b.z;
			e[18] = b.x;
			e[19] = b.y;
			e[20] = b.z;
			e[21] = c.x;
			e[22] = b.y;
			e[23] = b.z;
			d.needsUpdate = !0;
			this.geometry.computeBoundingSphere()
		}
	}
}();
THREE.BoundingBoxHelper = function(a, b) {
	b = void 0 !== b ? b : 8947848;
	this.object = a;
	this.box = new THREE.Box3;
	THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
		color: b,
		wireframe: !0
	}))
};
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;
THREE.BoundingBoxHelper.prototype.update = function() {
	this.box.setFromObject(this.object);
	this.box.size(this.scale);
	this.box.center(this.position)
};
THREE.CameraHelper = function(a) {
	function b(a, b, d) {
		c(a, d);
		c(b, d)
	}

	function c(a, b) {
		d.vertices.push(new THREE.Vector3);
		d.colors.push(new THREE.Color(b));
		void 0 === f[a] && (f[a] = []);
		f[a].push(d.vertices.length - 1)
	}
	var d = new THREE.Geometry,
		e = new THREE.LineBasicMaterial({
			color: 16777215,
			vertexColors: THREE.FaceColors
		}),
		f = {};
	b("n1", "n2", 16755200);
	b("n2", "n4", 16755200);
	b("n4", "n3", 16755200);
	b("n3", "n1", 16755200);
	b("f1", "f2", 16755200);
	b("f2", "f4", 16755200);
	b("f4", "f3", 16755200);
	b("f3", "f1", 16755200);
	b("n1", "f1", 16755200);
	b("n2", "f2", 16755200);
	b("n3", "f3", 16755200);
	b("n4", "f4", 16755200);
	b("p", "n1", 16711680);
	b("p", "n2", 16711680);
	b("p", "n3", 16711680);
	b("p", "n4", 16711680);
	b("u1", "u2", 43775);
	b("u2", "u3", 43775);
	b("u3", "u1", 43775);
	b("c", "t", 16777215);
	b("p", "c", 3355443);
	b("cn1", "cn2", 3355443);
	b("cn3", "cn4", 3355443);
	b("cf1", "cf2", 3355443);
	b("cf3", "cf4", 3355443);
	THREE.LineSegments.call(this, d, e);
	this.camera = a;
	this.camera.updateProjectionMatrix();
	this.matrix = a.matrixWorld;
	this.matrixAutoUpdate = !1;
	this.pointMap = f;
	this.update()
};
THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;
THREE.CameraHelper.prototype.update = function() {
	function a(a, g, h, k) {
		d.set(g, h, k).unproject(e);
		a = c[a];
		if (void 0 !== a)
			for (g = 0, h = a.length; g < h; g++) b.vertices[a[g]].copy(d)
	}
	var b, c, d = new THREE.Vector3,
		e = new THREE.Camera;
	return function() {
		b = this.geometry;
		c = this.pointMap;
		e.projectionMatrix.copy(this.camera.projectionMatrix);
		a("c", 0, 0, -1);
		a("t", 0, 0, 1);
		a("n1", -1, -1, -1);
		a("n2", 1, -1, -1);
		a("n3", -1, 1, -1);
		a("n4", 1, 1, -1);
		a("f1", -1, -1, 1);
		a("f2", 1, -1, 1);
		a("f3", -1, 1, 1);
		a("f4", 1, 1, 1);
		a("u1", .7, 1.1, -1);
		a("u2", -.7, 1.1, -1);
		a("u3", 0, 2, -1);
		a("cf1", -1, 0, 1);
		a("cf2", 1, 0, 1);
		a("cf3", 0, -1, 1);
		a("cf4", 0, 1, 1);
		a("cn1", -1, 0, -1);
		a("cn2", 1, 0, -1);
		a("cn3", 0, -1, -1);
		a("cn4", 0, 1, -1);
		b.verticesNeedUpdate = !0
	}
}();
THREE.DirectionalLightHelper = function(a, b) {
	THREE.Object3D.call(this);
	this.light = a;
	this.light.updateMatrixWorld();
	this.matrix = a.matrixWorld;
	this.matrixAutoUpdate = !1;
	void 0 === b && (b = 1);
	a = new THREE.BufferGeometry;
	a.addAttribute("position", new THREE.Float32Attribute([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
	b = new THREE.LineBasicMaterial({
		fog: !1
	});
	this.add(new THREE.Line(a, b));
	a = new THREE.BufferGeometry;
	a.addAttribute("position", new THREE.Float32Attribute([0, 0, 0, 0, 0, 1], 3));
	this.add(new THREE.Line(a, b));
	this.update()
};
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;
THREE.DirectionalLightHelper.prototype.dispose = function() {
	var a = this.children[0],
		b = this.children[1];
	a.geometry.dispose();
	a.material.dispose();
	b.geometry.dispose();
	b.material.dispose()
};
THREE.DirectionalLightHelper.prototype.update = function() {
	var a = new THREE.Vector3,
		b = new THREE.Vector3,
		c = new THREE.Vector3;
	return function() {
		a.setFromMatrixPosition(this.light.matrixWorld);
		b.setFromMatrixPosition(this.light.target.matrixWorld);
		c.subVectors(b, a);
		var d = this.children[0],
			e = this.children[1];
		d.lookAt(c);
		d.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
		e.lookAt(c);
		e.scale.z = c.length()
	}
}();
THREE.EdgesHelper = function(a, b, c) {
	b = void 0 !== b ? b : 16777215;
	THREE.LineSegments.call(this, new THREE.EdgesGeometry(a.geometry, c), new THREE.LineBasicMaterial({
		color: b
	}));
	this.matrix = a.matrixWorld;
	this.matrixAutoUpdate = !1
};
THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;
THREE.FaceNormalsHelper = function(a, b, c, d) {
	this.object = a;
	this.size = void 0 !== b ? b : 1;
	a = void 0 !== c ? c : 16776960;
	d = void 0 !== d ? d : 1;
	b = 0;
	c = this.object.geometry;
	c instanceof THREE.Geometry ? b = c.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
	c = new THREE.BufferGeometry;
	b = new THREE.Float32Attribute(6 * b, 3);
	c.addAttribute("position", b);
	THREE.LineSegments.call(this, c, new THREE.LineBasicMaterial({
		color: a,
		linewidth: d
	}));
	this.matrixAutoUpdate = !1;
	this.update()
};
THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;
THREE.FaceNormalsHelper.prototype.update = function() {
	var a = new THREE.Vector3,
		b = new THREE.Vector3,
		c = new THREE.Matrix3;
	return function e() {
		this.object.updateMatrixWorld(!0);
		c.getNormalMatrix(this.object.matrixWorld);
		for (var f = this.object.matrixWorld, g = this.geometry.attributes.position, h = this.object.geometry, k = h.vertices, h = h.faces, l = 0, m = 0, n = h.length; m < n; m++) {
			var r = h[m],
				t = r.normal;
			a.copy(k[r.a]).add(k[r.b]).add(k[r.c]).divideScalar(3).applyMatrix4(f);
			b.copy(t).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
			g.setXYZ(l, a.x, a.y, a.z);
			l += 1;
			g.setXYZ(l, b.x, b.y, b.z);
			l += 1
		}
		g.needsUpdate = !0;
		return this
	}
}();
THREE.GridHelper = function(a, b, c, d) {
	c = new THREE.Color(void 0 !== c ? c : 4473924);
	d = new THREE.Color(void 0 !== d ? d : 8947848);
	for (var e = [], f = [], g = -a, h = 0; g <= a; g += b) {
		e.push(-a, 0, g, a, 0, g);
		e.push(g, 0, -a, g, 0, a);
		var k = 0 === g ? c : d;
		k.toArray(f, h);
		h += 3;
		k.toArray(f, h);
		h += 3;
		k.toArray(f, h);
		h += 3;
		k.toArray(f, h);
		h += 3
	}
	a = new THREE.BufferGeometry;
	a.addAttribute("position", new THREE.Float32Attribute(e, 3));
	a.addAttribute("color", new THREE.Float32Attribute(f, 3));
	e = new THREE.LineBasicMaterial({
		vertexColors: THREE.VertexColors
	});
	THREE.LineSegments.call(this,
		a, e)
};
THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.GridHelper.prototype.constructor = THREE.GridHelper;
THREE.GridHelper.prototype.setColors = function() {
	console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
};
THREE.HemisphereLightHelper = function(a, b) {
	THREE.Object3D.call(this);
	this.light = a;
	this.light.updateMatrixWorld();
	this.matrix = a.matrixWorld;
	this.matrixAutoUpdate = !1;
	this.colors = [new THREE.Color, new THREE.Color];
	a = new THREE.SphereGeometry(b, 4, 2);
	a.rotateX(-Math.PI / 2);
	for (b = 0; 8 > b; b++) a.faces[b].color = this.colors[4 > b ? 0 : 1];
	b = new THREE.MeshBasicMaterial({
		vertexColors: THREE.FaceColors,
		wireframe: !0
	});
	this.lightSphere = new THREE.Mesh(a, b);
	this.add(this.lightSphere);
	this.update()
};
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;
THREE.HemisphereLightHelper.prototype.dispose = function() {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose()
};
THREE.HemisphereLightHelper.prototype.update = function() {
	var a = new THREE.Vector3;
	return function() {
		this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
		this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
		this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
		this.lightSphere.geometry.colorsNeedUpdate = !0
	}
}();
THREE.PointLightHelper = function(a, b) {
	this.light = a;
	this.light.updateMatrixWorld();
	a = new THREE.SphereBufferGeometry(b, 4, 2);
	b = new THREE.MeshBasicMaterial({
		wireframe: !0,
		fog: !1
	});
	b.color.copy(this.light.color).multiplyScalar(this.light.intensity);
	THREE.Mesh.call(this, a, b);
	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = !1
};
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;
THREE.PointLightHelper.prototype.dispose = function() {
	this.geometry.dispose();
	this.material.dispose()
};
THREE.PointLightHelper.prototype.update = function() {
	this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
};
THREE.SkeletonHelper = function(a) {
	this.bones = this.getBoneList(a);
	for (var b = new THREE.Geometry, c = 0; c < this.bones.length; c++) {
		var d = this.bones[c];
		d.parent instanceof THREE.Bone && (b.vertices.push(new THREE.Vector3), b.vertices.push(new THREE.Vector3), b.colors.push(new THREE.Color(0, 0, 1)), b.colors.push(new THREE.Color(0, 1, 0)))
	}
	b.dynamic = !0;
	c = new THREE.LineBasicMaterial({
		vertexColors: THREE.VertexColors,
		depthTest: !1,
		depthWrite: !1,
		transparent: !0
	});
	THREE.LineSegments.call(this, b, c);
	this.root = a;
	this.matrix = a.matrixWorld;
	this.matrixAutoUpdate = !1;
	this.update()
};
THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;
THREE.SkeletonHelper.prototype.getBoneList = function(a) {
	var b = [];
	a instanceof THREE.Bone && b.push(a);
	for (var c = 0; c < a.children.length; c++) b.push.apply(b, this.getBoneList(a.children[c]));
	return b
};
THREE.SkeletonHelper.prototype.update = function() {
	for (var a = this.geometry, b = (new THREE.Matrix4).getInverse(this.root.matrixWorld), c = new THREE.Matrix4, d = 0, e = 0; e < this.bones.length; e++) {
		var f = this.bones[e];
		f.parent instanceof THREE.Bone && (c.multiplyMatrices(b, f.matrixWorld), a.vertices[d].setFromMatrixPosition(c), c.multiplyMatrices(b, f.parent.matrixWorld), a.vertices[d + 1].setFromMatrixPosition(c), d += 2)
	}
	a.verticesNeedUpdate = !0;
	a.computeBoundingSphere()
};
THREE.SpotLightHelper = function(a) {
	THREE.Object3D.call(this);
	this.light = a;
	this.light.updateMatrixWorld();
	this.matrix = a.matrixWorld;
	this.matrixAutoUpdate = !1;
	a = new THREE.BufferGeometry;
	for (var b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], c = 0, d = 1; 32 > c; c++, d++) {
		var e = c / 32 * Math.PI * 2,
			f = d / 32 * Math.PI * 2;
		b.push(Math.cos(e), Math.sin(e), 1, Math.cos(f), Math.sin(f), 1)
	}
	a.addAttribute("position", new THREE.Float32Attribute(b, 3));
	b = new THREE.LineBasicMaterial({
		fog: !1
	});
	this.cone = new THREE.LineSegments(a,
		b);
	this.add(this.cone);
	this.update()
};
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;
THREE.SpotLightHelper.prototype.dispose = function() {
	this.cone.geometry.dispose();
	this.cone.material.dispose()
};
THREE.SpotLightHelper.prototype.update = function() {
	var a = new THREE.Vector3,
		b = new THREE.Vector3;
	return function() {
		var c = this.light.distance ? this.light.distance : 1E3,
			d = c * Math.tan(this.light.angle);
		this.cone.scale.set(d, d, c);
		a.setFromMatrixPosition(this.light.matrixWorld);
		b.setFromMatrixPosition(this.light.target.matrixWorld);
		this.cone.lookAt(b.sub(a));
		this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
	}
}();
THREE.VertexNormalsHelper = function(a, b, c, d) {
	this.object = a;
	this.size = void 0 !== b ? b : 1;
	a = void 0 !== c ? c : 16711680;
	d = void 0 !== d ? d : 1;
	b = 0;
	c = this.object.geometry;
	c instanceof THREE.Geometry ? b = 3 * c.faces.length : c instanceof THREE.BufferGeometry && (b = c.attributes.normal.count);
	c = new THREE.BufferGeometry;
	b = new THREE.Float32Attribute(6 * b, 3);
	c.addAttribute("position", b);
	THREE.LineSegments.call(this, c, new THREE.LineBasicMaterial({
		color: a,
		linewidth: d
	}));
	this.matrixAutoUpdate = !1;
	this.update()
};
THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;
THREE.VertexNormalsHelper.prototype.update = function() {
	var a = new THREE.Vector3,
		b = new THREE.Vector3,
		c = new THREE.Matrix3;
	return function e() {
		var f = ["a", "b", "c"];
		this.object.updateMatrixWorld(!0);
		c.getNormalMatrix(this.object.matrixWorld);
		var g = this.object.matrixWorld,
			h = this.geometry.attributes.position,
			k = this.object.geometry;
		if (k instanceof THREE.Geometry)
			for (var l = k.vertices, m = k.faces, n = k = 0, r = m.length; n < r; n++)
				for (var t = m[n], u = 0, w = t.vertexNormals.length; u < w; u++) {
					var v = l[t[f[u]]],
						x = t.vertexNormals[u];
					a.copy(v).applyMatrix4(g);
					b.copy(x).applyMatrix3(c).normalize().multiplyScalar(this.size).add(a);
					h.setXYZ(k, a.x, a.y, a.z);
					k += 1;
					h.setXYZ(k, b.x, b.y, b.z);
					k += 1
				} else if (k instanceof THREE.BufferGeometry)
					for (f = k.attributes.position, l = k.attributes.normal, u = k = 0, w = f.count; u < w; u++) a.set(f.getX(u), f.getY(u), f.getZ(u)).applyMatrix4(g), b.set(l.getX(u), l.getY(u), l.getZ(u)), b.applyMatrix3(c).normalize().multiplyScalar(this.size).add(a), h.setXYZ(k, a.x, a.y, a.z), k += 1, h.setXYZ(k, b.x, b.y, b.z), k += 1;
		h.needsUpdate = !0;
		return this
	}
}();
THREE.WireframeHelper = function(a, b) {
	b = void 0 !== b ? b : 16777215;
	THREE.LineSegments.call(this, new THREE.WireframeGeometry(a.geometry), new THREE.LineBasicMaterial({
		color: b
	}));
	this.matrix = a.matrixWorld;
	this.matrixAutoUpdate = !1
};
THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype);
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;
THREE.ImmediateRenderObject = function(a) {
	THREE.Object3D.call(this);
	this.material = a;
	this.render = function(a) {}
};
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype);
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;
THREE.MorphBlendMesh = function(a, b) {
	THREE.Mesh.call(this, a, b);
	this.animationsMap = {};
	this.animationsList = [];
	b = this.geometry.morphTargets.length;
	a = b - 1;
	b /= 1;
	this.createAnimation("__default", 0, a, b);
	this.setAnimationWeight("__default", 1)
};
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype);
q = THREE.MorphBlendMesh.prototype;
q.constructor = THREE.MorphBlendMesh;
q.createAnimation = function(a, b, c, d) {
	b = {
		start: b,
		end: c,
		length: c - b + 1,
		fps: d,
		duration: (c - b) / d,
		lastFrame: 0,
		currentFrame: 0,
		active: !1,
		time: 0,
		direction: 1,
		weight: 1,
		directionBackwards: !1,
		mirroredLoop: !1
	};
	this.animationsMap[a] = b;
	this.animationsList.push(b)
};
q.autoCreateAnimations = function(a) {
	for (var b = /([a-z]+)_?(\d+)/i, c, d = {}, e = this.geometry, f = 0, g = e.morphTargets.length; f < g; f++) {
		var h = e.morphTargets[f];
		if ((h = h.name.match(b)) && 1 < h.length) {
			var k = h[1];
			d[k] || (d[k] = {
				start: Infinity,
				end: -Infinity
			});
			h = d[k];
			f < h.start && (h.start = f);
			f > h.end && (h.end = f);
			c || (c = k)
		}
	}
	for (k in d) h = d[k], this.createAnimation(k, h.start, h.end, a);
	this.firstAnimation = c
};
q.setAnimationDirectionForward = function(a) {
	if (a = this.animationsMap[a]) a.direction = 1, a.directionBackwards = !1
};
q.setAnimationDirectionBackward = function(a) {
	if (a = this.animationsMap[a]) a.direction = -1, a.directionBackwards = !0
};
q.setAnimationFPS = function(a, b) {
	if (a = this.animationsMap[a]) a.fps = b, a.duration = (a.end - a.start) / a.fps
};
q.setAnimationDuration = function(a, b) {
	if (a = this.animationsMap[a]) a.duration = b, a.fps = (a.end - a.start) / a.duration
};
q.setAnimationWeight = function(a, b) {
	if (a = this.animationsMap[a]) a.weight = b
};
q.setAnimationTime = function(a, b) {
	if (a = this.animationsMap[a]) a.time = b
};
q.getAnimationTime = function(a) {
	var b = 0;
	if (a = this.animationsMap[a]) b = a.time;
	return b
};
q.getAnimationDuration = function(a) {
	var b = -1;
	if (a = this.animationsMap[a]) b = a.duration;
	return b
};
q.playAnimation = function(a) {
	var b = this.animationsMap[a];
	b ? (b.time = 0, b.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + a + "] undefined in .playAnimation()")
};
q.stopAnimation = function(a) {
	if (a = this.animationsMap[a]) a.active = !1
};
q.update = function(a) {
	for (var b = 0, c = this.animationsList.length; b < c; b++) {
		var d = this.animationsList[b];
		if (d.active) {
			var e = d.duration / d.length;
			d.time += d.direction * a;
			if (d.mirroredLoop) {
				if (d.time > d.duration || 0 > d.time) d.direction *= -1, d.time > d.duration && (d.time = d.duration, d.directionBackwards = !0), 0 > d.time && (d.time = 0, d.directionBackwards = !1)
			} else d.time %= d.duration, 0 > d.time && (d.time += d.duration);
			var f = d.start + THREE.Math.clamp(Math.floor(d.time / e), 0, d.length - 1),
				g = d.weight;
			f !== d.currentFrame && (this.morphTargetInfluences[d.lastFrame] =
				0, this.morphTargetInfluences[d.currentFrame] = 1 * g, this.morphTargetInfluences[f] = 0, d.lastFrame = d.currentFrame, d.currentFrame = f);
			e = d.time % e / e;
			d.directionBackwards && (e = 1 - e);
			d.currentFrame !== d.lastFrame ? (this.morphTargetInfluences[d.currentFrame] = e * g, this.morphTargetInfluences[d.lastFrame] = (1 - e) * g) : this.morphTargetInfluences[d.currentFrame] = g
		}
	}
};
THREE.OrbitControls = function(a, b) {
	function c() {
		return Math.pow(.95, u.zoomSpeed)
	}

	function d(a) {
		u.object instanceof THREE.PerspectiveCamera ? A /= a : u.object instanceof THREE.OrthographicCamera ? (u.object.zoom = Math.max(u.minZoom, Math.min(u.maxZoom, u.object.zoom * a)), u.object.updateProjectionMatrix(), O = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), u.enableZoom = !1)
	}

	function e(a) {
		u.object instanceof THREE.PerspectiveCamera ? A *= a : u.object instanceof THREE.OrthographicCamera ?
			(u.object.zoom = Math.max(u.minZoom, Math.min(u.maxZoom, u.object.zoom / a)), u.object.updateProjectionMatrix(), O = !0) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), u.enableZoom = !1)
	}

	function f(a) {
		if (!1 !== u.enabled) {
			a.preventDefault();
			if (a.button === u.mouseButtons.ORBIT) {
				if (!1 === u.enableRotate) return;
				M.set(a.clientX, a.clientY);
				D = y.ROTATE
			} else if (a.button === u.mouseButtons.ZOOM) {
				if (!1 === u.enableZoom) return;
				K.set(a.clientX, a.clientY);
				D = y.DOLLY
			} else if (a.button ===
				u.mouseButtons.PAN) {
				if (!1 === u.enablePan) return;
				L.set(a.clientX, a.clientY);
				D = y.PAN
			}
			D !== y.NONE && (document.addEventListener("mousemove", g, !1), document.addEventListener("mouseup", h, !1), document.addEventListener("mouseout", h, !1), u.dispatchEvent(v))
		}
	}

	function g(a) {
		!1 !== u.enabled && (a.preventDefault(), D === y.ROTATE ? !1 !== u.enableRotate && (J.set(a.clientX, a.clientY), P.subVectors(J, M), a = u.domElement === document ? u.domElement.body : u.domElement, G.theta -= 2 * Math.PI * P.x / a.clientWidth * u.rotateSpeed, G.phi -= 2 * Math.PI * P.y /
			a.clientHeight * u.rotateSpeed, M.copy(J), u.update()) : D === y.DOLLY ? !1 !== u.enableZoom && (X.set(a.clientX, a.clientY), ba.subVectors(X, K), 0 < ba.y ? d(c()) : 0 > ba.y && e(c()), K.copy(X), u.update()) : D === y.PAN && !1 !== u.enablePan && (Q.set(a.clientX, a.clientY), S.subVectors(Q, L), Y(S.x, S.y), L.copy(Q), u.update()))
	}

	function h(a) {
		!1 !== u.enabled && (document.removeEventListener("mousemove", g, !1), document.removeEventListener("mouseup", h, !1), document.removeEventListener("mouseout", h, !1), u.dispatchEvent(x), D = y.NONE)
	}

	function k(a) {
		if (!1 !==
			u.enabled && !1 !== u.enableZoom && (D === y.NONE || D === y.ROTATE)) {
			a.preventDefault();
			a.stopPropagation();
			var b = 0;
			void 0 !== a.wheelDelta ? b = a.wheelDelta : void 0 !== a.detail && (b = -a.detail);
			0 < b ? e(c()) : 0 > b && d(c());
			u.update();
			u.dispatchEvent(v);
			u.dispatchEvent(x)
		}
	}

	function l(a) {
		if (!1 !== u.enabled && !1 !== u.enableKeys && !1 !== u.enablePan) switch (a.keyCode) {
			case u.keys.UP:
				Y(0, u.keyPanSpeed);
				u.update();
				break;
			case u.keys.BOTTOM:
				Y(0, -u.keyPanSpeed);
				u.update();
				break;
			case u.keys.LEFT:
				Y(u.keyPanSpeed, 0);
				u.update();
				break;
			case u.keys.RIGHT:
				Y(-u.keyPanSpeed,
					0), u.update()
		}
	}

	function m(a) {
		if (!1 !== u.enabled) {
			switch (a.touches.length) {
				case 1:
					if (!1 === u.enableRotate) return;
					M.set(a.touches[0].pageX, a.touches[0].pageY);
					D = y.TOUCH_ROTATE;
					break;
				case 2:
					if (!1 === u.enableZoom) return;
					var b = a.touches[0].pageX - a.touches[1].pageX;
					a = a.touches[0].pageY - a.touches[1].pageY;
					b = Math.sqrt(b * b + a * a);
					K.set(0, b);
					D = y.TOUCH_DOLLY;
					break;
				case 3:
					if (!1 === u.enablePan) return;
					L.set(a.touches[0].pageX, a.touches[0].pageY);
					D = y.TOUCH_PAN;
					break;
				default:
					D = y.NONE
			}
			D !== y.NONE && u.dispatchEvent(v)
		}
	}

	function n(a) {
		if (!1 !==
			u.enabled) switch (a.preventDefault(), a.stopPropagation(), a.touches.length) {
			case 1:
				if (!1 === u.enableRotate) break;
				if (D !== y.TOUCH_ROTATE) break;
				J.set(a.touches[0].pageX, a.touches[0].pageY);
				P.subVectors(J, M);
				var b = u.domElement === document ? u.domElement.body : u.domElement;
				G.theta -= 2 * Math.PI * P.x / b.clientWidth * u.rotateSpeed;
				G.phi -= 2 * Math.PI * P.y / b.clientHeight * u.rotateSpeed;
				M.copy(J);
				u.update();
				break;
			case 2:
				if (!1 === u.enableZoom) break;
				if (D !== y.TOUCH_DOLLY) break;
				b = a.touches[0].pageX - a.touches[1].pageX;
				a = a.touches[0].pageY -
					a.touches[1].pageY;
				b = Math.sqrt(b * b + a * a);
				X.set(0, b);
				ba.subVectors(X, K);
				0 < ba.y ? e(c()) : 0 > ba.y && d(c());
				K.copy(X);
				u.update();
				break;
			case 3:
				if (!1 === u.enablePan) break;
				if (D !== y.TOUCH_PAN) break;
				Q.set(a.touches[0].pageX, a.touches[0].pageY);
				S.subVectors(Q, L);
				Y(S.x, S.y);
				L.copy(Q);
				u.update();
				break;
			default:
				D = y.NONE
		}
	}

	function r(a) {
		!1 !== u.enabled && (u.dispatchEvent(x), D = y.NONE)
	}

	function t(a) {
		a.preventDefault()
	}
	this.object = a;
	this.domElement = void 0 !== b ? b : document;
	this.enabled = !0;
	this.target = new THREE.Vector3;
	this.minDistance =
		0;
	this.maxDistance = Infinity;
	this.minZoom = 0;
	this.maxZoom = Infinity;
	this.minPolarAngle = 0;
	this.maxPolarAngle = Math.PI;
	this.minAzimuthAngle = -Infinity;
	this.maxAzimuthAngle = Infinity;
	this.enableDamping = !1;
	this.dampingFactor = .25;
	this.enableZoom = !0;
	this.zoomSpeed = 1;
	this.enableRotate = !0;
	this.rotateSpeed = 1;
	this.enablePan = !0;
	this.keyPanSpeed = 7;
	this.autoRotate = !1;
	this.autoRotateSpeed = 2;
	this.enableKeys = !0;
	this.keys = {
		LEFT: 37,
		UP: 38,
		RIGHT: 39,
		BOTTOM: 40
	};
	this.mouseButtons = {
		ORBIT: THREE.MOUSE.LEFT,
		ZOOM: THREE.MOUSE.MIDDLE,
		PAN: THREE.MOUSE.RIGHT
	};
	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.zoom0 = this.object.zoom;
	this.getPolarAngle = function() {
		return z.phi
	};
	this.getAzimuthalAngle = function() {
		return z.theta
	};
	this.reset = function() {
		u.target.copy(u.target0);
		u.object.position.copy(u.position0);
		u.object.zoom = u.zoom0;
		u.object.updateProjectionMatrix();
		u.dispatchEvent(w);
		u.update();
		D = y.NONE
	};
	this.update = function() {
		var b = new THREE.Vector3,
			c = (new THREE.Quaternion).setFromUnitVectors(a.up, new THREE.Vector3(0,
				1, 0)),
			d = c.clone().inverse(),
			e = new THREE.Vector3,
			f = new THREE.Quaternion;
		return function() {
			var a = u.object.position;
			b.copy(a).sub(u.target);
			b.applyQuaternion(c);
			z.setFromVector3(b);
			u.autoRotate && D === y.NONE && (G.theta -= 2 * Math.PI / 60 / 60 * u.autoRotateSpeed);
			z.theta += G.theta;
			z.phi += G.phi;
			z.theta = Math.max(u.minAzimuthAngle, Math.min(u.maxAzimuthAngle, z.theta));
			z.phi = Math.max(u.minPolarAngle, Math.min(u.maxPolarAngle, z.phi));
			z.makeSafe();
			z.radius *= A;
			z.radius = Math.max(u.minDistance, Math.min(u.maxDistance, z.radius));
			u.target.add(H);
			b.setFromSpherical(z);
			b.applyQuaternion(d);
			a.copy(u.target).add(b);
			u.object.lookAt(u.target);
			!0 === u.enableDamping ? (G.theta *= 1 - u.dampingFactor, G.phi *= 1 - u.dampingFactor) : G.set(0, 0, 0);
			A = 1;
			H.set(0, 0, 0);
			return O || 1E-6 < e.distanceToSquared(u.object.position) || 1E-6 < 8 * (1 - f.dot(u.object.quaternion)) ? (u.dispatchEvent(w), e.copy(u.object.position), f.copy(u.object.quaternion), O = !1, !0) : !1
		}
	}();
	this.dispose = function() {
		u.domElement.removeEventListener("contextmenu", t, !1);
		u.domElement.removeEventListener("mousedown",
			f, !1);
		u.domElement.removeEventListener("mousewheel", k, !1);
		u.domElement.removeEventListener("MozMousePixelScroll", k, !1);
		u.domElement.removeEventListener("touchstart", m, !1);
		u.domElement.removeEventListener("touchend", r, !1);
		u.domElement.removeEventListener("touchmove", n, !1);
		document.removeEventListener("mousemove", g, !1);
		document.removeEventListener("mouseup", h, !1);
		document.removeEventListener("mouseout", h, !1);
		window.removeEventListener("keydown", l, !1)
	};
	var u = this,
		w = {
			type: "change"
		},
		v = {
			type: "start"
		},
		x = {
			type: "end"
		},
		y = {
			NONE: -1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_DOLLY: 4,
			TOUCH_PAN: 5
		},
		D = y.NONE,
		z = new THREE.Spherical,
		G = new THREE.Spherical,
		A = 1,
		H = new THREE.Vector3,
		O = !1,
		M = new THREE.Vector2,
		J = new THREE.Vector2,
		P = new THREE.Vector2,
		L = new THREE.Vector2,
		Q = new THREE.Vector2,
		S = new THREE.Vector2,
		K = new THREE.Vector2,
		X = new THREE.Vector2,
		ba = new THREE.Vector2,
		ca = function() {
			var a = new THREE.Vector3;
			return function aa(b, c) {
				a.setFromMatrixColumn(c, 0);
				a.multiplyScalar(-b);
				H.add(a)
			}
		}(),
		ia = function() {
			var a = new THREE.Vector3;
			return function aa(b, c) {
				a.setFromMatrixColumn(c, 1);
				a.multiplyScalar(b);
				H.add(a)
			}
		}(),
		Y = function() {
			var a = new THREE.Vector3;
			return function(b, c) {
				var d = u.domElement === document ? u.domElement.body : u.domElement;
				if (u.object instanceof THREE.PerspectiveCamera) {
					var e = u.object.position;
					a.copy(e).sub(u.target);
					e = a.length();
					e *= Math.tan(u.object.fov / 2 * Math.PI / 180);
					ca(2 * b * e / d.clientHeight, u.object.matrix);
					ia(2 * c * e / d.clientHeight, u.object.matrix)
				} else u.object instanceof THREE.OrthographicCamera ? (ca(b * (u.object.right -
					u.object.left) / u.object.zoom / d.clientWidth, u.object.matrix), ia(c * (u.object.top - u.object.bottom) / u.object.zoom / d.clientHeight, u.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), u.enablePan = !1)
			}
		}();
	u.domElement.addEventListener("contextmenu", t, !1);
	u.domElement.addEventListener("mousedown", f, !1);
	u.domElement.addEventListener("mousewheel", k, !1);
	u.domElement.addEventListener("MozMousePixelScroll", k, !1);
	u.domElement.addEventListener("touchstart",
		m, !1);
	u.domElement.addEventListener("touchend", r, !1);
	u.domElement.addEventListener("touchmove", n, !1);
	window.addEventListener("keydown", l, !1);
	this.update()
};
THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
THREE.OrbitControls.prototype.constructor = THREE.OrbitControls;
Object.defineProperties(THREE.OrbitControls.prototype, {
	center: {
		get: function() {
			console.warn("THREE.OrbitControls: .center has been renamed to .target");
			return this.target
		}
	},
	noZoom: {
		get: function() {
			console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
			return !this.enableZoom
		},
		set: function(a) {
			console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
			this.enableZoom = !a
		}
	},
	noRotate: {
		get: function() {
			console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.");
			return !this.enableRotate
		},
		set: function(a) {
			console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.");
			this.enableRotate = !a
		}
	},
	noPan: {
		get: function() {
			console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
			return !this.enablePan
		},
		set: function(a) {
			console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
			this.enablePan = !a
		}
	},
	noKeys: {
		get: function() {
			console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
			return !this.enableKeys
		},
		set: function(a) {
			console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
			this.enableKeys = !a
		}
	},
	staticMoving: {
		get: function() {
			console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
			return !this.enableDamping
		},
		set: function(a) {
			console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
			this.enableDamping = !a
		}
	},
	dynamicDampingFactor: {
		get: function() {
			console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
			return this.dampingFactor
		},
		set: function(a) {
			console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
			this.dampingFactor = a
		}
	}
});
/*

 The MIT License (MIT)
 Copyright (c) 2015 Waylon Flinn

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.

 Copyright (c) 2015 Waylon Flinn

 webgl.js

 multiply matrices up to 4096 x 4096 on GPUs that support OES_texture_float
 extension. input is encoded into the red and green channels of an input texture and
 calculations are done using a custom fragment shader.

 async
 https://github.com/caolan/async

 Copyright 2010-2014 Caolan McMahon
 Released under the MIT license
*/
(function(a) {
	if ("object" === typeof exports && "undefined" !== typeof module) module.exports = a();
	else if ("function" === typeof define && define.amd) define([], a);
	else {
		var b;
		b = "undefined" !== typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : this;
		b.weblas = a()
	}
})(function() {
	var a, b;
	return function d(a, b, g) {
		function e(h, k) {
			if (!b[h]) {
				if (!a[h]) {
					var l = "function" == typeof require && require;
					if (!k && l) return l(h, !0);
					if (f) return f(h, !0);
					k = Error("Cannot find module '" + h + "'");
					throw k.code =
						"MODULE_NOT_FOUND", k;
				}
				k = b[h] = {
					exports: {}
				};
				a[h][0].call(k.exports, function(b) {
					var d = a[h][1][b];
					return e(d ? d : b)
				}, k, k.exports, d, a, b, g)
			}
			return b[h].exports
		}
		for (var f = "function" == typeof require && require, l = 0; l < g.length; l++) e(g[l]);
		return e
	}({
		1: [function(a, b, f) {
			function d(a, b, d, e, f, g, h, k) {
				if (null != k && k.length != b) throw Error("Only vector C with length matching rows in A is currently supported.");
				var l;
				l = t(d, b, g);
				g = z.createDataTexture(a, d, f);
				f = z.createDataTexture(b, d, l);
				l = null;
				null != k && (l = z.createDataTexture(1,
					b, k));
				k = z.createOutputTexture(a, b);
				G.calculate(a, b, d, e, g, f, h, l, k);
				rawBuffer = z.readData(a, b);
				z.context.deleteTexture(g);
				z.context.deleteTexture(f);
				null != l && z.context.deleteTexture(l);
				z.context.deleteTexture(k);
				return new Float32Array(rawBuffer)
			}

			function e(a, b, d, e) {
				var f = d;
				"[object Float32Array]" === Object.prototype.toString.call(e) ? d = e : (d = new Float32Array(a), d.fill(e));
				e = z.createDataTexture(1, a, f);
				d = z.createDataTexture(1, a, d);
				f = z.createOutputTexture(1, a);
				A.calculate(a, b, e, d, f);
				a = z.readData(1, a);
				z.context.deleteTexture(e);
				z.context.deleteTexture(d);
				z.context.deleteTexture(f);
				return new Float32Array(a)
			}

			function k(a, b, d, e, f) {
				f = z.createDataTexture(a, b, f);
				var g = z.createOutputTexture(a, b);
				H.calculate(a, b, d, e, f, g);
				a = z.readData(a, b);
				z.context.deleteTexture(f);
				z.context.deleteTexture(g);
				return new Float32Array(a)
			}

			function l(a, b, d, e, f) {
				f = z.createDataTexture(a, b, f);
				var g = z.createOutputTexture(a, b);
				H.calculate(a, b, 1 / e, -1 * d / e, f, g);
				a = z.readData(a, b);
				z.context.deleteTexture(f);
				z.context.deleteTexture(g);
				return new Float32Array(a)
			}

			function m(a, b, d, e, f, g) {
				var h = g;
				g = z.createDataTexture(a, b * d, g);
				var h = Math.floor((b - e) / f) + 1,
					k = Math.floor((a - e) / f) + 1,
					l = z.createOutputTexture(k, h * d);
				O.calculate(a, b, d, e, f, g, l);
				rawBuffer = z.readData(k, h * d);
				z.context.deleteTexture(g);
				z.context.deleteTexture(l);
				return new Float32Array(rawBuffer)
			}

			function n(a, b, d, e, f) {
				d = null != d ? d : Number.MIN_VALUE;
				e = null != e ? e : Number.MAX_VALUE;
				f = z.createDataTexture(a, b, f);
				var g = z.createOutputTexture(a, b);
				M.calculate(a, b, d, e, f, g);
				a = z.readData(a, b);
				z.context.deleteTexture(f);
				z.context.deleteTexture(g);
				return new Float32Array(a)
			}

			function r(a, b, d) {
				var e = [],
					f;
				d ? (e[1] = a.length, e[0] = a[0].length) : (e[0] = a.length, e[1] = a[0].length);
				f = e[1];
				b = b || Float32Array;
				b = new b(e[0] * e[1]);
				for (var g = 0; g < e[0]; ++g)
					for (var h = 0; h < e[1]; ++h) b[g * f + h] = d ? a[h][g] : a[g][h];
				return b
			}

			function t(a, b, d) {
				for (var e = new d.constructor(a * b), f = 0; f < a; f++)
					for (var g = 0; g < b; g++) e[g * a + f] = d[f * b + g];
				return e
			}
			f = a("./lib/globals");
			var u = a("./lib/pipeline"),
				w = a("./lib/sgemmcalculator"),
				v = a("./lib/saxpycalculator"),
				x = a("./lib/sscalcalculator"),
				y = a("./lib/sdwnscalculator"),
				D = a("./lib/sclmpcalculator");
			a = a("./lib/test");
			var z = f.gl,
				G = new w(z),
				A = new v(z),
				H = new x(z),
				O = new y(z),
				M = new D(z);
			b.exports = {
				saxpy: e,
				sscal: k,
				sgemm: d,
				sstd: l,
				sdwns: m,
				sclmp: n,
				pipeline: u,
				gpu: {
					gl: z,
					sgemm: u.sgemmcalculator.calculate.bind(u.sgemmcalculator),
					sscal: u.sscalcalculator.calculate.bind(u.sscalcalculator),
					sclmp: u.sclmpcalculator.calculate.bind(u.sclmpcalculator),
					sdwns: u.sdwnscalculator.calculate.bind(u.sdwnscalculator),
					encode: z.encode.bind(z)
				},
				util: {
					fromArray: r,
					transpose: t
				},
				test: a
			};
			String.prototype.format || (String.prototype.format = function() {
				var a = arguments;
				return this.replace(/{(\d+)}/g, function(b, d) {
					return "undefined" != typeof a[d] ? a[d] : b
				})
			})
		}, {
			"./lib/globals": 2,
			"./lib/pipeline": 3,
			"./lib/saxpycalculator": 4,
			"./lib/sclmpcalculator": 5,
			"./lib/sdwnscalculator": 6,
			"./lib/sgemmcalculator": 7,
			"./lib/sscalcalculator": 9,
			"./lib/test": 11
		}],
		2: [function(a, b, f) {
			a = a("./webgl");
			a = new a;
			b.exports = {
				gl: a
			}
		}, {
			"./webgl": 12
		}],
		3: [function(a, b, f) {
			function d(a, b, d) {
				var e = d.shape[0],
					f = d.shape[1],
					g = new x([e, f], null);
				D.calculate(e, f, a, b, d.texture, g.texture);
				return g
			}

			function e(a, b, d, e, f) {
				if (d.shape[1] !== b.shape[1]) throw Error("Second dimension must be of same size for input Tensors (second Tensor is transposed).");
				var g = b.shape[0],
					h = d.shape[0],
					k = b.shape[1];
				f = f ? f.texture : null;
				var l = new x([g, h], null);
				y.calculate(g, h, k, a, b.texture, d.texture, e, f, l.texture);
				return l
			}

			function k(a, b, d, e) {
				if (0 !== e.shape[1] % a) throw Error("Second dimension of tensor must be a multiple of channels");
				var f = e.shape[0],
					g = e.shape[1] / a,
					h = Math.floor((f - b) / d) + 1,
					k = Math.floor((g - b) / d) + 1,
					h = new x([h, k * a], null);
				z.calculate(f, g, a, b, d, e.texture, h.texture);
				return h
			}

			function l(a, b, d) {
				a = null != a ? a : Number.MIN_VALUE;
				b = null != b ? b : Number.MAX_VALUE;
				var e = d.shape[0],
					f = d.shape[1],
					g = new x([e, f], null);
				G.calculate(e, f, a, b, d.texture, g.texture);
				return g
			}

			function m(a, b, d, e, f) {
				if (0 !== f.shape[1] % a) throw Error("Second dimension of tensor must be a multiple of channels");
				var g = f.shape[0],
					h = f.shape[1] / a,
					k, l;
				e ? (k = Math.ceil((h + 2 * e - b) / d) + 1, l = Math.ceil((g +
					2 * e - b) / d) + 1) : (e = 0, k = Math.ceil((h - b) / d) + 1, l = Math.ceil((g - b) / d) + 1);
				var m = b * b * a;
				l *= k;
				var n = new x([l, m], null);
				A.calculate(g, h, a, l, m, k, b, d, e, f.texture, n.texture);
				return n
			}
			var n = a("./globals"),
				r = a("./sgemmcalculator"),
				t = a("./saxpycalculator");
			f = a("./sscalcalculator");
			var u = a("./sdwnscalculator"),
				w = a("./sclmpcalculator"),
				v = a("./slokncalculator"),
				x = a("./tensor");
			a = n.gl;
			var y = new r(a, !1),
				r = new t(a, !1),
				D = new f(a, !1),
				z = new u(a, !1),
				G = new w(a, !1),
				A = new v(a, !1);
			b.exports = {
				Tensor: x,
				sscal: d,
				sgemm: e,
				sdwns: k,
				sclmp: l,
				slokn: m,
				sgemmcalculator: y,
				saxpycalculator: r,
				sscalcalculator: D,
				sdwnscalculator: z,
				sclmpcalculator: G,
				slokncalculator: A
			}
		}, {
			"./globals": 2,
			"./saxpycalculator": 4,
			"./sclmpcalculator": 5,
			"./sdwnscalculator": 6,
			"./sgemmcalculator": 7,
			"./slokncalculator": 8,
			"./sscalcalculator": 9,
			"./tensor": 10
		}],
		4: [function(a, b, f) {
			function d(a, b) {
				this.webgl = a;
				this.program = (this.standalone = b || !0, this.webgl.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D X;\t\t// texture with data from padded A\nuniform sampler2D Y;\t\t// texture with data from padded transpose of B\nuniform int       N;\nuniform float     a; \t\t// coefficient to multiplication\n\n// Render float to bytes according to IEEE 754 Floating Point\nvec4 encode_float_1540259130(float val) {\n\n\t// TODO: correctly handle denormal numbers\n\t// http://www.2ality.com/2012/04/number-encoding.html\n\tfloat a = abs(val);                           // encode absolute value + sign\n\tfloat exp = floor(log2(a));                 // number of powers of 2\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n\tfloat mant3 = mod(mant,256.);               // third 8 bits\n\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n\treturn vec4(m3,m2,m1,e);\n}\n\n// select an element from a vector based on index\nfloat select_index_1604150559(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n \tfloat row = outTex.y;\n\tfloat col = outTex.x;\n\n\t// direct usage of col requires output be padded exactly like input\n\tvec4 x = texture2D( X, vec2(col, row));\n\tvec4 y = texture2D( Y, vec2(col, row));\n\tvec4 sum_v = (a * x) + y;\n\tint channel = int(mod(col * float(N), 4.0 ));\n\tfloat sum = select_index_1604150559(sum_v, channel);\n\n\tif (sum == 0.) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n \t// output vec4 with bytes for an IEEE754 32-bit floating point number\n\tgl_FragColor = encode_float_1540259130(sum);\n}\n"))
			}
			a = a("./webgl");
			b.exports = d;
			d.TEXTURE_UNIFORM_NAME_0 = "X";
			d.TEXTURE_UNIFORM_NAME_1 = "Y";
			d.LENGTH_UNIFORM_NAME = "N";
			d.COEFFICIENT_UNIFORM_NAME = "a";
			d.prototype.calculate = function(a, b, e, f, g) {
				var h = this.webgl.context;
				this.webgl.selectProgram(this.program);
				this.bindInputTexture(e, h.TEXTURE0, d.TEXTURE_UNIFORM_NAME_0);
				this.bindInputTexture(f, h.TEXTURE1, d.TEXTURE_UNIFORM_NAME_1);
				e = this.webgl.getPad(a);
				this.bindUniforms(a + e, b);
				this.webgl.bindOutputTexture(1, a + e, g);
				h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT,
					0);
				this.webgl.unbindInputTexture(h.TEXTURE0);
				this.webgl.unbindInputTexture(h.TEXTURE1)
			};
			d.prototype.bindInputTexture = function(a, b, d) {
				var e = this.webgl.context,
					f = this.program;
				e.activeTexture(b);
				e.bindTexture(e.TEXTURE_2D, a);
				a = e.getUniformLocation(f, d);
				e.uniform1i(a, b - e.TEXTURE0)
			};
			d.prototype.bindUniforms = function(a, b) {
				var e = this.webgl.context,
					f = e.getUniformLocation(this.program, d.LENGTH_UNIFORM_NAME),
					g = e.getUniformLocation(this.program, d.COEFFICIENT_UNIFORM_NAME);
				e.uniform1i(f, a);
				e.uniform1f(g, b)
			}
		}, {
			"./webgl": 12
		}],
		5: [function(a, b, f) {
			function d(a, b) {
				this.webgl = a;
				this.program = (this.standalone = null != b ? b : !0) ? this.webgl.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D X;\t\t// texture with data from padded A\nuniform int       N;\t\t// number of columns\nuniform int       pad;\t\t// additional columns to nearest multiple of four\nuniform float     a; \t\t// lower bound\nuniform float     b; \t\t// upper bound\n\n// Render float to bytes according to IEEE 754 Floating Point\nvec4 encode_float_1604150559(float val) {\n\n\t// TODO: correctly handle denormal numbers\n\t// http://www.2ality.com/2012/04/number-encoding.html\n\tfloat a = abs(val);                           // encode absolute value + sign\n\tfloat exp = floor(log2(a));                 // number of powers of 2\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n\tfloat mant3 = mod(mant,256.);               // third 8 bits\n\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n\treturn vec4(m3,m2,m1,e);\n}\n\n// select an element from a vector based on index\nfloat select_index_1540259130(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row = outTex.y;\n\tfloat col = outTex.x;\n\n\t// return 0.0 if in padded region of output texture\n\tif(col * float(N + pad) > float(N) ) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n\t// direct usage of col requires output be padded exactly like input\n\tvec4 x = texture2D( X, vec2(col, row));\n\tvec4 val = clamp(x, a, b);\n\n\t// select and output channel (standalone version only)\n\tint channel = int(mod(col * float(N + pad), 4.0));\n\tfloat sum = select_index_1540259130(val, channel);\n\n\tif (sum == 0.) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n\t// output vec4 with bytes for an IEEE754 32-bit floating point number\n\tgl_FragColor = encode_float_1604150559(sum);\n}\n") :
					this.webgl.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D X;\t\t// texture with data from padded A\nuniform int       N;\t\t// number of columns\nuniform int       pad;\t\t// additional columns to nearest multiple of four\nuniform float     a; \t\t// lower bound\nuniform float     b; \t\t// upper bound\n\n// set pad values to 0.0, if in padded region of output texture\nvoid fix_pad_1540259130(inout vec4 v, int pad){\n\tv.a = 0.0;\n\tif(pad == 2){\n\t\tv.b = 0.0;\n\t} else if(pad == 3){\n\t\tv.b = 0.0;\n\t\tv.g = 0.0;\n\t}\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\n\n\t// direct usage of col requires output be padded exactly like input\n\tvec4 x = texture2D( X, vec2(col_t, row_t));\n\tvec4 val_v = clamp(x, a, b);\n\n\t// is last element in pixel past row length?\n\tif(pad > 0 && (col + 4.0) > float(N) ) {\n\t\t// fix elements in padded region\n\t\tfix_pad_1540259130(val_v, pad);\n\t}\n\n\tgl_FragColor = val_v;\n}\n")
			}
			a = a("./webgl");
			b.exports = d;
			d.TEXTURE_UNIFORM_NAME_0 = "X";
			d.LENGTH_UNIFORM_NAME = "N";
			d.LOWER_UNIFORM_NAME = "a";
			d.UPPER_UNIFORM_NAME = "b";
			d.prototype.calculate = function(a, b, e, f, g, r) {
				e = null != e ? e : Number.MIN_VALUE;
				f = null != f ? f : Number.MAX_VALUE;
				var h = this.webgl.context;
				this.webgl.selectProgram(this.program);
				this.bindInputTexture(g, h.TEXTURE0, d.TEXTURE_UNIFORM_NAME_0);
				g = this.webgl.getPad(b);
				this.bindUniforms(b, g, e, f);
				this.standalone ? this.webgl.bindOutputTexture(a, b + g, r) : this.webgl.bindOutputTexture(a, (b + g) / 4,
					r);
				h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0);
				this.webgl.unbindInputTexture(h.TEXTURE0)
			};
			d.prototype.bindInputTexture = function(a, b, d) {
				var e = this.webgl.context,
					f = this.program;
				e.activeTexture(b);
				e.bindTexture(e.TEXTURE_2D, a);
				a = e.getUniformLocation(f, d);
				e.uniform1i(a, b - e.TEXTURE0)
			};
			d.prototype.bindUniforms = function(a, b, e, f) {
				var g = this.webgl.context,
					h = g.getUniformLocation(this.program, d.LENGTH_UNIFORM_NAME),
					k = g.getUniformLocation(this.program, d.UPPER_UNIFORM_NAME),
					l = g.getUniformLocation(this.program,
						d.LOWER_UNIFORM_NAME),
					m = g.getUniformLocation(this.program, "pad");
				g.uniform1i(h, a);
				g.uniform1i(m, b);
				g.uniform1f(l, e);
				g.uniform1f(k, f)
			}
		}, {
			"./webgl": 12
		}],
		6: [function(a, b, f) {
			function d(a, b) {
				this.webgl = a;
				this.standalone = null != b ? b : !0;
				p = "// TODO: unroll loop for stride == factor and small values (2, 3)\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;  // texture coords of row/column to calculate\nuniform sampler2D X;       // texture with data from padded A\nuniform int       factor;  // width of image patch\nuniform float     stride;  // width between image patches\nuniform float     C;       // number of channels\nuniform float     M;\nuniform float     N;\nuniform float     N_out;\nuniform float     M_out;\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate and translate to output pixel space.\n\tfloat row = floor(outTex.y * M_out);   // row on output texture (pixel space)\n\tfloat col = floor(outTex.x * N_out); // column on output texture (matrix space)\n\tfloat vcol = floor(col / C);   // virtual column on output texture (matrix space)\n\tfloat vchannel = floor(mod(col, C)); // virtual channel on output texture\n\n\tconst float min = -1.0e+08;\n\tvec4 currentMax = vec4(min, min, min, min);\n\n\tfloat deltaY = 1.0/M;\n\tfloat deltaX = 1.0/N;\n\tfloat y = ((row * stride) + 0.5)*deltaY; // texture position of input row\n\tfloat x;\n\tfloat z = vchannel * deltaX;\n\tfor (int i = 0; i < 100; i += 1) {\n\t\tif (i >= factor) {\n\t\t\tbreak;\n\t\t}\n\t\tx = ((vcol * stride * C) + 0.5) * deltaX; // texture position of input column\n\n\t\tfor (int j = 0; j < 100; j += 1) {\n\t\t\tif (j >= factor) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec2 coords = vec2(x + z, y);\n\t\t\tvec4 x_v = texture2D(X, coords);\n\t\t\tcurrentMax = max(currentMax, x_v);\n\n\t\t\tx += (deltaX * C);\n\t\t}\n\t\ty += deltaY;\n\t}\n\n\tgl_FragColor = currentMax;\n}\n";
				this.program = this.standalone ? this.webgl.createProgram("// TODO: unroll loop for stride == factor and small values (2, 3)\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;  // texture coords of row/column to calculate\nuniform sampler2D X;       // texture with data from padded A\nuniform int       factor;  // width of image patch\nuniform float     stride;  // width between image patches\nuniform float     C;       // number of channels\nuniform float     M;\nuniform float     N;\nuniform float     N_out;\nuniform float     M_out;\n\n// Render float to bytes according to IEEE 754 Floating Point\nvec4 encode_float_1540259130(float val) {\n\n\t// TODO: correctly handle denormal numbers\n\t// http://www.2ality.com/2012/04/number-encoding.html\n\tfloat a = abs(val);                           // encode absolute value + sign\n\tfloat exp = floor(log2(a));                 // number of powers of 2\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n\tfloat mant3 = mod(mant,256.);               // third 8 bits\n\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n\treturn vec4(m3,m2,m1,e);\n}\n\n// select an element from a vector based on index\nfloat select_index_1604150559(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate and translate to output pixel space.\n\tfloat row = floor(outTex.y * M_out);   // row on output texture (matrix space)\n\tfloat col = floor(outTex.x * N_out); // column on output texture (matrix space)\n\tfloat vcol = floor(col / C);   // virtual column on output texture (matrix space)\n\tfloat vchannel = floor(mod(col, C)); // virtual channel on output texture\n\n\tconst float min = -1.0e+08;\n\tvec4 currentMax = vec4(min, min, min, min);\n\n\tfloat deltaY = 1.0/M;\n\tfloat deltaX = 1.0/N;\n\tfloat y = ((row * stride) + 0.5)*deltaY; // texture position of input row\n\tfloat x;\n\tfloat z = vchannel * deltaX;\n\tfor (int i = 0; i < 100; i += 1) {\n\t\tif (i >= factor) {\n\t\t\tbreak;\n\t\t}\n\t\tx = ((vcol * stride * C) + 0.5) * deltaX; // texture position of input column\n\n\t\tfor (int j = 0; j < 100; j += 1) {\n\t\t\tif (j >= factor) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvec2 coords = vec2(x + z, y);\n\t\t\tvec4 x_v = texture2D(X, coords);\n\t\t\tcurrentMax = max(currentMax, x_v);\n\n\t\t\tx += (deltaX * C);\n\t\t}\n\t\ty += deltaY;\n\t}\n\tint chan = int(mod(outTex.x * N_out, 4.0 ));\n\tfloat val = select_index_1604150559(currentMax, int(chan));\n\tif (val == 0.) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n\tgl_FragColor = encode_float_1540259130(val);\n}\n") :
					this.webgl.createProgram(p)
			}
			var e = a("./webgl");
			b.exports = d;
			d.TEXTURE_UNIFORM_NAME_0 = "X";
			d.INPUT_ROW_COUNT_UNIFORM_NAME = "M";
			d.INPUT_COLUMN_COUNT_UNIFORM_NAME = "N";
			d.OUTPUT_ROW_COUNT_UNIFORM_NAME = "M_out";
			d.OUTPUT_COLUMN_COUNT_UNIFORM_NAME = "N_out";
			d.FACTOR_UNIFORM_NAME = "factor";
			d.STRIDE_UNIFORM_NAME = "stride";
			d.CHANNEL_COUNT_UNIFORM_NAME = "C";
			d.prototype.calculate = function(a, b, f, g, h, t, u) {
				if (0 != f % e.COMPONENTS_PER_TEXEL) throw Error("Channel count must be a multiple of " + e.COMPONENTS_PER_TEXEL);
				var k = this.webgl.context,
					l = (Math.floor((b - g) / h) + 1) * f,
					m = Math.floor((a - g) / h) + 1;
				this.webgl.selectProgram(this.program);
				this.bindInputTexture(t, k.TEXTURE0, d.TEXTURE_UNIFORM_NAME_0);
				this.bindUniforms(a, b * f, m, l, g, h, f);
				this.standalone ? this.webgl.bindOutputTexture(m, l, u) : this.webgl.bindOutputTexture(m, l / e.COMPONENTS_PER_TEXEL, u);
				k.drawElements(k.TRIANGLES, 6, k.UNSIGNED_SHORT, 0);
				this.webgl.unbindInputTexture(k.TEXTURE0)
			};
			d.prototype.bindInputTexture = function(a, b, d) {
				var e = this.webgl.context,
					f = this.program;
				e.activeTexture(b);
				e.bindTexture(e.TEXTURE_2D,
					a);
				a = e.getUniformLocation(f, d);
				e.uniform1i(a, b - e.TEXTURE0)
			};
			d.prototype.bindUniforms = function(a, b, e, f, g, h, u) {
				var k = this.webgl.context,
					l = k.getUniformLocation(this.program, d.INPUT_ROW_COUNT_UNIFORM_NAME),
					m = k.getUniformLocation(this.program, d.INPUT_COLUMN_COUNT_UNIFORM_NAME),
					n = k.getUniformLocation(this.program, d.OUTPUT_ROW_COUNT_UNIFORM_NAME),
					r = k.getUniformLocation(this.program, d.OUTPUT_COLUMN_COUNT_UNIFORM_NAME),
					t = k.getUniformLocation(this.program, d.FACTOR_UNIFORM_NAME),
					G = k.getUniformLocation(this.program,
						d.STRIDE_UNIFORM_NAME),
					A = k.getUniformLocation(this.program, d.CHANNEL_COUNT_UNIFORM_NAME);
				k.uniform1f(l, a);
				k.uniform1f(m, b);
				k.uniform1f(n, e);
				k.uniform1f(r, f);
				k.uniform1i(t, g);
				k.uniform1f(G, h);
				k.uniform1f(A, u)
			}
		}, {
			"./webgl": 12
		}],
		7: [function(a, b, f) {
			function d(a, b) {
				this.webgl = a;
				(this.standalone = null != b ? b : !0) ? (this.program_ = this.webgl.createProgram("// fragment shader that calculates the matrix product and renders each\n// element to the bytes representing a 32-bit IEEE754 floating point in\n// the output RGBA canvas.\n// readPixel is used to read the bytes.\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform sampler2D B_t;\t\t// texture with data from padded transpose of B\nuniform int       K;\t\t// number of elements in shared dimension\nuniform int       N;\t\t// number of columns in output\nuniform int       pad;\t\t//\nuniform float     alpha; \t// coefficient to multiplication\n\n// sum of products between elements in row i (from A) x col j (from B)\n\n// Calculate the dot product between the row (from A) and column (from B)\n// identified by the passed indeces (output texture coordinate space).\n// We loop over elements in the row and column and sum the product\n// using the glsl `dot` function to process four elements at a time.\n// This four element optimization requires that the matrix B be\n// transposed before texel packing and that both matrices be padded\n// (with zeros) to a multiple of four (4) in their shared dimension.\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\n\tfloat delta_t = 1./float(K);// space (on texture) between elements\n\tfloat sum = 0.;\t\t\t// sum for this row/column pair\n\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\n\n\tfor (int l=0 ; l<4096 ; ++l) {\n\t\tif(l >= K / 4) break;    // stop when we finish the row/column\n\t\t// l is in pixel space, so we divide by four\n\n\t\t// retrieve next four elements from each texture\n\t\tvec4 a_ik = texture2D(  A, vec2(z, y));\n\t\tvec4 b_kj = texture2D(B_t, vec2(z, x));\n\n\t// use `dot` to process four elements at a time\n\t\tsum +=  dot(a_ik, b_kj);\n\t\tz += (4.0 * delta_t);      // (z + 0.5)*delta\n\t}\n\treturn sum;\n}\n\n// Render float to bytes according to IEEE 754 Floating Point\nvec4 encode_float_1604150559(float val) {\n\n\t// TODO: correctly handle denormal numbers\n\t// http://www.2ality.com/2012/04/number-encoding.html\n\tfloat a = abs(val);                           // encode absolute value + sign\n\tfloat exp = floor(log2(a));                 // number of powers of 2\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n\tfloat mant3 = mod(mant,256.);               // third 8 bits\n\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n\treturn vec4(m3,m2,m1,e);\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\n\t// sum row x col for the passed pixel\n\tfloat sum = alpha * dot_rowcol_1540259130(row_t, col_t * float(N + pad)/float(N), A, B_t, K);\n\n\tif (sum == 0.) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n\t// output vec4 with bytes for an IEEE754 32-bit floating point number\n\tgl_FragColor = encode_float_1604150559(sum);\n}\n"),
					this.program_c = this.webgl.createProgram("// fragment shader that calculates the matrix product (with additive 'C' term)\n// and renders each element to the bytes representing a 32-bit IEEE754 floating\n// point in the output RGBA canvas.\n// readPixel is used to read the bytes.\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform sampler2D B_t;\t\t// texture with data from padded transpose of B\nuniform sampler2D C;\t\t// texture with data from C\nuniform int       K;\t\t// number of elements in shared dimension\nuniform int       N;\t\t// number of columns in output\nuniform int       pad;\t\t//\nuniform float     alpha; \t// coefficient to multiplication\nuniform float     beta; \t// coefficient to additive term\n\n// sum of products between elements in row i (from A) x col j (from B)\n\n// Calculate the dot product between the row (from A) and column (from B)\n// identified by the passed indeces (output texture coordinate space).\n// We loop over elements in the row and column and sum the product\n// using the glsl `dot` function to process four elements at a time.\n// This four element optimization requires that the matrix B be\n// transposed before texel packing and that both matrices be padded\n// (with zeros) to a multiple of four (4) in their shared dimension.\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\n\tfloat delta_t = 1./float(K);// space (on texture) between elements\n\tfloat sum = 0.;\t\t\t// sum for this row/column pair\n\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\n\n\tfor (int l=0 ; l<4096 ; ++l) {\n\t\tif(l >= K / 4) break;    // stop when we finish the row/column\n\t\t// l is in pixel space, so we divide by four\n\n\t\t// retrieve next four elements from each texture\n\t\tvec4 a_ik = texture2D(  A, vec2(z, y));\n\t\tvec4 b_kj = texture2D(B_t, vec2(z, x));\n\n\t// use `dot` to process four elements at a time\n\t\tsum +=  dot(a_ik, b_kj);\n\t\tz += (4.0 * delta_t);      // (z + 0.5)*delta\n\t}\n\treturn sum;\n}\n\n// Render float to bytes according to IEEE 754 Floating Point\nvec4 encode_float_1604150559(float val) {\n\n\t// TODO: correctly handle denormal numbers\n\t// http://www.2ality.com/2012/04/number-encoding.html\n\tfloat a = abs(val);                           // encode absolute value + sign\n\tfloat exp = floor(log2(a));                 // number of powers of 2\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n\tfloat mant3 = mod(mant,256.);               // third 8 bits\n\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n\treturn vec4(m3,m2,m1,e);\n}\n\n// select an element from a vector based on index\nfloat select_index_1117569599(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\tvec4 c_vec = texture2D(C, vec2(col_t, 0.5));\n\n\t// should be -0.5, but that subtly breaks at zero\n\tfloat col = col_t * float(N + pad); // index of first element in pixel (matrix space)\n\tint channel = int(mod(col, 4.0 ));\n\tfloat c = select_index_1117569599(c_vec, channel);\n\n\t// sum row x col for the passed pixel\n\tfloat sum = alpha * dot_rowcol_1540259130(row_t, col_t * float(N + pad)/float(N), A, B_t, K);\n\tsum += beta * c;\n\n\tif (sum == 0.) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n\t// output vec4 with bytes for an IEEE754 32-bit floating point number\n\tgl_FragColor = encode_float_1604150559(sum);\n}\n")) :
				(this.program_ = this.webgl.createProgram("// fragment shader that calculates the matrix product and writes each\n// element to a pixel component in a floating point texture.\n// the output RGBA canvas.\n// readPixel is used to read the bytes.\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform sampler2D B_t;\t\t// texture with data from padded transpose of B\nuniform int       K;\t\t// number of elements in shared dimension\nuniform int       N;\t\t// number of columns in output\nuniform int       pad;\t\t//\nuniform float     alpha; \t// coefficient to multiplication\n\n// sum of products between elements in row i (from A) x col j (from B)\n\n// Calculate the dot product between the row (from A) and column (from B)\n// identified by the passed indeces (output texture coordinate space).\n// We loop over elements in the row and column and sum the product\n// using the glsl `dot` function to process four elements at a time.\n// This four element optimization requires that the matrix B be\n// transposed before texel packing and that both matrices be padded\n// (with zeros) to a multiple of four (4) in their shared dimension.\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\n\tfloat delta_t = 1./float(K);// space (on texture) between elements\n\tfloat sum = 0.;\t\t\t// sum for this row/column pair\n\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\n\n\tfor (int l=0 ; l<4096 ; ++l) {\n\t\tif(l >= K / 4) break;    // stop when we finish the row/column\n\t\t// l is in pixel space, so we divide by four\n\n\t\t// retrieve next four elements from each texture\n\t\tvec4 a_ik = texture2D(  A, vec2(z, y));\n\t\tvec4 b_kj = texture2D(B_t, vec2(z, x));\n\n\t// use `dot` to process four elements at a time\n\t\tsum +=  dot(a_ik, b_kj);\n\t\tz += (4.0 * delta_t);      // (z + 0.5)*delta\n\t}\n\treturn sum;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\n\tvec4 sum_v = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\n\tsum_v.r = alpha * dot_rowcol_1540259130(row_t, (col + 0.5)/float(N), A, B_t, K);\n\t// is last element in pixel past row length?\n\tif(pad > 0 && (col + 4.0) > float(N) ) {\n\t\t// compute elements in padded region\n\t\tif(pad < 3){\n\t\t\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\n\t\t}\n\t\tif(pad < 2){\n\t\t\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\n\t\t}\n\t} else {\n\t\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\n\t\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\n\t\tsum_v.a = alpha * dot_rowcol_1540259130(row_t, (col + 3.5)/float(N), A, B_t, K);\n\t}\n\n\tgl_FragColor = sum_v;\n}\n"),
					this.program_c = this.webgl.createProgram("// fragment shader that calculates the matrix product and writes each\n// element to a pixel component in a floating point texture.\n// the output RGBA canvas.\n// readPixel is used to read the bytes.\n\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform sampler2D B_t;\t\t// texture with data from padded transpose of B\nuniform sampler2D C;\t\t// texture with data from C\nuniform int       K;\t\t// number of elements in shared dimension\nuniform int       N;\t\t// number of columns in output\nuniform int       pad;\t\t//\nuniform float     alpha; \t// coefficient to multiplication\nuniform float     beta; \t// coefficient to addition\n\n// sum of products between elements in row i (from A) x col j (from B)\n\n// Calculate the dot product between the row (from A) and column (from B)\n// identified by the passed indeces (output texture coordinate space).\n// We loop over elements in the row and column and sum the product\n// using the glsl `dot` function to process four elements at a time.\n// This four element optimization requires that the matrix B be\n// transposed before texel packing and that both matrices be padded\n// (with zeros) to a multiple of four (4) in their shared dimension.\nfloat dot_rowcol_1540259130(float y, float x, sampler2D A, sampler2D B_t, int K) {\n\tfloat delta_t = 1./float(K);// space (on texture) between elements\n\tfloat sum = 0.;\t\t\t// sum for this row/column pair\n\tfloat z = 0.5 * (4.0 * delta_t);// position for shared dimension on source textures\n\n\tfor (int l=0 ; l<4096 ; ++l) {\n\t\tif(l >= K / 4) break;    // stop when we finish the row/column\n\t\t// l is in pixel space, so we divide by four\n\n\t\t// retrieve next four elements from each texture\n\t\tvec4 a_ik = texture2D(  A, vec2(z, y));\n\t\tvec4 b_kj = texture2D(B_t, vec2(z, x));\n\n\t// use `dot` to process four elements at a time\n\t\tsum +=  dot(a_ik, b_kj);\n\t\tz += (4.0 * delta_t);      // (z + 0.5)*delta\n\t}\n\treturn sum;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\tvec4 c_v = texture2D(C, vec2(col_t, 0.5));\n\n\tvec4 sum_v = vec4(0.0, 0.0, 0.0, 0.0);\n\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\n\tsum_v.r = alpha * dot_rowcol_1540259130(row_t, (col + 0.5)/float(N), A, B_t, K);\n\t// in the padding region?\n\tif(pad > 0 && (col + 4.0) > float(N) ) {\n\t\t// pad\n\t\tif(pad < 3){\n\t\t\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\n\t\t}\n\t\tif(pad < 2){\n\t\t\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\n\t\t}\n\t} else {\n\t\tsum_v.g = alpha * dot_rowcol_1540259130(row_t, (col + 1.5)/float(N), A, B_t, K);\n\t\tsum_v.b = alpha * dot_rowcol_1540259130(row_t, (col + 2.5)/float(N), A, B_t, K);\n\t\tsum_v.a = alpha * dot_rowcol_1540259130(row_t, (col + 3.5)/float(N), A, B_t, K);\n\t}\n\n\tgl_FragColor = sum_v + beta*c_v;\n}\n"))
			}
			a = a("./webgl");
			b.exports = d;
			d.TEXTURE_UNIFORM_NAME_0 = "A";
			d.TEXTURE_UNIFORM_NAME_1 = "B_t";
			d.TEXTURE_UNIFORM_NAME_2 = "C";
			d.SHARED_LENGTH_UNIFORM_NAME = "K";
			d.COLUMN_COUNT_UNIFORM_NAME = "N";
			d.PAD_UNIFORM_NAME = "pad";
			d.ALPHA_UNIFORM_NAME = "alpha";
			d.BETA_UNIFORM_NAME = "beta";
			d.prototype.calculate = function(a, b, e, f, g, r, t, u, w) {
				var h = this.webgl.context;
				null != u ? this.program = this.program_c : (t = null, this.program = this.program_);
				this.webgl.selectProgram(this.program);
				this.bindInputTexture(g, h.TEXTURE0, d.TEXTURE_UNIFORM_NAME_0);
				this.bindInputTexture(r, h.TEXTURE1, d.TEXTURE_UNIFORM_NAME_1);
				null != u && this.bindInputTexture(u, h.TEXTURE2, d.TEXTURE_UNIFORM_NAME_2);
				g = this.webgl.getPad(e);
				r = this.webgl.getPad(b);
				this.bindUniforms(b, e + g, r, f, t);
				this.standalone ? this.webgl.bindOutputTexture(a, b + r, w) : this.webgl.bindOutputTexture(a, (b + r) / 4, w);
				h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0);
				this.webgl.unbindInputTexture(h.TEXTURE0);
				this.webgl.unbindInputTexture(h.TEXTURE1);
				this.webgl.unbindInputTexture(h.TEXTURE2)
			};
			d.prototype.bindInputTexture =
				function(a, b, d) {
					var e = this.webgl.context,
						f = this.program;
					e.activeTexture(b);
					e.bindTexture(e.TEXTURE_2D, a);
					a = e.getUniformLocation(f, d);
					e.uniform1i(a, b - e.TEXTURE0)
				};
			d.prototype.bindUniforms = function(a, b, e, f, g) {
				var h = this.webgl.context,
					k = h.getUniformLocation(this.program, d.SHARED_LENGTH_UNIFORM_NAME),
					l = h.getUniformLocation(this.program, d.ALPHA_UNIFORM_NAME),
					m = h.getUniformLocation(this.program, d.BETA_UNIFORM_NAME),
					n = h.getUniformLocation(this.program, d.COLUMN_COUNT_UNIFORM_NAME),
					x = x = h.getUniformLocation(this.program,
						d.PAD_UNIFORM_NAME);
				h.uniform1f(m, g);
				h.uniform1i(n, a);
				h.uniform1i(x, e);
				h.uniform1i(k, b);
				h.uniform1f(l, f)
			}
		}, {
			"./webgl": 12
		}],
		8: [function(a, b, f) {
			function d(a, b) {
				this.webgl = a;
				this.program = (this.standalone = null != b ? b : !0) ? this.webgl.createProgram(s) : this.webgl.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;  // texture coords of row/column to calculate\nuniform sampler2D X;       // texture with data from padded A\nuniform float     factor;  // width of image patch\nuniform float     stride;  // width between image patches\nuniform float     margin;\nuniform float     N_p;     // patches across\nuniform float     M;\nuniform float     N;\nuniform float     pad;\nuniform float     M_in;\nuniform float     N_in;\nuniform float     C;       // number of channels in input\nuniform float     pad_in;\n\n// select an element from a vector based on index\nfloat select_index_1540259130(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\n// translate a linear index into x, y coordinates for a matrix\nvec2 linear_index_coords_1604150559(float linear_index, float row_length){\n\tvec2 coords;\n\n\tcoords.x = floor(mod(linear_index + 0.5, row_length)); // column\n\tcoords.y = floor((linear_index + 0.5) / row_length); // row\n\n\treturn coords;\n}\n\n// set pad values to 0.0, if in padded region of output texture\nvoid fix_pad_1117569599(inout vec4 v, int pad){\n\tv.a = 0.0;\n\tif(pad == 2){\n\t\tv.b = 0.0;\n\t} else if(pad == 3){\n\t\tv.b = 0.0;\n\t\tv.g = 0.0;\n\t}\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\n\t// row corresponds to patch\n\tfloat row = floor(row_t * M) + 0.5;\n\t// column corresponds to placement in patch\n\tfloat col_0 = floor(col_t * (N + pad) - 1.5); // index of first element in output pixel (matrix space)\n\n\t// N_p = patches across\n\tfloat col_patch = floor(mod(row, N_p)); // column index in grid of patches\n\tfloat row_patch = floor(row / N_p); // row index in grid of patches\n\tfloat col_in_0 = (col_patch * stride - margin) * C; // input column index of left element in patch\n\tfloat row_in_0 = row_patch * stride - margin; // input row index of top element in patch\n\n\tvec4 pixel_in;\n\tvec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 coords = linear_index_coords_1604150559(col_0, factor * C); // coords inside patch\n\tvec2 ncoords;\n\tint channel_in = int(mod(col_in_0 + coords.x, 4.0));\n\tvec2 scale_in = vec2(1.0/(N_in + pad_in), 1.0/M_in); // scale from matrix to input texture coords\n\tvec2 offset_in = vec2(col_in_0 + 2.0 - float(channel_in), row_in_0 + 0.5); // offset into patch (and pixel)\n\n\tconst vec2 pixel_scale = vec2(1.0/4.0, 1.0); // scale from matrix to pixel coords\n\n\tpixel_in = texture2D(X, (coords + offset_in) * scale_in);\n\n\t// go through channels for current output pixel\n\tfor(int channel = 0; channel < 4; channel++){\n\n\t\t// are we on a new input pixel?\n\t\tncoords = linear_index_coords_1604150559(col_0 + float(channel), factor * C);\n\n\t\t// are we in the margin or outside the input texture?\n\t\tif((col_in_0 + ncoords.x + 0.5 < 0.0) || (row_in_0 + ncoords.y + 0.5 < 0.0) ||\n\t\t   (col_in_0 + ncoords.x + 0.5) > (N_in) || row_in_0 + ncoords.y + 0.5 > M_in){\n\t\t\t// yes, create a virtual pixel\n\t\t\tpixel_in = vec4(0.0, 0.0, 0.0, 0.0);\n\t\t} else if(floor(ncoords * pixel_scale) != floor(coords * pixel_scale)){\n\t\t\t// no, get the get the next real pixel\n\t\t\tcoords = ncoords;\n\t\t\toffset_in.x += float(channel_in);\n\t\t\tchannel_in = 0;\n\t\t\tpixel_in = texture2D(X, (coords + offset_in) * scale_in);\n\t\t}\n\n\t\tif(channel == 0){\n\t\t\tresult.r = select_index_1540259130(pixel_in, channel_in);\n\t\t} else if(channel == 1){\n\t\t\tresult.g = select_index_1540259130(pixel_in, channel_in);\n\t\t} else if(channel == 2){\n\t\t\tresult.b = select_index_1540259130(pixel_in, channel_in);\n\t\t} else {\n\t\t\tresult.a = select_index_1540259130(pixel_in, channel_in);\n\t\t}\n\n\t\tchannel_in++;\n\t\toffset_in.x -= 1.0;\n\t}\n\n\t// fix padded region\n\tif(pad > 0.0 && col_0 + 4.0 > N ) {\n\t\tfix_pad_1117569599(result, int(pad));\n\t}\n\n\t//gl_FragColor = vec4(row_in_0, col_in_0, channel_in, N_p);\n\tgl_FragColor = result;\n}\n")
			}
			a = a("./webgl");
			b.exports = d;
			d.TEXTURE_UNIFORM_NAME_0 = "X";
			d.STRIDE_UNIFORM_NAME = "stride";
			d.KERNEL_WIDTH_UNIFORM_NAME = "factor";
			d.prototype.calculate = function(a, b, e, f, g, r, t, u, w, v, x) {
				var h = this.webgl.context,
					k = this.webgl.getPad(b * e),
					l = this.webgl.getPad(g);
				this.webgl.selectProgram(this.program);
				this.bindInputTexture(v, h.TEXTURE0, d.TEXTURE_UNIFORM_NAME_0);
				this.bindUniforms(f, g, l, a, b * e, e, k, r, t, u, w);
				this.standalone ? this.webgl.bindOutputTexture(f, g + l, x) : this.webgl.bindOutputTexture(f, (g + l) / 4, x);
				h.drawElements(h.TRIANGLES,
					6, h.UNSIGNED_SHORT, 0);
				this.webgl.unbindInputTexture(h.TEXTURE0)
			};
			d.prototype.bindInputTexture = function(a, b, d) {
				var e = this.webgl.context,
					f = this.program;
				e.activeTexture(b);
				e.bindTexture(e.TEXTURE_2D, a);
				a = e.getUniformLocation(f, d);
				e.uniform1i(a, b - e.TEXTURE0)
			};
			d.prototype.bindUniforms = function(a, b, e, f, g, r, t, u, w, v, x) {
				var h = this.webgl.context,
					k = h.getUniformLocation(this.program, "M"),
					l = h.getUniformLocation(this.program, "N"),
					m = h.getUniformLocation(this.program, "C"),
					n = h.getUniformLocation(this.program, "M_in"),
					H = h.getUniformLocation(this.program, "N_in"),
					O = h.getUniformLocation(this.program, d.STRIDE_UNIFORM_NAME),
					M = h.getUniformLocation(this.program, d.KERNEL_WIDTH_UNIFORM_NAME),
					J = h.getUniformLocation(this.program, "pad"),
					P = h.getUniformLocation(this.program, "pad_in"),
					L = h.getUniformLocation(this.program, "N_p");
				margin_gl = h.getUniformLocation(this.program, "margin");
				h.uniform1f(k, a);
				h.uniform1f(l, b);
				h.uniform1f(J, e);
				h.uniform1f(n, f);
				h.uniform1f(H, g);
				h.uniform1f(m, r);
				h.uniform1f(P, t);
				h.uniform1f(L, u);
				h.uniform1f(M,
					w);
				h.uniform1f(O, v);
				h.uniform1f(margin_gl, x)
			}
		}, {
			"./webgl": 12
		}],
		9: [function(a, b, f) {
			function d(a, b) {
				this.webgl = a;
				this.program = (this.standalone = null != b ? b : !0) ? this.webgl.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D X;\t\t// texture with data from padded X\nuniform int       N;\t\t// number of columns\nuniform int       pad;\t\t// additional columns to nearest multiple of four\nuniform float     b; \t\t// additive term\nuniform float     a; \t\t// multiplicative term\n\n// Render float to bytes according to IEEE 754 Floating Point\nvec4 encode_float_1540259130(float val) {\n\n\t// TODO: correctly handle denormal numbers\n\t// http://www.2ality.com/2012/04/number-encoding.html\n\tfloat a = abs(val);                           // encode absolute value + sign\n\tfloat exp = floor(log2(a));                 // number of powers of 2\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n\tfloat mant3 = mod(mant,256.);               // third 8 bits\n\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n\treturn vec4(m3,m2,m1,e);\n}\n\n// select an element from a vector based on index\nfloat select_index_1604150559(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n \tfloat row = outTex.y;\n\tfloat col = outTex.x;\n\n\t// direct usage of col requires output be padded exactly like input\n\tvec4 x = texture2D( X, vec2(col, row));\n\tvec4 sum_v = (a * x) + b;\n\tint channel = int(mod(col * float(N + pad), 4.0 ));\n\tfloat sum = select_index_1604150559(sum_v, channel);\n\n\tif (sum == 0.) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n \t// output vec4 with bytes for an IEEE754 32-bit floating point number\n\tgl_FragColor = encode_float_1540259130(sum);\n}\n") :
					this.webgl.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D X;\t\t// texture with data from padded X\nuniform int       N;\t\t// number of columns\nuniform int       pad;\t\t// additional columns to nearest multiple of four\nuniform float     b; \t\t// additive term\nuniform float     a; \t\t// multiplicative term\n\n// set pad values to 0.0, if in padded region of output texture\nvoid fix_pad_1540259130(inout vec4 v, int pad){\n\tv.a = 0.0;\n\tif(pad == 2){\n\t\tv.b = 0.0;\n\t} else if(pad == 3){\n\t\tv.b = 0.0;\n\t\tv.g = 0.0;\n\t}\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\tfloat col = (col_t * float(N + pad) - 2.0); // index of first element in pixel (matrix space)\n\n\t// direct usage of col requires output be padded exactly like input\n\tvec4 x = texture2D( X, vec2(col_t, row_t));\n\tvec4 sum_v = (a * x) + b;\n\n\t// fix padded region\n\tif(pad > 0 && col + 4.0 > float(N) ) {\n\t\tfix_pad_1540259130(sum_v, pad);\n\t}\n\n\tgl_FragColor = sum_v;\n}\n")
			}
			a = a("./webgl");
			b.exports = d;
			d.TEXTURE_UNIFORM_NAME_0 = "X";
			d.LENGTH_UNIFORM_NAME = "N";
			d.ADD_UNIFORM_NAME = "b";
			d.MUL_UNIFORM_NAME = "a";
			d.prototype.calculate = function(a, b, e, f, g, r) {
				var h = this.webgl.context,
					k = this.webgl.getPad(b);
				this.webgl.selectProgram(this.program);
				this.bindInputTexture(g, h.TEXTURE0, d.TEXTURE_UNIFORM_NAME_0);
				this.bindUniforms(b, k, e, f);
				this.standalone ? this.webgl.bindOutputTexture(a, b + k, r) : this.webgl.bindOutputTexture(a, (b + k) / 4, r);
				h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0);
				this.webgl.unbindInputTexture(h.TEXTURE0)
			};
			d.prototype.bindInputTexture = function(a, b, d) {
				var e = this.webgl.context,
					f = this.program;
				e.activeTexture(b);
				e.bindTexture(e.TEXTURE_2D, a);
				a = e.getUniformLocation(f, d);
				e.uniform1i(a, b - e.TEXTURE0)
			};
			d.prototype.bindUniforms = function(a, b, e, f) {
				var g = this.webgl.context,
					h = g.getUniformLocation(this.program, d.LENGTH_UNIFORM_NAME),
					k = g.getUniformLocation(this.program, d.ADD_UNIFORM_NAME),
					l = g.getUniformLocation(this.program, d.MUL_UNIFORM_NAME),
					m = g.getUniformLocation(this.program, "pad");
				g.uniform1i(h, a);
				g.uniform1i(m,
					b);
				g.uniform1f(l, e);
				g.uniform1f(k, f)
			}
		}, {
			"./webgl": 12
		}],
		10: [function(a, b, f) {
			function d(a, b) {
				if (2 != a.length) throw Error("Only Tensor of order two (matrix) is supported right now.");
				var d = a[0];
				a = a[1];
				this.texture = e.createDataTexture(d, a, b);
				this.shape = [d, a]
			}
			a = a("./globals");
			var e = a.gl;
			b.exports = d;
			d.prototype.delete = function() {
				e.context.deleteTexture(this.texture);
				this.shape = this.texture = null
			};
			d.prototype.transfer = function(a) {
				var b = this.shape[0],
					d = this.shape[1],
					f;
				f = e.createOutputTexture(b, d);
				e.encode(b,
					d, this.texture, f);
				b = new Float32Array(e.readData(b, d));
				e.context.deleteTexture(f);
				a || this.delete();
				return b
			};
			d.prototype.reshape = function(a, b) {
				var f = this.shape[0],
					g = this.shape[1],
					h = a[0],
					k = a[1];
				a = new d(a, null);
				e.reshape(f, g, h, k, this.texture, a.texture);
				b || this.delete();
				return a
			};
			d.prototype.transpose = function(a) {
				var b = this.shape[0],
					f = this.shape[1],
					g = new d([f, b], null);
				e.transpose(b, f, this.texture, g.texture);
				a || this.delete();
				return g
			};
			d.prototype.split = function(a, b) {
				var f = this.shape[0],
					g = this.shape[1];
				if (0 !== g % 2) throw Error("row count must be multiple of two.");
				var h = new d([f, g / 2], null),
					k = new d([f, g / 2], null);
				e.submatrix(g, f, g / 2, a, 0, this.texture, h.texture);
				e.submatrix(g, f, g / 2, a, 1, this.texture, k.texture);
				b || this.delete();
				return [h, k]
			};
			d.combine = function(a, b, f, g) {
				var h = a.shape[0],
					k = a.shape[1];
				if (a.shape[1] !== b.shape[1] || a.shape[0] !== b.shape[0]) throw Error("row and column counts must be equal.");
				if (0 !== f % 4) throw Error("stride must be a multiple of four");
				var l = new d([h, 2 * k], null);
				e.combine(h, k, f, a.texture,
					b.texture, l.texture);
				g || (a.delete(), b.delete());
				return l
			}
		}, {
			"./globals": 2
		}],
		11: [function(a, b, f) {
			function d(a, b) {
				return k.load(a, Float32Array, b)
			}
			var e = a("async"),
				k = a("arrayloader");
			test = {
				allclose: function(a, b, d, e) {
					d = d || 1E-5;
					e = e || 1E-8;
					if (a.length != b.length) return console.log("lengths not equal: " + a.length + ", " + b.length), {
						result: !1,
						index: null
					};
					for (var f, g = 0; g < a.length; g++)
						if (f = Math.abs(a[g] - b[g]) <= e + d * Math.abs(b[g]), !f) return {
							result: !1,
							index: g
						};
					return {
						result: !0,
						index: g
					}
				},
				randomArray: function(a, b) {
					for (var d = [], e = 0; e < a; e++) {
						for (var f = [], g = 0; g < b; g++) f[g] = Math.random() / Math.sqrt(a);
						d.push(f)
					}
					return d
				},
				padData: function(a, b, d, e) {
					for (var f = new Float32Array(a * (b + d)), g = 0; g < a; g++) f.set(e.subarray(g * b, (g + 1) * b), g * (b + d));
					return f
				},
				submatrix: function(a, b, d, e, f) {
					for (var g = new f.constructor(b * d), h = 0; h < b; h++)
						for (var k = 0; k < d; k++) g[h * d + k] = f[h * a + k + e];
					return g
				},
				load: function(a, b, f) {
					b = b.map(function(b) {
						return a + b
					});
					e.map(b, d, function(a, b) {
						if (a) return f(a);
						f(a, b)
					})
				},
				assert: {}
			};
			test.assert.allclose = function(a, b, d, e, f, g) {
				f =
					test.allclose(b, d, f, g);
				var h = g = "[";
				if (!f.result) {
					1 < f.index && (g += "..., ", h += "..., ");
					0 < f.index && (g += b[f.index - 1] + ", ", h += d[f.index - 1] + ", ");
					g += "--\x3e";
					for (var h = h + "--\x3e", k = f.index; k < f.index + 4 && k < b.length; k++) g += b[k] + ", ", h += d[k] + ", ";
					k < b.length ? (g += "...]", h += "...]") : (g += "]", h += "]");
					e = e || "should be allclose at " + f.index
				}
				a._assert(f.result, {
					message: e || "should be allclose",
					operator: "allclose",
					actual: g,
					expected: h,
					extra: null
				})
			};
			b.exports = test
		}, {
			arrayloader: 13,
			async: 14
		}],
		12: [function(a, b, f) {
			function d(a) {
				var b;
				a = a || {};
				this.canvas = "undefined" === typeof a.canvas ? document.createElement("canvas") : a.canvas;
				a = {
					premultipliedAlpha: !1,
					preserveDrawingBuffer: !1
				};
				this.context = this.canvas.getContext("experimental-webgl", a);
				if (null != this.context) {
					try {
						b = this.context.getExtension("OES_texture_float")
					} catch (l) {}
					b ? this.hasFloat = !0 : (console.log("No support for OES_texture_float extension."), this.hasFloat = !1);
					b = this.context.getShaderPrecisionFormat(this.context.FRAGMENT_SHADER, this.context.HIGH_FLOAT);
					if (this.hasHighPrecision =
						0 != b.precision) this.highp = b;
					this.vertexShader = this.context.createShader(this.context.VERTEX_SHADER);
					this.context.shaderSource(this.vertexShader, "// vertex shader for a single quad\n// work is performed in the operation specific texture shader\n\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 pos;\nattribute vec2 tex;\nvarying vec2   outTex;\nvoid main(void)\n{\n\t// just pass the position and texture coords\n\tgl_Position = vec4(pos, 1.0);\n\toutTex = tex;\n}\n");
					this.context.compileShader(this.vertexShader);
					this.encode_program = this.createProgram("\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform int       N;\t\t// number of columns in output\nuniform int       pad;\t\t//\n\n// Render float to bytes according to IEEE 754 Floating Point\nvec4 encode_float_1540259130(float val) {\n\n\t// TODO: correctly handle denormal numbers\n\t// http://www.2ality.com/2012/04/number-encoding.html\n\tfloat a = abs(val);                           // encode absolute value + sign\n\tfloat exp = floor(log2(a));                 // number of powers of 2\n\tfloat mant = pow(2.,log2(a)-exp) * pow(2.,23.);  // multiply to fill 24 bits (implied leading 1)\n\tfloat mant1 = floor(mant / 256. / 256.);    // first 8 bits of mantissa\n\tfloat mant2 = mod(floor(mant / 256.),256.); // second 8 bits\n\tfloat mant3 = mod(mant,256.);               // third 8 bits\n\n\thighp float sign = 128.-128.*(a/val);\t\t\t// sign bit is 256 or 0\n\thighp float e = (sign+exp+127.)/510.;\t\t// exponent and sign\n\thighp float m1 = (mant1-(128.*(1.-mod(exp+127.,2.))))/255.; // handle leading bit\n\thighp float m2 = (mant2)/255.;\t\t\t\t// middle part\n\thighp float m3 = (mant3+.5)/255.;\t\t\t// scale to 0 - 255\n\n\treturn vec4(m3,m2,m1,e);\n}\n\n// select an element from a vector based on index\nfloat select_index_1604150559(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\n\tvec4 val_v = texture2D(A, vec2(col_t * float(N)/float(N + pad), row_t));\n\tint channel = int(mod(col_t * float(N), 4.0 ));\n\tfloat val = select_index_1604150559(val_v, channel);\n\n\tif (val == 0.) {\n\t\tgl_FragColor = vec4(0.,0.,0.,0.);\n\t\treturn;\n\t}\n\n \t// output vec4 with bytes for an IEEE754 32-bit floating point number\n\tgl_FragColor = encode_float_1540259130(val);\n}\n");
					this.transpose_program = this.createProgram("\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform int       M;\t\t// number of rows in output\nuniform int       N;\t\t// number of columns in output\nuniform int       mpad;\t\t//\nuniform int       npad;\t\t//\n\n// select an element from a vector based on index\nfloat select_index_1540259130(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\tfloat col = (col_t * float(N + npad) - 2.0); // index of first element in pixel (matrix space)\n\n\t// get rows in the input, each containing one element in the output\n\tvec4 row_1 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 0.5)/float(N)));\n\tvec4 row_2 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 1.5)/float(N)));\n\tvec4 row_3 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 2.5)/float(N)));\n\tvec4 row_4 = texture2D(A, vec2((row_t * float(M))/float(M + mpad), (col + 3.5)/float(N)));\n\n\t// package into output vector\n\tint channel = int(mod(row_t * float(M), 4.0 ));\n\n\tvec4 col_v = vec4(0.0, 0.0, 0.0, 0.0); // vec4 representing four elements in a column in the input\n\n\t// extract relevent element from each input row\n\tcol_v.r = select_index_1540259130(row_1, channel);\n\tif(npad > 0 && (col + 4.0) > float(N) ) {\n\t\t// compute elements in padded region\n\t\tif(npad < 3){\n\t\t\tcol_v.g = select_index_1540259130(row_2, channel);\n\t\t}\n\t\tif(npad < 2){\n\t\t\tcol_v.b = select_index_1540259130(row_3, channel);\n\t\t}\n\t} else {\n\t\tcol_v.g = select_index_1540259130(row_2, channel);\n\t\tcol_v.b = select_index_1540259130(row_3, channel);\n\t\tcol_v.a = select_index_1540259130(row_4, channel);\n\t}\n\n\tgl_FragColor = col_v;\n}\n");
					this.reshape_program = this.createProgram("\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform float     M;\t\t// number of rows in output\nuniform float     N;\t\t// number of columns in output\nuniform float     pad;\t\t// column padding in output\nuniform float     M_in;\t\t// number of rows in input\nuniform float     N_in;\t\t// number of columns in input\nuniform float     pad_in;\t// column padding in input\n\n/* number of input pixels\n   origin index (channel) for each\n   termination index (channel) for each\n   destination origin index (channel) for each\n */\n// select an element from a vector based on index\nfloat select_index_1540259130(vec4 v, int index){\n\tfloat val;\n\tif (index == 0) {\n\t\tval = v.r;\n\t} else if(index == 1) {\n\t\tval = v.g;\n\t} else if(index == 2) {\n\t\tval = v.b;\n\t} else if(index == 3){\n\t\tval = v.a;\n\t} else {\n\t\t// should never be here\n\t\tval = 0.0;\n\t}\n\n\treturn val;\n}\n\n// set pad values to 0.0, if in padded region of output texture\nvoid fix_pad_1604150559(inout vec4 v, int pad){\n\tv.a = 0.0;\n\tif(pad == 2){\n\t\tv.b = 0.0;\n\t} else if(pad == 3){\n\t\tv.b = 0.0;\n\t\tv.g = 0.0;\n\t}\n}\n\n// translate a linear index into x, y coordinates for a matrix\nvec2 linear_index_coords_1117569599(float linear_index, float row_length){\n\tvec2 coords;\n\n\tcoords.x = floor(mod(linear_index + 0.5, row_length)); // column\n\tcoords.y = floor((linear_index + 0.5) / row_length); // row\n\n\treturn coords;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\n\tfloat row = floor(row_t * M);\n\tfloat col_0 = (col_t * (N + pad) - 2.0); // index of first element in pixel (matrix space)\n\t//float col_0 = floor(col_t * (N + pad)/4.0)*4.0; // index of first element in pixel (matrix space)\n\tfloat lin_index_0 = row * N + col_0; // linearized index of first element in pixel in output\n\n\tvec4 pixel_in = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec4 result = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec2 coords = linear_index_coords_1117569599(lin_index_0, N_in);\n\tvec2 ncoords;\n\tint channel_in = int(mod(coords.x, 4.0));\n\n\tvec2 scale_in = vec2(1.0/(N_in + pad_in), 1.0/M_in); // scale from matrix to input texture coords\n\tvec2 offset_in = vec2(0.5, 0.5); // move away from edge of pixel\n\tconst vec2 pixel_scale = vec2(1.0/4.0, 1.0); // scale from matrix to pixel coords\n\n\tpixel_in = texture2D(A, (coords + offset_in) * scale_in);\n\n\t// go through channels for current output pixel\n\tfor(int channel = 0; channel < 4; channel++){\n\n\t\t// are we on a new input pixel?\n\t\tncoords = linear_index_coords_1117569599(lin_index_0 + float(channel), N_in);\n\t\tif(floor(ncoords * pixel_scale) != floor(coords * pixel_scale)){\n\t\t\tcoords = ncoords;\n\t\t\tpixel_in = texture2D(A, (coords + offset_in) * scale_in);\n\t\t\tchannel_in = 0;\n\t\t}\n\n\t\tif(channel == 0){\n\t\t\tresult.r = select_index_1540259130(pixel_in, channel_in);\n\t\t} else if(channel == 1){\n\t\t\tresult.g = select_index_1540259130(pixel_in, channel_in);\n\t\t} else if(channel == 2){\n\t\t\tresult.b = select_index_1540259130(pixel_in, channel_in);\n\t\t} else {\n\t\t\tresult.a = select_index_1540259130(pixel_in, channel_in);\n\t\t}\n\n\t\tchannel_in++;\n\t}\n\n\t// are we in the padded (output) region?\n\tif(pad > 0.0 && col_0 + 3.5 > N ) {\n\t\tfix_pad_1604150559(result, int(pad));\n\t}\n\n\tgl_FragColor = result;\n}\n");
					this.reshape_simple_program = this.createProgram("\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform float     M;\t\t// number of rows in output\nuniform float     N;\t\t// number of columns in output\nuniform float     M_in;\t\t// number of rows in input\nuniform float     N_in;\t\t// number of columns in input\n\n// translate a linear index into x, y coordinates for a matrix\nvec2 linear_index_coords_1540259130(float linear_index, float row_length){\n\tvec2 coords;\n\n\tcoords.x = floor(mod(linear_index + 0.5, row_length)); // column\n\tcoords.y = floor((linear_index + 0.5) / row_length); // row\n\n\treturn coords;\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\n\tfloat row = floor(row_t * M);\n\tfloat col_0 = floor(col_t * N - 1.5); // index of first element in pixel (matrix space)\n\tfloat lin_index_0 = row * N + col_0; // linearized index of first element in pixel in output\n\n\tvec4 result;\n\tvec2 coords = linear_index_coords_1540259130(lin_index_0, N_in);\n\n\tvec2 scale_in = vec2(1.0/N_in, 1.0/M_in); // scale from matrix to input texture coords\n\tvec2 offset_in = vec2(0.5, 0.5); // move away from edge of pixel\n\n\tresult = texture2D(A, (coords + offset_in) * scale_in);\n\n\tgl_FragColor = result;\n}\n");
					this.submatrix_program = this.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D X;\t\t// texture with data from padded X\nuniform float     N;\t\t// number of columns\nuniform float     pad;\t\t// additional columns to nearest multiple of four\nuniform float     N_in;\t\t// number of columns (input)\nuniform float     pad_in;\t// additional columns to nearest multiple of four (input)\nuniform float     stride;\nuniform float     offset;   // zero or one\n\n// set pad values to 0.0, if in padded region of output texture\nvoid fix_pad_1540259130(inout vec4 v, int pad){\n\tv.a = 0.0;\n\tif(pad == 2){\n\t\tv.b = 0.0;\n\t} else if(pad == 3){\n\t\tv.b = 0.0;\n\t\tv.g = 0.0;\n\t}\n}\n\n/* join parts of two pixels into one, selecting four continguous elements\n  starting at channel.\n*/\nvoid join_pixels_1604150559(inout vec4 x, vec4 x0, vec4 x1, float channel){\n\tif(channel == 1.0){\n\t\tx.rgb = x0.gba;\n\t\tx.a = x1.r;\n\t} else if(channel == 2.0){\n\t\tx.rg = x0.ba;\n\t\tx.ba = x1.rg;\n\t} else if(channel == 3.0){\n\t\tx.r = x0.a;\n\t\tx.gba = x1.rgb;\n\t}\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\tfloat col = floor(col_t * (N + pad) - 1.5); // index of first element in pixel (output matrix space)\n\n\tfloat stripe = floor(col / stride);\n\tfloat sub_col = floor(mod(col, stride));\n\n\tfloat col_in = (offset + (2.0 * stripe)) * stride + sub_col;\n\n\tvec4 x;\n\tfloat channel = mod(col_in, 4.0); // channel in the input of first element in output\n\n\t// are we at the beggining of an input pixel?\n\tif(channel == 0.0){\n\t\t// yes, select the whole thing\n\t\tx = texture2D( X, vec2((col_in + 2.0 - channel) / (N_in + pad_in) , row_t));\n\t} else {\n\t\t// no, select parts from two pixels\n\t\tvec4 x0, x1;\n\t\tx0 = texture2D( X, vec2((col_in + 2.0 - channel) / (N_in + pad_in) , row_t));\n\t\tx1 = texture2D( X, vec2((col_in + 6.0 - channel) / (N_in + pad_in) , row_t));\n\n\t\tjoin_pixels_1604150559(x, x0, x1, channel);\n\n\t}\n\n\t// fix padded region\n\tif(pad > 0.0 && col + 4.0 > N ) {\n\t\tfix_pad_1540259130(x, int(pad));\n\t}\n\n\tgl_FragColor = x;\n}\n");
					this.combine_program = this.createProgram("precision highp float;\n#define GLSLIFY 1\n\nvarying vec2      outTex;\t// texture coords of row/column to calculate\nuniform sampler2D A;\t\t// texture with data from padded A\nuniform sampler2D B;\t\t// texture with data from padded B\nuniform float     N_in;\t\t// number of columns\nuniform float     pad_in;\t// additional columns to nearest multiple of four\nuniform float     stride;\n\n// set pad values to 0.0, if in padded region of output texture\nvoid fix_pad_1540259130(inout vec4 v, int pad){\n\tv.a = 0.0;\n\tif(pad == 2){\n\t\tv.b = 0.0;\n\t} else if(pad == 3){\n\t\tv.b = 0.0;\n\t\tv.g = 0.0;\n\t}\n}\n\nvoid main(void) {\n\n\t// get the implied row and column from .y and .x of passed (output)\n\t// texture coordinate. These map directly to input texture space when\n\t// the relevant dimensions are the same.\n\tfloat row_t = outTex.y;\n\tfloat col_t = outTex.x;\n\tfloat N = N_in * 2.0;\n\tfloat pad = mod(N, 4.0);\n\tfloat col = floor(col_t * (N + pad) - 1.5); // index of first element in pixel (output matrix space)\n\n\tfloat stripe = floor(col / stride);\n\tfloat sub_col = floor(mod(col, stride));\n\n\tfloat tex_select = mod(stripe, 2.0);\n\tfloat col_in = floor(stripe / 2.0) * stride + sub_col;\n\n\tvec4 x;\n\tfloat channel = mod(col_in, 4.0); // channel in the input of first element in output\n\n\t// which input texture are we getting this pixel from?\n\tif(tex_select == 0.0){\n\t\tx = texture2D( A, vec2((col_in + 2.0) / (N_in + pad_in) , row_t));\n\t} else {\n\t\tx = texture2D( B, vec2((col_in + 2.0) / (N_in + pad_in) , row_t));\n\t}\n\n\t// fix padded region\n\tif(pad > 0.0 && col + 4.0 > N ) {\n\t\tfix_pad_1540259130(x, int(pad));\n\t}\n\n\tgl_FragColor = x;\n}\n")
				}
			}
			b.exports = d;
			d.COMPONENTS_PER_TEXEL = 4;
			d.POSITION_UNIFORM_NAME = "pos";
			d.TEXTURE_UNIFORM_NAME = "tex";
			d.prototype.encode = function(a, b, d, e) {
				this.program = this.encode_program;
				this.selectProgram(this.program);
				var f = this.getPad(b),
					g = this.context.getUniformLocation(this.program, "N"),
					h = this.context.getUniformLocation(this.program, "pad");
				this.context.uniform1i(g, b);
				this.context.uniform1i(h, f);
				this.bindInputTexture(d, this.context.TEXTURE0, "A");
				this.bindOutputTexture(a, b, e);
				this.context.drawElements(this.context.TRIANGLES,
					6, this.context.UNSIGNED_SHORT, 0);
				this.unbindInputTexture(this.context.TEXTURE0)
			};
			d.prototype.transpose = function(a, b, d, e) {
				this.program = this.transpose_program;
				this.selectProgram(this.program);
				var f = this.getPad(b),
					g = this.getPad(a),
					h = this.context.getUniformLocation(this.program, "N"),
					k = this.context.getUniformLocation(this.program, "npad"),
					l = this.context.getUniformLocation(this.program, "M"),
					m = this.context.getUniformLocation(this.program, "mpad");
				this.context.uniform1i(h, a);
				this.context.uniform1i(k, g);
				this.context.uniform1i(l,
					b);
				this.context.uniform1i(m, f);
				this.bindInputTexture(d, this.context.TEXTURE0, "A");
				this.bindOutputTexture(b, (a + g) / 4, e);
				this.context.drawElements(this.context.TRIANGLES, 6, this.context.UNSIGNED_SHORT, 0);
				this.unbindInputTexture(this.context.TEXTURE0)
			};
			d.prototype.reshape = function(a, b, d, e, f, g) {
				var h = this.getPad(b),
					k = this.getPad(e);
				0 == h && 0 == k ? this.program = this.reshape_simple_program : (this.program = this.reshape_program, console.log("# WARNING: using slow reshape shader."));
				this.selectProgram(this.program);
				var l = this.context.getUniformLocation(this.program, "M"),
					m = this.context.getUniformLocation(this.program, "N"),
					n = this.context.getUniformLocation(this.program, "pad"),
					r = this.context.getUniformLocation(this.program, "M_in"),
					D = this.context.getUniformLocation(this.program, "N_in"),
					z = this.context.getUniformLocation(this.program, "pad_in");
				this.context.uniform1f(l, d);
				this.context.uniform1f(m, e);
				this.context.uniform1f(n, k);
				this.context.uniform1f(r, a);
				this.context.uniform1f(D, b);
				this.context.uniform1f(z, h);
				this.bindInputTexture(f,
					this.context.TEXTURE0, "A");
				this.bindOutputTexture(d, (e + k) / 4, g);
				this.context.drawElements(this.context.TRIANGLES, 6, this.context.UNSIGNED_SHORT, 0);
				this.unbindInputTexture(this.context.TEXTURE0)
			};
			d.prototype.submatrix = function(a, b, d, e, f, g, t) {
				this.program = this.submatrix_program;
				this.selectProgram(this.program);
				var h = this.getPad(a),
					k = this.getPad(d),
					l = this.context.getUniformLocation(this.program, "N"),
					m = this.context.getUniformLocation(this.program, "pad"),
					n = this.context.getUniformLocation(this.program, "N_in"),
					r = this.context.getUniformLocation(this.program, "pad_in"),
					z = this.context.getUniformLocation(this.program, "offset");
				stride_gl = this.context.getUniformLocation(this.program, "stride");
				this.context.uniform1f(l, d);
				this.context.uniform1f(m, k);
				this.context.uniform1f(n, a);
				this.context.uniform1f(r, h);
				this.context.uniform1f(stride_gl, e);
				this.context.uniform1f(z, f);
				this.bindInputTexture(g, this.context.TEXTURE0, "X");
				this.bindOutputTexture(b, (d + k) / 4, t);
				this.context.drawElements(this.context.TRIANGLES, 6, this.context.UNSIGNED_SHORT,
					0);
				this.unbindInputTexture(this.context.TEXTURE0)
			};
			d.prototype.combine = function(a, b, d, e, f, g) {
				this.program = this.combine_program;
				this.selectProgram(this.program);
				var h = 2 * b,
					k = this.getPad(b),
					l = this.getPad(h),
					m = this.context.getUniformLocation(this.program, "N_in"),
					n = this.context.getUniformLocation(this.program, "pad_in"),
					r = this.context.getUniformLocation(this.program, "stride");
				this.context.uniform1f(m, b);
				this.context.uniform1f(n, k);
				this.context.uniform1f(r, d);
				this.bindInputTexture(e, this.context.TEXTURE0,
					"A");
				this.bindInputTexture(f, this.context.TEXTURE1, "B");
				this.bindOutputTexture(a, (h + l) / 4, g);
				this.context.drawElements(this.context.TRIANGLES, 6, this.context.UNSIGNED_SHORT, 0);
				this.unbindInputTexture(this.context.TEXTURE0)
			};
			d.prototype.bindInputTexture = function(a, b, d) {
				var e = this.context,
					f = this.program;
				e.activeTexture(b);
				e.bindTexture(e.TEXTURE_2D, a);
				a = e.getUniformLocation(f, d);
				e.uniform1i(a, b - e.TEXTURE0)
			};
			d.prototype.createProgram = function(a) {
				var b = this.context,
					d;
				if (null != b) {
					d = b.createShader(b.FRAGMENT_SHADER);
					b.shaderSource(d, a);
					b.compileShader(d);
					if (0 == b.getShaderParameter(d, b.COMPILE_STATUS)) throw Error(b.getShaderInfoLog(d));
					a = b.createProgram();
					b.attachShader(a, this.vertexShader);
					b.attachShader(a, d);
					b.linkProgram(a);
					return a
				}
			};
			d.prototype.selectProgram = function(a) {
				var b = this.context;
				b.useProgram(a);
				this.bindVertices(a)
			};
			d.prototype.bindVertices = function(a) {
				var b = this.context,
					e = b.getAttribLocation(a, d.POSITION_UNIFORM_NAME),
					f = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, f);
				f = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1,
					1, 0
				];
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(f), b.STATIC_DRAW);
				b.vertexAttribPointer(e, 3, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(e);
				a = b.getAttribLocation(a, d.TEXTURE_UNIFORM_NAME);
				e = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, e);
				e = [0, 0, 1, 0, 1, 1, 0, 1];
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(e), b.STATIC_DRAW);
				b.vertexAttribPointer(a, 2, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(a);
				a = b.createBuffer();
				b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, a);
				a = [0, 1, 2, 0, 2, 3];
				b.bufferData(b.ELEMENT_ARRAY_BUFFER,
					new Uint16Array(a), b.STATIC_DRAW)
			};
			d.prototype.createDataTexture = function(a, b, e) {
				var f = this.context,
					g = [0, 0, 0, 0],
					h = b % d.COMPONENTS_PER_TEXEL,
					k = 0 == h ? 0 : d.COMPONENTS_PER_TEXEL - h,
					l = f.createTexture();
				f.bindTexture(f.TEXTURE_2D, l);
				if (0 == k || null == e || "undefined" === typeof e) f.texImage2D(f.TEXTURE_2D, 0, f.RGBA, (b + k) / d.COMPONENTS_PER_TEXEL, a, 0, f.RGBA, f.FLOAT, e);
				else {
					f.texImage2D(f.TEXTURE_2D, 0, f.RGBA, (b + k) / d.COMPONENTS_PER_TEXEL, a, 0, f.RGBA, f.FLOAT, null);
					for (var k = b - h, w = k / d.COMPONENTS_PER_TEXEL, v = 0, g = new Float32Array(g),
							x = 0; x < a; x++) v = x * b, full_texel_row_end = v + k, v = new Float32Array(e.buffer, v * e.BYTES_PER_ELEMENT, k), 0 < k && f.texSubImage2D(f.TEXTURE_2D, 0, 0, x, w, 1, f.RGBA, f.FLOAT, v), v = new Float32Array(e.buffer, full_texel_row_end * e.BYTES_PER_ELEMENT, h), g.set(v), f.texSubImage2D(f.TEXTURE_2D, 0, w, x, 1, 1, f.RGBA, f.FLOAT, g)
				}
				f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, f.CLAMP_TO_EDGE);
				f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, f.CLAMP_TO_EDGE);
				f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, f.NEAREST);
				f.texParameteri(f.TEXTURE_2D,
					f.TEXTURE_MIN_FILTER, f.NEAREST);
				f.bindTexture(f.TEXTURE_2D, null);
				return l
			};
			d.prototype.createOutputTexture = function(a, b) {
				var d = this.context,
					e = this.getPad(b),
					f = d.createTexture();
				d.bindTexture(d.TEXTURE_2D, f);
				d.texImage2D(d.TEXTURE_2D, 0, d.RGBA, b + e, a, 0, d.RGBA, d.UNSIGNED_BYTE, null);
				d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE);
				d.texParameteri(d.TEXTURE_2D, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE);
				d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MAG_FILTER, d.NEAREST);
				d.texParameteri(d.TEXTURE_2D, d.TEXTURE_MIN_FILTER,
					d.NEAREST);
				d.bindTexture(d.TEXTURE_2D, null);
				return f
			};
			d.prototype.bindOutputTexture = function(a, b, d) {
				var e = this.context;
				this.canvas.height = a;
				this.canvas.width = b;
				e.viewport(0, 0, b, a);
				this.framebuffer = this.framebuffer || e.createFramebuffer();
				e.bindFramebuffer(e.FRAMEBUFFER, this.framebuffer);
				e.framebufferTexture2D(e.FRAMEBUFFER, e.COLOR_ATTACHMENT0, e.TEXTURE_2D, d, 0);
				if (e.checkFramebufferStatus(e.FRAMEBUFFER) != e.FRAMEBUFFER_COMPLETE) throw Error("Bound framebuffer is not complete.");
				return this.framebuffer
			};
			d.prototype.unbindInputTexture = function(a) {
				var b = this.context;
				b.activeTexture(a);
				b.bindTexture(b.TEXTURE_2D, null)
			};
			d.prototype.readData = function(a, b) {
				var d = this.context;
				rawbuffer = new ArrayBuffer(a * b * Float32Array.BYTES_PER_ELEMENT);
				prod = new Uint8Array(rawbuffer);
				d.readPixels(0, 0, b, a, d.RGBA, d.UNSIGNED_BYTE, prod);
				return rawbuffer
			};
			d.prototype.getPad = function(a) {
				a %= d.COMPONENTS_PER_TEXEL;
				return a = 0 == a ? 0 : d.COMPONENTS_PER_TEXEL - a
			}
		}, {}],
		13: [function(a, b, f) {
			f.load = function(a, b, d) {
				var e = new XMLHttpRequest;
				e.onreadystatechange = function() {
					if (4 === e.readyState)
						if (200 <= e.status && 300 > e.status) {
							var f = e.response;
							if (f) try {
								var g = new b(f);
								return d(null, g)
							} catch (r) {
								return d(r)
							} else return d("empty response")
						} else f = Error("failed to request file '" + a + "'"), f.errno = 34, d(f)
				};
				try {
					e.open("GET", a, !0), e.responseType = "arraybuffer", e.send(null)
				} catch (m) {
					d(m)
				}
			}
		}, {}],
		14: [function(b, e, f) {
			(function(b, d) {
				(function() {
					function f() {}

					function g(a) {
						return a
					}

					function h(a) {
						return !!a
					}

					function n(a) {
						return !a
					}

					function r(a) {
						return function() {
							if (null ===
								a) throw Error("Callback was already called.");
							a.apply(this, arguments);
							a = null
						}
					}

					function t(a) {
						return function() {
							null !== a && (a.apply(this, arguments), a = null)
						}
					}

					function u(a) {
						return Fa(a) || "number" === typeof a.length && 0 <= a.length && 0 === a.length % 1
					}

					function w(a, b) {
						for (var d = -1, e = a.length; ++d < e;) b(a[d], d, a)
					}

					function v(a, b) {
						for (var d = -1, e = a.length, f = Array(e); ++d < e;) f[d] = b(a[d], d, a);
						return f
					}

					function x(a) {
						return v(Array(a), function(a, b) {
							return b
						})
					}

					function y(a, b, d) {
						w(a, function(a, e, f) {
							d = b(d, a, e, f)
						});
						return d
					}

					function D(a,
						b) {
						w(Xa(a), function(d) {
							b(a[d], d)
						})
					}

					function z(a, b) {
						for (var d = 0; d < a.length; d++)
							if (a[d] === b) return d;
						return -1
					}

					function G(a) {
						var b = -1,
							d, e;
						if (u(a)) return d = a.length,
							function La() {
								b++;
								return b < d ? b : null
							};
						e = Xa(a);
						d = e.length;
						return function La() {
							b++;
							return b < d ? e[b] : null
						}
					}

					function A(a, b) {
						b = null == b ? a.length - 1 : +b;
						return function() {
							for (var d = Math.max(arguments.length - b, 0), e = Array(d), f = 0; f < d; f++) e[f] = arguments[f + b];
							switch (b) {
								case 0:
									return a.call(this, e);
								case 1:
									return a.call(this, arguments[0], e)
							}
						}
					}

					function H(a) {
						return function(b,
							d, e) {
							return a(b, e)
						}
					}

					function O(a) {
						return function(b, d, e) {
							e = t(e || f);
							b = b || [];
							var g = G(b);
							if (0 >= a) return e(null);
							var h = !1,
								k = 0,
								l = !1;
							(function Sa() {
								if (h && 0 >= k) return e(null);
								for (; k < a && !l;) {
									var f = g();
									if (null === f) {
										h = !0;
										0 >= k && e(null);
										break
									}
									k += 1;
									d(b[f], f, r(function(a) {
										--k;
										a ? (e(a), l = !0) : Sa()
									}))
								}
							})()
						}
					}

					function M(a) {
						return function(b, d, e) {
							return a(I.eachOf, b, d, e)
						}
					}

					function J(a) {
						return function(b, d, e, f) {
							return a(O(d), b, e, f)
						}
					}

					function P(a) {
						return function(b, d, e) {
							return a(I.eachOfSeries, b, d, e)
						}
					}

					function L(a, b, d,
						e) {
						e = t(e || f);
						b = b || [];
						var g = u(b) ? [] : {};
						a(b, function(a, b, e) {
							d(a, function(a, d) {
								g[b] = d;
								e(a)
							})
						}, function(a) {
							e(a, g)
						})
					}

					function Q(a, b, d, e) {
						var f = [];
						a(b, function(a, b, e) {
							d(a, function(d) {
								d && f.push({
									index: b,
									value: a
								});
								e()
							})
						}, function() {
							e(v(f.sort(function(a, b) {
								return a.index - b.index
							}), function(a) {
								return a.value
							}))
						})
					}

					function S(a, b, d, e) {
						Q(a, b, function(a, b) {
							d(a, function(a) {
								b(!a)
							})
						}, e)
					}

					function K(a, b, d) {
						return function(e, f, g, h) {
							function k() {
								h && h(d(!1, void 0))
							}

							function l(a, e, f) {
								if (!h) return f();
								g(a, function(e) {
									h &&
										b(e) && (h(d(!0, a)), h = g = !1);
									f()
								})
							}
							3 < arguments.length ? a(e, f, l, k) : (h = g, g = f, a(e, l, k))
						}
					}

					function X(a, b) {
						return b
					}

					function ba(a, b, d) {
						d = d || f;
						var e = u(b) ? [] : {};
						a(b, function(a, b, d) {
							a(A(function(a, f) {
								1 >= f.length && (f = f[0]);
								e[b] = f;
								d(a)
							}))
						}, function(a) {
							d(a, e)
						})
					}

					function ca(a, b, d, e) {
						var f = [];
						a(b, function(a, b, e) {
							d(a, function(a, b) {
								f = f.concat(b || []);
								e(a)
							})
						}, function(a) {
							e(a, f)
						})
					}

					function ia(a, b, d) {
						function e(a, b, d, e) {
							if (null != e && "function" !== typeof e) throw Error("task callback must be a function");
							a.started = !0;
							Fa(b) ||
								(b = [b]);
							if (0 === b.length && a.idle()) return I.setImmediate(function() {
								a.drain()
							});
							w(b, function(b) {
								b = {
									data: b,
									callback: e || f
								};
								d ? a.tasks.unshift(b) : a.tasks.push(b);
								a.tasks.length === a.concurrency && a.saturated()
							});
							I.setImmediate(a.process)
						}

						function g(a, b) {
							return function() {
								--h;
								var d = !1,
									e = arguments;
								w(b, function(a) {
									w(k, function(b, e) {
										b !== a || d || (k.splice(e, 1), d = !0)
									});
									a.callback.apply(a, e)
								});
								0 === a.tasks.length + h && a.drain();
								a.process()
							}
						}
						if (null == b) b = 1;
						else if (0 === b) throw Error("Concurrency must not be zero");
						var h =
							0,
							k = [],
							l = {
								tasks: [],
								concurrency: b,
								payload: d,
								saturated: f,
								empty: f,
								drain: f,
								started: !1,
								paused: !1,
								push: function(a, b) {
									e(l, a, !1, b)
								},
								kill: function() {
									l.drain = f;
									l.tasks = []
								},
								unshift: function(a, b) {
									e(l, a, !0, b)
								},
								process: function() {
									for (; !l.paused && h < l.concurrency && l.tasks.length;) {
										var b = l.payload ? l.tasks.splice(0, l.payload) : l.tasks.splice(0, l.tasks.length),
											d = v(b, function(a) {
												return a.data
											});
										0 === l.tasks.length && l.empty();
										h += 1;
										k.push(b[0]);
										b = r(g(l, b));
										a(d, b)
									}
								},
								length: function() {
									return l.tasks.length
								},
								running: function() {
									return h
								},
								workersList: function() {
									return k
								},
								idle: function() {
									return 0 === l.tasks.length + h
								},
								pause: function() {
									l.paused = !0
								},
								resume: function() {
									if (!1 !== l.paused) {
										l.paused = !1;
										for (var a = Math.min(l.concurrency, l.tasks.length), b = 1; b <= a; b++) I.setImmediate(l.process)
									}
								}
							};
						return l
					}

					function Y(a) {
						return A(function(b, d) {
							b.apply(null, d.concat([A(function(b, d) {
								"object" === typeof console && (b ? console.error && console.error(b) : console[a] && w(d, function(b) {
									console[a](b)
								}))
							})]))
						})
					}

					function ha(a) {
						return function(b, d, e) {
							a(x(b), d, e)
						}
					}

					function Z(a) {
						return A(function(b,
							d) {
							var e = A(function(d) {
								var e = this,
									f = d.pop();
								return a(b, function(a, b, f) {
									a.apply(e, d.concat([f]))
								}, f)
							});
							return d.length ? e.apply(this, d) : e
						})
					}

					function aa(a) {
						return A(function(b) {
							var d = b.pop();
							b.push(function() {
								var a = arguments;
								e ? I.setImmediate(function() {
									d.apply(null, a)
								}) : d.apply(null, a)
							});
							var e = !0;
							a.apply(this, b);
							e = !1
						})
					}
					var I = {},
						ma, ka = "object" === typeof self && self.self === self && self || "object" === typeof d && d.global === d && d || this;
					null != ka && (ma = ka.async);
					I.noConflict = function() {
						ka.async = ma;
						return I
					};
					var oa =
						Object.prototype.toString,
						Fa = Array.isArray || function(a) {
							return "[object Array]" === oa.call(a)
						},
						Pa = function(a) {
							var b = typeof a;
							return "function" === b || "object" === b && !!a
						},
						Xa = Object.keys || function(a) {
							var b = [],
								d;
							for (d in a) a.hasOwnProperty(d) && b.push(d);
							return b
						},
						Ba = "function" === typeof setImmediate && setImmediate,
						Qa = Ba ? function(a) {
							Ba(a)
						} : function(a) {
							setTimeout(a, 0)
						};
					I.nextTick = "object" === typeof b && "function" === typeof b.nextTick ? b.nextTick : Qa;
					I.setImmediate = Ba ? Qa : I.nextTick;
					I.forEach = I.each = function(a, b, d) {
						return I.eachOf(a,
							H(b), d)
					};
					I.forEachSeries = I.eachSeries = function(a, b, d) {
						return I.eachOfSeries(a, H(b), d)
					};
					I.forEachLimit = I.eachLimit = function(a, b, d, e) {
						return O(b)(a, H(d), e)
					};
					I.forEachOf = I.eachOf = function(a, b, d) {
						function e(a) {
							k--;
							a ? d(a) : null === h && 0 >= k && d(null)
						}
						d = t(d || f);
						a = a || [];
						for (var g = G(a), h, k = 0; null != (h = g());) k += 1, b(a[h], h, r(e));
						0 === k && d(null)
					};
					I.forEachOfSeries = I.eachOfSeries = function(a, b, d) {
						function e() {
							var f = !0;
							if (null === h) return d(null);
							b(a[h], h, r(function(a) {
								if (a) d(a);
								else {
									h = g();
									if (null === h) return d(null);
									f ?
										I.setImmediate(e) : e()
								}
							}));
							f = !1
						}
						d = t(d || f);
						a = a || [];
						var g = G(a),
							h = g();
						e()
					};
					I.forEachOfLimit = I.eachOfLimit = function(a, b, d, e) {
						O(b)(a, d, e)
					};
					I.map = M(L);
					I.mapSeries = P(L);
					I.mapLimit = J(L);
					I.inject = I.foldl = I.reduce = function(a, b, d, e) {
						I.eachOfSeries(a, function(a, e, f) {
							d(b, a, function(a, d) {
								b = d;
								f(a)
							})
						}, function(a) {
							e(a, b)
						})
					};
					I.foldr = I.reduceRight = function(a, b, d, e) {
						a = v(a, g).reverse();
						I.reduce(a, b, d, e)
					};
					I.transform = function(a, b, d, e) {
						3 === arguments.length && (e = d, d = b, b = Fa(a) ? [] : {});
						I.eachOf(a, function(a, e, f) {
								d(b, a, e, f)
							},
							function(a) {
								e(a, b)
							})
					};
					I.select = I.filter = M(Q);
					I.selectLimit = I.filterLimit = J(Q);
					I.selectSeries = I.filterSeries = P(Q);
					I.reject = M(S);
					I.rejectLimit = J(S);
					I.rejectSeries = P(S);
					I.any = I.some = K(I.eachOf, h, g);
					I.someLimit = K(I.eachOfLimit, h, g);
					I.all = I.every = K(I.eachOf, n, n);
					I.everyLimit = K(I.eachOfLimit, n, n);
					I.detect = K(I.eachOf, g, X);
					I.detectSeries = K(I.eachOfSeries, g, X);
					I.detectLimit = K(I.eachOfLimit, g, X);
					I.sortBy = function(a, b, d) {
						function e(a, b) {
							a = a.criteria;
							b = b.criteria;
							return a < b ? -1 : a > b ? 1 : 0
						}
						I.map(a, function(a, d) {
							b(a,
								function(b, e) {
									b ? d(b) : d(null, {
										value: a,
										criteria: e
									})
								})
						}, function(a, b) {
							if (a) return d(a);
							d(null, v(b.sort(e), function(a) {
								return a.value
							}))
						})
					};
					I.auto = function(a, b, d) {
						function e() {
							h--;
							w(n.slice(0), function(a) {
								a()
							})
						}
						"function" === typeof b && (d = b, b = null);
						d = t(d || f);
						var g = Xa(a),
							h = g.length;
						if (!h) return d(null);
						b || (b = h);
						var k = {},
							l = 0,
							m = !1,
							n = [];
						n.unshift(function() {
							h || d(null, k)
						});
						w(g, function(f) {
							function g() {
								return l < b && y(u, function(a, b) {
									return a && k.hasOwnProperty(b)
								}, !0) && !k.hasOwnProperty(f)
							}

							function h() {
								if (g()) {
									l++;
									var a = z(n, h);
									0 <= a && n.splice(a, 1);
									r[r.length - 1](t, k)
								}
							}
							if (!m) {
								for (var r = Fa(a[f]) ? a[f] : [a[f]], t = A(function(a, b) {
										l--;
										1 >= b.length && (b = b[0]);
										if (a) {
											var g = {};
											D(k, function(a, b) {
												g[b] = a
											});
											g[f] = b;
											m = !0;
											d(a, g)
										} else k[f] = b, I.setImmediate(e)
									}), u = r.slice(0, r.length - 1), v = u.length, w; v--;) {
									if (!(w = a[u[v]])) throw Error("Has nonexistent dependency in " + u.join(", "));
									if (Fa(w) && 0 <= z(w, f)) throw Error("Has cyclic dependencies");
								}
								g() ? (l++, r[r.length - 1](t, k)) : n.unshift(h)
							}
						})
					};
					I.retry = function(a, b, d) {
						function e(a, b) {
							if ("number" ===
								typeof b) a.times = parseInt(b, 10) || 5;
							else if ("object" === typeof b) a.times = parseInt(b.times, 10) || 5, a.interval = parseInt(b.interval, 10) || 0;
							else throw Error("Unsupported argument type for 'times': " + typeof b);
						}

						function f(a, b) {
							function d(a, d) {
								return function(e) {
									a(function(a, b) {
										e(!a || d, {
											err: a,
											result: b
										})
									}, b)
								}
							}

							function e(a) {
								return function(b) {
									setTimeout(function() {
										b(null)
									}, a)
								}
							}
							for (; h.times;) {
								var f = !--h.times;
								g.push(d(h.task, f));
								!f && 0 < h.interval && g.push(e(h.interval))
							}
							I.series(g, function(b, d) {
								d = d[d.length - 1];
								(a || h.callback)(d.err, d.result)
							})
						}
						var g = [],
							h = {
								times: 5,
								interval: 0
							},
							k = arguments.length;
						if (1 > k || 3 < k) throw Error("Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)");
						2 >= k && "function" === typeof a && (d = b, b = a);
						"function" !== typeof a && e(h, a);
						h.callback = d;
						h.task = b;
						return h.callback ? f() : f
					};
					I.waterfall = function(a, b) {
						function d(a) {
							return A(function(e, f) {
								e ? b.apply(null, [e].concat(f)) : ((e = a.next()) ? f.push(d(e)) : f.push(b), aa(a).apply(null, f))
							})
						}
						b = t(b || f);
						if (!Fa(a)) return a =
							Error("First argument to waterfall must be an array of functions"), b(a);
						if (!a.length) return b();
						d(I.iterator(a))()
					};
					I.parallel = function(a, b) {
						ba(I.eachOf, a, b)
					};
					I.parallelLimit = function(a, b, d) {
						ba(O(b), a, d)
					};
					I.series = function(a, b) {
						ba(I.eachOfSeries, a, b)
					};
					I.iterator = function(a) {
						function b(d) {
							function e() {
								a.length && a[d].apply(null, arguments);
								return e.next()
							}
							e.next = function() {
								return d < a.length - 1 ? b(d + 1) : null
							};
							return e
						}
						return b(0)
					};
					I.apply = A(function(a, b) {
						return A(function(d) {
							return a.apply(null, b.concat(d))
						})
					});
					I.concat = M(ca);
					I.concatSeries = P(ca);
					I.whilst = function(a, b, d) {
						d = d || f;
						if (a()) {
							var e = A(function(f, g) {
								f ? d(f) : a.apply(this, g) ? b(e) : d.apply(null, [null].concat(g))
							});
							b(e)
						} else d(null)
					};
					I.doWhilst = function(a, b, d) {
						var e = 0;
						return I.whilst(function() {
							return 1 >= ++e || b.apply(this, arguments)
						}, a, d)
					};
					I.until = function(a, b, d) {
						return I.whilst(function() {
							return !a.apply(this, arguments)
						}, b, d)
					};
					I.doUntil = function(a, b, d) {
						return I.doWhilst(a, function() {
							return !b.apply(this, arguments)
						}, d)
					};
					I.during = function(a, b, d) {
						d = d || f;
						var e =
							A(function(b, e) {
								b ? d(b) : (e.push(g), a.apply(this, e))
							}),
							g = function(a, f) {
								a ? d(a) : f ? b(e) : d(null)
							};
						a(g)
					};
					I.doDuring = function(a, b, d) {
						var e = 0;
						I.during(function(a) {
							1 > e++ ? a(null, !0) : b.apply(this, arguments)
						}, a, d)
					};
					I.queue = function(a, b) {
						return b = ia(function(b, d) {
							a(b[0], d)
						}, b, 1)
					};
					I.priorityQueue = function(a, b) {
						function d(a, b) {
							return a.priority - b.priority
						}

						function e(a, b, d) {
							for (var e = -1, f = a.length - 1; e < f;) {
								var g = e + (f - e + 1 >>> 1);
								0 <= d(b, a[g]) ? e = g : f = g - 1
							}
							return e
						}

						function g(a, b, g, h) {
							if (null != h && "function" !== typeof h) throw Error("task callback must be a function");
							a.started = !0;
							Fa(b) || (b = [b]);
							if (0 === b.length) return I.setImmediate(function() {
								a.drain()
							});
							w(b, function(b) {
								b = {
									data: b,
									priority: g,
									callback: "function" === typeof h ? h : f
								};
								a.tasks.splice(e(a.tasks, b, d) + 1, 0, b);
								a.tasks.length === a.concurrency && a.saturated();
								I.setImmediate(a.process)
							})
						}
						var h = I.queue(a, b);
						h.push = function(a, b, d) {
							g(h, a, b, d)
						};
						delete h.unshift;
						return h
					};
					I.cargo = function(a, b) {
						return ia(a, 1, b)
					};
					I.log = Y("log");
					I.dir = Y("dir");
					I.memoize = function(a, b) {
						var d = {},
							e = {},
							f = Object.prototype.hasOwnProperty;
						b = b ||
							g;
						var h = A(function ub(g) {
							var h = g.pop(),
								k = b.apply(null, g);
							f.call(d, k) ? I.setImmediate(function() {
								h.apply(null, d[k])
							}) : f.call(e, k) ? e[k].push(h) : (e[k] = [h], a.apply(null, g.concat([A(function(a) {
								d[k] = a;
								var b = e[k];
								delete e[k];
								for (var f = 0, g = b.length; f < g; f++) b[f].apply(null, a)
							})])))
						});
						h.memo = d;
						h.unmemoized = a;
						return h
					};
					I.unmemoize = function(a) {
						return function() {
							return (a.unmemoized || a).apply(null, arguments)
						}
					};
					I.times = ha(I.map);
					I.timesSeries = ha(I.mapSeries);
					I.timesLimit = function(a, b, d, e) {
						return I.mapLimit(x(a),
							b, d, e)
					};
					I.seq = function() {
						var a = arguments;
						return A(function(b) {
							var d = this,
								e = b[b.length - 1];
							"function" == typeof e ? b.pop() : e = f;
							I.reduce(a, b, function(a, b, e) {
								b.apply(d, a.concat([A(function(a, b) {
									e(a, b)
								})]))
							}, function(a, b) {
								e.apply(d, [a].concat(b))
							})
						})
					};
					I.compose = function() {
						return I.seq.apply(null, Array.prototype.reverse.call(arguments))
					};
					I.applyEach = Z(I.eachOf);
					I.applyEachSeries = Z(I.eachOfSeries);
					I.forever = function(a, b) {
						function d(a) {
							if (a) return e(a);
							g(d)
						}
						var e = r(b || f),
							g = aa(a);
						d()
					};
					I.ensureAsync = aa;
					I.constant =
						A(function(a) {
							var b = [null].concat(a);
							return function(a) {
								return a.apply(this, b)
							}
						});
					I.wrapSync = I.asyncify = function Ua(a) {
						return A(function(b) {
							var d = b.pop(),
								e;
							try {
								e = a.apply(this, b)
							} catch (Ia) {
								return d(Ia)
							}
							if (Pa(e) && "function" === typeof e.then) e.then(function(a) {
								d(null, a)
							})["catch"](function(a) {
								d(a.message ? a : Error(a))
							});
							else d(null, e)
						})
					};
					"object" === typeof e && e.exports ? e.exports = I : "function" === typeof a && a.amd ? a([], function() {
						return I
					}) : ka.async = I
				})()
			}).call(this, b("_process"), "undefined" !== typeof global ?
				global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {})
		}, {
			_process: 15
		}],
		15: [function(a, b, f) {
			function d() {
				n = !1;
				r.length ? m = r.concat(m) : t = -1;
				m.length && e()
			}

			function e() {
				if (!n) {
					var a = setTimeout(d);
					n = !0;
					for (var b = m.length; b;) {
						r = m;
						for (m = []; ++t < b;) r && r[t].run();
						t = -1;
						b = m.length
					}
					r = null;
					n = !1;
					clearTimeout(a)
				}
			}

			function k(a, b) {
				this.fun = a;
				this.array = b
			}

			function l() {}
			a = b.exports = {};
			var m = [],
				n = !1,
				r, t = -1;
			a.nextTick = function(a) {
				var b = Array(arguments.length - 1);
				if (1 < arguments.length)
					for (var d = 1; d <
						arguments.length; d++) b[d - 1] = arguments[d];
				m.push(new k(a, b));
				1 !== m.length || n || setTimeout(e, 0)
			};
			k.prototype.run = function() {
				this.fun.apply(null, this.array)
			};
			a.title = "browser";
			a.browser = !0;
			a.env = {};
			a.argv = [];
			a.version = "";
			a.versions = {};
			a.on = l;
			a.addListener = l;
			a.once = l;
			a.off = l;
			a.removeListener = l;
			a.removeAllListeners = l;
			a.emit = l;
			a.binding = function(a) {
				throw Error("process.binding is not supported");
			};
			a.cwd = function() {
				return "/"
			};
			a.chdir = function(a) {
				throw Error("process.chdir is not supported");
			};
			a.umask = function() {
				return 0
			}
		}, {}]
	}, {}, [1])(1)
});
var Nm = {
	javascript: {}
};
Nm.javascript.typescript = {};
Nm.javascript.typescript.compiler = {};
Nm.javascript.typescript.compiler.helpers = {};
var Om;
Om = "undefined" !== typeof window ? window : "undefined" !== typeof self ? self : global;

function __extends(a, b) {
	function c() {
		this.constructor = a
	}
	for (var d in b) b.hasOwnProperty(d) && (a[d] = b[d]);
	a.prototype = null === b ? Object.create(b) : (c.prototype = b.prototype, new c)
}

function __decorate(a, b, c, d) {
	var e = arguments.length,
		f = 3 > e ? b : null === d ? d = Object.getOwnPropertyDescriptor(b, c) : d,
		g;
	g = Om.Reflect;
	if ("object" === typeof g && "function" === typeof g.decorate) f = g.decorate(a, b, c, d);
	else
		for (var h = a.length - 1; 0 <= h; h--)
			if (g = a[h]) f = (3 > e ? g(f) : 3 < e ? g(b, c, f) : g(b, c)) || f; return 3 < e && f && Object.defineProperty(b, c, f), f
}

function __metadata(a, b) {
	var c = Om.Reflect;
	if ("object" === typeof c && "function" === typeof c.metadata) return c.metadata(a, b)
}
var __param = function(a, b) {
		return function(c, d) {
			b(c, d, a)
		}
	},
	__awaiter = function(a, b, c, d) {
		return new(c || (c = Promise))(function(e, f) {
			function g(a) {
				try {
					k(d.next(a))
				} catch (m) {
					f(m)
				}
			}

			function h(a) {
				try {
					k(d.throw(a))
				} catch (m) {
					f(m)
				}
			}

			function k(a) {
				a.done ? e(a.value) : (new c(function(b) {
					b(a.value)
				})).then(g, h)
			}
			k((d = d.apply(a, b)).next())
		})
	};
"undefined" !== typeof Om.COMPILED && Om.COMPILED || (Om.__extends = __extends, Om.__decorate = __decorate, Om.__metadata = __metadata, Om.__param = __param, Om.__awaiter = __awaiter);
var Pm = {},
	Qm = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/analyticsLogger"
	},
	Rm = function(a, b) {
		"undefined" === typeof ga || null == ga ? this.pageViewLogging = this.eventLogging = !1 : (this.eventLogging = b, this.pageViewLogging = a)
	};
Rm.prototype.logPageView = function(a) {
	this.pageViewLogging && ga("send", {
		hitType: "pageview",
		page: "/v/" + a
	})
};
Rm.prototype.logProjectionChanged = function(a) {
	this.eventLogging && ga("send", {
		hitType: "event",
		eventCategory: "Projection",
		eventAction: "click",
		eventLabel: a
	})
};
Rm.prototype.logWebGLDisabled = function() {
	this.eventLogging && ga("send", {
		hitType: "event",
		eventCategory: "Error",
		eventAction: "PageLoad",
		eventLabel: "WebGL_disabled"
	})
};
Pm.AnalyticsLogger = Rm;

function Sm() {};
var Tm = {},
	Um = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/sptree"
	},
	Wm = function(a) {
		if (1 > a.length) throw Error("There should be at least 1 data point");
		this.dim = a[0].length;
		this.masks = Array(Math.pow(2, this.dim));
		for (var b = 0; b < this.masks.length; ++b) this.masks[b] = 1 << b;
		b = Array(this.dim);
		Vm(b, Number.POSITIVE_INFINITY);
		var c = Array(this.dim);
		Vm(c, Number.NEGATIVE_INFINITY);
		for (var d = 0; d < a.length; ++d)
			for (var e = 0; e < this.dim; ++e) b[e] = Math.min(b[e], a[d][e]), c[e] = Math.max(c[e], a[d][e]);
		for (var d =
				Array(this.dim), f = e = 0; f < this.dim; ++f) {
			var g = c[f] - b[f];
			d[f] = b[f] + g / 2;
			e = Math.max(e, g / 2)
		}
		this.root = {
			box: {
				center: d,
				halfDim: e
			},
			point: a[0]
		};
		for (b = 1; b < a.length; ++b) this.insert(this.root, a[b])
	};
Wm.prototype.visit = function(a, b) {
	b = void 0 === b ? !1 : b;
	this.visitNode(this.root, a, b)
};
Wm.prototype.visitNode = function(a, b, c) {
	var d;
	if (c) d = b(a);
	else {
		d = Array(this.dim);
		for (var e = Array(this.dim), f = 0; f < this.dim; ++f) d[f] = a.box.center[f] - a.box.halfDim, e[f] = a.box.center[f] + a.box.halfDim;
		d = b(a, d, e)
	}
	if (a.children && !d)
		for (d = 0; d < a.children.length; ++d)(e = a.children[d]) && this.visitNode(e, b, c)
};
Wm.prototype.insert = function(a, b) {
	null == a.children && (a.children = Array(this.masks.length));
	for (var c = 0, d = 0; d < this.dim; ++d) b[d] > a.box.center[d] && (c |= this.masks[d]);
	null == a.children[c] ? this.makeChild(a, c, b) : this.insert(a.children[c], b)
};
Wm.prototype.makeChild = function(a, b, c) {
	for (var d = a.box.center, e = a.box.halfDim / 2, f = Array(this.dim), g = 0; g < this.dim; ++g) f[g] = b & 1 << g ? d[g] + e : d[g] - e;
	a.children[b] = {
		box: {
			center: f,
			halfDim: e
		},
		point: c
	}
};
Tm.SPTree = Wm;

function Xm() {}

function Vm(a, b) {
	for (var c = 0; c < a.length; ++c) a[c] = b
};
var Ym = {},
	Zm = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/bh_tsne"
	},
	$m = !1,
	an = 0;

function bn(a, b) {
	if (a.length !== b.length) throw Error("Vectors a and b must be of same length");
	for (var c = 0, d = 0; d < a.length; ++d) var e = a[d] - b[d],
		c = c + e * e;
	return c
}
Ym.dist2 = bn;

function cn(a, b) {
	var c = a[0] - b[0];
	a = a[1] - b[1];
	return c * c + a * a
}
Ym.dist2_2D = cn;

function dn(a, b) {
	var c = a[0] - b[0],
		d = a[1] - b[1];
	a = a[2] - b[2];
	return c * c + d * d + a * a
}
Ym.dist2_3D = dn;

function en(a) {
	if ($m) return $m = !1, an;
	var b = 2 * a() - 1,
		c = 2 * a() - 1,
		d = b * b + c * c;
	if (0 === d || 1 < d) return en(a);
	a = Math.sqrt(-2 * Math.log(d) / d);
	an = c * a;
	$m = !0;
	return b * a
}

function fn(a, b, c) {
	return b + en(a) * c
}

function gn(a) {
	return new Float64Array(a)
}

function hn(a, b, c) {
	a *= b;
	b = gn(a);
	for (var d = 0; d < a; ++d) b[d] = fn(c, 0, 1E-4);
	return b
}

function jn(a, b, c) {
	for (var d = [], e = 0; e < a; ++e) d.push(3 === b ? [c, c, c] : [c, c]);
	return d
}

function kn(a, b, c) {
	var d = a.length,
		e = Math.log(b);
	b = gn(d * d);
	for (var f = a[0].length, f = Array(f), g = 0; g < d; ++g) {
		for (var h = a[g], k = -Infinity, l = Infinity, m = 1, n = 50, r = 0;;) {
			for (var t = 0, u = 0; u < h.length; ++u) {
				var w = h[u],
					w = g === w.index ? 0 : Math.exp(-w.dist * m),
					w = Math.max(w, 1E-9);
				f[u] = w;
				t += w
			}
			for (w = u = 0; w < f.length; ++w) {
				f[w] /= t;
				var v = f[w];
				1E-7 < v && (u -= v * Math.log(v))
			}
			u > e ? (k = m, m = Infinity === l ? 2 * m : (m + l) / 2) : (l = m, m = -Infinity === k ? m / 2 : (m + k) / 2);
			r++;
			if (r >= n || Math.abs(u - e) < c) break
		}
		for (k = 0; k < f.length; ++k) l = f[k], m = h[k].index, b[g * d + m] = l
	}
	a =
		2 * d;
	for (c = 0; c < d; ++c)
		for (e = c + 1; e < d; ++e) f = c * d + e, g = e * d + c, h = (b[f] + b[g]) / a, b[f] = h, b[g] = h;
	return b
}

function ln(a) {
	return 0 < a ? 1 : 0 > a ? -1 : 0
}

function mn(a, b, c, d) {
	a[0] += b * (c[0] - d[0]);
	a[1] += b * (c[1] - d[1])
}

function nn(a, b, c, d) {
	a[0] += b * (c[0] - d[0]);
	a[1] += b * (c[1] - d[1]);
	a[2] += b * (c[2] - d[2])
}
var on = function(a) {
	this.iter = 0;
	a = a || {
		dim: 2
	};
	this.perplexity = a.perplexity || 30;
	this.epsilon = a.epsilon || 10;
	this.rng = a.rng || Math.random;
	this.dim = a.dim;
	if (2 === a.dim) this.dist2 = cn, this.computeForce = mn;
	else if (3 === a.dim) this.dist2 = dn, this.computeForce = nn;
	else throw Error("Only 2D and 3D is supported");
};
q = on.prototype;
q.initDataDist = function(a) {
	var b = a.length;
	this.nearest = a;
	this.P = kn(a, this.perplexity, 1E-4);
	this.N = b;
	this.initSolution()
};
q.initSolution = function() {
	this.Y = hn(this.N, this.dim, this.rng);
	this.gains = jn(this.N, this.dim, 1);
	this.ystep = jn(this.N, this.dim, 0);
	this.iter = 0
};
q.getSolution = function() {
	return this.Y
};
q.step = function() {
	this.iter += 1;
	for (var a = this.N, b = this.costGrad(this.Y), c = 3 === this.dim ? [0, 0, 0] : [0, 0], d = 0; d < a; ++d)
		for (var e = 0; e < this.dim; ++e) {
			var f = b[d][e],
				g = this.ystep[d][e],
				h = this.gains[d][e],
				f = ln(f) === ln(g) ? .8 * h : h + .2;
			.01 > f && (f = .01);
			this.gains[d][e] = f;
			h = 250 > this.iter ? .5 : .8;
			g = h * g - this.epsilon * f * b[d][e];
			this.ystep[d][e] = g;
			f = d * this.dim + e;
			this.Y[f] += g;
			c[e] += this.Y[f]
		}
	for (b = 0; b < a; ++b)
		for (d = 0; d < this.dim; ++d) this.Y[b * this.dim + d] -= c[d] / a
};
q.costGrad = function(a) {
	for (var b = this, c = this.N, d = this.P, e = 100 > this.iter ? 4 : 1, f = Array(c), g = 0; g < c; ++g) {
		for (var h = g * this.dim, k = Array(this.dim), l = 0; l < this.dim; ++l) k[l] = a[h + l];
		f[g] = k
	}
	h = new Wm(f);
	a = h.root;
	var m = function(a) {
		var c = 1;
		if (null == a.children) return a.numCells = c, a.yCell = a.point, {
			numCells: c,
			yCell: a.yCell
		};
		for (var d = a.point.slice(), e = 0; e < a.children.length; ++e) {
			var f = a.children[e];
			if (null != f)
				for (var f = m(f), c = c + f.numCells, g = 0; g < b.dim; ++g) d[g] += f.yCell[g]
		}
		a.numCells = c;
		a.yCell = d.map(function(a) {
			return a /
				c
		});
		return {
			numCells: c,
			yCell: d
		}
	};
	m(a);
	h.visit(function(a, b, c) {
		a.rCell = c[0] - b[0];
		return !1
	});
	a = [];
	for (var n = 0, g = Array(c), k = {}, l = 0; l < c; k = {
			pointI: k.pointI,
			FnegZ: k.FnegZ
		}, ++l) {
		k.pointI = f[l];
		for (var r = 3 === this.dim ? [0, 0, 0] : [0, 0], t = this.nearest[l], u = 0; u < t.length; ++u) {
			var w = t[u].index,
				v = d[l * c + w],
				w = f[w],
				x = this.dist2(k.pointI, w),
				v = v / (1 + x);
			this.computeForce(r, v, k.pointI, w)
		}
		k.FnegZ = 3 === this.dim ? [0, 0, 0] : [0, 0];
		h.visit(function(a) {
			return function(c) {
				var d = b.dist2(a.pointI, c.yCell);
				if (null == c.children || 0 < d && .8 > c.rCell /
					Math.sqrt(d)) {
					var d = 1 / (1 + d),
						e = c.numCells * d;
					n += e;
					e *= d;
					b.computeForce(a.FnegZ, e, a.pointI, c.yCell);
					return !0
				}
				d = b.dist2(a.pointI, c.point);
				d = 1 / (1 + d);
				n += d;
				d *= d;
				b.computeForce(a.FnegZ, d, a.pointI, c.point);
				return !1
			}
		}(k), !0);
		g[l] = [r, k.FnegZ]
	}
	d = 4 * e;
	e = 4 / n;
	for (f = 0; f < c; ++f) {
		k = F.makeIterator(g[f]);
		h = k.next().value;
		k = k.next().value;
		l = Array(this.dim);
		for (r = 0; r < this.dim; ++r) l[r] = d * h[r] - e * k[r];
		a.push(l)
	}
	return a
};
Ym.TSNE = on;

function pn() {};
var qn = {},
	rn = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/logging"
	},
	sn = null,
	tn = 0,
	un = 0;

function vn(a) {
	sn = a
}
qn.setDomContainer = vn;

function wn(a, b, c, d) {
	b = void 0 === b ? null : b;
	c = void 0 === c ? null : c;
	d = void 0 === d ? !1 : d;
	if (null == sn) console.warn("Can't show modal message before the dom is initialized");
	else {
		null == b && (b = (tn++).toString());
		var e = sn.querySelector("#notification-dialog");
		e.querySelector(".close-button").style.display = d ? null : "none";
		var f = e.querySelector(".progress");
		f.style.display = d ? "none" : null;
		f.active = d ? null : !0;
		e.querySelector("#notification-title").innerHTML = c;
		c = e.querySelector("#notify-msgs");
		d ? d3.select(c).html("") : d3.select(c).selectAll(".error").remove();
		var f = "notify-msg-" + b,
			g = d3.select(e.querySelector("#" + f)),
			h = 0 < g.size();
		h || (g = d3.select(c).insert("div", ":first-child").attr("class", "notify-msg").classed("error", d).attr("id", f), d ? un = 0 : un++);
		null == a ? (un--, 0 === un && e.close(), g.remove()) : (g.text(a), e.open());
		return b
	}
}
qn.setModalMessage = wn;

function xn(a, b) {
	wn(a, null, "Error " + (null != b ? b : ""), !0)
}
qn.setErrorMessage = xn;

function yn(a) {
	var b = sn.querySelector("#toast");
	b.text = a;
	b.duration = 1E4;
	b.open()
}
qn.setWarningMessage = yn;
var zn = {},
	An = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/util"
	};

function Bn(a) {
	for (var b = a.length, c, d; b;) d = Math.floor(Math.random() * b--), c = a[b], a[b] = a[d], a[d] = c;
	return a
}
zn.shuffle = Bn;

function Cn(a, b, c, d) {
	var e = window.devicePixelRatio;
	a = (new THREE.Vector3).copy(d).project(a);
	return b = [(a.x + 1) / 2 * b * e, -((a.y - 1) / 2 * c) * e]
}
zn.vector3DToScreenCoords = Cn;

function Dn(a, b) {
	b *= 3;
	return new THREE.Vector3(a[b], a[b + 1], a[b + 2])
}
zn.vector3FromPackedArray = Dn;

function En(a, b, c) {
	var d = Infinity,
		e = 0;
	c = (new THREE.Vector3).copy(c).sub(b);
	c = (new THREE.Vector3).copy(c).normalize();
	for (var f = a.length / 3, g = 0, h = new THREE.Vector3, k = new THREE.Vector3, l = 0; l < f; l++) {
		h.x = a[g];
		h.y = a[g + 1];
		h.z = a[g + 2];
		g += 3;
		k.copy(h).sub(b);
		var m = c.dot(k);
		0 > m || (e = m > e ? m : e, d = m < d ? m : d)
	}
	return [d, e]
}
zn.getNearFarPoints = En;

function Fn(a) {
	a = new THREE.Texture(a);
	a.needsUpdate = !0;
	a.minFilter = THREE.LinearFilter;
	a.generateMipmaps = !1;
	a.flipY = !1;
	return a
}
zn.createTexture = Fn;

function Gn(a, b) {
	if (!a) throw b = b || "Assertion failed", Error(b);
}
zn.assert = Gn;

function Hn(a, b, c) {
	if (b) {
		var d = new RegExp(a, "i");
		b = function(a) {
			return d.test(a.metadata[c].toString())
		}
	} else a = a.toLowerCase(), b = function(b) {
		b = b.metadata[c].toString().toLowerCase();
		return 0 <= b.indexOf(a)
	};
	return b
}
zn.getSearchPredicate = Hn;

function In(a, b, c) {
	c = void 0 === c ? null : c;
	var d = null == c;
	c = wn(a, c);
	return new Promise(function(a, f) {
		d3.timer(function() {
			try {
				var e = b();
				d && wn(null, c);
				a(e)
			} catch (h) {
				f(h)
			}
			return !0
		}, 200)
	})
}
zn.runAsyncTask = In;

function Jn(a) {
	if (!a) return {};
	a = -1 !== a.indexOf("?") ? a.split("?")[1] : a;
	a.indexOf("#") && (a = a.split("#")[0]);
	a = a.split("&");
	for (var b = {}, c = 0; c < a.length; c++) {
		var d = a[c].split("=");
		b[d[0].toLowerCase()] = decodeURIComponent(d[1])
	}
	return b
}
zn.getURLParams = Jn;
var Kn = ["/Adagrad"];

function Ln(a) {
	for (var b = 0; b < Kn.length; b++)
		if (0 <= a.indexOf(Kn[b])) return !0;
	return !1
}
zn.tensorIsGenerated = Ln;

function Mn(a, b) {
	return (a || b) && !(a && b)
}
zn.xor = Mn;

function Nn() {
	try {
		var a = document.createElement("canvas"),
			b = a.getContext("webgl") || a.getContext("experimental-webgl");
		return null != b && "undefined" !== typeof weblas
	} catch (c) {
		return !1
	}
}
zn.hasWebGLSupport = Nn;
var On = {},
	Pn = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/heap"
	},
	Qn = function() {
		this.arr = []
	};
q = Qn.prototype;
q.push = function(a, b) {
	this.arr.push({
		key: a,
		value: b
	});
	this.bubbleUp(this.arr.length - 1)
};
q.pop = function() {
	if (0 === this.arr.length) throw Error("pop() called on empty binary heap");
	var a = this.arr[0],
		b = this.arr.length - 1;
	this.arr[0] = this.arr[b];
	this.arr.pop();
	0 < b && this.bubbleDown(0);
	return a
};
q.peek = function() {
	return this.arr[0]
};
q.popPush = function(a, b) {
	if (0 === this.arr.length) throw Error("pop() called on empty binary heap");
	var c = this.arr[0];
	this.arr[0] = {
		key: a,
		value: b
	};
	0 < this.arr.length && this.bubbleDown(0);
	return c
};
q.size = function() {
	return this.arr.length
};
q.items = function() {
	return this.arr
};
q.swap = function(a, b) {
	var c = this.arr[a];
	this.arr[a] = this.arr[b];
	this.arr[b] = c
};
q.bubbleDown = function(a) {
	var b = (a << 1) + 1,
		c = b + 1,
		d = a;
	b < this.arr.length && this.arr[b].key < this.arr[d].key && (d = b);
	c < this.arr.length && this.arr[c].key < this.arr[d].key && (d = c);
	d !== a && (this.swap(d, a), this.bubbleDown(d))
};
q.bubbleUp = function(a) {
	if (!(0 >= a)) {
		var b = a - 1 >> 1;
		this.arr[a].key < this.arr[b].key && (this.swap(a, b), this.bubbleUp(b))
	}
};
On.MinHeap = Qn;

function Rn() {}
var Sn = function(a) {
	this.maxHeap = new Qn;
	this.k = a
};
Sn.prototype.add = function(a, b) {
	if (this.maxHeap.size() < this.k) this.maxHeap.push(-a, b);
	else {
		var c = this.maxHeap.peek();
		a < -c.key && this.maxHeap.popPush(-a, b)
	}
};
Sn.prototype.getMinKItems = function() {
	var a = this.maxHeap.items();
	a.sort(function(a, c) {
		return c.key - a.key
	});
	return a.map(function(a) {
		return a.value
	})
};
Sn.prototype.getSize = function() {
	return this.maxHeap.size()
};
Sn.prototype.getLargestKey = function() {
	return 0 === this.maxHeap.size() ? null : -this.maxHeap.peek().key
};
On.KMin = Sn;

function Tn() {};
var Un = {},
	Vn = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vector"
	};

function Wn(a, b) {
	Gn(a.length === b.length, "Vectors a and b must be of same length");
	for (var c = 0, d = 0; d < a.length; ++d) c += a[d] * b[d];
	return c
}
Un.dot = Wn;

function Xn(a) {
	for (var b = 0, c = 0; c < a.length; ++c) b += a[c];
	return b
}
Un.sum = Xn;

function Yn(a, b) {
	Gn(a.length === b.length, "Vectors a and b must be of same length");
	for (var c = new Float32Array(a.length), d = 0; d < a.length; ++d) c[d] = a[d] + b[d];
	return c
}
Un.add = Yn;

function Zn(a, b) {
	Gn(a.length === b.length, "Vectors a and b must be of same length");
	for (var c = new Float32Array(a.length), d = 0; d < a.length; ++d) c[d] = a[d] - b[d];
	return c
}
Un.sub = Zn;

function $n(a) {
	for (var b = 0, c = 0; c < a.length; ++c) b += a[c] * a[c];
	return b
}
Un.norm2 = $n;

function ao(a, b) {
	return Math.sqrt(bo(a, b))
}
Un.dist = ao;

function bo(a, b) {
	Gn(a.length === b.length, "Vectors a and b must be of same length");
	for (var c = 0, d = 0; d < a.length; ++d) var e = a[d] - b[d],
		c = c + e * e;
	return c
}
Un.dist2 = bo;

function co(a, b) {
	var c = a[0] - b[0];
	a = a[1] - b[1];
	return c * c + a * a
}
Un.dist2_2D = co;

function eo(a, b) {
	var c = a[0] - b[0],
		d = a[1] - b[1];
	a = a[2] - b[2];
	return c * c + d * d + a * a
}
Un.dist2_3D = eo;

function fo(a, b) {
	return Math.sqrt(eo(a, b))
}
Un.dist_3D = fo;

function go(a, b, c) {
	Gn(a.length === b.length, "Vectors a and b must be of same length");
	for (var d = 0, e = 0; e < a.length; ++e) {
		var f = a[e] - b[e],
			d = d + f * f;
		if (d >= c) return -1
	}
	return d
}
Un.dist2WithLimit = go;

function ho(a, b) {
	var c = a[0] - b[0];
	a = a[1] - b[1];
	return c * c + a * a
}
Un.dist22D = ho;

function io(a) {
	var b = Math.sqrt($n(a));
	Gn(0 <= b, "Norm of the vector must be > 0");
	for (var c = 0; c < a.length; ++c) a[c] /= b
}
Un.unit = io;

function jo(a, b) {
	for (var c = a[0].length, d = a.length, e = Array(d), f = 0; f < d; ++f) e[f] = new Float32Array(b);
	for (f = 0; f < b; ++f)
		for (var g = ko(c), h = 0; h < d; ++h) e[h][f] = Wn(a[h], g);
	return e
}
Un.projectRandom = jo;

function lo(a, b, c) {
	return [Wn(a, b), Wn(a, c)]
}
Un.project2d = lo;

function mo(a, b) {
	if (0 === a.length) return null;
	null == b && (b = function(a) {
		return a
	});
	Gn(0 <= a.length, "`vectors` must be of length >= 1");
	for (var c = new Float32Array(b(a[0]).length), d = 0; d < a.length; ++d)
		for (var e = a[d], e = b(e), f = 0; f < c.length; ++f) c[f] += e[f];
	for (b = 0; b < c.length; ++b) c[b] /= a.length;
	return c
}
Un.centroid = mo;

function ko(a) {
	for (var b = d3.random.normal(), c = new Float32Array(a), d = 0; d < a; ++d) c[d] = b();
	return c
}
Un.rn = ko;

function no(a, b) {
	return 1 - Wn(a, b)
}
Un.cosDistNorm = no;

function oo(a, b) {
	return 1 - po(a, b)
}
Un.cosDist = oo;

function po(a, b) {
	return Wn(a, b) / Math.sqrt($n(a) * $n(b))
}
Un.cosSim = po;

function qo(a, b) {
	for (var c = a.length, d = b(a[0]).length, e = new Float32Array(c * d), f = 0; f < c; ++f)
		for (var g = b(a[f]), h = 0; h < d; ++h) e[f * d + h] = g[h];
	return e
}
Un.toTypedArray = qo;

function ro(a, b, c) {
	for (var d = new Float32Array(a * b), e = 0; e < a; ++e)
		for (var f = 0; f < b; ++f) d[f * a + e] = c[e * b + f];
	return d
}
Un.transposeTypedArray = ro;
var so = {},
	to = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/knn"
	};

function uo(a, b, c) {
	function d(g) {
		var v = "Finding nearest neighbors: " + (100 * t).toFixed() + "%";
		In(v, function() {
			for (var d = w < n ? m + 1 : m, g = new Float32Array(d * f), l = 0; l < d; ++l)
				for (var v = c(a[r + l]), x = 0; x < f; ++x) g[l * f + x] = v[x];
			l = new weblas.pipeline.Tensor([d, f], g);
			v = weblas.pipeline.sgemm(1, h, l, null, null);
			g = v.transfer();
			l.delete();
			v.delete();
			t += u;
			for (l = 0; l < d; l++) {
				for (var v = new Sn(b), x = r + l, H = 0; H < e; H++)
					if (H !== x) {
						var O = 1 - g[H * d + l];
						v.add(O, {
							index: H,
							dist: O
						})
					}
				k[x] = v.getMinKItems()
			}
			t += u;
			r += d;
			w++
		}, "knn-gpu").then(function() {
			w <
				l ? d(g) : (wn(null, "knn-gpu"), h.delete(), g(k))
		}, function(d) {
			wn(null, "knn-gpu");
			d = function(a, b, c) {
				return no(a, b)
			};
			vo(a, b, c, d).then(function(a) {
				g(a)
			})
		})
	}
	var e = a.length,
		f = c(a[0]).length,
		g = qo(a, c),
		h = new weblas.pipeline.Tensor([e, f], g),
		k = Array(e),
		l = Math.ceil(e / 256),
		m = Math.floor(e / l),
		n = e % l,
		r = 0,
		t = 0,
		u = 1 / (2 * l),
		w = 0;
	return new Promise(function(a) {
		return d(a)
	})
}
so.findKNNGPUCosine = uo;

function vo(a, b, c, d) {
	return In("Finding nearest neighbors...", function() {
		for (var e = a.length, f = Array(e), g = Array(e), h = 0; h < e; h++) g[h] = new Sn(b);
		for (h = 0; h < e; h++)
			for (var k = c(a[h]), l = g[h], m = h + 1; m < e; m++) {
				var n = g[m],
					r = l.getSize() === b ? l.getLargestKey() || Number.MAX_VALUE : Number.MAX_VALUE,
					t = n.getSize() === b ? n.getLargestKey() || Number.MAX_VALUE : Number.MAX_VALUE,
					r = Math.max(r, t),
					r = d(k, c(a[m]), r);
				0 <= r && (l.add(r, {
					index: m,
					dist: r
				}), n.add(r, {
					index: h,
					dist: r
				}))
			}
		for (h = 0; h < e; h++) f[h] = g[h].getMinKItems();
		return f
	})
}
so.findKNN = vo;

function wo(a, b, c, d, e) {
	var f = a[0];
	a = a[1];
	var g = f - b,
		h = f - d,
		k = a - c,
		l = a - e;
	if (0 >= g * h) return 0 >= k * l ? 0 : Math.min(Math.abs(k), Math.abs(l));
	if (0 >= k * l) return Math.min(Math.abs(g), Math.abs(h));
	b = f > d ? a > e ? [d, e] : [d, c] : a > e ? [b, e] : [b, c];
	return Math.sqrt(ho([f, a], b))
}

function xo(a, b, c, d, e) {
	c = new Sn(c);
	for (var f = d(a[b]), g = 0; g < a.length; ++g)
		if (g !== b) {
			var h = d(a[g]),
				h = e(f, h);
			c.add(h, {
				index: g,
				dist: h
			})
		}
	return c.getMinKItems()
}
so.findKNNofPoint = xo;
var yo = {},
	zo = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/data"
	},
	Ao = 0 <= navigator.userAgent.toLowerCase().indexOf("firefox"),
	Bo = Nn() && !Ao;
yo.TSNE_SAMPLE_SIZE = 1E4;
yo.PCA_SAMPLE_SIZE = 5E4;
yo.PCA_SAMPLE_DIM = 200;
var Co = function(a, b) {
	this.shuffledDataIndices = [];
	this.projections = d3.set();
	this.tSNEIteration = 0;
	this.tSNEShouldStop = !0;
	this.dim = [0, 0];
	this.hasTSNERun = !1;
	this.points = a;
	this.shuffledDataIndices = Bn(d3.range(this.points.length));
	this.traces = this.computeTraces(a);
	this.dim = [this.points.length, this.points[0].vector.length];
	this.spriteAndMetadataInfo = b
};
q = Co.prototype;
q.computeTraces = function(a) {
	for (var b = new Int8Array(a.length), c = {}, d = [], e = 0; e < a.length; e++)
		if (!b[e]) {
			b[e] = 1;
			var f = a[e].metadata.__next__;
			if (null != f && "" !== f)
				if (f in c) f = c[+f], f.pointIndices.unshift(e), c[e] = f;
				else {
					f = {
						pointIndices: []
					};
					c[e] = f;
					d.push(f);
					for (var g = e; a[g];) f.pointIndices.push(g), g = a[g].metadata.__next__, null != g && "" !== g ? (b[+g] = 1, g = +g) : g = -1
				}
		}
	return d
};
q.projectionCanBeRendered = function(a) {
	return "tsne" !== a ? !0 : 0 < this.tSNEIteration
};
q.getSubset = function(a) {
	var b = this;
	a = null != a && 0 < a.length ? a.map(function(a) {
		return b.points[a]
	}) : this.points;
	a = a.map(function(a) {
		return {
			metadata: a.metadata,
			index: a.index,
			vector: a.vector.slice(),
			projections: {}
		}
	});
	return new Co(a, this.spriteAndMetadataInfo)
};
q.normalize = function() {
	var a = mo(this.points, function(a) {
		return a.vector
	});
	if (null == a) throw Error("centroid should not be null");
	for (var b = 0; b < this.points.length; ++b) {
		var c = this.points[b];
		c.vector = Zn(c.vector, a);
		io(c.vector)
	}
};
q.projectLinear = function(a, b) {
	this.projections.add(b);
	this.points.forEach(function(c) {
		c.projections[b] = Wn(c.vector, a)
	})
};
q.projectPCA = function() {
	var a = this;
	return this.projections.has("pca-0") ? Promise.resolve(null) : In("Computing PCA...", function() {
		var b = a.points[0].vector.length,
			c = a.shuffledDataIndices.map(function(b) {
				return a.points[b].vector
			});
		b > yo.PCA_SAMPLE_DIM && (c = jo(c, yo.PCA_SAMPLE_DIM));
		for (var b = c.slice(0, yo.PCA_SAMPLE_SIZE), b = numeric.div(numeric.dot(numeric.transpose(b), b), b.length), b = numeric.svd(b), d = b.S, e = 0, f = 0; f < d.length; ++f) e += d[f];
		for (f = 0; f < d.length; ++f) d[f] /= e;
		a.fracVariancesExplained = d;
		for (var g = b.U,
				c = c.map(function(a) {
					for (var b = new Float32Array(10), c = 0; 10 > c; c++) {
						for (var d = 0, e = 0; e < a.length; e++) d += a[e] * g[e][c];
						b[c] = d
					}
					return b
				}), b = 0; 10 > b; b++)
			for (d = "pca-" + b, a.projections.add(d), e = 0; e < c.length; e++) f = a.shuffledDataIndices[e], a.points[f].projections[d] = c[e][b]
	})
};
q.projectTSNE = function(a, b, c, d) {
	var e = this;
	this.hasTSNERun = !0;
	var f = Math.floor(3 * a);
	a = {
		epsilon: b,
		perplexity: a,
		dim: c
	};
	this.tsne = new on(a);
	this.tSNEShouldStop = !1;
	this.tSNEIteration = 0;
	var g = this.shuffledDataIndices.slice(0, yo.TSNE_SAMPLE_SIZE),
		h = function() {
			if (e.tSNEShouldStop) d(null), e.tsne = null;
			else {
				e.tsne.step();
				var a = e.tsne.getSolution();
				g.forEach(function(b, d) {
					b = e.points[b];
					b.projections["tsne-0"] = a[d * c + 0];
					b.projections["tsne-1"] = a[d * c + 1];
					3 === c && (b.projections["tsne-2"] = a[d * c + 2])
				});
				e.tSNEIteration++;
				d(e.tSNEIteration);
				requestAnimationFrame(h)
			}
		};
	null != this.nearest && f === this.nearestK ? f = Promise.resolve(this.nearest) : (a = g.map(function(a) {
		return e.points[a]
	}), this.nearestK = f, f = Bo ? uo(a, f, function(a) {
		return a.vector
	}) : vo(a, f, function(a) {
		return a.vector
	}, function(a, b, c) {
		return no(a, b)
	}));
	f.then(function(a) {
		e.nearest = a;
		In("Initializing T-SNE...", function() {
			e.tsne.initDataDist(e.nearest)
		}).then(h)
	})
};
q.mergeMetadata = function(a) {
	var b = this;
	if (a.pointsInfo.length !== this.points.length) {
		var c = "Number of tensors (" + this.points.length + ") do not match the number of lines in metadata" + (" (" + a.pointsInfo.length + ").");
		if (1 === a.stats.length && this.points.length + 1 === a.pointsInfo.length) return xn(c + " Single column metadata should not have a header row.", "merging metadata"), !1;
		if (1 < a.stats.length && this.points.length - 1 === a.pointsInfo.length) return xn(c + " Multi-column metadata should have a header row with column labels.",
			"merging metadata"), !1;
		yn(c)
	}
	this.spriteAndMetadataInfo = a;
	a.pointsInfo.slice(0, this.points.length).forEach(function(a, c) {
		return b.points[c].metadata = a
	});
	return !0
};
q.stopTSNE = function() {
	this.tSNEShouldStop = !0
};
q.findNeighbors = function(a, b, c) {
	a = xo(this.points, a, c, function(a) {
		return a.vector
	}, b);
	return c = a.slice(0, c)
};
q.query = function(a, b, c) {
	var d = Hn(a, b, c),
		e = [];
	this.points.forEach(function(a, b) {
		d(a) && e.push(b)
	});
	return e
};
yo.DataSet = Co;

function Do() {}
var Eo = function(a, b, c, d) {
	this.projectionType = a;
	this.projectionComponents = b;
	this.dimensionality = c;
	this.dataSet = d
};
yo.Projection = Eo;

function Fo() {}
var Go = function() {
	this.label = "";
	this.isSelected = !1;
	this.tSNELearningRate = this.tSNEPerplexity = this.tSNEIteration = 0;
	this.tSNEis3d = !0;
	this.pcaComponentDimensions = [];
	this.projections = [];
	this.selectedPoints = []
};
yo.State = Go;

function Ho() {}

function Io(a, b) {
	if (3 < b.length) throw new RangeError("components length must be <= 3");
	var c = [null, null, null];
	a = "custom" === a ? "linear" : a;
	for (var d = 0; d < b.length; ++d) null != b[d] && (c[d] = a + "-" + b[d]);
	return c
}
yo.getProjectionComponents = Io;

function Jo(a) {
	var b;
	switch (a.selectedProjection) {
		case "pca":
			b = a.pcaComponentDimensions.slice();
			break;
		case "tsne":
			b = [0, 1];
			a.tSNEis3d && b.push(2);
			break;
		// case "custom":
		// 	b = ["x", "y"];
		// 	break;
		case "cluster":
			b = ["x", "y"];
			break;
		default:
			throw Error("Unexpected fallthrough");
	}
	return b
}
yo.stateGetAccessorDimensions = Jo;
var Ko = {},
	Lo = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/data-provider"
	};
Ko.METADATA_MSG_ID = "metadata";
Ko.TENSORS_MSG_ID = "tensors";

function Mo(a, b, c, d, e, f) {
	wn("Fetching tensor values...", Ko.TENSORS_MSG_ID);
	var g = new XMLHttpRequest;
	g.open("GET", e);
	g.responseType = "arraybuffer";
	g.onprogress = function(a) {
		a.lengthComputable && (a = (100 * a.loaded / a.total).toFixed(1), wn("Fetching tensor values: " + a + "%", Ko.TENSORS_MSG_ID))
	};
	g.onload = function() {
		if (200 !== g.status) {
			var a = String.fromCharCode.apply(null, new Uint8Array(g.response));
			xn(a, "fetching tensors")
		} else {
			try {
				a = new Float32Array(g.response)
			} catch (m) {
				xn(m, "parsing tensor bytes");
				return
			}
			var c =
				b.tensorShape[1],
				d = a.length / c;
			b.tensorShape[0] > d && yn("Showing the first " + d.toLocaleString() + (" of " + b.tensorShape[0].toLocaleString() + " data points"));
			No(a, c).then(function(a) {
				f(new yo.DataSet(a))
			})
		}
	};
	g.send()
}
Ko.retrieveTensorAsBytes = Mo;

function Oo(a, b) {
	Po(a).then(function(a) {
		b(new yo.DataSet(a))
	})
}
Ko.parseRawTensors = Oo;

function Qo(a, b) {
	Ro(a).then(function(a) {
		return b(a)
	})
}
Ko.parseRawMetadata = Qo;

function Po(a, b) {
	b = void 0 === b ? "\t" : b;
	var c = [],
		d;
	return In("Parsing tensors...", function() {
		var e = a.split("\n");
		e.forEach(function(a) {
			a = a.trim();
			if ("" !== a) {
				a = a.split(b);
				var e = {
					metadata: {},
					vector: null,
					index: c.length,
					projections: null
				};
				isNaN(a[0]) || d === a.length - 1 ? (e.metadata.label = a[0], e.vector = new Float32Array(a.slice(1).map(Number))) : e.vector = new Float32Array(a.map(Number));
				c.push(e);
				null == d && (d = e.vector.length);
				if (d !== e.vector.length) throw wn("Parsing failed. Vector dimensions do not match"), Error("Parsing failed");
				if (1 >= d) throw wn("Parsing failed. Found a vector with only one dimension?"), Error("Parsing failed");
			}
		});
		return c
	}, Ko.TENSORS_MSG_ID).then(function(a) {
		wn(null, Ko.TENSORS_MSG_ID);
		return a
	})
}
Ko.parseTensors = Po;

function No(a, b) {
	return In("Parsing tensors...", function() {
		for (var c = a.length / b, d = [], e = 0, f = 0; f < c; ++f) d.push({
			metadata: {},
			vector: a.subarray(e, e + b),
			index: f,
			projections: null
		}), e += b;
		return d
	}, Ko.TENSORS_MSG_ID).then(function(a) {
		wn(null, Ko.TENSORS_MSG_ID);
		return a
	})
}
Ko.parseTensorsFromFloat32Array = No;

function So(a, b) {
	var c = a.map(function(a) {
			return {
				name: a,
				isNumeric: !0,
				tooManyUniqueValues: !1,
				min: Number.POSITIVE_INFINITY,
				max: Number.NEGATIVE_INFINITY
			}
		}),
		d = a.map(function() {
			return d3.map()
		});
	b.forEach(function(b) {
		a.forEach(function(a, e) {
			var f = c[e];
			e = d[e];
			var g = b[a];
			null != g && (f.tooManyUniqueValues || (e.has(g) ? e.set(g, e.get(g) + 1) : e.set(g, 1), 60 < e.size() && (f.tooManyUniqueValues = !0)), isNaN(g) ? f.isNumeric = !1 : (b[a] = +g, f.min = Math.min(f.min, +g), f.max = Math.max(f.max, +g)))
		})
	});
	c.forEach(function(a, b) {
		b = d[b];
		a.tooManyUniqueValues ||
			(a.uniqueEntries = b.entries().map(function(a) {
				return {
					label: a.key,
					count: a.value
				}
			}))
	});
	return c
}
Ko.analyzeMetadata = So;

function Ro(a) {
	return In("Parsing metadata...", function() {
		var b = a.split("\n").filter(function(a) {
				return 0 < a.trim().length
			}),
			c = 0 <= b[0].indexOf("\t"),
			d = [],
			e = ["label"];
		c && (e = b[0].split("\t"), b = b.slice(1));
		b.forEach(function(a) {
			var b = a.split("\t"),
				c = {};
			d.push(c);
			e.forEach(function(a, d) {
				d = b[d];
				d = "" === d ? null : d;
				c[a] = d
			})
		});
		return {
			stats: So(e, d),
			pointsInfo: d
		}
	}, Ko.METADATA_MSG_ID).then(function(a) {
		wn(null, Ko.METADATA_MSG_ID);
		return a
	})
}
Ko.parseMetadata = Ro;

function To(a) {
	return new Promise(function(b, c) {
		var d = new Image;
		d.onload = function() {
			return b(d)
		};
		d.onerror = function(a) {
			return c(a)
		};
		d.crossOrigin = "";
		d.src = a
	})
}
Ko.fetchImage = To;

function Uo(a, b, c, d) {
	var e = Promise.resolve({});
	a && (e = new Promise(function(b, c) {
		wn("Fetching metadata...", Ko.METADATA_MSG_ID);
		d3.text(a, function(a, d) {
			a ? (xn(a.responseText, "fetching metadata"), c(a)) : b(Ro(d))
		})
	}));
	var f = null,
		g = null;
	b && (f = wn("Fetching sprite image..."), g = To(b));
	Promise.all([e, g]).then(function(a) {
		f && wn(null, f);
		var b = F.makeIterator(a);
		a = b.next().value;
		(b = b.next().value) && (8192 < b.height || 8192 < b.width) ? wn("Error: Sprite image of dimensions " + b.width + "px x " + (b.height + "px exceeds maximum dimensions ") +
			"8192px x 8192px"): (a.spriteImage = b, a.spriteMetadata = c, d(a))
	})
}
Ko.retrieveSpriteAndMetadataInfo = Uo;
var Vo = {},
	Wo = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/data-provider-demo"
	},
	Xo = Ko,
	Yo = function(a) {
		this.projectorConfigPath = a
	};
q = Yo.prototype;
q.getEmbeddingInfo = function(a) {
	for (var b = this.projectorConfig.embeddings, c = 0; c < b.length; c++) {
		var d = b[c];
		if (d.tensorName === a) return d
	}
	return null
};
q.retrieveRuns = function(a) {
	a(["Demo"])
};
q.retrieveProjectorConfig = function(a, b) {
	var c = this,
		d = wn("Fetching projector config...");
	d3.json(this.projectorConfigPath, function(a, f) {
		a ? (f = a, null != a.responseText && (f = "Cannot fetch projector config, possibly a Cross-Origin request error."), xn(f, "fetching projector config")) : (wn(null, d), c.projectorConfig = f, b(f))
	})
};
q.retrieveTensor = function(a, b, c) {
	var d = this.getEmbeddingInfo(b),
		e = "" + d.tensorPath;
	".bytes" === d.tensorPath.substr(-6) ? Xo.retrieveTensorAsBytes(this, this.getEmbeddingInfo(b), a, b, e, c) : (wn("Fetching tensors...", Ko.TENSORS_MSG_ID), d3.text(e, function(a, b) {
		a ? xn(a.responseText, "fetching tensors") : Xo.parseTensors(b).then(function(a) {
			c(new yo.DataSet(a))
		})
	}))
};
q.retrieveSpriteAndMetadata = function(a, b, c) {
	a = this.getEmbeddingInfo(b);
	b = null;
	a.sprite && a.sprite.imagePath && (b = a.sprite.imagePath);
	Xo.retrieveSpriteAndMetadataInfo(a.metadataPath, b, a.sprite, c)
};
q.getBookmarks = function(a, b, c) {
	a = this.getEmbeddingInfo(b);
	var d = wn("Fetching bookmarks...");
	d3.json(a.bookmarksPath, function(a, b) {
		a ? xn(a.responseText) : (wn(null, d), c(b))
	})
};
Vo.DemoDataProvider = Yo;

function Zo() {};
var $o = {},
	ap = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/data-provider-proto"
	},
	bp = function(a) {
		this.dataProto = a
	};
q = bp.prototype;
q.retrieveRuns = function(a) {
	a(["proto"])
};
q.retrieveProjectorConfig = function(a, b) {
	b({
		modelCheckpointPath: "proto",
		embeddings: [{
			tensorName: "proto",
			tensorShape: this.dataProto.shape,
			metadataPath: "proto"
		}]
	})
};
q.retrieveTensor = function(a, b, c) {
	c(this.flatArrayToDataset(this.dataProto.tensor))
};
q.retrieveSpriteAndMetadata = function(a, b, c) {
	a = this.dataProto.metadata.columns.map(function(a) {
		return a.name
	});
	var d = this.dataProto.shape[0],
		e = Array(d);
	this.dataProto.metadata.columns.forEach(function(a) {
		for (var b = a.numericValues || a.stringValues, c = 0; c < d; c++) e[c] = e[c] || {}, e[c][a.name] = b[c]
	});
	c({
		stats: Ko.analyzeMetadata(a, e),
		pointsInfo: e
	})
};
q.getBookmarks = function(a, b, c) {
	return c([])
};
q.flatArrayToDataset = function(a) {
	var b = [],
		c = this.dataProto.shape[0],
		d = this.dataProto.shape[1];
	if (c * d !== a.length) throw "The shape doesn't match the length of the flattened array";
	for (var e = 0; e < c; e++) {
		var f = e * d;
		b.push({
			vector: new Float32Array(a.slice(f, f + d)),
			metadata: {},
			projections: null,
			index: e
		})
	}
	return new yo.DataSet(b)
};
$o.ProtoDataProvider = bp;

function cp() {};
var dp = {},
	ep = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/data-provider-server"
	};
dp.LIMIT_NUM_POINTS = 1E5;
var fp = function(a) {
	this.runProjectorConfigCache = {};
	this.routePrefix = a
};
q = fp.prototype;
q.getEmbeddingInfo = function(a, b, c) {
	this.retrieveProjectorConfig(a, function(a) {
		a = a.embeddings;
		for (var d = 0; d < a.length; d++) {
			var f = a[d];
			if (f.tensorName === b) {
				c(f);
				return
			}
		}
		c(null)
	})
};
q.retrieveRuns = function(a) {
	var b = wn("Fetching runs...");
	d3.json(this.routePrefix + "/runs", function(c, d) {
		c ? xn(c.responseText, "fetching runs") : (wn(null, b), a(d))
	})
};
q.retrieveProjectorConfig = function(a, b) {
	var c = this;
	if (a in this.runProjectorConfigCache) b(this.runProjectorConfigCache[a]);
	else {
		var d = wn("Fetching projector config...");
		d3.json(this.routePrefix + "/info?run=" + a, function(e, f) {
			e ? xn(e.responseText, "fetching projector config") : (wn(null, d), c.runProjectorConfigCache[a] = f, b(f))
		})
	}
};
q.retrieveTensor = function(a, b, c) {
	var d = this;
	this.getEmbeddingInfo(a, b, function(e) {
		Ko.retrieveTensorAsBytes(d, e, a, b, d.routePrefix + "/tensor?run=" + a + "&name=" + b + ("&num_rows=" + dp.LIMIT_NUM_POINTS), c)
	})
};
q.retrieveSpriteAndMetadata = function(a, b, c) {
	var d = this;
	this.getEmbeddingInfo(a, b, function(e) {
		var f = null;
		e.metadataPath && (f = d.routePrefix + "/metadata?" + ("run=" + a + "&name=" + b + "&num_rows=" + dp.LIMIT_NUM_POINTS));
		var g = null;
		e.sprite && e.sprite.imagePath && (g = d.routePrefix + "/sprite_image?run=" + a + "&name=" + b);
		Ko.retrieveSpriteAndMetadataInfo(f, g, e.sprite, c)
	})
};
q.getBookmarks = function(a, b, c) {
	var d = wn("Fetching bookmarks...");
	d3.json(this.routePrefix + "/bookmarks?run=" + a + "&name=" + b, function(a, b) {
		wn(null, d);
		a || c(b)
	})
};
dp.ServerDataProvider = fp;

function gp() {};
var hp = {},
	ip = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/label"
	},
	jp = function(a, b, c) {
		this.bound = a;
		this.cellWidth = b;
		this.cellHeight = c;
		this.numHorizCells = Math.ceil(this.boundWidth(a) / b);
		this.numVertCells = Math.ceil(this.boundHeight(a) / c);
		this.grid = Array(this.numHorizCells * this.numVertCells)
	};
q = jp.prototype;
q.boundWidth = function(a) {
	return a.hiX - a.loX
};
q.boundHeight = function(a) {
	return a.hiY - a.loY
};
q.boundsIntersect = function(a, b) {
	return !(a.loX > b.hiX || a.loY > b.hiY || a.hiX < b.loX || a.hiY < b.loY)
};
q.insert = function(a, b) {
	b = void 0 === b ? !1 : b;
	if (a.hiX < this.bound.loX || a.loX > this.bound.hiX || a.hiY < this.bound.loY || a.loY > this.bound.hiY) return !1;
	for (var c = this.getCellX(a.loX), d = this.getCellX(a.hiX), e = this.getCellY(a.loY), f = this.getCellY(a.hiY), g = e * this.numHorizCells + c, h = g, k = e; k <= f; k++) {
		for (var l = c; l <= d; l++) {
			var m = this.grid[h++];
			if (m)
				for (var n = 0; n < m.length; n++)
					if (this.boundsIntersect(a, m[n])) return !1
		}
		h += this.numHorizCells - (d - c + 1)
	}
	if (b) return !0;
	h = g;
	for (b = e; b <= f; b++) {
		for (e = c; e <= d; e++) this.grid[h] ? this.grid[h].push(a) :
			this.grid[h] = [a], h++;
		h += this.numHorizCells - (d - c + 1)
	}
	return !0
};
q.getCellX = function(a) {
	return Math.floor((a - this.bound.loX) / this.cellWidth)
};
q.getCellY = function(a) {
	return Math.floor((a - this.bound.loY) / this.cellHeight)
};
hp.CollisionGrid = jp;

function kp() {};
var lp = {},
	mp = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/projectorEventContext"
	};
var np = {},
	op = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/renderContext"
	},
	pp = function(a, b, c, d, e, f, g) {
		this.pointIndices = a;
		this.labelStrings = b;
		this.scaleFactors = c;
		this.useSceneOpacityFlags = d;
		this.defaultFontSize = e;
		this.fillColors = f;
		this.strokeColors = g
	};
np.LabelRenderParams = pp;

function qp() {}
np.CameraType = {};
np.CameraType.Perspective = 0;
np.CameraType.Orthographic = 1;
np.CameraType[np.CameraType.Perspective] = "Perspective";
np.CameraType[np.CameraType.Orthographic] = "Orthographic";
var rp = function(a, b, c, d, e, f, g, h, k, l, m, n, r, t) {
	this.camera = a;
	this.cameraType = b;
	this.cameraTarget = c;
	this.screenWidth = d;
	this.screenHeight = e;
	this.nearestCameraSpacePointZ = f;
	this.farthestCameraSpacePointZ = g;
	this.backgroundColor = h;
	this.pointColors = k;
	this.pointScaleFactors = l;
	this.labels = m;
	this.traceColors = n;
	this.traceOpacities = r;
	this.traceWidths = t
};
np.RenderContext = rp;

function sp() {};
var tp = {},
	up = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/scatterPlotRectangleSelector"
	},
	vp = function(a, b) {
		this.svgElement = d3.select(a).select("#selector");
		this.rectElement = this.svgElement.append("rect").style("stroke", "#aaaaaa").style("stroke-dasharray", "10 5").style("stroke-width", 2).style("fill", "#dddddd").style("fill-opacity", .2);
		this.selectionCallback = b;
		this.isMouseDown = !1
	};
vp.prototype.onMouseDown = function(a, b) {
	this.isMouseDown = !0;
	this.svgElement.style("display", "block");
	this.startCoordinates = [a, b];
	this.lastBoundingBox = {
		x: this.startCoordinates[0],
		y: this.startCoordinates[1],
		width: 1,
		height: 1
	}
};
vp.prototype.onMouseMove = function(a, b) {
	this.isMouseDown && (this.lastBoundingBox.x = Math.min(a, this.startCoordinates[0]), this.lastBoundingBox.y = Math.max(b, this.startCoordinates[1]), this.lastBoundingBox.width = Math.max(a, this.startCoordinates[0]) - this.lastBoundingBox.x, this.lastBoundingBox.height = this.lastBoundingBox.y - Math.min(b, this.startCoordinates[1]), this.rectElement.attr({
		x: this.lastBoundingBox.x,
		y: this.lastBoundingBox.y - this.lastBoundingBox.height,
		width: this.lastBoundingBox.width,
		height: this.lastBoundingBox.height
	}))
};
vp.prototype.onMouseUp = function() {
	this.isMouseDown = !1;
	this.svgElement.style("display", "none");
	this.rectElement.attr("width", 0);
	this.rectElement.attr("height", 0);
	this.selectionCallback(this.lastBoundingBox)
};
tp.ScatterPlotRectangleSelector = vp;

function wp() {};
var xp = {},
	yp = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/scatterPlot"
	},
	zp = new THREE.Vector3(.45, .9, 1.6),
	Ap = new THREE.Vector3(0, 0, 0),
	Bp = new THREE.Vector3(0, 0, 4),
	Cp = new THREE.Vector3(0, 0, 0);
xp.MouseMode = {};
xp.MouseMode.AREA_SELECT = 0;
xp.MouseMode.CAMERA_AND_CLICK_SELECT = 1;
xp.MouseMode[xp.MouseMode.AREA_SELECT] = "AREA_SELECT";
xp.MouseMode[xp.MouseMode.CAMERA_AND_CLICK_SELECT] = "CAMERA_AND_CLICK_SELECT";
var Dp = function() {
	this.orthographic = !1
};
xp.CameraDef = Dp;

function Ep() {}
var Fp = function(a, b) {
	var c = this;
	this.visualizers = [];
	this.onCameraMoveListeners = [];
	this.backgroundColor = 16777215;
	this.dimensionality = 3;
	this.cameraDef = null;
	this.isDragSequence = this.mouseIsDown = this.selecting = this.orbitAnimationOnNextCameraCreation = !1;
	this.containerNode = a.node();
	this.projectorEventContext = b;
	this.getLayoutValues();
	this.scene = new THREE.Scene;
	this.renderer = new THREE.WebGLRenderer({
		alpha: !0,
		premultipliedAlpha: !1,
		antialias: !1
	});
	this.renderer.setClearColor(16777215, 1);
	this.containerNode.appendChild(this.renderer.domElement);
	this.light = new THREE.PointLight(16772287, 1, 0);
	this.scene.add(this.light);
	this.setDimensions(3);
	this.recreateCamera(this.makeDefaultCameraDef(this.dimensionality));
	this.renderer.render(this.scene, this.camera);
	this.rectangleSelector = new vp(this.containerNode, function(a) {
		return c.selectBoundingBox(a)
	});
	this.addInteractionListeners()
};
q = Fp.prototype;
q.addInteractionListeners = function() {
	this.containerNode.addEventListener("mousemove", this.onMouseMove.bind(this));
	this.containerNode.addEventListener("mousedown", this.onMouseDown.bind(this));
	this.containerNode.addEventListener("mouseup", this.onMouseUp.bind(this));
	this.containerNode.addEventListener("click", this.onClick.bind(this));
	window.addEventListener("keydown", this.onKeyDown.bind(this), !1);
	window.addEventListener("keyup", this.onKeyUp.bind(this), !1)
};
q.addCameraControlsEventListeners = function(a) {
	var b = this;
	a.addEventListener("start", function() {
		b.stopOrbitAnimation();
		b.onCameraMoveListeners.forEach(function(c) {
			return c(b.camera.position, a.target)
		})
	});
	a.addEventListener("change", function() {
		b.render()
	});
	a.addEventListener("end", function() {})
};
q.makeOrbitControls = function(a, b, c) {
	null != this.orbitCameraControls && this.orbitCameraControls.dispose();
	var d = new THREE.OrbitControls(a, this.renderer.domElement);
	d.target0 = new THREE.Vector3(b.target[0], b.target[1], b.target[2]);
	d.position0 = (new THREE.Vector3).copy(a.position);
	d.zoom0 = b.zoom;
	d.enableRotate = c;
	d.autoRotate = !1;
	d.rotateSpeed = 1;
	c ? (d.mouseButtons.ORBIT = THREE.MOUSE.LEFT, d.mouseButtons.PAN = THREE.MOUSE.RIGHT) : (d.mouseButtons.ORBIT = null, d.mouseButtons.PAN = THREE.MOUSE.LEFT);
	d.reset();
	this.camera =
		a;
	this.orbitCameraControls = d;
	this.addCameraControlsEventListeners(this.orbitCameraControls)
};
q.makeCamera3D = function(a, b, c) {
	b /= c;
	b = new THREE.PerspectiveCamera(70, b, .01, 100);
	b.position.set(a.position[0], a.position[1], a.position[2]);
	c = new THREE.Vector3(a.target[0], a.target[1], a.target[2]);
	b.lookAt(c);
	b.zoom = a.zoom;
	b.updateProjectionMatrix();
	this.camera = b;
	this.makeOrbitControls(b, a, !0)
};
q.makeCamera2D = function(a, b, c) {
	var d = new THREE.Vector3(a.target[0], a.target[1], a.target[2]);
	b /= c;
	c = -1.2;
	var e = 1.2,
		f = -1.2,
		g = 1.2;
	1 < b ? (c *= b, e *= b) : (g /= b, f /= b);
	b = new THREE.OrthographicCamera(c, e, g, f, -1E3, 1E3);
	b.position.set(a.position[0], a.position[1], a.position[2]);
	b.up = new THREE.Vector3(0, 1, 0);
	b.lookAt(d);
	b.zoom = a.zoom;
	b.updateProjectionMatrix();
	this.camera = b;
	this.makeOrbitControls(b, a, !1)
};
q.makeDefaultCameraDef = function(a) {
	var b = new Dp;
	b.orthographic = 2 === a;
	b.zoom = 1;
	b.orthographic ? (b.position = [Bp.x, Bp.y, Bp.z], b.target = [Cp.x, Cp.y, Cp.z]) : (b.position = [zp.x, zp.y, zp.z], b.target = [Ap.x, Ap.y, Ap.z]);
	return b
};
q.recreateCamera = function(a) {
	a.orthographic ? this.makeCamera2D(a, this.width, this.height) : this.makeCamera3D(a, this.width, this.height);
	this.orbitCameraControls.minDistance = .05;
	this.orbitCameraControls.maxDistance = 10;
	this.orbitCameraControls.update();
	this.orbitAnimationOnNextCameraCreation && this.startOrbitAnimation()
};
q.onClick = function(a, b) {
	b = void 0 === b ? !0 : b;
	a && this.selecting || (!this.isDragSequence && b && (a = null != this.nearestPoint ? [this.nearestPoint] : [], this.projectorEventContext.notifySelectionChanged(a)), this.isDragSequence = !1, this.render())
};
q.onMouseDown = function(a) {
	this.isDragSequence = !1;
	this.mouseIsDown = !0;
	this.selecting ? (this.orbitCameraControls.enabled = !1, this.rectangleSelector.onMouseDown(a.offsetX, a.offsetY), this.setNearestPointToMouse(a)) : !a.ctrlKey && this.sceneIs3D() && this.orbitCameraControls.mouseButtons.ORBIT === THREE.MOUSE.RIGHT ? (this.orbitCameraControls.mouseButtons.ORBIT = THREE.MOUSE.LEFT, this.orbitCameraControls.mouseButtons.PAN = THREE.MOUSE.RIGHT) : a.ctrlKey && this.sceneIs3D() && this.orbitCameraControls.mouseButtons.ORBIT ===
		THREE.MOUSE.LEFT && (this.orbitCameraControls.mouseButtons.ORBIT = THREE.MOUSE.RIGHT, this.orbitCameraControls.mouseButtons.PAN = THREE.MOUSE.LEFT)
};
q.onMouseUp = function(a) {
	this.selecting && (this.orbitCameraControls.enabled = !0, this.rectangleSelector.onMouseUp(), this.render());
	this.mouseIsDown = !1
};
q.onMouseMove = function(a) {
	this.isDragSequence = this.mouseIsDown;
	this.selecting && this.mouseIsDown ? (this.rectangleSelector.onMouseMove(a.offsetX, a.offsetY), this.render()) : this.mouseIsDown || (this.setNearestPointToMouse(a), this.projectorEventContext.notifyHoverOverPoint(this.nearestPoint))
};
q.onKeyDown = function(a) {
	17 === a.keyCode && this.sceneIs3D() && (this.orbitCameraControls.mouseButtons.ORBIT = THREE.MOUSE.RIGHT, this.orbitCameraControls.mouseButtons.PAN = THREE.MOUSE.LEFT);
	16 === a.keyCode && (this.selecting = !0, this.containerNode.style.cursor = "crosshair")
};
q.onKeyUp = function(a) {
	17 === a.keyCode && this.sceneIs3D() && (this.orbitCameraControls.mouseButtons.ORBIT = THREE.MOUSE.LEFT, this.orbitCameraControls.mouseButtons.PAN = THREE.MOUSE.RIGHT);
	16 === a.keyCode && (this.selecting = this.getMouseMode() === xp.MouseMode.AREA_SELECT, this.selecting || (this.containerNode.style.cursor = "default"), this.render())
};
q.getPointIndicesFromPickingTexture = function(a) {
	if (null == this.worldSpacePointPositions) return null;
	var b = this.worldSpacePointPositions.length / 3,
		c = window.devicePixelRatio || 1,
		d = Math.floor(a.x * c),
		e = Math.floor(a.y * c),
		f = Math.floor(a.width * c);
	a = Math.floor(a.height * c);
	c = new Uint8Array(f * a * 4);
	this.renderer.readRenderTargetPixels(this.pickingTexture, d, this.pickingTexture.height - e, f, a, c);
	d = new Uint8Array(this.worldSpacePointPositions.length);
	for (e = 0; e < f * a; e++) {
		var g = c[4 * e] << 16 | c[4 * e + 1] << 8 | c[4 * e + 2];
		16777215 !==
			g && g < b && (d[g] = 1)
	}
	b = [];
	for (f = 0; f < d.length; f++) 1 === d[f] && b.push(f);
	return b
};
q.selectBoundingBox = function(a) {
	a = this.getPointIndicesFromPickingTexture(a);
	this.projectorEventContext.notifySelectionChanged(a)
};
q.setNearestPointToMouse = function(a) {
	null == this.pickingTexture ? this.nearestPoint = null : (a = {
		x: a.offsetX,
		y: a.offsetY,
		width: 1,
		height: 1
	}, a = this.getPointIndicesFromPickingTexture(a), this.nearestPoint = null != a ? a[0] : null)
};
q.getLayoutValues = function() {
	this.width = this.containerNode.offsetWidth;
	this.height = Math.max(1, this.containerNode.offsetHeight);
	return [this.width, this.height]
};
q.sceneIs3D = function() {
	return 3 === this.dimensionality
};
q.remove3dAxisFromScene = function() {
	var a = this.scene.getObjectByName("axes");
	null != a && this.scene.remove(a);
	return a
};
q.add3dAxis = function() {
	var a = new THREE.AxisHelper;
	a.name = "axes";
	this.scene.add(a)
};
q.setDimensions = function(a) {
	if (2 !== a && 3 !== a) throw new RangeError("dimensionality must be 2 or 3");
	this.dimensionality = a;
	var b = this.cameraDef || this.makeDefaultCameraDef(a);
	this.recreateCamera(b);
	this.remove3dAxisFromScene();
	3 === a && this.add3dAxis()
};
q.getCameraDef = function() {
	var a = new Dp,
		b = this.camera.position,
		c = this.orbitCameraControls.target;
	a.orthographic = !this.sceneIs3D();
	a.position = [b.x, b.y, b.z];
	a.target = [c.x, c.y, c.z];
	a.zoom = this.camera.zoom;
	return a
};
q.setCameraParametersForNextCameraCreation = function(a, b) {
	this.cameraDef = a;
	this.orbitAnimationOnNextCameraCreation = b
};
q.getCameraPosition = function() {
	var a = this.camera.position;
	return [a.x, a.y, a.z]
};
q.getCameraTarget = function() {
	var a = this.orbitCameraControls.target;
	return [a.x, a.y, a.z]
};
q.setCameraPositionAndTarget = function(a, b) {
	this.stopOrbitAnimation();
	this.camera.position.set(a[0], a[1], a[2]);
	this.orbitCameraControls.target.set(b[0], b[1], b[2]);
	this.orbitCameraControls.update();
	this.render()
};
q.startOrbitAnimation = function() {
	this.sceneIs3D() && (null != this.orbitAnimationId && this.stopOrbitAnimation(), this.orbitCameraControls.autoRotate = !0, this.orbitCameraControls.rotateSpeed = 7, this.updateOrbitAnimation())
};
q.updateOrbitAnimation = function() {
	var a = this;
	this.orbitCameraControls.update();
	this.orbitAnimationId = requestAnimationFrame(function() {
		return a.updateOrbitAnimation()
	})
};
q.stopOrbitAnimation = function() {
	this.orbitCameraControls.autoRotate = !1;
	this.orbitCameraControls.rotateSpeed = 1;
	null != this.orbitAnimationId && (cancelAnimationFrame(this.orbitAnimationId), this.orbitAnimationId = null)
};
q.addVisualizer = function(a) {
	this.scene && a.setScene(this.scene);
	a.onResize(this.width, this.height);
	a.onPointPositionsChanged(this.worldSpacePointPositions);
	this.visualizers.push(a)
};
q.removeAllVisualizers = function() {
	this.visualizers.forEach(function(a) {
		return a.dispose()
	});
	this.visualizers = []
};
q.setPointPositions = function(a) {
	this.worldSpacePointPositions = a;
	this.visualizers.forEach(function(b) {
		return b.onPointPositionsChanged(a)
	})
};
q.render = function() {
	var a = this.camera.position.clone();
	a.x += 1;
	a.y += 1;
	this.light.position.set(a.x, a.y, a.z);
	var a = this.camera instanceof THREE.PerspectiveCamera ? np.CameraType.Perspective : np.CameraType.Orthographic,
		b = [0, 0];
	null != this.worldSpacePointPositions && (b = En(this.worldSpacePointPositions, this.camera.position, this.orbitCameraControls.target));
	var c = new rp(this.camera, a, this.orbitCameraControls.target, this.width, this.height, b[0], b[1], this.backgroundColor, this.pointColors, this.pointScaleFactors,
		this.labels, this.traceColors, this.traceOpacities, this.traceWidths);
	this.visualizers.forEach(function(a) {
		return a.onPickingRender(c)
	});
	a = this.remove3dAxisFromScene();
	this.renderer.render(this.scene, this.camera, this.pickingTexture);
	null != a && this.scene.add(a);
	this.visualizers.forEach(function(a) {
		return a.onRender(c)
	});
	this.renderer.render(this.scene, this.camera)
};
q.setMouseMode = function(a) {
	this.mouseMode = a;
	a === xp.MouseMode.AREA_SELECT ? (this.selecting = !0, this.containerNode.style.cursor = "crosshair") : (this.selecting = !1, this.containerNode.style.cursor = "default")
};
q.setPointColors = function(a) {
	this.pointColors = a
};
q.setPointScaleFactors = function(a) {
	this.pointScaleFactors = a
};
q.setLabels = function(a) {
	this.labels = a
};
q.setTraceColors = function(a) {
	this.traceColors = a
};
q.setTraceOpacities = function(a) {
	this.traceOpacities = a
};
q.setTraceWidths = function(a) {
	this.traceWidths = a
};
q.getMouseMode = function() {
	return this.mouseMode
};
q.resetZoom = function() {
	this.recreateCamera(this.makeDefaultCameraDef(this.dimensionality));
	this.render()
};
q.setDayNightMode = function(a) {
	d3.select(this.containerNode).selectAll("canvas").style("filter", a ? "invert(100%)" : null)
};
q.resize = function(a) {
	a = void 0 === a ? !0 : a;
	var b = F.makeIterator([this.width, this.height]),
		c = b.next().value,
		d = b.next().value,
		b = F.makeIterator(this.getLayoutValues()),
		e = b.next().value,
		f = b.next().value;
	3 === this.dimensionality ? (b = this.camera, b.aspect = e / f) : (b = this.camera, c = e / c, d = f / d, c = (b.right - b.left) * c / 2, d = (b.top - b.bottom) * d / 2, b.top = d, b.bottom = -d, b.left = -c, b.right = c);
	b.updateProjectionMatrix();
	b = window.devicePixelRatio || 1;
	this.renderer.setPixelRatio(b);
	this.renderer.setSize(e, f);
	b = this.renderer.getSize();
	c = this.renderer.getPixelRatio();
	this.pickingTexture = new THREE.WebGLRenderTarget(b.width * c, b.height * c);
	this.pickingTexture.texture.minFilter = THREE.LinearFilter;
	this.visualizers.forEach(function(a) {
		return a.onResize(e, f)
	});
	a && this.render()
};
q.onCameraMove = function(a) {
	this.onCameraMoveListeners.push(a)
};
q.clickOnPoint = function(a) {
	this.nearestPoint = a;
	this.onClick(null, !1)
};
xp.ScatterPlot = Fp;

function Gp() {};
var Hp = {},
	Ip = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/scatterPlotVisualizer3DLabels"
	},
	Jp = function() {};
q = Jp.prototype;
q.createGlyphTexture = function() {
	var a = document.createElement("canvas");
	a.width = 8192;
	a.height = 80;
	var b = a.getContext("2d");
	b.font = "bold 60px roboto";
	b.textBaseline = "top";
	b.fillStyle = "white";
	b.rect(0, 0, a.width, a.height);
	b.fill();
	b.fillStyle = "black";
	for (var c = b.measureText(" ").width, d = new Float32Array(256), e = new Float32Array(256), f = 0, g = 0; 256 > g; g++) {
		var h = " " + String.fromCharCode(g),
			k = b.measureText(h).width;
		d[g] = k - c;
		e[g] = f;
		b.fillText(h, f - c, 0);
		f += k
	}
	a = Fn(a);
	return {
		texture: a,
		lengths: d,
		offsets: e
	}
};
q.processLabelVerts = function(a) {
	var b = 0;
	this.labelVertexMap = [];
	for (var c = 0; c < a; c++) {
		for (var d = this.labelStrings[c], e = [], f = 0; f < d.length; f++) {
			for (var g = 0; 6 > g; g++) e.push(6 * b + g);
			b++
		}
		this.labelVertexMap.push(e)
	}
	this.totalVertexCount = 6 * b
};
q.createColorBuffers = function(a) {
	var b = this;
	this.pickingColors = new Float32Array(3 * this.totalVertexCount);
	this.renderColors = new Float32Array(3 * this.totalVertexCount);
	for (var c = {}, d = 0; d < a; c = {
			color: c.color
		}, d++) c.color = new THREE.Color(d), this.labelVertexMap[d].forEach(function(a) {
		return function(c) {
			b.pickingColors[3 * c] = a.color.r;
			b.pickingColors[3 * c + 1] = a.color.g;
			b.pickingColors[3 * c + 2] = a.color.b;
			b.renderColors[3 * c] = 1;
			b.renderColors[3 * c + 1] = 1;
			b.renderColors[3 * c + 2] = 1
		}
	}(c))
};
q.createLabels = function() {
	var a = this;
	if (null != this.labelStrings && null != this.worldSpacePointPositions) {
		var b = this.worldSpacePointPositions.length / 3;
		if (b === this.labelStrings.length) {
			this.glyphTexture = this.createGlyphTexture();
			this.uniforms = {
				texture: {
					type: "t"
				},
				picking: {
					type: "bool"
				}
			};
			this.material = new THREE.ShaderMaterial({
				uniforms: this.uniforms,
				transparent: !0,
				vertexShader: "\n    attribute vec2 posObj;\n    attribute vec3 color;\n    varying vec2 vUv;\n    varying vec3 vColor;\n\n    void main() {\n      vUv = uv;\n      vColor = color;\n\n      // Rotate label to face camera.\n\n      vec4 vRight = vec4(\n        modelViewMatrix[0][0], modelViewMatrix[1][0], modelViewMatrix[2][0], 0);\n\n      vec4 vUp = vec4(\n        modelViewMatrix[0][1], modelViewMatrix[1][1], modelViewMatrix[2][1], 0);\n\n      vec4 vAt = -vec4(\n        modelViewMatrix[0][2], modelViewMatrix[1][2], modelViewMatrix[2][2], 0);\n\n      mat4 pointToCamera = mat4(vRight, vUp, vAt, vec4(0, 0, 0, 1));\n\n      vec2 scaledPos = posObj * 0.0125 * 2.2;\n\n      vec4 posRotated = pointToCamera * vec4(scaledPos, 0, 1);\n      vec4 mvPosition = modelViewMatrix * (vec4(position, 0) + posRotated);\n      gl_Position = projectionMatrix * mvPosition;\n    }",
				fragmentShader: "\n    uniform sampler2D texture;\n    uniform bool picking;\n    varying vec2 vUv;\n    varying vec3 vColor;\n\n    void main() {\n      if (picking) {\n        gl_FragColor = vec4(vColor, 1.0);\n      } else {\n        vec4 fromTexture = texture2D(texture, vUv);\n        gl_FragColor = vec4(vColor, 1.0) * fromTexture;\n      }\n    }"
			});
			this.processLabelVerts(b);
			this.createColorBuffers(b);
			var c = new Float32Array(3 * this.totalVertexCount);
			this.positions = new THREE.BufferAttribute(c, 3);
			var c = new Float32Array(3 * this.totalVertexCount),
				d = new Float32Array(2 * this.totalVertexCount),
				e = new Float32Array(3 * this.totalVertexCount),
				c = new THREE.BufferAttribute(c, 2),
				d = new THREE.BufferAttribute(d, 2),
				e = new THREE.BufferAttribute(e, 3);
			this.geometry = new THREE.BufferGeometry;
			this.geometry.addAttribute("posObj", c);
			this.geometry.addAttribute("position", this.positions);
			this.geometry.addAttribute("uv", d);
			this.geometry.addAttribute("color", e);
			for (var f = e = 0; f < b; f++) {
				for (var g = this.labelStrings[f], h = 0, k = 0; k <
					g.length; k++) var l = g.charCodeAt(k),
					h = h + this.glyphTexture.lengths[l];
				h /= -2;
				for (k = 0; k < g.length; k++) {
					var m = g.charCodeAt(k),
						l = this.glyphTexture.lengths[m],
						n = 80,
						r = (h + l) / n,
						t = h / n,
						n = 80 / n;
					c.setXY(6 * e + 0, t, 0);
					c.setXY(6 * e + 1, r, 0);
					c.setXY(6 * e + 2, t, n);
					c.setXY(6 * e + 3, t, n);
					c.setXY(6 * e + 4, r, 0);
					c.setXY(6 * e + 5, r, n);
					r = this.glyphTexture.offsets[m];
					m = this.glyphTexture.offsets[m] + l;
					r /= 8192;
					m /= 8192;
					t = 1;
					n = 0;
					d.setXY(6 * e + 0, r, t);
					d.setXY(6 * e + 1, m, t);
					d.setXY(6 * e + 2, r, n);
					d.setXY(6 * e + 3, r, n);
					d.setXY(6 * e + 4, m, t);
					d.setXY(6 * e + 5, m, n);
					e++;
					h +=
						l
				}
			}
			c = {};
			for (d = 0; d < b; c = {
					p$34: c.p$34
				}, d++) c.p$34 = Dn(this.worldSpacePointPositions, d), this.labelVertexMap[d].forEach(function(b) {
				return function(c) {
					a.positions.setXYZ(c, b.p$34.x, b.p$34.y, b.p$34.z)
				}
			}(c));
			this.labelsMesh = new THREE.Mesh(this.geometry, this.material);
			this.labelsMesh.frustumCulled = !1;
			this.scene.add(this.labelsMesh)
		}
	}
};
q.colorLabels = function(a) {
	if (null != this.labelStrings && null != this.geometry && null != a) {
		var b = this.geometry.getAttribute("color");
		b.array = this.renderColors;
		for (var c = a.length / 3, d = 0, e = 0; e < c; ++e) {
			for (var f = new THREE.Color(a[d], a[d + 1], a[d + 2]), g = this.labelVertexMap[e].length, h = 0; h < g; ++h) b.setXYZ(this.labelVertexMap[e][h], f.r, f.g, f.b);
			d += 3
		}
		b.needsUpdate = !0
	}
};
q.setScene = function(a) {
	this.scene = a
};
q.dispose = function() {
	this.labelsMesh && (this.scene && this.scene.remove(this.labelsMesh), this.labelsMesh = null);
	this.geometry && (this.geometry.dispose(), this.geometry = null);
	null != this.glyphTexture && null != this.glyphTexture.texture && (this.glyphTexture.texture.dispose(), this.glyphTexture.texture = null)
};
q.onPickingRender = function(a) {
	null == this.geometry && this.createLabels();
	null != this.geometry && (this.material.uniforms.texture.value = this.glyphTexture.texture, this.material.uniforms.picking.value = !0, a = this.geometry.getAttribute("color"), a.array = this.pickingColors, a.needsUpdate = !0)
};
q.onRender = function(a) {
	null == this.geometry && this.createLabels();
	null != this.geometry && (this.colorLabels(a.pointColors), this.material.uniforms.texture.value = this.glyphTexture.texture, this.material.uniforms.picking.value = !1, a = this.geometry.getAttribute("color"), a.array = this.renderColors, a.needsUpdate = !0)
};
q.onPointPositionsChanged = function(a) {
	this.worldSpacePointPositions = a;
	this.dispose()
};
q.setLabelStrings = function(a) {
	this.labelStrings = a;
	this.dispose()
};
q.onResize = function(a, b) {};
Hp.ScatterPlotVisualizer3DLabels = Jp;

function Kp() {};
var Lp = {},
	Mp = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/scatterPlotVisualizerCanvasLabels"
	},
	Np = function(a) {
		this.labelsActive = !0;
		this.canvas = a.append("canvas").node();
		this.gc = this.canvas.getContext("2d");
		d3.select(this.canvas).style({
			position: "absolute",
			left: 0,
			top: 0
		});
		this.canvas.style.pointerEvents = "none"
	};
q = Np.prototype;
q.removeAllLabels = function() {
	var a = this.canvas.width * window.devicePixelRatio,
		b = this.canvas.height * window.devicePixelRatio;
	this.gc.clearRect(0, 0, a, b)
};
q.makeLabels = function(a) {
	if (null != a.labels && 0 !== a.labels.pointIndices.length && null != this.worldSpacePointPositions) {
		var b = a.labels,
			c = a.cameraType === np.CameraType.Perspective,
			d = parseInt(this.gc.font, 10),
			e = window.devicePixelRatio,
			f;
		f = this.canvas.width * e;
		var g = this.canvas.height * e,
			h = {
				loX: 0,
				hiX: f,
				loY: 0,
				hiY: g
			};
		f = new jp(h, f / 25, g / 50);
		var g = d3.scale.pow().exponent(Math.E).domain([a.farthestCameraSpacePointZ, a.nearestCameraSpacePointZ]).range([.1, 1]),
			h = a.camera.position,
			k = h.clone().sub(a.cameraTarget),
			l = new THREE.Vector3;
		this.gc.textBaseline = "middle";
		this.gc.miterLimit = 2;
		for (var m = Math.min(1E4, b.pointIndices.length), n = 0; n < m; ++n) {
			var r = void 0,
				r = b.pointIndices[n],
				r = Dn(this.worldSpacePointPositions, r);
			l.copy(h).sub(r);
			if (!(0 > k.dot(l))) {
				var t = F.makeIterator(Cn(a.camera, a.screenWidth, a.screenHeight, r)),
					r = t.next().value,
					t = t.next().value,
					r = r + 4,
					u = {
						loX: r - 2,
						hiX: r + 1 + 2,
						loY: t - d / 2 - 2,
						hiY: t + d / 2 + 2
					};
				if (f.insert(u, !0)) {
					var w = b.labelStrings[n],
						v = b.defaultFontSize * b.scaleFactors[n] * e;
					this.gc.font = v + "px roboto";
					u.hiX += this.gc.measureText(w).width -
						1;
					f.insert(u) && (u = 1, c && 1 === b.useSceneOpacityFlags[n] && (u = g(l.length())), this.gc.fillStyle = this.styleStringFromPackedRgba(b.fillColors, n, u), this.gc.strokeStyle = this.styleStringFromPackedRgba(b.strokeColors, n, u), this.gc.lineWidth = 3, this.gc.strokeText(w, r, t), this.gc.lineWidth = 6, this.gc.fillText(w, r, t))
				}
			}
		}
	}
};
q.styleStringFromPackedRgba = function(a, b, c) {
	var d = 3 * b;
	b = a[d];
	var e = a[d + 1];
	a = a[d + 2];
	return "rgba(" + b + "," + e + "," + a + "," + c + ")"
};
q.onResize = function(a, b) {
	var c = window.devicePixelRatio;
	d3.select(this.canvas).attr("width", a * c).attr("height", b * c).style({
		width: a + "px",
		height: b + "px"
	})
};
q.dispose = function() {
	this.removeAllLabels();
	this.gc = this.canvas = null
};
q.onPointPositionsChanged = function(a) {
	this.worldSpacePointPositions = a;
	this.removeAllLabels()
};
q.onRender = function(a) {
	this.labelsActive && (this.removeAllLabels(), this.makeLabels(a))
};
q.setScene = function(a) {};
q.onPickingRender = function(a) {};
Lp.ScatterPlotVisualizerCanvasLabels = Np;

function Op() {};
var Pp = {},
	Qp = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/scatterPlotVisualizerSprites"
	},
	Rp = "\n  // Index of the specific vertex (passed in as bufferAttribute), and the\n  // variable that will be used to pass it to the fragment shader.\n  attribute float spriteIndex;\n  attribute vec3 color;\n  attribute float scaleFactor;\n\n  varying vec2 xyIndex;\n  varying vec3 vColor;\n\n  uniform bool sizeAttenuation;\n  uniform float pointSize;\n  uniform float spritesPerRow;\n  uniform float spritesPerColumn;\n\n  void main() {\n    // Pass index and color values to fragment shader.\n    vColor = color;\n    xyIndex = vec2(mod(spriteIndex, spritesPerRow),\n              floor(spriteIndex / spritesPerColumn));\n\n    // Transform current vertex by modelViewMatrix (model world position and\n    // camera world position matrix).\n    vec4 cameraSpacePos = modelViewMatrix * vec4(position, 1.0);\n\n    // Project vertex in camera-space to screen coordinates using the camera's\n    // projection matrix.\n    gl_Position = projectionMatrix * cameraSpacePos;\n\n    // Create size attenuation (if we're in 3D mode) by making the size of\n    // each point inversly proportional to its distance to the camera.\n    float outputPointSize = pointSize;\n    if (sizeAttenuation) {\n      outputPointSize = -pointSize / cameraSpacePos.z;\n    }\n\n    gl_PointSize =\n      max(outputPointSize * scaleFactor, " +
	(5).toFixed(1) + ");\n  }",
	Sp = "\n  varying vec2 xyIndex;\n  varying vec3 vColor;\n\n  uniform sampler2D texture;\n  uniform float spritesPerRow;\n  uniform float spritesPerColumn;\n  uniform bool isImage;\n\n  " + THREE.ShaderChunk.common + "\n  " + THREE.ShaderChunk.fog_pars_fragment + "\n  \n  bool point_in_unit_circle(vec2 spriteCoord) {\n    vec2 centerToP = spriteCoord - vec2(0.5, 0.5);\n    return dot(centerToP, centerToP) < (0.5 * 0.5);\n  }\n\n  bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {\n    vec3 v0 = vec3(0, 1, 0);\n    vec3 v1 = vec3(0.5, 0, 0);\n    vec3 v2 = vec3(1, 1, 0);\n    vec3 p = vec3(spriteCoord, 0);\n    float p_in_v0_v1 = cross(v1 - v0, p - v0).z;\n    float p_in_v1_v2 = cross(v2 - v1, p - v1).z;\n    return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);\n  }\n\n  bool point_in_unit_square(vec2 spriteCoord) {\n    return true;\n  }\n\n\n  void main() {\n    if (isImage) {\n      // Coordinates of the vertex within the entire sprite image.\n      vec2 coords =\n        (gl_PointCoord + xyIndex) / vec2(spritesPerRow, spritesPerColumn);\n      gl_FragColor = vec4(vColor, 1.0) * texture2D(texture, coords);\n    } else {\n      bool inside = point_in_unit_circle(gl_PointCoord);\n      if (!inside) {\n        discard;\n      }\n      gl_FragColor = vec4(vColor, 1);\n    }\n    " +
	THREE.ShaderChunk.fog_fragment + "\n  }",
	Tp = function() {
		this.texture = null;
		this.standinTextureForPoints = Fn(document.createElement("canvas"));
		this.renderMaterial = this.createRenderMaterial(!1);
		this.pickingMaterial = this.createPickingMaterial(!1)
	};
q = Tp.prototype;
q.createTextureFromSpriteAtlas = function(a, b, c) {
	this.texture = Fn(a);
	this.spritesPerRow = a.width / b[0];
	this.spritesPerColumn = a.height / b[1];
	this.spriteIndexBufferAttribute = new THREE.BufferAttribute(c, 1);
	null != this.points && this.points.geometry.addAttribute("spriteIndex", this.spriteIndexBufferAttribute)
};
q.createUniforms = function() {
	return {
		texture: {
			type: "t"
		},
		spritesPerRow: {
			type: "f"
		},
		spritesPerColumn: {
			type: "f"
		},
		fogColor: {
			type: "c"
		},
		fogNear: {
			type: "f"
		},
		fogFar: {
			type: "f"
		},
		isImage: {
			type: "bool"
		},
		sizeAttenuation: {
			type: "bool"
		},
		pointSize: {
			type: "f"
		}
	}
};
q.createRenderMaterial = function(a) {
	var b = this.createUniforms();
	return new THREE.ShaderMaterial({
		uniforms: b,
		vertexShader: Rp,
		fragmentShader: Sp,
		transparent: !a,
		depthTest: a,
		depthWrite: a,
		fog: !0,
		blending: THREE.MultiplyBlending
	})
};
q.createPickingMaterial = function(a) {
	a = this.createUniforms();
	return new THREE.ShaderMaterial({
		uniforms: a,
		vertexShader: Rp,
		fragmentShader: "\n  varying vec2 xyIndex;\n  varying vec3 vColor;\n  uniform bool isImage;\n\n  \n  bool point_in_unit_circle(vec2 spriteCoord) {\n    vec2 centerToP = spriteCoord - vec2(0.5, 0.5);\n    return dot(centerToP, centerToP) < (0.5 * 0.5);\n  }\n\n  bool point_in_unit_equilateral_triangle(vec2 spriteCoord) {\n    vec3 v0 = vec3(0, 1, 0);\n    vec3 v1 = vec3(0.5, 0, 0);\n    vec3 v2 = vec3(1, 1, 0);\n    vec3 p = vec3(spriteCoord, 0);\n    float p_in_v0_v1 = cross(v1 - v0, p - v0).z;\n    float p_in_v1_v2 = cross(v2 - v1, p - v1).z;\n    return (p_in_v0_v1 > 0.0) && (p_in_v1_v2 > 0.0);\n  }\n\n  bool point_in_unit_square(vec2 spriteCoord) {\n    return true;\n  }\n\n\n  void main() {\n    xyIndex; // Silence 'unused variable' warning.\n    if (isImage) {\n      gl_FragColor = vec4(vColor, 1);\n    } else {\n      bool inside = point_in_unit_circle(gl_PointCoord);\n      if (!inside) {\n        discard;\n      }\n      gl_FragColor = vec4(vColor, 1);\n    }\n  }",
		transparent: !0,
		depthTest: !0,
		depthWrite: !0,
		fog: !1,
		blending: THREE.NormalBlending
	})
};
q.createPointSprites = function(a, b) {
	b = null != b ? b.length / 3 : 0;
	b = this.createGeometry(b);
	this.fog = new THREE.Fog(16777215);
	this.points = new THREE.Points(b, this.renderMaterial);
	this.points.frustumCulled = !1;
	null != this.spriteIndexBufferAttribute && this.points.geometry.addAttribute("spriteIndex", this.spriteIndexBufferAttribute);
	a.add(this.points)
};
q.calculatePointSize = function(a) {
	if (null != this.texture) return 30;
	var b = null != this.worldSpacePointPositions ? this.worldSpacePointPositions.length / 3 : 1,
		b = 200 / Math.log(b) / Math.log(8);
	return a ? b : b / 1.5
};
q.createGeometry = function(a) {
	this.pickingColors = new Float32Array(3 * a);
	for (var b = 0, c = 0; c < a; c++) {
		var d = new THREE.Color(c);
		this.pickingColors[b++] = d.r;
		this.pickingColors[b++] = d.g;
		this.pickingColors[b++] = d.b
	}
	a = new THREE.BufferGeometry;
	a.addAttribute("position", new THREE.BufferAttribute(null, 3));
	a.addAttribute("color", new THREE.BufferAttribute(null, 3));
	a.addAttribute("scaleFactor", new THREE.BufferAttribute(null, 1));
	return a
};
q.setFogDistances = function(a, b, c) {
	a ? (a = this.worldSpacePointPositions.length / 3, this.fog.near = b, b = 2 - Math.min(a, 5E3) / 5E3, this.fog.far = c * b) : (this.fog.near = Infinity, this.fog.far = Infinity)
};
q.dispose = function() {
	this.disposeGeometry();
	this.disposeTextureAtlas()
};
q.disposeGeometry = function() {
	null != this.points && (this.scene.remove(this.points), this.points.geometry.dispose(), this.worldSpacePointPositions = this.points = null)
};
q.disposeTextureAtlas = function() {
	null != this.texture && this.texture.dispose();
	this.pickingMaterial = this.renderMaterial = this.texture = null
};
q.setScene = function(a) {
	this.scene = a
};
q.setSpriteAtlas = function(a, b, c) {
	this.disposeTextureAtlas();
	this.createTextureFromSpriteAtlas(a, b, c);
	this.renderMaterial = this.createRenderMaterial(!0);
	this.pickingMaterial = this.createPickingMaterial(!0)
};
q.clearSpriteAtlas = function() {
	this.disposeTextureAtlas();
	this.renderMaterial = this.createRenderMaterial(!1);
	this.pickingMaterial = this.createPickingMaterial(!1)
};
q.onPointPositionsChanged = function(a) {
	if (null == a || 0 === a.length) this.dispose();
	else {
		null != this.points && this.worldSpacePointPositions.length !== a.length && this.disposeGeometry();
		this.worldSpacePointPositions = a;
		null == this.points && this.createPointSprites(this.scene, a);
		var b = this.points.geometry.getAttribute("position");
		b.array = a;
		b.needsUpdate = !0
	}
};
q.onPickingRender = function(a) {
	if (null != this.points) {
		var b = a.cameraType === np.CameraType.Perspective;
		this.pickingMaterial.uniforms.spritesPerRow.value = this.spritesPerRow;
		this.pickingMaterial.uniforms.spritesPerRow.value = this.spritesPerColumn;
		this.pickingMaterial.uniforms.sizeAttenuation.value = b;
		this.pickingMaterial.uniforms.pointSize.value = this.calculatePointSize(b);
		this.points.material = this.pickingMaterial;
		b = this.points.geometry.getAttribute("color");
		b.array = this.pickingColors;
		b.needsUpdate = !0;
		b = this.points.geometry.getAttribute("scaleFactor");
		b.array = a.pointScaleFactors;
		b.needsUpdate = !0
	}
};
q.onRender = function(a) {
	if (this.points) {
		var b = a.camera instanceof THREE.PerspectiveCamera;
		this.setFogDistances(b, a.nearestCameraSpacePointZ, a.farthestCameraSpacePointZ);
		this.scene.fog = this.fog;
		this.scene.fog.color = new THREE.Color(a.backgroundColor);
		this.renderMaterial.uniforms.fogColor.value = this.scene.fog.color;
		this.renderMaterial.uniforms.fogNear.value = this.fog.near;
		this.renderMaterial.uniforms.fogFar.value = this.fog.far;
		this.renderMaterial.uniforms.spritesPerRow.value = this.spritesPerRow;
		this.renderMaterial.uniforms.spritesPerColumn.value =
			this.spritesPerColumn;
		this.renderMaterial.uniforms.isImage.value = null != this.texture;
		this.renderMaterial.uniforms.texture.value = null != this.texture ? this.texture : this.standinTextureForPoints;
		this.renderMaterial.uniforms.sizeAttenuation.value = b;
		this.renderMaterial.uniforms.pointSize.value = this.calculatePointSize(b);
		this.points.material = this.renderMaterial;
		b = this.points.geometry.getAttribute("color");
		this.renderColors = a.pointColors;
		b.array = this.renderColors;
		b.needsUpdate = !0;
		b = this.points.geometry.getAttribute("scaleFactor");
		b.array = a.pointScaleFactors;
		b.needsUpdate = !0
	}
};
q.onResize = function(a, b) {};
Pp.ScatterPlotVisualizerSprites = Tp;

function Up() {};
var Vp = {},
	Wp = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/scatterPlotVisualizerTraces"
	},
	Xp = function() {
		this.tracePositionBuffer = {};
		this.traceColorBuffer = {}
	};
q = Xp.prototype;
q.updateTraceIndicesInDataSet = function(a) {
	for (var b = 0; b < a.traces.length; b++)
		for (var c = a.traces[b], d = 0; d < c.pointIndices.length - 1; d++) a.points[c.pointIndices[d]].traceIndex = b, a.points[c.pointIndices[d + 1]].traceIndex = b
};
q.createTraces = function(a) {
	if (this.dataSet && this.dataSet.traces) {
		this.updateTraceIndicesInDataSet(this.dataSet);
		this.traces = [];
		for (var b = 0; b < this.dataSet.traces.length; b++) {
			var c = new THREE.BufferGeometry;
			c.addAttribute("position", this.tracePositionBuffer[b]);
			c.addAttribute("color", this.traceColorBuffer[b]);
			var d = new THREE.LineBasicMaterial({
					linewidth: 1,
					opacity: 1,
					transparent: !0,
					vertexColors: THREE.VertexColors
				}),
				c = new THREE.LineSegments(c, d);
			c.frustumCulled = !1;
			this.traces.push(c);
			a.add(c)
		}
	}
};
q.dispose = function() {
	if (null != this.traces) {
		for (var a = 0; a < this.traces.length; a++) this.scene.remove(this.traces[a]), this.traces[a].geometry.dispose();
		this.traces = null;
		this.tracePositionBuffer = {};
		this.traceColorBuffer = {}
	}
};
q.setScene = function(a) {
	this.scene = a
};
q.setDataSet = function(a) {
	this.dataSet = a
};
q.onPointPositionsChanged = function(a) {
	null != a && null == this.traces || this.dispose();
	if (null != a && null != this.dataSet) {
		for (var b = 0; b < this.dataSet.traces.length; b++) {
			var c = this.dataSet.traces[b],
				c = 2 * (c.pointIndices.length - 1),
				d = new Float32Array(3 * c);
			this.tracePositionBuffer[b] = new THREE.BufferAttribute(d, 3);
			c = new Float32Array(3 * c);
			this.traceColorBuffer[b] = new THREE.BufferAttribute(c, 3)
		}
		for (b = 0; b < this.dataSet.traces.length; b++) {
			for (var c = this.dataSet.traces[b], e = d = 0; e < c.pointIndices.length - 1; e++) {
				var f = c.pointIndices[e],
					g = c.pointIndices[e + 1],
					f = Dn(a, f),
					g = Dn(a, g);
				this.tracePositionBuffer[b].setXYZ(d, f.x, f.y, f.z);
				this.tracePositionBuffer[b].setXYZ(d + 1, g.x, g.y, g.z);
				d += 2
			}
			this.tracePositionBuffer[b].needsUpdate = !0
		}
		null == this.traces && this.createTraces(this.scene)
	}
};
q.onRender = function(a) {
	if (null != this.traces)
		for (var b = 0; b < this.traces.length; b++) this.traces[b].material.opacity = a.traceOpacities[b], this.traces[b].material.linewidth = a.traceWidths[b], this.traceColorBuffer[b].array = a.traceColors[b], this.traceColorBuffer[b].needsUpdate = !0
};
q.onPickingRender = function(a) {};
q.onResize = function(a, b) {};
Vp.ScatterPlotVisualizerTraces = Xp;

function Yp() {};
var Zp = {},
	$p = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/projectorScatterPlotAdapter"
	},
	aq = d3.scale.linear().domain([1, .7, .4]).range(["hsl(285, 80%, 40%)", "hsl(0, 80%, 65%)", "hsl(40, 70%, 60%)"]).clamp(!0),
	bq = function(a, b) {
		var c = this;
		this.renderLabelsIn3D = !1;
		this.scatterPlot = new Fp(a, b);
		this.scatterPlotContainer = a;
		b.registerProjectionChangedListener(function(a) {
			c.projection = a;
			c.updateScatterPlotWithNewProjection(a)
		});
		b.registerSelectionChangedListener(function(a, b) {
			c.selectedPointIndices =
				a;
			c.neighborsOfFirstSelectedPoint = b;
			c.updateScatterPlotPositions();
			c.updateScatterPlotAttributes();
			c.scatterPlot.render()
		});
		b.registerHoverListener(function(a) {
			c.hoverPointIndex = a;
			c.updateScatterPlotAttributes();
			c.scatterPlot.render()
		});
		b.registerDistanceMetricChangedListener(function(a) {
			c.distanceMetric = a;
			c.updateScatterPlotAttributes();
			c.scatterPlot.render()
		});
		this.createVisualizers(!1)
	};
q = bq.prototype;
q.notifyProjectionPositionsUpdated = function() {
	this.updateScatterPlotPositions();
	this.scatterPlot.render()
};
q.setDataSet = function(a) {
	null != this.projection && (this.projection.dataSet = a);
	null != this.traceVisualizer && this.traceVisualizer.setDataSet(a);
	null != this.labels3DVisualizer && this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray(a, this.labelPointAccessor));
	if (null != this.spriteVisualizer && (this.spriteVisualizer.clearSpriteAtlas(), null != a && null != a.spriteAndMetadataInfo)) {
		var b = a.spriteAndMetadataInfo;
		if (null != b.spriteImage && null != b.spriteMetadata) {
			for (var c = a.points.length, d = new Float32Array(c),
					e = 0; e < c; ++e) d[e] = a.points[e].index;
			this.spriteVisualizer.setSpriteAtlas(b.spriteImage, b.spriteMetadata.singleImageDim, d)
		}
	}
};
q.set3DLabelMode = function(a) {
	this.renderLabelsIn3D = a;
	this.createVisualizers(a);
	this.updateScatterPlotAttributes();
	this.scatterPlot.render()
};
q.setLegendPointColorer = function(a) {
	this.legendPointColorer = a
};
q.setLabelPointAccessor = function(a) {
	this.labelPointAccessor = a;
	if (null != this.labels3DVisualizer) {
		var b = null == this.projection ? null : this.projection.dataSet;
		this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray(b, a))
	}
};
q.resize = function() {
	this.scatterPlot.resize()
};
q.populateBookmarkFromUI = function(a) {
	a.cameraDef = this.scatterPlot.getCameraDef()
};
q.restoreUIFromBookmark = function(a) {
	this.scatterPlot.setCameraParametersForNextCameraCreation(a.cameraDef, !1)
};
q.updateScatterPlotPositions = function() {
	var a = null == this.projection ? null : this.projection.dataSet,
		b = null == this.projection ? null : this.projection.projectionComponents,
		a = this.generatePointPositionArray(a, b);
	this.scatterPlot.setPointPositions(a)
};
q.updateScatterPlotAttributes = function() {
	if (null != this.projection) {
		var a = this.projection.dataSet,
			b = this.selectedPointIndices,
			c = this.hoverPointIndex,
			d = this.neighborsOfFirstSelectedPoint,
			e = this.legendPointColorer,
			f = this.generatePointColorArray(a, e, this.distanceMetric, b, d, c, this.renderLabelsIn3D, this.getSpriteImageMode()),
			g = this.generatePointScaleFactorArray(a, b, d, c),
			c = this.generateVisibleLabelRenderParams(a, b, d, c),
			e = this.generateLineSegmentColorMap(a, e),
			d = this.generateLineSegmentOpacityArray(a, b),
			a =
			this.generateLineSegmentWidthArray(a, b);
		this.scatterPlot.setPointColors(f);
		this.scatterPlot.setPointScaleFactors(g);
		this.scatterPlot.setLabels(c);
		this.scatterPlot.setTraceColors(e);
		this.scatterPlot.setTraceOpacities(d);
		this.scatterPlot.setTraceWidths(a)
	}
};
q.render = function() {
	this.scatterPlot.render()
};
q.generatePointPositionArray = function(a, b) {
	if (null == a) return null;
	var c = d3.scale.linear(),
		d = d3.scale.linear(),
		e = null,
		f = d3.extent(a.points, function(c, d) {
			return a.points[d].projections[b[0]]
		}),
		g = d3.extent(a.points, function(c, d) {
			return a.points[d].projections[b[1]]
		}),
		h = [-1, 1];
	c.domain(f).range(h);
	d.domain(g).range(h);
	null != b[2] && (f = d3.extent(a.points, function(c, d) {
		return a.points[d].projections[b[2]]
	}), e = d3.scale.linear(), e.domain(f).range(h));
	var k = new Float32Array(3 * a.points.length),
		l = 0;
	a.points.forEach(function(e,
		f) {
		k[l++] = c(a.points[f].projections[b[0]]);
		k[l++] = d(a.points[f].projections[b[1]]);
		k[l++] = 0
	});
	e && (l = 2, a.points.forEach(function(c, d) {
		k[l] = e(a.points[d].projections[b[2]]);
		l += 3
	}));
	return k
};
q.generateVisibleLabelRenderParams = function(a, b, c, d) {
	if (null == a) return null;
	var e = null == b ? 0 : b.length,
		f = null == c ? 0 : c.length,
		g = e + f + (null != d ? 1 : 0),
		h = new Uint32Array(g),
		k = new Float32Array(g),
		l = new Int8Array(g),
		m = new Uint8Array(3 * g),
		g = new Uint8Array(3 * g),
		n = [];
	k.fill(1);
	l.fill(1);
	var r = 0;
	null != d && (n.push(this.getLabelText(a, d, this.labelPointAccessor)), h[r] = d, k[r] = 2, l[r] = 0, d = cq(0), dq(m, r, d[0], d[1], d[2]), d = cq(16777215), dq(g, r, d[0], d[1], d[1]), ++r);
	d = cq(0);
	for (var t = cq(16777215), u = 0; u < e; ++u) {
		var w = b[u];
		n.push(this.getLabelText(a,
			w, this.labelPointAccessor));
		h[r] = w;
		k[r] = 2;
		l[r] = 1 === e ? 0 : 1;
		dq(m, r, d[0], d[1], d[2]);
		dq(g, r, t[0], t[1], t[2]);
		++r
	}
	b = f;
	f = cq(0);
	e = cq(16777215);
	for (d = 0; d < b; ++d) t = c[d].index, n.push(this.getLabelText(a, t, this.labelPointAccessor)), h[r] = t, dq(m, r, f[0], f[1], f[2]), dq(g, r, e[0], e[1], e[2]), ++r;
	return new pp(h, n, k, l, 10, m, g)
};
q.generatePointScaleFactorArray = function(a, b, c, d) {
	if (null == a) return new Float32Array(0);
	a = new Float32Array(a.points.length);
	a.fill(1);
	for (var e = null == b ? 0 : b.length, f = null == c ? 0 : c.length, g = 0; g < e; ++g) {
		var h = b[g];
		a[h] = 1.2
	}
	b = f;
	for (f = 0; f < b; ++f) e = c[f].index, a[e] = 1.2;
	null != d && (a[d] = 1.2);
	return a
};
q.generateLineSegmentColorMap = function(a, b) {
	var c = {};
	if (null == a) return c;
	for (var d = 0; d < a.traces.length; d++) {
		var e = a.traces[d],
			f = new Float32Array(6 * (e.pointIndices.length - 1)),
			g = 0;
		if (b)
			for (var h = 0; h < e.pointIndices.length - 1; h++) {
				var k = new THREE.Color(b(a, e.pointIndices[h])),
					l = new THREE.Color(b(a, e.pointIndices[h + 1]));
				f[g++] = k.r;
				f[g++] = k.g;
				f[g++] = k.b;
				f[g++] = l.r;
				f[g++] = l.g;
				f[g++] = l.b
			} else
				for (h = 0; h < e.pointIndices.length - 1; h++) k = eq(h, e.pointIndices.length), l = eq(h + 1, e.pointIndices.length), f[g++] = k.r, f[g++] =
					k.g, f[g++] = k.b, f[g++] = l.r, f[g++] = l.g, f[g++] = l.b;
		c[d] = f
	}
	return c
};
q.generateLineSegmentOpacityArray = function(a, b) {
	if (null == a) return new Float32Array(0);
	var c = new Float32Array(a.traces.length),
		d = null == b ? 0 : b.length;
	0 < d ? (c.fill(.05), a = a.points[b[0]].traceIndex, c[a] = .9) : c.fill(.2);
	return c
};
q.generateLineSegmentWidthArray = function(a, b) {
	if (null == a) return new Float32Array(0);
	var c = new Float32Array(a.traces.length);
	c.fill(2);
	var d = null == b ? 0 : b.length;
	0 < d && (a = a.points[b[0]].traceIndex, c[a] = 3);
	return c
};
q.generatePointColorArray = function(a, b, c, d, e, f, g, h) {
	if (null == a) return new Float32Array(0);
	var k = null == d ? 0 : d.length,
		l = null == e ? 0 : e.length,
		m = new Float32Array(3 * a.points.length),
		n = 14935011,
		r = 7697881;
	g && (r = n = 16777215);
	h && (r = n = 16777215);
	g = a.points.length;
	h = 0;
	if (0 < k)
		for (a = new THREE.Color(n), b = 0; b < g; ++b) m[h++] = a.r, m[h++] = a.g, m[h++] = a.b;
	else if (null != b)
		for (n = 0; n < g; ++n) r = new THREE.Color(b(a, n)), m[h++] = r.r, m[h++] = r.g, m[h++] = r.b;
	else
		for (a = new THREE.Color(r), b = 0; b < g; ++b) m[h++] = a.r, m[h++] = a.g, m[h++] = a.b;
	g = new THREE.Color(16410214);
	for (h = 0; h < k; ++h) a = 3 * d[h], m[a++] = g.r, m[a++] = g.g, m[a++] = g.b;
	d = l;
	l = 0 < d ? e[0].dist : 0;
	for (k = 0; k < d; ++k) g = new THREE.Color(fq(c, e[k].dist, l)), h = 3 * e[k].index, m[h++] = g.r, m[h++] = g.g, m[h++] = g.b;
	null != f && (c = new THREE.Color(7736143), f *= 3, m[f++] = c.r, m[f++] = c.g, m[f++] = c.b);
	return m
};
q.generate3DLabelsArray = function(a, b) {
	if (null == a || null == b) return null;
	for (var c = [], d = a.points.length, e = 0; e < d; ++e) c.push(this.getLabelText(a, e, b));
	return c
};
q.getLabelText = function(a, b, c) {
	return a.points[b].metadata[c].toString()
};
q.updateScatterPlotWithNewProjection = function(a) {
	null == a ? (this.createVisualizers(this.renderLabelsIn3D), this.scatterPlot.render()) : (this.setDataSet(a.dataSet), this.scatterPlot.setDimensions(a.dimensionality), a.dataSet.projectionCanBeRendered(a.projectionType) && (this.updateScatterPlotAttributes(), this.notifyProjectionPositionsUpdated()), this.scatterPlot.setCameraParametersForNextCameraCreation(null, !1))
};
q.createVisualizers = function(a) {
	var b = null == this.projection ? null : this.projection.dataSet,
		c = this.scatterPlot;
	c.removeAllVisualizers();
	this.traceVisualizer = this.spriteVisualizer = this.canvasLabelsVisualizer = this.labels3DVisualizer = null;
	a ? (this.labels3DVisualizer = new Jp, this.labels3DVisualizer.setLabelStrings(this.generate3DLabelsArray(b, this.labelPointAccessor))) : (this.spriteVisualizer = new Tp, c.addVisualizer(this.spriteVisualizer), this.canvasLabelsVisualizer = new Np(this.scatterPlotContainer));
	this.traceVisualizer =
		new Xp;
	this.setDataSet(b);
	this.spriteVisualizer && c.addVisualizer(this.spriteVisualizer);
	this.labels3DVisualizer && c.addVisualizer(this.labels3DVisualizer);
	this.canvasLabelsVisualizer && c.addVisualizer(this.canvasLabelsVisualizer);
	c.addVisualizer(this.traceVisualizer)
};
q.getSpriteImageMode = function() {
	if (null == this.projection) return !1;
	var a = this.projection.dataSet;
	return null == a || null == a.spriteAndMetadataInfo ? !1 : null != a.spriteAndMetadataInfo.spriteImage
};
Zp.ProjectorScatterPlotAdapter = bq;

function gq() {}

function dq(a, b, c, d, e) {
	a[3 * b] = c;
	a[3 * b + 1] = d;
	a[3 * b + 2] = e
}

function cq(a) {
	a = new THREE.Color(a);
	return [255 * a.r | 0, 255 * a.g | 0, 255 * a.b | 0]
}

function eq(a, b) {
	a = 60 + 300 * a / b;
	a = d3.hsl(a, 1, .3).rgb();
	return new THREE.Color(a.r / 255, a.g / 255, a.b / 255)
}

function hq(a, b, c) {
	return a === ao ? c / b : 1 - b
}
Zp.normalizeDist = hq;

function fq(a, b, c) {
	return aq(hq(a, b, c))
}
Zp.dist2color = fq;
var iq = {},
	jq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/scatterPlotVisualizer"
	};
var kq = {},
	lq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-util"
	};

function mq(a) {
	return Polymer.Class(a)
}
kq.PolymerElement = mq;
var nq = {},
	oq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-bookmark-panel"
	};
nq.BookmarkPanelPolymer = mq({
	is: "vz-projector-bookmark-panel",
	properties: {
		savedStates: Object,
		hasStates: {
			type: Boolean,
			value: !1
		},
		selectedState: Number
	}
});
var pq = function() {
	var a;
	a = nq.BookmarkPanelPolymer.apply(this, [].concat(F.arrayFromIterable(arguments))) || this;
	a.hasStates = !1;
	return a
};
F.inherits(pq, nq.BookmarkPanelPolymer);
q = pq.prototype;
q.ready = function() {
	this.dom = d3.select(this);
	this.savedStates = [];
	this.setupUploadButton();
	this.ignoreNextProjectionEvent = !1
};
q.initialize = function(a, b) {
	var c = this;
	this.projector = a;
	b.registerProjectionChangedListener(function() {
		c.ignoreNextProjectionEvent ? c.ignoreNextProjectionEvent = !1 : c.clearStateSelection()
	})
};
q.setSelectedTensor = function(a, b, c) {
	var d = this;
	this.addStates(null);
	b && b.bookmarksPath ? c.getBookmarks(a, b.tensorName, function(a) {
		d.addStates(a);
		d._expandMore()
	}) : this._expandLess()
};
q._expandMore = function() {
	this.$.panel.show();
	this.dom.select("#expand-more").style("display", "none");
	this.dom.select("#expand-less").style("display", "")
};
q._expandLess = function() {
	this.$.panel.hide();
	this.dom.select("#expand-more").style("display", "");
	this.dom.select("#expand-less").style("display", "none")
};
q._addBookmark = function() {
	var a = this.projector.getCurrentState();
	a.label = "State " + this.savedStates.length;
	a.isSelected = !0;
	this.selectedState = this.savedStates.length;
	for (var b = 0; b < this.savedStates.length; b++) this.savedStates[b].isSelected = !1, this.notifyPath("savedStates." + b + ".isSelected", !1, !1);
	this.push("savedStates", a);
	this.updateHasStates()
};
q._downloadFile = function() {
	var a = this.serializeAllSavedStates(),
		a = new Blob([a], {
			type: "text/plain"
		}),
		a = window.URL.createObjectURL(a),
		b = document.createElement("a");
	document.body.appendChild(b);
	b.style.display = "none";
	b.href = a;
	b.download = "state";
	b.click();
	document.body.removeChild(b);
	window.URL.revokeObjectURL(a)
};
q._uploadFile = function() {
	var a = this.dom.select("#state-file");
	a.node().click()
};
q.setupUploadButton = function() {
	var a = this,
		b = this.dom.select("#state-file");
	b.on("change", function() {
		var b = d3.event.target.files[0];
		d3.event.target.value = "";
		var d = new FileReader;
		d.onload = function(b) {
			b = b.target.result;
			b = JSON.parse(b);
			a.savedStatesValid(b) ? (a.addStates(b), a.loadSavedState(0)) : yn("Unable to load bookmarks: wrong dataset, expected dataset " + ("with shape (" + b[0].dataSetDimensions + ")."))
		};
		d.readAsText(b)
	})
};
q.addStates = function(a) {
	if (null == a) this.savedStates = [];
	else
		for (var b = 0; b < a.length; b++) a[b].isSelected = !1, this.push("savedStates", a[b]);
	this.updateHasStates()
};
q.clearStateSelection = function() {
	for (var a = 0; a < this.savedStates.length; a++) this.setSelectionState(a, !1)
};
q._radioButtonHandler = function(a) {
	a = this.getParentDataIndex(a);
	this.loadSavedState(a);
	this.setSelectionState(a, !0)
};
q.loadSavedState = function(a) {
	for (var b = 0; b < this.savedStates.length; b++) this.savedStates[b].isSelected ? this.setSelectionState(b, !1) : a === b && (this.setSelectionState(b, !0), this.ignoreNextProjectionEvent = !0, this.projector.loadState(this.savedStates[b]))
};
q.setSelectionState = function(a, b) {
	this.savedStates[a].isSelected = b;
	a = "savedStates." + a + ".isSelected";
	this.notifyPath(a, b, !1)
};
q.getParentDataIndex = function(a) {
	for (var b = 0; b < a.path.length; b++) {
		var c = a.path[b].getAttribute("data-index");
		if (null != c) return +c
	}
	return -1
};
q._clearButtonHandler = function(a) {
	a = this.getParentDataIndex(a);
	this.splice("savedStates", a, 1);
	this.updateHasStates()
};
q._labelChange = function(a) {
	var b = this.getParentDataIndex(a);
	this.savedStates[b].label = a.target.value
};
q._isSelectedState = function(a) {
	return a === this.selectedState
};
q._isNotSelectedState = function(a) {
	return a !== this.selectedState
};
q.serializeAllSavedStates = function() {
	return JSON.stringify(this.savedStates)
};
q.loadSavedStates = function(a) {
	this.savedStates = JSON.parse(a);
	this.updateHasStates()
};
q.updateHasStates = function() {
	this.hasStates = 0 !== this.savedStates.length
};
q.savedStatesValid = function(a) {
	for (var b = 0; b < a.length; b++)
		if (a[b].dataSetDimensions[0] !== this.projector.dataSet.dim[0] || a[b].dataSetDimensions[1] !== this.projector.dataSet.dim[1]) return !1;
	return !0
};
nq.BookmarkPanel = pq;

function qq() {}
document.registerElement(pq.prototype.is, pq);
var rq = {},
	sq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-data-panel"
	};
rq.DataPanelPolymer = mq({
	is: "vz-projector-data-panel",
	properties: {
		selectedTensor: {
			type: String,
			observer: "_selectedTensorChanged"
		},
		selectedRun: {
			type: String,
			observer: "_selectedRunChanged"
		},
		selectedColorOptionName: {
			type: String,
			notify: !0,
			observer: "_selectedColorOptionNameChanged"
		},
		selectedLabelOption: {
			type: String,
			notify: !0,
			observer: "_selectedLabelOptionChanged"
		},
		normalizeData: Boolean
	}
});
var tq = function(a) {
	return rq.DataPanelPolymer.apply(this, arguments) || this
};
F.inherits(tq, rq.DataPanelPolymer);
q = tq.prototype;
q.ready = function() {
	this.dom = d3.select(this);
	this.normalizeData = !0
};
q.initialize = function(a, b) {
	var c = this;
	this.projector = a;
	this.dataProvider = b;
	this.setupUploadButtons();
	this.querySelector("#normalize-data-checkbox").addEventListener("change", function() {
		c.projector.setNormalizeData(c.normalizeData)
	});
	this.dataProvider.retrieveRuns(function(a) {
		c.runNames = a;
		0 < c.runNames.length && (c.selectedRun = a[0])
	})
};
q.getSeparatorClass = function(a) {
	return a ? "separator" : null
};
q.metadataChanged = function(a, b) {
	this.updateMetadataUI(a.stats, b)
};
q.addWordBreaks = function(a) {
	return null == a ? "" : a.replace(/([\/=-_,])/g, "$1<wbr>")
};
q.updateMetadataUI = function(a, b) {
	this.dom.select("#metadata-file").html(this.addWordBreaks(b)).attr("title", b);
	var c = -1;
	this.labelOptions = a.map(function(a, b) {
		a.isNumeric || -1 !== c || (c = b);
		return a.name
	});
	this.selectedLabelOption = this.labelOptions[Math.max(0, c)];
	b = [{
		name: "No color map"
	}];
	a = a.filter(function(a) {
		return !a.tooManyUniqueValues || a.isNumeric
	}).map(function(a) {
		var b, c, d;
		if (a.tooManyUniqueValues) d = [{
			color: "#ffffdd",
			value: a.min
		}, {
			color: "#1f2d86",
			value: a.max
		}], b = d3.scale.linear().domain(d.map(function(a) {
			return a.value
		})).range(d.map(function(a) {
			return a.color
		}));
		else {
			b = d3.scale.category20();
			var h = b.range(),
				k = h.map(function(a, b) {
					a = 3 * b % h.length;
					return h[a]
				});
			c = a.uniqueEntries;
			b.range(k).domain(c.map(function(a) {
				return a.label
			}))
		}
		k = a.tooManyUniqueValues ? "gradient" : a.uniqueEntries.length + (20 < a.uniqueEntries.length ? " non-unique" : "") + " colors";
		return {
			name: a.name,
			desc: k,
			map: b,
			items: c,
			thresholds: d
		}
	});
	0 < a.length && b.push({
		name: "Metadata",
		isSeparator: !0
	});
	this.colorOptions = b.concat(a);
	this.selectedColorOptionName = this.colorOptions[0].name
};
q.setNormalizeData = function(a) {
	this.normalizeData = a
};
q._selectedTensorChanged = function() {
	var a = this;
	my_tensor = this.selectedTensor
	this.projector.updateDataSet(null, null, null);
	null != this.selectedTensor && (this.dataProvider.retrieveTensor(this.selectedRun, this.selectedTensor, function(b) {
		var c = a.getEmbeddingInfoByName(a.selectedTensor).metadataPath;
		a.dataProvider.retrieveSpriteAndMetadata(a.selectedRun, a.selectedTensor, function(d) {
			a.projector.updateDataSet(b, d, c)
		})
	}), this.projector.setSelectedTensor(this.selectedRun, this.getEmbeddingInfoByName(this.selectedTensor)))
};
q._selectedRunChanged = function() {
	var a = this;
	this.dataProvider.retrieveProjectorConfig(this.selectedRun, function(b) {
		a.projectorConfig = b;
		b = a.projectorConfig.embeddings.map(function(a) {
			return a.tensorName
		}).filter(function(b) {
			b = a.getEmbeddingInfoByName(b).tensorShape;
			return 2 === b.length && 1 < b[0] && 1 < b[1]
		}).sort(function(b, c) {
			var d = a.getEmbeddingInfoByName(b),
				e = a.getEmbeddingInfoByName(c);
			if (Mn(!!d.metadataPath, !!e.metadataPath)) return d.metadataPath ? -1 : 1;
			var h = Ln(b),
				k = Ln(c);
			if (Mn(h, k)) return k ? -1 : 1;
			d =
				d.tensorShape[0];
			e = e.tensorShape[0];
			return d !== e ? e - d : b <= c ? -1 : 1
		});
		a.tensorNames = b.map(function(b) {
			return {
				name: b,
				shape: a.getEmbeddingInfoByName(b).tensorShape
			}
		});
		var c = a.addWordBreaks(a.projectorConfig.modelCheckpointPath);
		a.dom.select("#checkpoint-file").html(c).attr("title", a.projectorConfig.modelCheckpointPath);
		b = "demo" === a.projector.servingMode ? a.projectorConfig.embeddings[0].tensorName : b[0];
		a.selectedTensor === b ? a._selectedTensorChanged() : a.selectedTensor = b
	})
};
q._selectedLabelOptionChanged = function() {
	this.projector.setSelectedLabelOption(this.selectedLabelOption)
};
q._selectedColorOptionNameChanged = function() {
	for (var a, b = 0; b < this.colorOptions.length; b++)
		if (this.colorOptions[b].name === this.selectedColorOptionName) {
			a = this.colorOptions[b];
			break
		}
	a && (null == a.map ? this.colorLegendRenderInfo = null : a.items ? (b = a.items.map(function(b) {
		return {
			color: a.map(b.label),
			label: b.label,
			count: b.count
		}
	}), this.colorLegendRenderInfo = {
		items: b,
		thresholds: null
	}) : this.colorLegendRenderInfo = {
		items: null,
		thresholds: a.thresholds
	}, this.projector.setSelectedColorOption(a))
};
q.tensorWasReadFromFile = function(a, b) {
	var c = this;
	Ko.parseRawTensors(a, function(a) {
		c.dom.select("#checkpoint-file").text(b).attr("title", b);
		c.projector.updateDataSet(a)
	})
};
q.metadataWasReadFromFile = function(a, b) {
	var c = this;
	Ko.parseRawMetadata(a, function(a) {
		c.projector.updateDataSet(c.projector.dataSet, a, b)
	})
};
q.getEmbeddingInfoByName = function(a) {
	for (var b = 0; b < this.projectorConfig.embeddings.length; b++) {
		var c = this.projectorConfig.embeddings[b];
		if (c.tensorName === a) return c
	}
};
q.setupUploadButtons = function() {
	var a = this,
		b = this.dom.select("#file");
	b.on("change", function() {
		var b = d3.event.target.files[0];
		d3.event.target.value = "";
		var c = new FileReader;
		c.onload = function(c) {
			c = c.target.result;
			a.tensorWasReadFromFile(c, b.name)
		};
		c.readAsText(b)
	});
	var c = this.dom.select("#upload-tensors");
	c.on("click", function() {
		b.node().click()
	});
	var d = this.dom.select("#file-metadata");
	d.on("change", function() {
		var b = d3.event.target.files[0];
		d3.event.target.value = "";
		var c = new FileReader;
		c.onload = function(c) {
			c =
				c.target.result;
			a.metadataWasReadFromFile(c, b.name)
		};
		c.readAsText(b)
	});
	c = this.dom.select("#upload-metadata");
	c.on("click", function() {
		d.node().click()
	});
	if ("demo" === this.projector.servingMode) {
		this.$$("#demo-data-buttons-container").style.display = "block";
		var e = this.$$("#projector-config-template"),
			f = {
				embeddings: [{
					tensorName: "My tensor",
					tensorShape: [1E3, 50],
					tensorPath: "https://gist.github.com/.../tensors.tsv",
					metadataPath: "https://gist.github.com/.../optional.metadata.tsv"
				}]
			};
		this.setProjectorConfigTemplateJson(e,
			f);
		var g = this.$$("#config-sprite-checkbox");
		g.addEventListener("change", function() {
			g.checked ? f.embeddings[0].sprite = {
				imagePath: "https://github.com/.../optional.sprite.png",
				singleImageDim: [32, 32]
			} : delete f.embeddings[0].sprite;
			a.setProjectorConfigTemplateJson(e, f)
		});
		var h = this.$$("#config-bookmarks-checkbox");
		h.addEventListener("change", function() {
			h.checked ? f.embeddings[0].bookmarksPath = "https://gist.github.com/.../bookmarks.txt" : delete f.embeddings[0].bookmarksPath;
			a.setProjectorConfigTemplateJson(e,
				f)
		});
		var k = this.$$("#config-metadata-checkbox");
		k.addEventListener("change", function() {
			k.checked ? f.embeddings[0].metadataPath = "https://gist.github.com/.../optional.metadata.tsv" : delete f.embeddings[0].metadataPath;
			a.setProjectorConfigTemplateJson(e, f)
		});
		var l = this.$$("#projector-config-url"),
			m = this.$$("#projector-share-url"),
			n = this.$$("#projector-share-url-link");
		l.addEventListener("input", function() {
			var a = location.protocol + "//" + location.host + location.pathname + "?config=" + l.value;
			m.value = a;
			n.href =
				a
		})
	}
};
q.setProjectorConfigTemplateJson = function(a, b) {
	a.value = JSON.stringify(b, null, 2)
};
q._getNumTensorsLabel = function() {
	return 1 === this.tensorNames.length ? "1 tensor" : this.tensorNames.length + " tensors"
};
q._getNumRunsLabel = function() {
	return 1 === this.runNames.length ? "1 run" : this.runNames.length + " runs"
};
q._hasChoices = function(a) {
	return 1 < a.length
};
rq.DataPanel = tq;

function uq() {}
document.registerElement(tq.prototype.is, tq);
var vq = {},
	wq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-input"
	};
vq.PolymerClass = mq({
	is: "vz-projector-input",
	properties: {
		label: String,
		message: String
	}
});
var xq = function(a) {
	return vq.PolymerClass.apply(this, arguments) || this
};
F.inherits(xq, vq.PolymerClass);
q = xq.prototype;
q.registerInputChangedListener = function(a) {
	this.textChangedListeners.push(a)
};
q.ready = function() {
	var a = this;
	this.inRegexMode = !1;
	this.textChangedListeners = [];
	this.dom = d3.select(this);
	this.paperInput = this.querySelector("paper-input");
	this.inRegexModeButton = this.querySelector("paper-button");
	this.paperInput.setAttribute("error-message", "Invalid regex");
	this.paperInput.addEventListener("input", function() {
		a.onTextChanged()
	});
	this.paperInput.addEventListener("keydown", function(a) {
		a.stopPropagation()
	});
	this.inRegexModeButton.addEventListener("click", function() {
		return a.onClickRegexModeButton()
	});
	this.updateRegexModeDisplaySlashes();
	this.onTextChanged()
};
q.onClickRegexModeButton = function() {
	this.inRegexMode = this.inRegexModeButton.active;
	this.updateRegexModeDisplaySlashes();
	this.onTextChanged()
};
q.notifyInputChanged = function(a, b) {
	this.textChangedListeners.forEach(function(c) {
		return c(a, b)
	})
};
q.onTextChanged = function() {
	try {
		this.inRegexMode && new RegExp(this.paperInput.value)
	} catch (a) {
		this.paperInput.setAttribute("invalid", "true");
		this.message = "";
		this.notifyInputChanged(null, !0);
		return
	}
	this.paperInput.removeAttribute("invalid");
	this.notifyInputChanged(this.paperInput.value, this.inRegexMode)
};
q.updateRegexModeDisplaySlashes = function() {
	d3.select(this.paperInput).selectAll(".slash").style("display", this.inRegexMode ? null : "none")
};
q.getValue = function() {
	return this.paperInput.value
};
q.getInRegexMode = function() {
	return this.inRegexMode
};
q.set = function(a, b) {
	this.inRegexModeButton.active = b;
	this.paperInput.value = a;
	this.onClickRegexModeButton()
};
vq.ProjectorInput = xq;

function yq() {}
document.registerElement(xq.prototype.is, xq);
var zq = {},
	Aq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-inspector-panel"
	};
zq.PolymerClass = mq({
	is: "vz-projector-inspector-panel",
	properties: {
		selectedMetadataField: String,
		metadataFields: Array
	}
});
var Bq = function(a) {
	return zq.PolymerClass.apply(this, arguments) || this
};
F.inherits(Bq, zq.PolymerClass);
q = Bq.prototype;
q.ready = function() {
	this.dom = d3.select(this);
	this.resetFilterButton = this.dom.select(".reset-filter");
	this.setFilterButton = this.dom.select(".set-filter");
	this.clearSelectionButton = this.dom.select(".clear-selection");
	this.limitMessage = this.dom.select(".limit-msg");
	this.searchBox = this.querySelector("#search-box");
	this.scopeSubtree(this, !0)
};
q.initialize = function(a, b) {
	var c = this;
	this.projector = a;
	this.projectorEventContext = b;
	this.setupUI(a);
	b.registerSelectionChangedListener(function(a, b) {
		return c.updateInspectorPane(a, b)
	})
};
q.updateInspectorPane = function(a, b) {
	this.neighborsOfFirstPoint = b;
	this.selectedPointIndices = a;
	this.updateFilterButtons(a.length + b.length);
	this.updateNeighborsList(b);
	0 === b.length ? this.updateSearchResults(a) : this.updateSearchResults([])
};
q.enableResetFilterButton = function(a) {
	this.resetFilterButton.attr("disabled", a ? null : !0)
};
q.restoreUIFromBookmark = function(a) {
	this.enableResetFilterButton(null != a.filteredPoints)
};
q.metadataChanged = function(a) {
	var b = -1;
	this.metadataFields = a.stats.map(function(a, d) {
		a.isNumeric || -1 !== b || (b = d);
		return a.name
	});
	b = Math.max(0, b);
	this.selectedMetadataField = a.stats[b].name
};
q.datasetChanged = function() {
	this.enableResetFilterButton(!1)
};
q.updateSearchResults = function(a) {
	var b = this,
		c = this.dom.select(".matches-list");
	c.style("display", a.length ? null : "none");
	c = c.select(".list");
	c.html("");
	0 !== a.length && (this.limitMessage.style("display", 100 >= a.length ? "none" : null), a = a.slice(0, 100), a = c.selectAll(".row").data(a).enter().append("div").attr("class", "row"), a.append("a").attr("class", "label").attr("title", function(a) {
			return b.getLabelFromIndex(a)
		}).text(function(a) {
			return b.getLabelFromIndex(a)
		}), a.on("mouseenter", function(a) {
			b.projectorEventContext.notifyHoverOverPoint(a)
		}),
		a.on("mouseleave", function() {
			b.projectorEventContext.notifyHoverOverPoint(null)
		}), a.on("click", function(a) {
			b.projectorEventContext.notifySelectionChanged([a])
		}))
};
q.getLabelFromIndex = function(a) {
	a = this.projector.dataSet.points[a];
	return a.metadata[this.selectedMetadataField].toString()
};
q.updateNeighborsList = function(a) {
	var b = this,
		c = this.dom.select(".nn-list");
	c.html("");
	this.dom.select(".nn").style("display", a.length ? null : "none");
	if (0 !== a.length) {
		this.searchBox.message = "";
		var d = 0 < a.length ? a[0].dist : 0;
		a = c.selectAll(".neighbor").data(a).enter().append("div").attr("class", "neighbor").append("a").attr("class", "neighbor-link").attr("title", function(a) {
			return b.getLabelFromIndex(a.index)
		});
		c = a.append("div").attr("class", "label-and-value");
		c.append("div").attr("class", "label").style("color",
			function(a) {
				return fq(b.distFunc, a.dist, d)
			}).text(function(a) {
			return b.getLabelFromIndex(a.index)
		});
		c.append("div").attr("class", "value").text(function(a) {
			return a.dist.toFixed(3)
		});
		c = a.append("div").attr("class", "bar");
		c.append("div").attr("class", "fill").style("border-top-color", function(a) {
			return fq(b.distFunc, a.dist, d)
		}).style("width", function(a) {
			return 100 * hq(b.distFunc, a.dist, d) + "%"
		});
		c.selectAll(".tick").data(d3.range(1, 4)).enter().append("div").attr("class", "tick").style("left", function(a) {
			return 100 *
				a / 4 + "%"
		});
		a.on("mouseenter", function(a) {
			b.projectorEventContext.notifyHoverOverPoint(a.index)
		});
		a.on("mouseleave", function() {
			b.projectorEventContext.notifyHoverOverPoint(null)
		});
		a.on("click", function(a) {
			b.projectorEventContext.notifySelectionChanged([a.index])
		})
	}
};
q.updateFilterButtons = function(a) {
	1 < a ? (this.setFilterButton.text("Isolate " + a + " points").attr("disabled", null), this.clearSelectionButton.attr("disabled", null)) : (this.setFilterButton.attr("disabled", !0), this.clearSelectionButton.attr("disabled", !0))
};
q.setupUI = function(a) {
	var b = this;
	this.distFunc = oo;
	var c = this.dom.select(".distance a.euclidean");
	c.on("click", function() {
		b.dom.selectAll(".distance a").classed("selected", !1);
		c.classed("selected", !0);
		b.distFunc = ao;
		b.projectorEventContext.notifyDistanceMetricChanged(b.distFunc);
		var d = a.dataSet.findNeighbors(b.selectedPointIndices[0], b.distFunc, b.numNN);
		b.updateNeighborsList(d)
	});
	var d = this.dom.select(".distance a.cosine");
	d.on("click", function() {
		b.dom.selectAll(".distance a").classed("selected", !1);
		d.classed("selected", !0);
		b.distFunc = oo;
		b.projectorEventContext.notifyDistanceMetricChanged(b.distFunc);
		var c = a.dataSet.findNeighbors(b.selectedPointIndices[0], b.distFunc, b.numNN);
		b.updateNeighborsList(c)
	});
	this.searchBox.registerInputChangedListener(function(c, d) {
		null == c || "" === c.trim() ? (b.searchBox.message = "", b.projectorEventContext.notifySelectionChanged([])) : (d = a.dataSet.query(c, d, b.selectedMetadataField), b.searchBox.message = 0 === d.length ? "0 matches." : d.length + " matches.", b.projectorEventContext.notifySelectionChanged(d))
	});
	var e = this.$$("#nn-slider"),
		f = function() {
			b.numNN = +e.value;
			b.dom.select(".num-nn .nn-count").text(b.numNN);
			null != b.selectedPointIndices && b.projectorEventContext.notifySelectionChanged([b.selectedPointIndices[0]])
		};
	e.addEventListener("change", f);
	f();
	this.setFilterButton.on("click", function() {
		var c = b.selectedPointIndices.concat(b.neighborsOfFirstPoint.map(function(a) {
			return a.index
		}));
		a.filterDataset(c);
		b.enableResetFilterButton(!0);
		b.updateFilterButtons(0)
	});
	this.resetFilterButton.on("click", function() {
		a.resetFilterDataset();
		b.enableResetFilterButton(!1)
	});
	this.clearSelectionButton.on("click", function() {
		a.adjustSelectionAndHover([])
	});
	this.enableResetFilterButton(!1)
};
zq.InspectorPanel = Bq;

function Cq() {}
document.registerElement(Bq.prototype.is, Bq);
var Dq = {},
	Eq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-legend"
	};
Dq.LegendPolymer = mq({
	is: "vz-projector-legend",
	properties: {
		renderInfo: {
			type: Object,
			observer: "_renderInfoChanged"
		}
	}
});
var Fq = function(a) {
	return Dq.LegendPolymer.apply(this, arguments) || this
};
F.inherits(Fq, Dq.LegendPolymer);
q = Fq.prototype;
q.ready = function() {
	this.dom = d3.select(this)
};
q._renderInfoChanged = function() {
	var a = this;
	null != this.renderInfo && this.renderInfo.thresholds && this.async(function() {
		return a.setupLinearGradient()
	})
};
q._getLastThreshold = function() {
	if (null != this.renderInfo && null != this.renderInfo.thresholds) return this.renderInfo.thresholds[this.renderInfo.thresholds.length - 1].value
};
q.getOffset = function(a) {
	var b = this.renderInfo.thresholds[0].value,
		c = this.renderInfo.thresholds[this.renderInfo.thresholds.length - 1].value;
	return (100 * (a - b) / (c - b)).toFixed(2) + "%"
};
q.setupLinearGradient = function() {
	var a = this,
		b = this.dom.select("#gradient"),
		c = this.dom.select("svg.gradient").node().clientWidth;
	this.dom.select("svg.gradient rect").attr("width", c);
	b.selectAll("*").remove();
	this.renderInfo.thresholds.forEach(function(c) {
		b.append("stop").attr("offset", a.getOffset(c.value)).attr("stop-color", c.color)
	})
};
Dq.Legend = Fq;

function Gq() {}
document.registerElement(Fq.prototype.is, Fq);
var Hq = {},
	Iq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-metadata-card"
	};
Hq.MetadataCardPolymer = mq({
	is: "vz-projector-metadata-card",
	properties: {
		hasMetadata: {
			type: Boolean,
			value: !1
		},
		metadata: {
			type: Array
		},
		label: String
	}
});
var Jq = function(a) {
	return Hq.MetadataCardPolymer.apply(this, arguments) || this
};
F.inherits(Jq, Hq.MetadataCardPolymer);
q = Jq.prototype;
q.ready = function() {
	this.dom = d3.select(this)
};
q._expandMore = function() {
	this.$$("#metadata-container").toggle();
	this.dom.select("#expand-more").style("display", "none");
	this.dom.select("#expand-less").style("display", "")
};
q._expandLess = function() {
	this.$$("#metadata-container").toggle();
	this.dom.select("#expand-more").style("display", "");
	this.dom.select("#expand-less").style("display", "none")
};
q.updateMetadata = function(a) {
	this.pointMetadata = a;
	this.hasMetadata = null != a;
	if (a) {
		var b = [],
			c;
		for (c in a) a.hasOwnProperty(c) && b.push({
			key: c,
			value: a[c]
		});
		this.metadata = b;
		this.label = "" + this.pointMetadata[this.labelOption]
	}
};
q.setLabelOption = function(a) {
	this.labelOption = a;
	this.pointMetadata && (this.label = "" + this.pointMetadata[this.labelOption])
};
Hq.MetadataCard = Jq;

function Kq() {}
document.registerElement(Jq.prototype.is, Jq);
var Lq = {},
	Mq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector-projections-panel"
	},
	Nq = yo;
Lq.ProjectionsPanelPolymer = mq({
	is: "vz-projector-projections-panel",
	properties: {
		pcaIs3d: {
			type: Boolean,
			value: !0,
			observer: "_pcaDimensionToggleObserver"
		},
		tSNEis3d: {
			type: Boolean,
			value: !0,
			observer: "_tsneDimensionToggleObserver"
		},
		pcaComponents: Array,
		pcaX: {
			type: Number,
			value: 0,
			observer: "showPCAIfEnabled"
		},
		pcaY: {
			type: Number,
			value: 1,
			observer: "showPCAIfEnabled"
		},
		pcaZ: {
			type: Number,
			value: 2,
			observer: "showPCAIfEnabled"
		},
		clusterOpts: Array,
		clusterRows: {
			type: String,
			value: "Cluster",
			observer: "showClusterIfEnabled"
		},
		clusterCols: {
			type: String,
			value: "Cluster",
			observer: "showClusterIfEnabled"
		},
		// customSelectedSearchByMetadataOption: {
		// 	type: String,
		// 	observer: "_customSelectedSearchByMetadataOptionChanged"
		// }
	}
});
var Oq = function(a) {
	return Lq.ProjectionsPanelPolymer.apply(this, arguments) || this
};
F.inherits(Oq, Lq.ProjectionsPanelPolymer);
q = Oq.prototype;
q.initialize = function(a) {
	this.polymerChangesTriggerReprojection = !0;
	this.projector = a;
	this.perplexity = 30;
	this.learningRate = 10;
	this.centroidValues = {
		xLeft: null,
		xRight: null,
		yUp: null,
		yDown: null
	};
	this.clearCentroids();
	this.setupUIControls()
};
q.ready = function() {
	this.dom = d3.select(this);
	this.zDropdown = this.dom.select("#z-dropdown");
	this.runTsneButton = this.dom.select(".run-tsne");
	this.stopTsneButton = this.dom.select(".stop-tsne");
	this.perplexitySlider = this.$$("#perplexity-slider");
	this.learningRateInput = this.$$("#learning-rate-slider");
	this.iterationLabel = this.dom.select(".run-tsne-iter")
};
q.disablePolymerChangesTriggerReprojection = function() {
	this.polymerChangesTriggerReprojection = !1
};
q.enablePolymerChangesTriggerReprojection = function() {
	this.polymerChangesTriggerReprojection = !0
};
q.updateTSNEPerplexityFromSliderChange = function() {
	this.perplexitySlider && (this.perplexity = +this.perplexitySlider.value);
	this.dom.select(".tsne-perplexity span").text(this.perplexity)
};
q.updateTSNELearningRateFromUIChange = function() {
	this.learningRateInput && (this.learningRate = Math.pow(10, +this.learningRateInput.value));
	this.dom.select(".tsne-learning-rate span").text(this.learningRate)
};
q.setupUIControls = function() {
	var a = this,
		b = this;
	this.dom.selectAll(".ink-tab").on("click", function() {
		var a = this.getAttribute("data-tab");
		b.showTab(a)
	});
	this.runTsneButton.on("click", function() {
		return a.runTSNE()
	});
	this.stopTsneButton.on("click", function() {
		return a.dataSet.stopTSNE()
	});
	this.perplexitySlider.value = this.perplexity.toString();
	this.perplexitySlider.addEventListener("change", function() {
		return a.updateTSNEPerplexityFromSliderChange()
	});
	this.updateTSNEPerplexityFromSliderChange();
	this.learningRateInput.addEventListener("change",
		function() {
			return a.updateTSNELearningRateFromUIChange()
		});
	this.updateTSNELearningRateFromUIChange();
	// this.setupCustomProjectionInputFields();
	this.dom.selectAll("paper-dropdown-menu paper-input input").style("font-size", "14px")
};
q.restoreUIFromBookmark = function(a) {
	this.disablePolymerChangesTriggerReprojection();
	this.pcaX = a.pcaComponentDimensions[0];
	this.pcaY = a.pcaComponentDimensions[1];
	3 === a.pcaComponentDimensions.length && (this.pcaZ = a.pcaComponentDimensions[2]);
	this.pcaIs3d = 3 === a.pcaComponentDimensions.length;
	this.perplexitySlider && (this.perplexitySlider.value = a.tSNEPerplexity.toString());
	this.learningRateInput && (this.learningRateInput.value = a.tSNELearningRate.toString());
	this.tSNEis3d = a.tSNEis3d;
	this.customSelectedSearchByMetadataOption =
		a.customSelectedSearchByMetadataOption;
	this.customProjectionXLeftInput && this.customProjectionXLeftInput.set(a.customXLeftText, a.customXLeftRegex);
	this.customProjectionXRightInput && this.customProjectionXRightInput.set(a.customXRightText, a.customXRightRegex);
	this.customProjectionYUpInput && this.customProjectionYUpInput.set(a.customYUpText, a.customYUpRegex);
	this.customProjectionYDownInput && this.customProjectionYDownInput.set(a.customYDownText, a.customYDownRegex);
	this.computeAllCentroids();
	this.setZDropdownEnabled(this.pcaIs3d);
	this.updateTSNEPerplexityFromSliderChange();
	this.updateTSNELearningRateFromUIChange();
	this.iterationLabel && this.iterationLabel.text(a.tSNEIteration.toString());
	this.showTab(a.selectedProjection);
	this.enablePolymerChangesTriggerReprojection()
};
q.populateBookmarkFromUI = function(a) {
	this.disablePolymerChangesTriggerReprojection();
	a.pcaComponentDimensions = [this.pcaX, this.pcaY];
	this.pcaIs3d && a.pcaComponentDimensions.push(this.pcaZ);
	null != this.perplexitySlider && (a.tSNEPerplexity = +this.perplexitySlider.value);
	null != this.learningRateInput && (a.tSNELearningRate = +this.learningRateInput.value);
	a.tSNEis3d = this.tSNEis3d;
	a.customSelectedSearchByMetadataOption = this.customSelectedSearchByMetadataOption;
	null != this.customProjectionXLeftInput && (a.customXLeftText =
		this.customProjectionXLeftInput.getValue(), a.customXLeftRegex = this.customProjectionXLeftInput.getInRegexMode());
	null != this.customProjectionXRightInput && (a.customXRightText = this.customProjectionXRightInput.getValue(), a.customXRightRegex = this.customProjectionXRightInput.getInRegexMode());
	null != this.customProjectionYUpInput && (a.customYUpText = this.customProjectionYUpInput.getValue(), a.customYUpRegex = this.customProjectionYUpInput.getInRegexMode());
	null != this.customProjectionYDownInput && (a.customYDownText =
		this.customProjectionYDownInput.getValue(), a.customYDownRegex = this.customProjectionYDownInput.getInRegexMode());
	this.enablePolymerChangesTriggerReprojection()
};
q.setZDropdownEnabled = function(a) {
	this.zDropdown && this.zDropdown.attr("disabled", a ? null : !0)
};
q.dataSetUpdated = function(a, b, c) {
	this.dataSet = a;
	this.originalDataSet = b;
	this.dim = c;
	b = null == a ? 0 : a.points.length;
	c = Math.max(5, Math.ceil(Math.sqrt(b) / 4));
	this.perplexitySlider.value = c.toString();
	this.updateTSNEPerplexityFromSliderChange();
	this.clearCentroids();
	this.dom.select("#tsne-sampling").style("display", b > yo.TSNE_SAMPLE_SIZE ? null : "none");
	a = null == a ? !1 : a.dim[0] > yo.PCA_SAMPLE_DIM || a.dim[1] > yo.PCA_SAMPLE_DIM;
	this.dom.select("#pca-sampling").style("display", a ? null : "none");
	this.showTab("pca")
};
q._pcaDimensionToggleObserver = function() {
	this.setZDropdownEnabled(this.pcaIs3d);
	this.beginProjection(this.currentProjection)
};
q._tsneDimensionToggleObserver = function() {
	this.beginProjection(this.currentProjection)
};
q.metadataChanged = function(a) {
	var b = -1;
	this.searchByMetadataOptions = a.stats.map(function(a, d) {
		a.isNumeric || -1 !== b || (b = d);
		return a.name
	});
	this.customSelectedSearchByMetadataOption = this.searchByMetadataOptions[Math.max(0, b)]
};
q.showTab = function(a) {
	var b = this;
	this.currentProjection = a;
	var c = this.dom.select('.ink-tab[data-tab="' + a + '"]');
	this.dom.selectAll(".ink-tab").classed("active", !1);
	c.classed("active", !0);
	this.dom.selectAll(".ink-panel-content").classed("active", !1);
	this.dom.select('.ink-panel-content[data-panel="' + a + '"]').classed("active", !0);
	if (null != this.$) {
		var d = this.$.main;
		requestAnimationFrame(function() {
			b.style.height = d.clientHeight + "px"
		})
	}
	this.beginProjection(a)
};
q.beginProjection = function(a) {
	// !1 !== this.polymerChangesTriggerReprojection && ("pca" === a ? (null != this.dataSet && this.dataSet.stopTSNE(), this.showPCA()) : "tsne" === a ? this.showTSNE() : "custom" === a && (null != this.dataSet && this.dataSet.stopTSNE(), this.computeAllCentroids(), this.reprojectCustom()))
	!1 !== this.polymerChangesTriggerReprojection && ("pca" === a ? (null != this.dataSet && this.dataSet.stopTSNE(), this.showPCA()) : "tsne" === a ? this.showTSNE() : "cluster" === a && (null != this.dataSet && this.dataSet.stopTSNE(), this.loadCluster()))
};
q.showTSNE = function() {
	console.log("show TSNE")
	d3.select("#clustergram-container").style("display","none")
	d3.select("#scatter").style("display","block")
	var a = this.dataSet;
	if (null != a) {
		var b = yo.getProjectionComponents("tsne", [0, 1, this.tSNEis3d ? 2 : null]),
			c = this.tSNEis3d ? 3 : 2,
			a = new Nq.Projection("tsne", b, c, a);
		this.projector.setProjection(a);
		this.dataSet.hasTSNERun ? this.projector.notifyProjectionPositionsUpdated() : this.runTSNE()
	}
};
q.runTSNE = function() {
	var a = this;
	this.runTsneButton.attr("disabled", !0);
	this.stopTsneButton.attr("disabled", null);
	this.dataSet.projectTSNE(this.perplexity, this.learningRate, this.tSNEis3d ? 3 : 2, function(b) {
		null != b ? (a.iterationLabel.text(b), a.projector.notifyProjectionPositionsUpdated()) : (a.runTsneButton.attr("disabled", null), a.stopTsneButton.attr("disabled", !0))
	})
};
q.showPCAIfEnabled = function() {
	this.polymerChangesTriggerReprojection && this.showPCA()
};
q.showClusterIfEnabled = function() {
	this.showCluster()
};
q.updateTotalVarianceMessage = function() {
	var a = this.dataSet.fracVariancesExplained,
		b = a[this.pcaX] + a[this.pcaY],
		c = "Total variance described: ";
	this.pcaIs3d && (b += a[this.pcaZ]);
	c += (100 * b).toFixed(1) + "%.";
	this.dom.select("#total-variance").html(c)
};
q.showPCA = function() {
	console.log("show PCA")
	d3.select("#clustergram-container").style("display","none")
	d3.select("#scatter").style("display","block")
	var a = this;
	null != this.dataSet && this.dataSet.projectPCA().then(function() {
		var b = yo.getProjectionComponents("pca", [a.pcaX, a.pcaY, a.pcaZ]),
			c = a.pcaIs3d ? 3 : 2,
			b = new Nq.Projection("pca", b, c, a.dataSet);
		a.projector.setProjection(b);
		b = Math.min(10, a.dataSet.dim[1]);
		a.updateTotalVarianceMessage();
		a.pcaComponents = d3.range(0, b).map(function(b) {
			var c = a.dataSet.fracVariancesExplained[b];
			return {
				id: b,
				componentNumber: b + 1,
				percVariance: (100 * c).toFixed(1)
			}
		})
	})
};
q.showCluster = function() {
	console.log("showCluster")
	var a = this;
	opts = ["Alphabetically", "Cluster", "Sum", "Variance"]
	a.clusterOpts = d3.range(0,opts.length).map(function(b) {
		return {
			id: b,
			option: opts[b]
		}
	})
};
q.loadCluster = function() {
	d3.select("#scatter").style("display","none")
	d3.select("#clustergram-container").style("display","block")

	// var a = this;
	console.log("load cluster")

	// a = this.getLegendPointColorer()

	var a = this.projector.getCurrentState()

	// console.log(this.DataPanel.getCurrentState())
	// console.log(this._properties)
	// console.log(this.DataPanel._properties)

	// var b = this.DataPanel.selectedTensor()


	var b = this.projector.dataSet

	label = a.selectedLabelOption
	color = a.selectedColorOptionName
	data = b.points

	// var b = this.projector.setupUploadButtons

	console.log(this.clusterCols)
	console.log(this.clusterRows)
	console.log(a)
	console.log(a.selectedLabelOption)
	console.log(a.selectedColorOptionName)
	console.log(b)
	console.log(b.points)

	make_clust('mult_view.json')
	// this.getSeparatorClass(item.isSeparator)
	// console.log(this.attributes)
	// console.log(a.dataPanel.selectedColorOptionName.name)
	// console.log(this.selectedLabelOption())	

	// console.log(a.selectedLabelOption)
	// console.log(this.)

	// console.log(this.selectedLabelOption)
	// console.log(this.selectedColorOptionName)
	// console.log("load cluster")
};
q.reprojectCustom = function() {
	if (null != this.centroids && null != this.centroids.xLeft && null != this.centroids.xRight && null != this.centroids.yUp && null != this.centroids.yDown) {
		var a = Zn(this.centroids.xRight, this.centroids.xLeft);
		this.dataSet.projectLinear(a, "linear-x");
		a = Zn(this.centroids.yUp, this.centroids.yDown);
		this.dataSet.projectLinear(a, "linear-y");
		a = yo.getProjectionComponents("custom", ["x", "y"]);
		a = new Nq.Projection("custom", a, 2, this.dataSet);
		this.projector.setProjection(a)
	}
};
q.clearCentroids = function() {
	this.centroids = {
		xLeft: null,
		xRight: null,
		yUp: null,
		yDown: null
	};
	this.allCentroid = null
};
q._customSelectedSearchByMetadataOptionChanged = function(a, b) {
	!1 !== this.polymerChangesTriggerReprojection && "custom" === this.currentProjection && (this.computeAllCentroids(), this.reprojectCustom())
};
// q.setupCustomProjectionInputFields = function() {
// 	this.customProjectionXLeftInput = this.setupCustomProjectionInputField("xLeft");
// 	this.customProjectionXRightInput = this.setupCustomProjectionInputField("xRight");
// 	this.customProjectionYUpInput = this.setupCustomProjectionInputField("yUp");
// 	this.customProjectionYDownInput = this.setupCustomProjectionInputField("yDown")
// };
q.computeAllCentroids = function() {
	this.computeCentroid("xLeft");
	this.computeCentroid("xRight");
	this.computeCentroid("yUp");
	this.computeCentroid("yDown")
};
q.computeCentroid = function(a) {
	var b = this.querySelector("#" + a);
	if (null != b) {
		var c = b.getValue();
		if (null != c) {
			var d = b.getInRegexMode(),
				d = this.getCentroid(c, d);
			0 === d.numMatches ? (b.message = "0 matches. Using a random vector.", d.centroid = ko(this.dim)) : b.message = d.numMatches + " matches.";
			this.centroids[a] = d.centroid;
			this.centroidValues[a] = c
		}
	}
};
q.setupCustomProjectionInputField = function(a) {
	var b = this,
		c = this.querySelector("#" + a);
	c.registerInputChangedListener(function(c, e) {
		b.polymerChangesTriggerReprojection && (b.computeCentroid(a), b.reprojectCustom())
	});
	return c
};
q.getCentroid = function(a, b) {
	var c = this;
	if (null == a || "" === a) return {
		numMatches: 0
	};
	var d = function(a) {
		return c.originalDataSet.points[a].vector
	};
	a = this.originalDataSet.query(a, b, this.customSelectedSearchByMetadataOption);
	return {
		centroid: mo(a, d),
		numMatches: a.length
	}
};
q.getPcaSampledDimText = function() {
	return yo.PCA_SAMPLE_DIM.toLocaleString()
};
q.getPcaSampleSizeText = function() {
	return yo.PCA_SAMPLE_SIZE.toLocaleString()
};
q.getTsneSampleSizeText = function() {
	return yo.TSNE_SAMPLE_SIZE.toLocaleString()
};
Lq.ProjectionsPanel = Oq;

function Pq() {}
document.registerElement(Oq.prototype.is, Oq);
var Qq = {},
	Rq = {
		id: "third_party/tensorflow/tensorboard/components/vz_projector/vz-projector"
	},
	Sq = yo;
Qq.ProjectorPolymer = mq({
	is: "vz-projector",
	properties: {
		routePrefix: String,
		dataProto: {
			type: String,
			observer: "_dataProtoChanged"
		},
		servingMode: String,
		projectorConfigJsonPath: String,
		pageViewLogging: Boolean,
		eventLogging: Boolean
	}
});
var Tq = function(a) {
	return Qq.ProjectorPolymer.apply(this, arguments) || this
};
F.inherits(Tq, Qq.ProjectorPolymer);
q = Tq.prototype;
q.ready = function() {
	this.dom = d3.select(this);
	vn(this);
	this.analyticsLogger = new Rm(this.pageViewLogging, this.eventLogging);
	this.analyticsLogger.logPageView("embeddings");
	Nn() ? (this.selectionChangedListeners = [], this.hoverListeners = [], this.projectionChangedListeners = [], this.distanceMetricChangedListeners = [], this.selectedPointIndices = [], this.neighborsOfFirstPoint = [], this.dataPanel = this.$["data-panel"], this.inspectorPanel = this.$["inspector-panel"], this.inspectorPanel.initialize(this, this), this.projectionsPanel =
		this.$["projections-panel"], this.projectionsPanel.initialize(this), this.bookmarkPanel = this.$["bookmark-panel"], this.bookmarkPanel.initialize(this, this), this.metadataCard = this.$["metadata-card"], this.statusBar = this.dom.select("#status-bar"), this.scopeSubtree(this.$$("#notification-dialog"), !0), this.setupUIControls(), this.initializeDataProvider()) : (this.analyticsLogger.logWebGLDisabled(), xn("Your browser or device does not have WebGL enabled. Please enable hardware acceleration, or use a browser that supports WebGL."))
};
q.setSelectedLabelOption = function(a) {
	this.selectedLabelOption = a;
	this.metadataCard.setLabelOption(this.selectedLabelOption);
	this.projectorScatterPlotAdapter.setLabelPointAccessor(a);
	this.projectorScatterPlotAdapter.updateScatterPlotAttributes();
	this.projectorScatterPlotAdapter.render()
};
q.setSelectedColorOption = function(a) {
	this.selectedColorOption = a;
	this.projectorScatterPlotAdapter.setLegendPointColorer(this.getLegendPointColorer(a));
	this.projectorScatterPlotAdapter.updateScatterPlotAttributes();
	this.projectorScatterPlotAdapter.render()
};
q.setNormalizeData = function(a) {
	this.normalizeData = a;
	this.setCurrentDataSet(this.originalDataSet.getSubset())
};
q.updateDataSet = function(a, b, c) {
	this.dataSetFilterIndices = null;
	this.originalDataSet = a;
	if (null != a) {
		this.normalizeData = 50 <= this.originalDataSet.dim[1];
		b = b || {};
		if (null == b.pointsInfo) {
			var d = F.makeIterator(this.makeDefaultPointsInfoAndStats(a.points)),
				e = d.next().value,
				d = d.next().value;
			b.pointsInfo = e;
			b.stats = d
		}
		e = a.mergeMetadata(b);
		if (!e) return
	}
	null != this.projectorScatterPlotAdapter && (null == a ? (this.projectorScatterPlotAdapter.setLabelPointAccessor(null), this.setProjection(null)) : (this.projectorScatterPlotAdapter.updateScatterPlotPositions(),
		this.projectorScatterPlotAdapter.updateScatterPlotAttributes(), this.projectorScatterPlotAdapter.resize(), this.projectorScatterPlotAdapter.render()));
	null != a ? (this.dataPanel.setNormalizeData(this.normalizeData), this.setCurrentDataSet(a.getSubset()), this.projectorScatterPlotAdapter.setLabelPointAccessor(this.selectedLabelOption), this.inspectorPanel.datasetChanged(), this.inspectorPanel.metadataChanged(b), this.projectionsPanel.metadataChanged(b), this.dataPanel.metadataChanged(b, c), a = this.dom.select("#container"),
		a.style("height", a.property("clientHeight") + "px")) : this.setCurrentDataSet(null)
};
q.setSelectedTensor = function(a, b) {
	this.bookmarkPanel.setSelectedTensor(a, b, this.dataProvider)
};
q.registerSelectionChangedListener = function(a) {
	this.selectionChangedListeners.push(a)
};
q.filterDataset = function(a) {
	var b = this.selectedPointIndices.length;
	null == this.dataSetBeforeFilter && (this.dataSetBeforeFilter = this.dataSet);
	this.setCurrentDataSet(this.dataSet.getSubset(a));
	this.dataSetFilterIndices = a;
	this.projectorScatterPlotAdapter.updateScatterPlotPositions();
	this.projectorScatterPlotAdapter.updateScatterPlotAttributes();
	this.adjustSelectionAndHover(d3.range(b))
};
q.resetFilterDataset = function() {
	var a = this,
		b = this.selectedPointIndices.map(function(b) {
			return a.dataSet.points[b].index
		});
	this.setCurrentDataSet(this.dataSetBeforeFilter);
	null != this.projection && (this.projection.dataSet = this.dataSetBeforeFilter);
	this.dataSetBeforeFilter = null;
	this.projectorScatterPlotAdapter.updateScatterPlotPositions();
	this.projectorScatterPlotAdapter.updateScatterPlotAttributes();
	this.dataSetFilterIndices = [];
	this.adjustSelectionAndHover(b)
};
q.notifySelectionChanged = function(a) {
	var b = this;
	this.selectedPointIndices = a;
	var c = [];
	1 === a.length ? (c = this.dataSet.findNeighbors(a[0], this.inspectorPanel.distFunc, this.inspectorPanel.numNN), this.metadataCard.updateMetadata(this.dataSet.points[a[0]].metadata)) : this.metadataCard.updateMetadata(null);
	this.selectionChangedListeners.forEach(function(a) {
		return a(b.selectedPointIndices, c)
	})
};
q.registerHoverListener = function(a) {
	this.hoverListeners.push(a)
};
q.notifyHoverOverPoint = function(a) {
	this.hoverListeners.forEach(function(b) {
		return b(a)
	})
};
q.registerProjectionChangedListener = function(a) {
	this.projectionChangedListeners.push(a)
};
q.notifyProjectionChanged = function(a) {
	this.projectionChangedListeners.forEach(function(b) {
		return b(a)
	})
};
q.registerDistanceMetricChangedListener = function(a) {
	this.distanceMetricChangedListeners.push(a)
};
q.notifyDistanceMetricChanged = function(a) {
	this.distanceMetricChangedListeners.forEach(function(b) {
		return b(a)
	})
};
q._dataProtoChanged = function(a) {
	a = a ? JSON.parse(a) : null;
	this.initializeDataProvider(a)
};
q.makeDefaultPointsInfoAndStats = function(a) {
	var b = [];
	a.forEach(function(a) {
		var c = {};
		c.__index__ = a.index;
		b.push(c)
	});
	a = [{
		name: "__index__",
		isNumeric: !1,
		tooManyUniqueValues: !0,
		min: 0,
		max: b.length - 1
	}];
	return [b, a]
};
q.initializeDataProvider = function(a) {
	if ("demo" === this.servingMode) a = Jn(window.location.search), a = "config" in a ? a.config : this.projectorConfigJsonPath, this.dataProvider = new Yo(a);
	else if ("server" === this.servingMode) {
		if (!this.routePrefix) throw "route-prefix is a required parameter";
		this.dataProvider = new fp(this.routePrefix)
	} else "proto" === this.servingMode && null != a && (this.dataProvider = new bp(a));
	this.dataPanel.initialize(this, this.dataProvider)
};
q.getLegendPointColorer = function(a) {
	var b = this;
	if (null == a || null == a.map) return null;
	var c = function(c, e) {
		c = c.points[e].metadata[b.selectedColorOption.name];
		return null == c ? "black" : a.map(c)
	};
	return c
};
q.get3DLabelModeButton = function() {
	return this.querySelector("#labels3DMode")
};
q.get3DLabelMode = function() {
	var a = this.get3DLabelModeButton();
	return a.active
};
q.adjustSelectionAndHover = function(a, b) {
	this.notifySelectionChanged(a);
	this.notifyHoverOverPoint(b);
	this.setMouseMode(xp.MouseMode.CAMERA_AND_CLICK_SELECT)
};
q.setMouseMode = function(a) {
	var b = this.querySelector("#selectMode");
	b.active = a === xp.MouseMode.AREA_SELECT;
	this.projectorScatterPlotAdapter.scatterPlot.setMouseMode(a)
};
q.setCurrentDataSet = function(a) {
	this.adjustSelectionAndHover([]);
	null != this.dataSet && this.dataSet.stopTSNE();
	null != a && this.normalizeData && a.normalize();
	this.dim = null == a ? 0 : a.dim[1];
	this.dom.select("span.numDataPoints").text(null == a ? "0" : a.dim[0]);
	this.dom.select("span.dim").text(null == a ? "0" : a.dim[1]);
	this.dataSet = a;
	this.projectionsPanel.dataSetUpdated(this.dataSet, this.originalDataSet, this.dim);
	this.projectorScatterPlotAdapter.setDataSet(this.dataSet);
	this.projectorScatterPlotAdapter.scatterPlot.setCameraParametersForNextCameraCreation(null, !0)
};
q.setupUIControls = function() {
	var a = this;
	this.querySelector("#reset-zoom").addEventListener("click", function() {
		a.projectorScatterPlotAdapter.scatterPlot.resetZoom();
		a.projectorScatterPlotAdapter.scatterPlot.startOrbitAnimation()
	});
	var b = this.querySelector("#selectMode");
	b.addEventListener("click", function(c) {
		a.setMouseMode(b.active ? xp.MouseMode.AREA_SELECT : xp.MouseMode.CAMERA_AND_CLICK_SELECT)
	});
	var c = this.querySelector("#nightDayMode");
	c.addEventListener("click", function() {
		a.projectorScatterPlotAdapter.scatterPlot.setDayNightMode(c.active)
	});
	var d =
		this.get3DLabelModeButton();
	d.addEventListener("click", function() {
		a.projectorScatterPlotAdapter.set3DLabelMode(a.get3DLabelMode())
	});
	window.addEventListener("resize", function() {
		var b = a.dom.select("#container"),
			c = b.node().parentNode.clientHeight;
		b.style("height", c + "px");
		a.projectorScatterPlotAdapter.resize()
	});
	this.projectorScatterPlotAdapter = new bq(this.getScatterContainer(), this);
	this.projectorScatterPlotAdapter.setLabelPointAccessor(this.selectedLabelOption);
	this.projectorScatterPlotAdapter.scatterPlot.onCameraMove(function(b,
		c) {
		return a.bookmarkPanel.clearStateSelection()
	});
	this.registerHoverListener(function(b) {
		return a.onHover(b)
	});
	this.registerSelectionChangedListener(function(b, c) {
		return a.onSelectionChanged(b, c)
	})
};
q.onHover = function(a) {
	this.hoverPointIndex = a;
	var b = null;
	null != a && (a = this.dataSet.points[a], a.metadata[this.selectedLabelOption] && (b = a.metadata[this.selectedLabelOption].toString()));
	0 === this.selectedPointIndices.length && (this.statusBar.style("display", b ? null : "none"), this.statusBar.text(b))
};
q.getScatterContainer = function() {
	return this.dom.select("#scatter")
};
q.onSelectionChanged = function(a, b) {
	this.selectedPointIndices = a;
	this.neighborsOfFirstPoint = b;
	a = this.selectedPointIndices.length + b.length;
	this.statusBar.text("Selected " + a + " points").style("display", 0 < a ? null : "none")
};
q.setProjection = function(a) {
	this.projection = a;
	null != a && this.analyticsLogger.logProjectionChanged(a.projectionType);
	this.notifyProjectionChanged(a)
};
q.notifyProjectionPositionsUpdated = function() {
	this.projectorScatterPlotAdapter.notifyProjectionPositionsUpdated()
};
q.getCurrentState = function() {
	var a = new Sq.State;
	a.projections = [];
	for (var b = 0; b < this.dataSet.points.length; b++) {
		for (var c = this.dataSet.points[b], d = {}, e = Object.keys(c.projections), f = 0; f < e.length; ++f) d[e[f]] = c.projections[e[f]];
		a.projections.push(d)
	}
	a.selectedProjection = this.projection.projectionType;
	a.dataSetDimensions = this.dataSet.dim;
	a.tSNEIteration = this.dataSet.tSNEIteration;
	a.selectedPoints = this.selectedPointIndices;
	a.filteredPoints = this.dataSetFilterIndices;
	this.projectorScatterPlotAdapter.populateBookmarkFromUI(a);
	a.selectedColorOptionName = this.dataPanel.selectedColorOptionName;
	a.selectedLabelOption = this.selectedLabelOption;
	this.projectionsPanel.populateBookmarkFromUI(a);
	return a
};
q.loadState = function(a) {
	this.setProjection(null);
	this.projectionsPanel.disablePolymerChangesTriggerReprojection();
	null != this.dataSetBeforeFilter && this.resetFilterDataset();
	null != a.filteredPoints && this.filterDataset(a.filteredPoints);
	this.projectionsPanel.enablePolymerChangesTriggerReprojection();
	for (var b = 0; b < a.projections.length; b++)
		for (var c = this.dataSet.points[b], d = a.projections[b], e = Object.keys(d), f = 0; f < e.length; ++f) c.projections[e[f]] = d[e[f]];
	this.dataSet.hasTSNERun = "tsne" === a.selectedProjection;
	this.dataSet.tSNEIteration = a.tSNEIteration;
	this.projectionsPanel.restoreUIFromBookmark(a);
	this.inspectorPanel.restoreUIFromBookmark(a);
	this.dataPanel.selectedColorOptionName = a.selectedColorOptionName;
	this.selectedLabelOption = a.selectedLabelOption;
	this.projectorScatterPlotAdapter.restoreUIFromBookmark(a);
	b = Sq.stateGetAccessorDimensions(a);
	c = yo.getProjectionComponents(a.selectedProjection, b);
	b = new Sq.Projection(a.selectedProjection, c, b.length, this.dataSet);
	this.setProjection(b);
	this.notifySelectionChanged(a.selectedPoints)
};
Qq.Projector = Tq;

function Uq() {}
document.registerElement(Tq.prototype.is, Tq);
(function(a, b, c, d, e, f, g) {
	a.GoogleAnalyticsObject = e;
	a[e] = a[e] || function() {
		(a[e].q = a[e].q || []).push(arguments)
	};
	a[e].l = 1 * new Date;
	f = b.createElement(c);
	g = b.getElementsByTagName(c)[0];
	f.async = 1;
	f.src = d;
	g.parentNode.insertBefore(f, g)
})(window, document, "script", "https://www.google-analytics.com/analytics.js", "ga");
ga("create", "UA-46457317-5", "auto");
var Vq = function() {};
Polymer({
	is: "vz-projector-app",
	properties: {
		pageViewLogging: {
			type: Boolean,
			value: !1
		},
		eventLogging: {
			type: Boolean,
			value: !1
		}
	}
});
var Wq = function() {};
Polymer({
	is: "vz-projector-colab",
	properties: {
		dataProto: Object
	}
});
var Xq = function() {};
(function() {
	Polymer({
		is: "vz-projector-dashboard",
		properties: {
			dataNotFound: Boolean,
			routePrefix: String
		},
		ready: function() {
			var a = this;
			d3.json(this.routePrefix + "/runs", function(b, c) {
				a.dataNotFound = 0 === c.length
			})
		}
	})
})();